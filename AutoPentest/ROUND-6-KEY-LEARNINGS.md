# Deep Audit Round 6: Key Learnings

## API Patterns Discovered

### 1. WorldModelDatabase API
**Critical Discovery**: No generic `add()` method exists!

**Wrong**:
```python
await db.add("findings", {"title": "...", "severity": "..."})
```

**Correct**:
```python
await db.add_finding(
    hypothesis_id="auto-123",  # REQUIRED
    title="SQL Injection",
    severity="HIGH",           # Must be in HYPOTHESIS_SEVERITIES
    confidence=0.8,            # REQUIRED, 0.0-1.0
    evidence_ids=[],
    remediation=None,
    metadata={}
)
```

**Available Methods**:
- `add_asset()`
- `add_endpoint()`
- `add_hypothesis()`
- `add_finding()` ← requires hypothesis_id
- `add_plan()`
- `store_knowledge()`

### 2. HttpClient.send_batch() Format
**Wrong**:
```python
await client.send_batch(requests)  # Raw list
```

**Correct**:
```python
batch_items = [
    {"request": req, "identity_id": None}
    for req in requests
]
await client.send_batch(batch_items)
```

### 3. ExchangeAnalyzer.analyze() Signature
**Wrong**:
```python
ea.analyze(
    url="...",
    method="GET",
    request_headers={},
    response_status=200,
    response_headers={},
    response_body="..."
)
```

**Correct**:
```python
ea.analyze(
    request={
        "method": "GET",
        "url": "...",
        "headers": {},
        "body": ""
    },
    response={
        "status": 200,
        "headers": {},
        "body": "..."
    }
)
```

### 4. NucleiRunner Constructor
**Wrong**:
```python
from lib.nuclei_runner import NucleiRunner
runner = NucleiRunner(mcp_service)  # Wrong!
```

**Correct**:
```python
from lib.nuclei_runner import NucleiRunner, NucleiConfig
config = NucleiConfig(
    timeout=300000,  # ms
    rate_limit=10,
    mock_mode=False
)
runner = NucleiRunner(config)
```

## Database Schema Learnings

### 5. wm_coverage_matrix Column Names
**After PostgreSQL Migration**:
- ✅ `id` (TEXT, UUID, NOT NULL)
- ✅ `created_at` (TIMESTAMP WITH TIME ZONE)
- ✅ `updated_at` (TIMESTAMP WITH TIME ZONE)
- ❌ `cell_id` (DOES NOT EXIST - was renamed to `id`)

**INSERT Pattern**:
```python
import uuid
from datetime import datetime, timezone

cell_id = str(uuid.uuid4())
now = datetime.now(timezone.utc)

await db._fetchall(
    "INSERT INTO wm_coverage_matrix (id, assessment_id, endpoint_id, "
    "vuln_class, parameter, tool_name, tool_args, priority, status, "
    "created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, "
    "'pending', $9, $10) ON CONFLICT DO NOTHING RETURNING id",
    (cell_id, assessment_id, endpoint_id, vuln_class, parameter,
     tool_name, json.dumps(tool_args), priority, now, now)
)
```

## Service Architecture Patterns

### 6. HTTP Client Caching
**Problem**: Budget tracking requires state preservation across requests

**Solution**: Cache per assessment_id
```python
def _get_http_client(mcp_service) -> HttpClient:
    cache_key = mcp_service.current_assessment_id
    if (hasattr(mcp_service, '_http_client_cache') and
        mcp_service._http_client_cache_key == cache_key):
        return mcp_service._http_client_cache

    client = HttpClient(...)
    mcp_service._http_client_cache = client
    mcp_service._http_client_cache_key = cache_key
    return client
```

### 7. Safe Card Processing Pipeline
**Always route through safe_add_card()** for:
- ✅ section_number auto-inference from phase
- ✅ wm_findings sync (for finding cards)
- ✅ Coverage matrix auto-marking
- ✅ Title deduplication checks

**Wrong**:
```python
result = await mcp_service.add_card(
    assessment_id=assessment_id,
    card_type="finding",
    **data
)
```

**Correct**:
```python
result = await mcp_service.safe_add_card(
    card_type="finding",
    **data
)
# Assessment ID inferred from mcp_service.current_assessment_id
# Section number auto-set from current phase
# wm_findings automatically synced
# Coverage matrix checked and marked
```

## Progress Calculation Patterns

### 8. Phase Completion = 100%
**Problem**: `completed_phases = current_phase - 1` gives 80% for phase 5

**Solution**: Check if final step is "done"
```python
completed_phases = current_phase - 1

if current_phase == 5:
    plan_id = await self._get_or_create_plan()
    plans = await self._db.query(table="plans", filters={"id": plan_id})
    if plans:
        steps = plans[0].get("steps", [])
        if len(steps) >= 5 and steps[4].get("status") == "done":
            completed_phases = 5

progress_pct = round((completed_phases / 5) * 100, 1)
```

## Frontend-Backend Integration

### 9. Correct API Endpoints
**Backend Route** (from `api/sections.py:166`):
```python
@router.get("/assessments/{id}/sections/phases")
async def get_phase_sections(id: int):
    ...
```

**Frontend Call**:
```javascript
// ✅ Correct
const response = await apiClient.get(`/assessments/${id}/sections/phases`);

// ❌ Wrong (404)
const response = await apiClient.get(`/assessments/${id}/phases/progress`);
```

## Security Patterns

### 10. Credential Redaction
**Always redact sensitive data in**:
- Logger output
- Card technical_analysis
- Card proof fields

```python
# ❌ Wrong - plaintext password
logger.info(f"Credential test: {username}:{password}")

# ✅ Correct - redacted
logger.info(f"Credential test: {username}:***")

# In card creation
technical_analysis=f"Tested {username}:*** against {target}"
```

## Common Pitfall Checklist

When adding new features:
- [ ] Check if WorldModelDatabase method exists (don't assume generic `add()`)
- [ ] Verify column names in PostgreSQL (not SQLite anymore)
- [ ] Include `id`, `created_at`, `updated_at` in INSERTs
- [ ] Wrap batch requests in correct format
- [ ] Cache clients that maintain state (budget, rate limits)
- [ ] Route cards through safe_add_card() not add_card()
- [ ] Use correct dict format for external library APIs
- [ ] Check constructor signatures (config objects vs direct params)
- [ ] Redact credentials in all output
- [ ] Test phase 5 completion shows 100%

## Testing Gotchas

1. **Import Errors**: Tests may fail with `ModuleNotFoundError: No module named 'mcp.modules'` on system Python - use venv Python 3.12
2. **Event Loop**: Use `unittest` not `pytest` to avoid cascade errors
3. **Mock Types**: Must mock `mcp.types` for verification tests
4. **SQL Parsing**: MockConnection doesn't support subqueries or HAVING
5. **Async Tests**: Need proper async test runner setup

## Reference Commands

```bash
# Run tests with venv Python
/mnt/d/testing_tool/AutoPentest/backend/venv/bin/python -m unittest discover tests -v

# Check specific fix
grep -n "add_finding(" backend/mcp/modules/service.py

# Verify column names
psql -U autopentest -d autopentest_db -c "\d wm_coverage_matrix"

# Count test results
python -m unittest discover tests 2>&1 | grep -E "Ran|OK|FAILED"
```
