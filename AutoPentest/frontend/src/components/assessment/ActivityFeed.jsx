/**
 * ActivityFeed Component
 *
 * Real-time scrolling activity feed for assessment testing progress.
 * Displays tool executions, phase changes, findings, and test results
 * with color-coded indicators and filtering.
 */

import React, { useState, useEffect, useRef } from 'react';
import { Card, Tag, Button, Space, Empty, Spin } from 'antd';
import {
  ClockCircleOutlined,
  CheckCircleOutlined,
  CloseCircleOutlined,
  BugOutlined,
  RocketOutlined,
  FilterOutlined,
  DownOutlined,
  UpOutlined
} from '@ant-design/icons';
import apiClient from '../../services/api';
import './ActivityFeed.css';

const ActivityFeed = ({ assessmentId, subscribe, isConnected }) => {
  const [activities, setActivities] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState('all'); // all | tools | findings | phases
  const [autoScroll, setAutoScroll] = useState(true);
  const feedRef = useRef(null);
  const bottomRef = useRef(null);

  // Maximum activities to keep in memory (prevent memory leak)
  const MAX_ACTIVITIES = 500;

  // Load initial activities from REST API
  useEffect(() => {
    const loadInitialActivities = async () => {
      try {
        setLoading(true);
        const response = await apiClient.get(
          `/assessments/${assessmentId}/activity_log?limit=50`
        );

        const activityList = response.data?.activities || response.data;
        if (activityList && Array.isArray(activityList)) {
          const formattedActivities = activityList.map(formatActivity);
          setActivities(formattedActivities);
        }
      } catch (error) {
        console.error('Failed to load initial activities:', error);
      } finally {
        setLoading(false);
      }
    };

    if (assessmentId) {
      loadInitialActivities();
    }
  }, [assessmentId]);

  // Subscribe to real-time WebSocket updates
  useEffect(() => {
    if (!subscribe || !assessmentId) return;

    // Subscribe to activity event types
    const unsubscribeFunctions = [
      subscribe('tool_started', handleToolStarted),
      subscribe('tool_completed', handleToolCompleted),
      subscribe('tool_failed', handleToolFailed),
      subscribe('phase_changed', handlePhaseChanged),
      subscribe('finding_discovered', handleFindingDiscovered),
      subscribe('scan_progress', handleScanProgress),
      subscribe('test_result', handleTestResult)
    ];

    // Cleanup subscriptions
    return () => {
      unsubscribeFunctions.forEach(unsub => unsub && unsub());
    };
  }, [subscribe, assessmentId]);

  // Auto-scroll to bottom when new activities arrive
  useEffect(() => {
    if (autoScroll && bottomRef.current) {
      bottomRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [activities, autoScroll]);

  // Round 11 Fix 2D: Polling fallback for activity feed (15-second interval)
  useEffect(() => {
    if (!assessmentId) return;

    const pollInterval = setInterval(async () => {
      try {
        const response = await axios.get(
          `/api/assessments/${assessmentId}/activity_log?limit=50`
        );
        const activityList = response.data?.activities || response.data;
        if (activityList && Array.isArray(activityList)) {
          const formattedActivities = activityList.map(formatActivity);
          // Only update if we have more activities than currently displayed
          if (formattedActivities.length > activities.length) {
            setActivities(formattedActivities);
          }
        }
      } catch (error) {
        // Silently fail - not critical
      }
    }, 15000); // Poll every 15 seconds

    return () => clearInterval(pollInterval);
  }, [assessmentId, activities.length]);

  // Format activity from REST API response
  const formatActivity = (activityData) => {
    return {
      id: activityData.id || Date.now(),
      type: activityData.activity_type || activityData.type,
      timestamp: activityData.timestamp || new Date().toISOString(),
      data: activityData.data || {},
      category: getCategory(activityData.activity_type || activityData.type)
    };
  };

  // WebSocket event handlers (Fix 8: first arg is data, not event)
  const handleToolStarted = (data) => {
    addActivity({
      id: data.activity_id || Date.now(),
      type: 'tool_started',
      timestamp: data.timestamp || new Date().toISOString(),
      data: data,
      category: 'tools'
    });
  };

  const handleToolCompleted = (data) => {
    addActivity({
      id: data.activity_id || Date.now(),
      type: 'tool_completed',
      timestamp: data.timestamp || new Date().toISOString(),
      data: data,
      category: 'tools'
    });
  };

  const handleToolFailed = (data) => {
    addActivity({
      id: data.activity_id || Date.now(),
      type: 'tool_failed',
      timestamp: data.timestamp || new Date().toISOString(),
      data: data,
      category: 'tools'
    });
  };

  const handlePhaseChanged = (data) => {
    addActivity({
      id: data.activity_id || Date.now(),
      type: 'phase_changed',
      timestamp: data.timestamp || new Date().toISOString(),
      data: data,
      category: 'phases'
    });
  };

  const handleFindingDiscovered = (data) => {
    addActivity({
      id: data.activity_id || Date.now(),
      type: 'finding_discovered',
      timestamp: data.timestamp || new Date().toISOString(),
      data: data,
      category: 'findings'
    });
  };

  const handleScanProgress = (data) => {
    addActivity({
      id: data.activity_id || Date.now(),
      type: 'scan_progress',
      timestamp: data.timestamp || new Date().toISOString(),
      data: data,
      category: 'tools'
    });
  };

  const handleTestResult = (data) => {
    addActivity({
      id: data.activity_id || Date.now(),
      type: 'test_result',
      timestamp: data.timestamp || new Date().toISOString(),
      data: data,
      category: 'tools'
    });
  };

  // Add new activity to the feed
  const addActivity = (activity) => {
    setActivities(prev => {
      const updated = [activity, ...prev];
      // Limit to MAX_ACTIVITIES to prevent memory issues
      return updated.slice(0, MAX_ACTIVITIES);
    });
  };

  // Get category from activity type
  const getCategory = (type) => {
    if (type.startsWith('tool_')) return 'tools';
    if (type === 'phase_changed' || type === 'phase_transition') return 'phases';
    if (type === 'finding_discovered' || type === 'finding_created') return 'findings';
    return 'tools';
  };

  // Filter activities based on selected filter
  const filteredActivities = activities.filter(activity => {
    if (filter === 'all') return true;
    return activity.category === filter;
  });

  // Render activity icon based on type
  const renderIcon = (activity) => {
    switch (activity.type) {
      case 'tool_started':
        return <ClockCircleOutlined style={{ color: '#1890ff' }} />;
      case 'tool_completed':
        return <CheckCircleOutlined style={{ color: '#52c41a' }} />;
      case 'tool_failed':
        return <CloseCircleOutlined style={{ color: '#ff4d4f' }} />;
      case 'phase_changed':
      case 'phase_transition':
        return <RocketOutlined style={{ color: '#722ed1' }} />;
      case 'finding_discovered':
      case 'finding_created':
        return <BugOutlined style={{ color: '#fa8c16' }} />;
      case 'scan_progress':
        return <ClockCircleOutlined style={{ color: '#13c2c2' }} />;
      case 'test_result':
        return activity.data.status === 'vulnerable'
          ? <BugOutlined style={{ color: '#fa8c16' }} />
          : <CheckCircleOutlined style={{ color: '#52c41a' }} />;
      default:
        return <ClockCircleOutlined />;
    }
  };

  // Render activity message
  const renderMessage = (activity) => {
    const data = activity.data || {};

    switch (activity.type) {
      case 'tool_started':
        return `Started: ${data.tool_name || 'tool'}`;
      case 'tool_completed':
        return `Completed: ${data.tool_name || 'tool'}${data.duration ? ` (${data.duration}ms)` : ''}`;
      case 'tool_failed':
        return `Failed: ${data.tool_name || 'tool'} - ${data.error || 'Unknown error'}`;
      case 'phase_changed':
      case 'phase_transition':
        return `Phase ${data.from_phase || '?'} â†’ ${data.to_phase || '?'}`;
      case 'finding_discovered':
      case 'finding_created':
        return `Finding: ${data.title || data.vuln_class || 'New vulnerability'}`;
      case 'scan_progress':
        return `Scan progress: ${data.progress || 0}%`;
      case 'test_result':
        return `Test ${data.vuln_class || 'unknown'}: ${data.status || 'completed'}`;
      default:
        return activity.type;
    }
  };

  // Render activity tag
  const renderTag = (activity) => {
    const data = activity.data || {};

    switch (activity.type) {
      case 'tool_started':
        return <Tag color="blue">Running</Tag>;
      case 'tool_completed':
        return <Tag color="green">Success</Tag>;
      case 'tool_failed':
        return <Tag color="red">Failed</Tag>;
      case 'phase_changed':
      case 'phase_transition':
        return <Tag color="purple">Phase Change</Tag>;
      case 'finding_discovered':
      case 'finding_created':
        return <Tag color="orange">{data.severity || 'Finding'}</Tag>;
      case 'test_result':
        return data.status === 'vulnerable'
          ? <Tag color="orange">Vulnerable</Tag>
          : <Tag color="green">Clean</Tag>;
      default:
        return null;
    }
  };

  // Format timestamp
  const formatTimestamp = (timestamp) => {
    try {
      const date = new Date(timestamp);
      return date.toLocaleTimeString();
    } catch {
      return '';
    }
  };

  return (
    <Card
      title={
        <Space>
          <span>Live Activity Feed</span>
          {isConnected ? (
            <Tag color="green">Connected</Tag>
          ) : (
            <Tag color="red">Disconnected</Tag>
          )}
        </Space>
      }
      extra={
        <Space>
          <Button.Group>
            <Button
              type={filter === 'all' ? 'primary' : 'default'}
              size="small"
              onClick={() => setFilter('all')}
            >
              All
            </Button>
            <Button
              type={filter === 'tools' ? 'primary' : 'default'}
              size="small"
              onClick={() => setFilter('tools')}
            >
              Tools
            </Button>
            <Button
              type={filter === 'findings' ? 'primary' : 'default'}
              size="small"
              onClick={() => setFilter('findings')}
            >
              Findings
            </Button>
            <Button
              type={filter === 'phases' ? 'primary' : 'default'}
              size="small"
              onClick={() => setFilter('phases')}
            >
              Phases
            </Button>
          </Button.Group>
          <Button
            size="small"
            icon={autoScroll ? <DownOutlined /> : <UpOutlined />}
            onClick={() => setAutoScroll(!autoScroll)}
          >
            {autoScroll ? 'Auto-scroll' : 'Manual'}
          </Button>
        </Space>
      }
      className="activity-feed-card"
    >
      <div className="activity-feed-container" ref={feedRef}>
        {loading ? (
          <div style={{ textAlign: 'center', padding: '40px' }}>
            <Spin size="large" />
          </div>
        ) : filteredActivities.length === 0 ? (
          <Empty
            description="No activities yet"
            style={{ padding: '40px' }}
          />
        ) : (
          <div className="activity-list">
            {filteredActivities.map((activity, index) => (
              <div key={activity.id || index} className="activity-item">
                <div className="activity-icon">
                  {renderIcon(activity)}
                </div>
                <div className="activity-content">
                  <div className="activity-header">
                    <span className="activity-message">
                      {renderMessage(activity)}
                    </span>
                    {renderTag(activity)}
                  </div>
                  <div className="activity-timestamp">
                    {formatTimestamp(activity.timestamp)}
                  </div>
                </div>
              </div>
            ))}
            <div ref={bottomRef} />
          </div>
        )}
      </div>
    </Card>
  );
};

export default ActivityFeed;
