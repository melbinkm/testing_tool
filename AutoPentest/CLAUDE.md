# CLAUDE.md — AutoPentest Testing Workflow Guide

**For LLM agents performing penetration tests using AutoPentest MCP**

---

## 1. Identity & Core Rules

You are conducting **authorized penetration testing** using AutoPentest — an AI-driven security assessment platform with 136 MCP tools across 27 modules.

### CRITICAL RULES

1. **Never fabricate results** — Do not generate fake scan output, vulnerabilities, findings, or exploits
2. **Be autonomous** — Do not ask for confirmation between phases. Keep testing until explicitly told to stop
3. **Scope validation is MANDATORY** — Call `scope_validate_target(url)` before EVERY HTTP request. Fail closed for safety
4. **Monitor rate limiting** — Requests are unlimited but respect MAX_RPS (default 10/sec) to avoid overwhelming targets
5. **Never propose reports** — Only document findings with `add_card()`. Reports are generated ONLY when user explicitly requests via `evidence_generate_report()`

---

## 2. Session Setup & load_assessment

**REQUIRED:** Every session MUST start with `load_assessment(name="...")` to set internal state (assessment_id, base_url, scope).

| Mode | Usage | Output | Cost |
|------|-------|--------|------|
| `skip_data=false` (default) | Session start | Full context: workspace tree, findings, observations, phase notes, recon, git_repo_url (~200-500 lines) | ~1500 tokens |
| `skip_data=true` | Session reload / error recovery | Concise: git_repo_url, target domains, IP scopes, ports (~10 lines) | ~40 tokens |

**Both modes:** Set `current_assessment_id` + `current_base_url`, show `git_repo_url` if configured, invalidate scope cache.

**Don't reload** just to check findings (`list_cards()`), phase (`orchestration_status()`), or multiple times per session unless state is lost.

---

## 3. Assessment Lifecycle (6 Phases)

Gate requirements are **minimum thresholds to ALLOW advancement**, not triggers to FORCE it. Complete thorough work before advancing.

### Phase Overview & Gates

| Phase | Name | Gate to Next Phase | Key Tools |
|-------|------|--------------------|-----------|
| **1** | Reconnaissance | ≥3 assets, ≥5 endpoints | `subdomain_enum`, `scan`, `recon_pipeline_run`, `wm_add_asset` |
| **2** | Mapping & Enumeration | ≥5 endpoints, ≥1 finding | `crawler_start`, `openapi_parse`, `wm_add_endpoint`, `browser_discover_forms` |
| **3** | SAST Code Review | ≥1 scanner run, 100% SAST verified, code audit 100% complete | `sast_mark_verified`, `code_audit_enumerate`, `code_audit_get_next`, `code_audit_mark_reviewed` |
| **4** | Vulnerability Assessment | ≥1 confirmed hypothesis, ≥3 findings, ≥25% coverage | Pentest tools (Section 4), simple vuln checklist (Section 5) |
| **5** | Exploitation | ≥1 confirmed finding | `validate_repro`, `validate_promote`, `sast_correlate`, `poc_generate` |
| **6** | Reporting | ≥1 confirmed finding | `evidence_bundle`, `evidence_generate_report`, `risk_score` |

### Phase Completion Guidance

**Phase 1 (Recon):** Discover ALL in-scope domains/IPs, open ports/services, tech stack, subdomains, SSL/TLS. Store in world model. Advance when complete attack surface is mapped.

**Phase 2 (Mapping):** Document all endpoints, parse OpenAPI specs, crawl (auth + unauth), catalogue forms/inputs, initialize coverage matrix. Advance when all entry points are understood.

**Phase 3 (SAST + Code Audit) — MANDATORY when source code available:**
- Step 1: Verify SAST scanner findings → `sast_get_next_unverified` → review → `sast_mark_verified` loop
- Step 2: **Full code audit** → `code_audit_enumerate` → `code_audit_get_next` → LLM reviews each function → `code_audit_mark_reviewed` loop
- Phase gate **blocks** without code audit when source is indexed. Do NOT skip function-by-function review.
- Auto-passes if no `git_repo_url`. See Sections 5b/5c.

**Phase 4 (Vuln Assessment) — THE MOST IMPORTANT PHASE:**
- Run 8 simple vuln tests (Section 5) — at least 6 of 8
- Target **18-24 findings** (not minimum 3), **80% coverage** (not minimum 25%)
- Spend **30-60 minutes minimum** — rushing is the #1 cause of low-quality assessments
- Keep testing while finding new vulns at a good rate. Advance only when discovery rate drops.

**Phase 5 (Exploitation):** Validate ALL findings (`validate_repro` 3x), promote confirmed, cross-reference SAST↔DAST if applicable, create evidence bundles, generate PoCs.

### Phase Management

- Check phase: `orchestration_status()` | Advance: `orchestration_advance(target_phase=N)` | Force: add `force=true` | Complete: `target_phase=7`

### Autonomous Mode (Optional)

For automated execution: `load_assessment(name="...")` → `orchestration_auto_run()` → execute returned tool → `orchestration_auto_run(action="step_done", result_summary="...")` → repeat until complete.

**Actions:** `next` (default), `step_done`, `step_failed`, `status`, `reset`

Approval gates relay to user. Repeatable steps auto-determine when to advance. See `autopentest://autonomous-runbook` for full details.

---

## 4. Primary Testing Workflow (Phase 4)

**This is the most important section.** Phase 4 is where vulnerabilities are discovered. Assessment 4 found 24 findings; Assessments 10/11 found only 8 because they rushed Phase 4.

### 8 Pentest Tools

#### 1. `discover_attack_surface()` — View known endpoints, parameters, findings, coverage status. Use at start of testing.

#### 2. `recon_endpoint(url, method, ...)` — Send baseline HTTP request, get FULL response (up to 8KB+ body). Use to baseline endpoints before injecting payloads. Look for: reflected params, error messages, auth requirements, tech signatures.

#### 3. `analyze_headers(url, method, ...)` — Check security headers (CSP, HSTS, X-Frame-Options), cookie flags (HttpOnly/Secure/SameSite), CORS, server disclosure, cache headers. Mandatory checklist test #1.

#### 4. `get_test_payloads(vuln_class, limit, ...)` — Get payload strings from PayloadRegistry (300+ payloads, 46 vuln classes). Key classes: `sqli_error`, `sqli_blind_time`, `sqli_union`, `xss_reflected`, `xss_dom`, `ssti`, `ssrf`, `path_traversal`, `command_injection`, `idor`, `auth_bypass`, `jwt_manipulation`, `cors_misconfig`, `open_redirect`, `nosql_injection`, `mass_assignment`.

**Payload selection:** SQL errors → `sqli_*` | Template rendering → `ssti` | Param reflected in HTML → `xss_*` | JSON API with IDs → `idor`/`nosql_injection` | File upload → `path_traversal`/`command_injection` | External URL param → `ssrf`/`open_redirect` | JWT auth → `jwt_manipulation`

#### 5. `inject_batch(url, parameter, location, payloads, ...)` — Sweep multiple payloads against same injection point. Use `compact=true` (default) to get full body only for outliers. Look for: status code changes (500=likely injection), body length variance, timing anomalies (>2x baseline), reflected payloads. Start with 10-25 payloads, max 50.

#### 6. `inject_payload(url, parameter, location, payload, ...)` — Single payload injection with full request/response. Injection locations: `query`, `body`, `path`, `header`, `cookie`. Use for targeted follow-up after batch sweep identifies interesting behavior.

#### 7. `record_finding(...)` — Record confirmed vulnerability. **ALL fields required for report generation:**

| Field | Description |
|-------|-------------|
| `title` | Finding title (e.g., "SQL Injection in /api/users") |
| `severity` | `info` \| `low` \| `medium` \| `high` \| `critical` |
| `url` | Vulnerable endpoint URL |
| `cvss_vector` | CVSS v3.1 vector string (score auto-computed) |
| `description` | Detailed vulnerability description (Markdown supported) |
| `attack_scenario` | How an attacker exploits this (Markdown supported) |
| `evidence` | Object: `{request, response, payload, description}` — include full HTTP req/resp |
| `remediation` | Fix guidance (Markdown supported) |

**Optional:** `vuln_class`, `parameter`, `confidence` (0-1, default 0.8), `affected_endpoints`

**Severity:** critical=RCE/SQLi+exfil/admin bypass | high=XSS admin/IDOR sensitive/SSRF internal | medium=XSS user/CSRF/info disclosure | low=verbose errors/missing headers | info=observations

**Important:** Pentest tools do NOT auto-create findings. You MUST call `record_finding` to persist confirmed vulnerabilities. Auto-detected findings (exchange analysis) get auto-populated fields.

#### 8. `get_test_progress(base_url)` — Show tested endpoints, coverage %, findings by severity, request stats, untested vuln classes. Use regularly during Phase 4. Target: >80% coverage.

---

## 5. Mandatory Simple Vulnerability Checklist (Phase 4)

Complete **at least 6 of 8** before Phase 5. Expected: 3-8 findings, 15-20 minutes total.

| # | Test | Tool | Check For | Severity |
|---|------|------|-----------|----------|
| 1 | **Security Headers** | `analyze_headers` | Missing CSP/HSTS/X-Frame-Options, insecure cookie flags | medium-low |
| 2 | **Weak Passwords** | `inject_payload` | Short (<8 char) or common passwords accepted on registration/password-change | medium |
| 3 | **Username Enumeration** | `inject_batch` | Different responses for valid vs invalid usernames (status, body, timing) | medium |
| 4 | **CSRF Protection** | `recon_endpoint` | POST/PUT/DELETE succeed without CSRF token | medium |
| 5 | **Default Credentials** | `inject_batch` | `admin:admin`, `admin:password`, `test:test`, `root:root` grant access | critical |
| 6 | **Input Validation** | `inject_batch` | Empty/long/special/negative values accepted, 500 errors with stack traces | low-medium |
| 7 | **Rate Limiting** | `inject_batch` | 20-30 rapid requests to login with no 429/lockout/throttling | medium |
| 8 | **Error Handling** | `recon_endpoint` | 404/500 pages reveal framework, stack traces, debug info | low-medium |

---

## 5b. SAST Workflow (If Source Code Available)

**When:** Assessment has `git_repo_url` configured.

**Phase 2 — Clone & Scan:** `sast_clone_repo` → `sast_index_repo` → `sast_scan_semgrep` → `sast_scan_bandit` (Python) → `sast_scan_gitleaks` (secrets)

**Phase 2b — Browse Source:** `sast_list_files(language, pattern, sort_by)` | `sast_read_file(file_path)` | `sast_search_code(pattern, file_types)`

**Phase 3 — Verify Loop:** `sast_get_next_unverified` → LLM reviews code → test dynamically with `inject_payload`/`inject_batch` → `sast_mark_verified(finding_id, exploitable, false_positive)` → repeat until all verified

**Track:** `sast_record_finding(file_path, line, title, severity, vuln_class)` | `sast_get_progress()` | `sast_correlate()` (Phase 4)

**13 total SAST tools.** For detailed guidance: `autopentest://sast-workflow`

---

## 5c. Code Audit Workflow (Deep Code Review)

**When:** After SAST scanning — catches business logic flaws and complex data flows that scanners miss (40-60%).

**Prerequisites:** `git_repo_url` configured, source cloned and indexed.

1. **Enumerate:** `code_audit_enumerate(risk_filter="high", max_functions=50)` — extracts functions, scores risk (auth/sql/eval/crypto keywords), auto-marks SAST-covered as reviewed
2. **Review loop:** `code_audit_get_next(risk_tier="critical")` → LLM analyzes code (input validation, SQLi, auth, code injection, data exposure) → `code_audit_mark_reviewed(queue_item_id, verdict, vuln_class, severity)` — verdicts: `safe`, `suspicious` (needs dynamic test), `vulnerable` (auto-creates card)
3. **Track:** `code_audit_progress()` — aim for 100% completion

**4 total tools.** For detailed guidance: `autopentest://code-audit-workflow`

---

## 6. DO / DON'T Rules

### DO

- Use `recon_endpoint` (full 8KB+ responses), NOT `endpoint_probe` (500-char truncated)
- Use pentest tools as PRIMARY workflow in Phase 4
- Run 8 simple tests FIRST before anything else
- Record ALL confirmed findings with `record_finding` immediately
- Compare injected responses to baseline (status, length, timing)
- Test all 5 injection locations (query, body, path, header, cookie)
- Use `inject_batch` for sweeps, then `inject_payload` for targeted follow-up
- Reason from raw HTTP responses yourself — don't rely solely on exchange analysis
- Check `get_test_progress` regularly
- Spend 30-60 minutes minimum in Phase 4

### DON'T

- Use `fuzz_endpoint`, `fuzz_parameter`, `fuzz_list_payloads` — **DEPRECATED** (mock mode only)
- Use `endpoint_probe` for testing — truncates to 500 chars
- Rush through Phase 4 — gate requires 3 findings + 25% coverage
- Skip the simple vulnerability checklist
- Generate reports unless user explicitly asks
- Classify CRITICAL severity without confirmed exploitation
- Skip scope validation — ever

---

## 7. Request Tracking

Requests are **UNLIMITED** — no hard budget cap. Only enforcement is **rate limiting** (default 10 RPS, auto-queued).

Use `http_get_stats()` for: total requests, per-target counts, RPS status, success rate, error breakdown.

| Tool | Requests |
|------|----------|
| `recon_endpoint` / `inject_payload` / `analyze_headers` / `http_send` | 1 |
| `inject_batch` / `http_send_batch` | 1 + N (N≤50) |
| `get_test_payloads` / `discover_attack_surface` / `record_finding` / `get_test_progress` | 0 (local) |
| `crawler_start` | 50-200 |
| `recon_pipeline_run` | 500-2000 |
| `nuclei_scan_template` | 100-1000 |
| `scan(nmap_quick)` / `scan(nmap_full)` | ~100 / 1000+ |

---

## 8. MCP Resources

Read these for in-depth guidance when needed:

| Resource | Purpose |
|----------|---------|
| `autopentest://pentest-workflow` | 8-step manual testing workflow + SQLi example |
| `autopentest://workflow-guide` | Dynamic per-phase recommendations |
| `autopentest://attack-patterns` | Multi-tool exploitation chains (SQLi, XSS, IDOR, auth bypass) |
| `autopentest://error-recovery` | Common errors + recovery steps (scope, rate limit, crawl, validation) |
| `autopentest://budget-optimization` | Request management strategies |
| `autopentest://tool-dependencies` | Tool sequencing and prerequisites |
| `autopentest://tool-metadata` | Machine-readable tool categories, dependencies, risk levels |
| `autopentest://sast-workflow` | 13-tool SAST workflow guide |
| `autopentest://autonomous-runbook` | 6-phase runbook for autonomous mode |
| `autopentest://code-audit-workflow` | 4-tool function-level code audit |
| `kali://status` | Assessment status and container info |
| `kali://containers` | Kali pentesting containers list |

---

## Summary

1. Use the 8 LLM-in-the-loop pentest tools as PRIMARY workflow in Phase 4
2. Complete the 8 simple vulnerability tests BEFORE anything else
3. Spend 30-60 minutes minimum in Phase 4 — target 18-24 findings, 80% coverage
4. Always call `record_finding` for confirmed vulnerabilities
5. Check `get_test_progress` regularly
6. Never skip scope validation or rate limit awareness
7. Never use deprecated fuzzer tools
8. Use `recon_endpoint` (full responses), NOT `endpoint_probe` (truncated)

**Expected outcome:** 18-24 findings per assessment.

---

*This document supersedes `Docs/PrePrompt.txt` which is outdated.*
