import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { OpenAPIParser } from './openapi-parser.js';
import type { ParsedEndpoint, ParsedSpec } from './openapi-parser.js';

// Sample OpenAPI specs for testing
const sampleJsonSpec = {
  openapi: '3.0.0',
  info: {
    title: 'Test API',
    version: '1.0.0',
  },
  servers: [{ url: 'https://api.example.com' }],
  paths: {
    '/users': {
      get: {
        summary: 'List users',
        tags: ['users'],
        responses: {
          '200': {
            description: 'List of users',
            content: {
              'application/json': {
                schema: {
                  type: 'array',
                  items: { type: 'object' },
                },
              },
            },
          },
        },
      },
      post: {
        summary: 'Create user',
        tags: ['users'],
        operationId: 'createUser',
        requestBody: {
          required: true,
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  name: { type: 'string' },
                  email: { type: 'string', format: 'email' },
                },
              },
            },
          },
        },
        responses: {
          '201': { description: 'User created' },
        },
      },
    },
    '/users/{id}': {
      parameters: [
        {
          name: 'id',
          in: 'path',
          required: true,
          schema: { type: 'integer' },
        },
      ],
      get: {
        summary: 'Get user by ID',
        tags: ['users'],
        parameters: [
          {
            name: 'include',
            in: 'query',
            schema: { type: 'string' },
          },
        ],
        responses: {
          '200': { description: 'User details' },
          '404': { description: 'User not found' },
        },
      },
      put: {
        summary: 'Update user',
        tags: ['users'],
        parameters: [
          {
            name: 'X-Request-ID',
            in: 'header',
            schema: { type: 'string', format: 'uuid' },
          },
        ],
        requestBody: {
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  name: { type: 'string' },
                },
              },
            },
          },
        },
        responses: {
          '200': { description: 'User updated' },
        },
      },
      delete: {
        summary: 'Delete user',
        tags: ['users'],
        responses: {
          '204': { description: 'User deleted' },
        },
      },
    },
    '/auth/login': {
      post: {
        summary: 'Login',
        tags: ['auth'],
        security: [{ apiKey: [] }],
        requestBody: {
          required: true,
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  username: { type: 'string' },
                  password: { type: 'string' },
                },
              },
            },
          },
        },
        responses: {
          '200': { description: 'Login successful' },
        },
      },
    },
  },
  components: {
    securitySchemes: {
      apiKey: {
        type: 'apiKey',
        in: 'header',
        name: 'X-API-Key',
      },
      bearerAuth: {
        type: 'http',
        scheme: 'bearer',
      },
    },
  },
  security: [{ bearerAuth: [] }],
};

const sampleYamlSpec = `
openapi: "3.0.0"
info:
  title: YAML Test API
  version: "2.0.0"
servers:
  - url: https://yaml.example.com
paths:
  /items:
    get:
      summary: List items
      tags:
        - items
      responses:
        "200":
          description: OK
`;

describe('OpenAPIParser', () => {
  let parser: OpenAPIParser;

  beforeEach(() => {
    parser = new OpenAPIParser();
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('parseRawSpec - JSON parsing', () => {
    it('should parse JSON spec correctly', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      expect(result.title).toBe('Test API');
      expect(result.version).toBe('1.0.0');
      expect(result.base_url).toBe('https://api.example.com');
    });

    it('should extract all endpoints', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      // Should have: GET /users, POST /users, GET /users/{id}, PUT /users/{id}, DELETE /users/{id}, POST /auth/login
      expect(result.endpoints.length).toBe(6);
    });

    it('should parse endpoint methods correctly', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const methods = result.endpoints.map((e) => e.method);
      expect(methods).toContain('GET');
      expect(methods).toContain('POST');
      expect(methods).toContain('PUT');
      expect(methods).toContain('DELETE');
    });

    it('should generate unique endpoint IDs', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const ids = result.endpoints.map((e) => e.endpoint_id);
      const uniqueIds = new Set(ids);
      expect(uniqueIds.size).toBe(ids.length);
    });

    it('should extract tags correctly', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const getUsersEndpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users'
      );
      expect(getUsersEndpoint?.tags).toContain('users');
    });

    it('should extract operation_id when present', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const createUserEndpoint = result.endpoints.find(
        (e) => e.method === 'POST' && e.path === '/users'
      );
      expect(createUserEndpoint?.operation_id).toBe('createUser');
    });

    it('should extract summary and description', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const getUsersEndpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users'
      );
      expect(getUsersEndpoint?.summary).toBe('List users');
    });

    it('should extract security schemes', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      expect(result.security_schemes).toHaveProperty('apiKey');
      expect(result.security_schemes).toHaveProperty('bearerAuth');
    });
  });

  describe('parseRawSpec - YAML parsing', () => {
    it('should parse YAML spec correctly', () => {
      const result = parser.parseRawSpec(sampleYamlSpec, 'test.yaml');

      expect(result.title).toBe('YAML Test API');
      expect(result.version).toBe('2.0.0');
      expect(result.base_url).toBe('https://yaml.example.com');
    });

    it('should detect YAML by content when source not provided', () => {
      const result = parser.parseRawSpec(sampleYamlSpec);

      expect(result.title).toBe('YAML Test API');
    });

    it('should detect YAML by .yml extension', () => {
      const result = parser.parseRawSpec(sampleYamlSpec, 'test.yml');

      expect(result.title).toBe('YAML Test API');
    });
  });

  describe('Parameter parsing', () => {
    it('should parse path parameters', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const getUserByIdEndpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users/{id}'
      );
      const idParam = getUserByIdEndpoint?.parameters.find(
        (p) => p.name === 'id'
      );

      expect(idParam).toBeDefined();
      expect(idParam?.in).toBe('path');
      expect(idParam?.required).toBe(true);
    });

    it('should parse query parameters', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const getUserByIdEndpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users/{id}'
      );
      const includeParam = getUserByIdEndpoint?.parameters.find(
        (p) => p.name === 'include'
      );

      expect(includeParam).toBeDefined();
      expect(includeParam?.in).toBe('query');
    });

    it('should parse header parameters', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const updateUserEndpoint = result.endpoints.find(
        (e) => e.method === 'PUT' && e.path === '/users/{id}'
      );
      const headerParam = updateUserEndpoint?.parameters.find(
        (p) => p.name === 'X-Request-ID'
      );

      expect(headerParam).toBeDefined();
      expect(headerParam?.in).toBe('header');
    });

    it('should merge path-level and operation-level parameters', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const getUserByIdEndpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users/{id}'
      );

      // Should have path-level id param + operation-level include param
      expect(getUserByIdEndpoint?.parameters.length).toBe(2);
    });

    it('should handle cookie parameters', () => {
      const specWithCookie = {
        openapi: '3.0.0',
        info: { title: 'Test', version: '1.0.0' },
        paths: {
          '/test': {
            get: {
              parameters: [
                { name: 'session', in: 'cookie', schema: { type: 'string' } },
              ],
              responses: { '200': { description: 'OK' } },
            },
          },
        },
      };

      const result = parser.parseRawSpec(JSON.stringify(specWithCookie));
      const cookieParam = result.endpoints[0]?.parameters.find(
        (p) => p.name === 'session'
      );

      expect(cookieParam?.in).toBe('cookie');
    });
  });

  describe('Request body parsing', () => {
    it('should parse request body with required flag', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const createUserEndpoint = result.endpoints.find(
        (e) => e.method === 'POST' && e.path === '/users'
      );

      expect(createUserEndpoint?.request_body).toBeDefined();
      expect(createUserEndpoint?.request_body?.required).toBe(true);
    });

    it('should extract content types', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const createUserEndpoint = result.endpoints.find(
        (e) => e.method === 'POST' && e.path === '/users'
      );

      expect(createUserEndpoint?.request_body?.content_types).toContain(
        'application/json'
      );
    });

    it('should extract schema from request body', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const createUserEndpoint = result.endpoints.find(
        (e) => e.method === 'POST' && e.path === '/users'
      );

      expect(createUserEndpoint?.request_body?.schema).toBeDefined();
    });

    it('should handle missing request body', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const getUsersEndpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users'
      );

      expect(getUsersEndpoint?.request_body).toBeUndefined();
    });
  });

  describe('Response parsing', () => {
    it('should parse responses with status codes', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const getUserByIdEndpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users/{id}'
      );

      expect(getUserByIdEndpoint?.responses).toHaveProperty('200');
      expect(getUserByIdEndpoint?.responses).toHaveProperty('404');
    });

    it('should extract response descriptions', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const getUserByIdEndpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users/{id}'
      );

      expect(getUserByIdEndpoint?.responses['200'].description).toBe(
        'User details'
      );
      expect(getUserByIdEndpoint?.responses['404'].description).toBe(
        'User not found'
      );
    });

    it('should extract response schema when present', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const getUsersEndpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users'
      );

      expect(getUsersEndpoint?.responses['200'].schema).toBeDefined();
    });
  });

  describe('Security parsing', () => {
    it('should parse operation-level security', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const loginEndpoint = result.endpoints.find(
        (e) => e.path === '/auth/login'
      );

      expect(loginEndpoint?.security).toContain('apiKey');
    });

    it('should inherit global security when operation has none', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const getUsersEndpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users'
      );

      expect(getUsersEndpoint?.security).toContain('bearerAuth');
    });
  });

  describe('Sample value generation', () => {
    it('should generate integer value', () => {
      const value = parser.generateSampleValue({ type: 'integer' }, 'count');
      expect(value).toBe('1');
    });

    it('should generate number value', () => {
      const value = parser.generateSampleValue({ type: 'number' }, 'price');
      expect(value).toBe('1.0');
    });

    it('should generate boolean value', () => {
      const value = parser.generateSampleValue({ type: 'boolean' }, 'active');
      expect(value).toBe('true');
    });

    it('should generate string value', () => {
      const value = parser.generateSampleValue({ type: 'string' }, 'name');
      expect(value).toBe('example');
    });

    it('should generate UUID for uuid format', () => {
      const value = parser.generateSampleValue(
        { type: 'string', format: 'uuid' },
        'id'
      );
      expect(value).toBe('550e8400-e29b-41d4-a716-446655440000');
    });

    it('should generate email for email format', () => {
      const value = parser.generateSampleValue(
        { type: 'string', format: 'email' },
        'email'
      );
      expect(value).toBe('test@example.com');
    });

    it('should generate date for date format', () => {
      const value = parser.generateSampleValue(
        { type: 'string', format: 'date' },
        'date'
      );
      expect(value).toBe('2024-01-01');
    });

    it('should generate datetime for date-time format', () => {
      const value = parser.generateSampleValue(
        { type: 'string', format: 'date-time' },
        'timestamp'
      );
      expect(value).toBe('2024-01-01T00:00:00Z');
    });

    it('should use example value when provided', () => {
      const value = parser.generateSampleValue(
        { type: 'string', example: 'custom-example' },
        'field'
      );
      expect(value).toBe('custom-example');
    });

    it('should use first enum value when enum provided', () => {
      const value = parser.generateSampleValue(
        { type: 'string', enum: ['active', 'inactive', 'pending'] },
        'status'
      );
      expect(value).toBe('active');
    });

    it('should generate numeric id for fields containing "id"', () => {
      const value = parser.generateSampleValue({ type: 'string' }, 'userId');
      expect(value).toBe('123');
    });

    it('should handle null schema', () => {
      const value = parser.generateSampleValue(null, 'field');
      expect(value).toBe('example');
    });

    it('should handle empty object schema', () => {
      const value = parser.generateSampleValue({}, 'field');
      expect(value).toBe('example');
    });
  });

  describe('Sample object generation', () => {
    it('should generate object with properties', () => {
      const schema = {
        type: 'object',
        properties: {
          name: { type: 'string' },
          age: { type: 'integer' },
        },
      };

      const result = parser.generateSampleObject(schema) as Record<
        string,
        unknown
      >;

      expect(result).toHaveProperty('name', 'example');
      expect(result).toHaveProperty('age', '1');
    });

    it('should generate array with items', () => {
      const schema = {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
          },
        },
      };

      const result = parser.generateSampleObject(schema) as unknown[];

      expect(Array.isArray(result)).toBe(true);
      expect(result.length).toBe(1);
    });

    it('should use example when provided', () => {
      const schema = {
        type: 'object',
        example: { custom: 'value' },
      };

      const result = parser.generateSampleObject(schema);

      expect(result).toEqual({ custom: 'value' });
    });

    it('should handle object without explicit type but with properties', () => {
      const schema = {
        properties: {
          field: { type: 'string' },
        },
      };

      const result = parser.generateSampleObject(schema) as Record<
        string,
        unknown
      >;

      expect(result).toHaveProperty('field', 'example');
    });

    it('should handle null schema', () => {
      const result = parser.generateSampleObject(null);
      expect(result).toEqual({});
    });
  });

  describe('Sample request generation', () => {
    it('should generate request with path parameters replaced', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));
      const endpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users/{id}'
      )!;

      const request = parser.generateSampleRequest(
        endpoint,
        'https://api.example.com'
      );

      expect(request.url).toBe(
        'https://api.example.com/users/1?include=example'
      );
    });

    it('should generate request with query parameters', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));
      const endpoint = result.endpoints.find(
        (e) => e.method === 'GET' && e.path === '/users/{id}'
      )!;

      const request = parser.generateSampleRequest(
        endpoint,
        'https://api.example.com'
      );

      expect(request.url).toContain('?');
      expect(request.url).toContain('include=');
    });

    it('should generate request with headers', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));
      const endpoint = result.endpoints.find(
        (e) => e.method === 'PUT' && e.path === '/users/{id}'
      )!;

      const request = parser.generateSampleRequest(
        endpoint,
        'https://api.example.com'
      );

      expect(request.headers).toHaveProperty('X-Request-ID');
    });

    it('should generate request with body for POST', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));
      const endpoint = result.endpoints.find(
        (e) => e.method === 'POST' && e.path === '/users'
      )!;

      const request = parser.generateSampleRequest(
        endpoint,
        'https://api.example.com'
      );

      expect(request.body).toBeDefined();
      expect(request.headers['Content-Type']).toBe('application/json');
    });

    it('should set correct method', () => {
      const result = parser.parseRawSpec(JSON.stringify(sampleJsonSpec));
      const endpoint = result.endpoints.find(
        (e) => e.method === 'DELETE' && e.path === '/users/{id}'
      )!;

      const request = parser.generateSampleRequest(
        endpoint,
        'https://api.example.com'
      );

      expect(request.method).toBe('DELETE');
    });
  });

  describe('load - file and URL loading', () => {
    it('should load spec from URL', async () => {
      const mockFetch = vi.fn().mockResolvedValue({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(sampleJsonSpec)),
      });
      vi.stubGlobal('fetch', mockFetch);

      const result = await parser.load('https://api.example.com/openapi.json');

      expect(mockFetch).toHaveBeenCalledWith(
        'https://api.example.com/openapi.json'
      );
      expect(result.title).toBe('Test API');
    });

    it('should throw on failed URL fetch', async () => {
      const mockFetch = vi.fn().mockResolvedValue({
        ok: false,
        status: 404,
        statusText: 'Not Found',
      });
      vi.stubGlobal('fetch', mockFetch);

      await expect(
        parser.load('https://api.example.com/openapi.json')
      ).rejects.toThrow('Failed to fetch spec: 404 Not Found');
    });

    // Note: File loading is tested via integration tests since mocking fs/promises
    // inside a test function is not supported by Vitest. The URL loading tests
    // verify the core parsing logic works correctly.

    it('should detect YAML from URL content', async () => {
      const mockFetch = vi.fn().mockResolvedValue({
        ok: true,
        text: () => Promise.resolve(sampleYamlSpec),
      });
      vi.stubGlobal('fetch', mockFetch);

      const result = await parser.load('https://api.example.com/spec');

      expect(result.title).toBe('YAML Test API');
    });
  });

  describe('Edge cases', () => {
    it('should handle empty paths', () => {
      const emptySpec = {
        openapi: '3.0.0',
        info: { title: 'Empty', version: '1.0.0' },
        paths: {},
      };

      const result = parser.parseRawSpec(JSON.stringify(emptySpec));

      expect(result.endpoints).toHaveLength(0);
    });

    it('should handle missing servers', () => {
      const noServersSpec = {
        openapi: '3.0.0',
        info: { title: 'No Servers', version: '1.0.0' },
        paths: {
          '/test': {
            get: { responses: { '200': { description: 'OK' } } },
          },
        },
      };

      const result = parser.parseRawSpec(JSON.stringify(noServersSpec));

      expect(result.base_url).toBe('');
    });

    it('should handle missing info fields', () => {
      const minimalSpec = {
        openapi: '3.0.0',
        info: {},
        paths: {},
      };

      const result = parser.parseRawSpec(JSON.stringify(minimalSpec));

      expect(result.title).toBe('Unknown API');
      expect(result.version).toBe('0.0.0');
    });

    it('should skip $ref parameters', () => {
      const specWithRef = {
        openapi: '3.0.0',
        info: { title: 'Test', version: '1.0.0' },
        paths: {
          '/test': {
            get: {
              parameters: [
                { $ref: '#/components/parameters/CommonParam' },
                { name: 'real', in: 'query', schema: { type: 'string' } },
              ],
              responses: { '200': { description: 'OK' } },
            },
          },
        },
      };

      const result = parser.parseRawSpec(JSON.stringify(specWithRef));
      const params = result.endpoints[0]?.parameters;

      expect(params?.length).toBe(1);
      expect(params?.[0].name).toBe('real');
    });

    it('should skip $ref request bodies', () => {
      const specWithRef = {
        openapi: '3.0.0',
        info: { title: 'Test', version: '1.0.0' },
        paths: {
          '/test': {
            post: {
              requestBody: { $ref: '#/components/requestBodies/Common' },
              responses: { '200': { description: 'OK' } },
            },
          },
        },
      };

      const result = parser.parseRawSpec(JSON.stringify(specWithRef));

      expect(result.endpoints[0]?.request_body).toBeUndefined();
    });

    it('should skip $ref responses', () => {
      const specWithRef = {
        openapi: '3.0.0',
        info: { title: 'Test', version: '1.0.0' },
        paths: {
          '/test': {
            get: {
              responses: {
                '200': { description: 'OK' },
                '500': { $ref: '#/components/responses/Error' },
              },
            },
          },
        },
      };

      const result = parser.parseRawSpec(JSON.stringify(specWithRef));

      expect(Object.keys(result.endpoints[0]?.responses || {})).toEqual(['200']);
    });

    it('should handle all HTTP methods', () => {
      const allMethodsSpec = {
        openapi: '3.0.0',
        info: { title: 'All Methods', version: '1.0.0' },
        paths: {
          '/test': {
            get: { responses: { '200': { description: 'OK' } } },
            post: { responses: { '200': { description: 'OK' } } },
            put: { responses: { '200': { description: 'OK' } } },
            delete: { responses: { '200': { description: 'OK' } } },
            patch: { responses: { '200': { description: 'OK' } } },
            head: { responses: { '200': { description: 'OK' } } },
            options: { responses: { '200': { description: 'OK' } } },
          },
        },
      };

      const result = parser.parseRawSpec(JSON.stringify(allMethodsSpec));

      expect(result.endpoints).toHaveLength(7);
      expect(result.endpoints.map((e) => e.method).sort()).toEqual([
        'DELETE',
        'GET',
        'HEAD',
        'OPTIONS',
        'PATCH',
        'POST',
        'PUT',
      ]);
    });

    it('should handle multiple content types in request body', () => {
      const multiContentSpec = {
        openapi: '3.0.0',
        info: { title: 'Multi Content', version: '1.0.0' },
        paths: {
          '/upload': {
            post: {
              requestBody: {
                content: {
                  'application/json': {
                    schema: { type: 'object' },
                  },
                  'multipart/form-data': {
                    schema: { type: 'object' },
                  },
                },
              },
              responses: { '200': { description: 'OK' } },
            },
          },
        },
      };

      const result = parser.parseRawSpec(JSON.stringify(multiContentSpec));

      expect(result.endpoints[0]?.request_body?.content_types).toContain(
        'application/json'
      );
      expect(result.endpoints[0]?.request_body?.content_types).toContain(
        'multipart/form-data'
      );
    });
  });

  describe('getLoadedSpec', () => {
    it('should return null before loading', () => {
      expect(parser.getLoadedSpec()).toBeNull();
    });

    it('should return spec after loading', () => {
      parser.parseRawSpec(JSON.stringify(sampleJsonSpec));

      const spec = parser.getLoadedSpec();
      expect(spec).not.toBeNull();
      expect(spec?.info.title).toBe('Test API');
    });
  });
});
