/**
 * OpenAPI MCP Server
 *
 * Provides MCP tools for parsing and exploring OpenAPI specifications:
 * - openapi_ingest: Load and parse an OpenAPI spec from file or URL
 * - openapi_list_endpoints: List all endpoints with filtering
 * - openapi_get_schema: Get detailed schema for an endpoint
 * - openapi_generate_request: Generate sample HTTP request for an endpoint
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';
import {
  OpenAPIParser,
  type ParsedSpec,
  type ParsedEndpoint,
} from './openapi-parser.js';

// State
let loadedSpec: ParsedSpec | null = null;
const parser = new OpenAPIParser();

// Create MCP Server
const server = new McpServer({
  name: 'openapi',
  version: '1.0.0',
});

// Tool: Ingest OpenAPI spec
server.registerTool(
  'openapi_ingest',
  {
    description:
      'Load and parse an OpenAPI specification from a file path or URL. Supports both JSON and YAML formats.',
    inputSchema: z.object({
      source: z
        .string()
        .describe('File path or URL to the OpenAPI spec (YAML or JSON)'),
    }).shape,
  },
  async (args: { source: string }) => {
    try {
      loadedSpec = await parser.load(args.source);

      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify(
              {
                success: true,
                title: loadedSpec.title,
                version: loadedSpec.version,
                base_url: loadedSpec.base_url,
                endpoint_count: loadedSpec.endpoints.length,
                security_schemes: Object.keys(loadedSpec.security_schemes),
              },
              null,
              2
            ),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({
              success: false,
              error: error instanceof Error ? error.message : 'Unknown error',
            }),
          },
        ],
      };
    }
  }
);

// Tool: List endpoints
server.registerTool(
  'openapi_list_endpoints',
  {
    description:
      'List all endpoints from the loaded OpenAPI spec with optional filtering by method, tag, or path.',
    inputSchema: z.object({
      method_filter: z
        .string()
        .optional()
        .describe('Filter by HTTP method (GET, POST, PUT, DELETE, etc.)'),
      tag_filter: z
        .string()
        .optional()
        .describe('Filter by tag'),
      path_contains: z
        .string()
        .optional()
        .describe('Filter paths containing this string'),
    }).shape,
  },
  async (args: {
    method_filter?: string;
    tag_filter?: string;
    path_contains?: string;
  }) => {
    if (!loadedSpec) {
      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({
              error: 'No spec loaded. Use openapi_ingest first.',
            }),
          },
        ],
      };
    }

    let endpoints = loadedSpec.endpoints;

    if (args.method_filter) {
      endpoints = endpoints.filter(
        (e) => e.method === args.method_filter!.toUpperCase()
      );
    }
    if (args.tag_filter) {
      endpoints = endpoints.filter((e) => e.tags.includes(args.tag_filter!));
    }
    if (args.path_contains) {
      endpoints = endpoints.filter((e) =>
        e.path.includes(args.path_contains!)
      );
    }

    return {
      content: [
        {
          type: 'text' as const,
          text: JSON.stringify(
            {
              count: endpoints.length,
              endpoints: endpoints.map((e) => ({
                endpoint_id: e.endpoint_id,
                method: e.method,
                path: e.path,
                summary: e.summary,
                tags: e.tags,
                requires_auth: e.security.length > 0,
              })),
            },
            null,
            2
          ),
        },
      ],
    };
  }
);

// Tool: Get endpoint schema
server.registerTool(
  'openapi_get_schema',
  {
    description:
      'Get detailed schema information for a specific endpoint. Use either endpoint_id or method+path to identify the endpoint.',
    inputSchema: z.object({
      endpoint_id: z
        .string()
        .optional()
        .describe('Endpoint ID from openapi_list_endpoints'),
      method: z
        .string()
        .optional()
        .describe('HTTP method (alternative to endpoint_id)'),
      path: z
        .string()
        .optional()
        .describe('Path (alternative to endpoint_id)'),
    }).shape,
  },
  async (args: { endpoint_id?: string; method?: string; path?: string }) => {
    if (!loadedSpec) {
      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({
              error: 'No spec loaded. Use openapi_ingest first.',
            }),
          },
        ],
      };
    }

    let endpoint: ParsedEndpoint | undefined;

    if (args.endpoint_id) {
      endpoint = loadedSpec.endpoints.find(
        (e) => e.endpoint_id === args.endpoint_id
      );
    } else if (args.method && args.path) {
      endpoint = loadedSpec.endpoints.find(
        (e) => e.method === args.method!.toUpperCase() && e.path === args.path
      );
    }

    if (!endpoint) {
      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({ error: 'Endpoint not found' }),
          },
        ],
      };
    }

    return {
      content: [
        {
          type: 'text' as const,
          text: JSON.stringify(endpoint, null, 2),
        },
      ],
    };
  }
);

// Tool: Generate sample request
server.registerTool(
  'openapi_generate_request',
  {
    description:
      'Generate a sample HTTP request for an endpoint based on its schema. Useful for testing endpoints.',
    inputSchema: z.object({
      endpoint_id: z
        .string()
        .describe('Endpoint ID from openapi_list_endpoints'),
      base_url: z
        .string()
        .optional()
        .describe('Override base URL from spec (optional)'),
    }).shape,
  },
  async (args: { endpoint_id: string; base_url?: string }) => {
    if (!loadedSpec) {
      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({
              error: 'No spec loaded. Use openapi_ingest first.',
            }),
          },
        ],
      };
    }

    const endpoint = loadedSpec.endpoints.find(
      (e) => e.endpoint_id === args.endpoint_id
    );
    if (!endpoint) {
      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({ error: 'Endpoint not found' }),
          },
        ],
      };
    }

    const baseUrl = args.base_url || loadedSpec.base_url;
    const sampleRequest = parser.generateSampleRequest(endpoint, baseUrl);

    return {
      content: [
        {
          type: 'text' as const,
          text: JSON.stringify(
            {
              endpoint_id: endpoint.endpoint_id,
              sample_request: sampleRequest,
            },
            null,
            2
          ),
        },
      ],
    };
  }
);

// Start the server
async function main(): Promise<void> {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('[openapi-mcp] MCP server started');
}

main().catch((error: unknown) => {
  console.error('[openapi-mcp] Fatal error:', error);
  process.exit(1);
});

// Export for testing
export { server, parser, loadedSpec };

// Export function to set loadedSpec for testing
export function setLoadedSpec(spec: ParsedSpec | null): void {
  loadedSpec = spec;
}

// Export function to get loadedSpec for testing
export function getLoadedSpec(): ParsedSpec | null {
  return loadedSpec;
}
