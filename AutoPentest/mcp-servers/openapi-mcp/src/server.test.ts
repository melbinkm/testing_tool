import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import type { ParsedSpec } from './openapi-parser.js';

// Tool handlers map shared across tests
const toolHandlers: Map<string, Function> = new Map();

// Mock parser object - needs to be hoisted
const mockParserInstance = {
  load: vi.fn(),
  parseRawSpec: vi.fn(),
  generateSampleRequest: vi.fn(),
  generateSampleValue: vi.fn(),
  generateSampleObject: vi.fn(),
  getLoadedSpec: vi.fn(),
};

// Mock the MCP SDK - vi.mock is hoisted
vi.mock('@modelcontextprotocol/sdk/server/mcp.js', () => {
  return {
    McpServer: vi.fn().mockImplementation(() => ({
      registerTool: vi.fn(
        (name: string, _config: object, handler: Function) => {
          toolHandlers.set(name, handler);
        }
      ),
      connect: vi.fn().mockResolvedValue(undefined),
    })),
  };
});

vi.mock('@modelcontextprotocol/sdk/server/stdio.js', () => ({
  StdioServerTransport: vi.fn().mockImplementation(() => ({})),
}));

// Mock OpenAPIParser - the factory is hoisted, so we use a global reference
vi.mock('./openapi-parser.js', () => {
  // This factory function is hoisted and run before test execution
  return {
    OpenAPIParser: vi.fn().mockImplementation(() => ({
      load: vi.fn(),
      parseRawSpec: vi.fn(),
      generateSampleRequest: vi.fn(),
      generateSampleValue: vi.fn(),
      generateSampleObject: vi.fn(),
      getLoadedSpec: vi.fn(),
    })),
  };
});

// Mock console.error to suppress startup messages
vi.spyOn(console, 'error').mockImplementation(() => {});

// Sample spec for testing
const sampleSpec: ParsedSpec = {
  title: 'Test API',
  version: '1.0.0',
  base_url: 'https://api.example.com',
  endpoints: [
    {
      endpoint_id: 'GET--users',
      method: 'GET',
      path: '/users',
      operation_id: 'listUsers',
      summary: 'List users',
      tags: ['users'],
      parameters: [],
      responses: { '200': { status_code: '200', description: 'OK' } },
      security: ['bearerAuth'],
    },
    {
      endpoint_id: 'POST--users',
      method: 'POST',
      path: '/users',
      operation_id: 'createUser',
      summary: 'Create user',
      tags: ['users'],
      parameters: [],
      request_body: {
        required: true,
        content_types: ['application/json'],
        schema: {
          type: 'object',
          properties: { name: { type: 'string' } },
        },
      },
      responses: { '201': { status_code: '201', description: 'Created' } },
      security: ['bearerAuth'],
    },
    {
      endpoint_id: 'GET--users--id-',
      method: 'GET',
      path: '/users/{id}',
      operation_id: 'getUser',
      summary: 'Get user',
      tags: ['users'],
      parameters: [
        { name: 'id', in: 'path', required: true, schema: { type: 'integer' } },
      ],
      responses: { '200': { status_code: '200', description: 'OK' } },
      security: [],
    },
    {
      endpoint_id: 'POST--auth-login',
      method: 'POST',
      path: '/auth/login',
      operation_id: 'login',
      summary: 'Login',
      tags: ['auth'],
      parameters: [],
      request_body: {
        required: true,
        content_types: ['application/json'],
        schema: { type: 'object' },
      },
      responses: { '200': { status_code: '200', description: 'OK' } },
      security: [],
    },
  ],
  security_schemes: {
    bearerAuth: { type: 'http', scheme: 'bearer' },
  },
};

describe('OpenAPI MCP Server', () => {
  let setLoadedSpec: (spec: ParsedSpec | null) => void;
  let parser: typeof mockParserInstance;

  beforeEach(async () => {
    vi.clearAllMocks();

    // Dynamically import to get the mocked version
    const serverModule = await import('./server.js');
    setLoadedSpec = serverModule.setLoadedSpec;

    // Get the parser instance from the module
    parser = serverModule.parser as typeof mockParserInstance;

    // Reset loaded spec before each test
    setLoadedSpec(null);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('openapi_ingest tool', () => {
    it('should load spec successfully', async () => {
      parser.load.mockResolvedValueOnce(sampleSpec);

      const handler = toolHandlers.get('openapi_ingest');
      expect(handler).toBeDefined();

      const result = await handler!({ source: '/path/to/spec.yaml' });

      expect(parser.load).toHaveBeenCalledWith('/path/to/spec.yaml');
      expect(result.content[0].type).toBe('text');

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.success).toBe(true);
      expect(parsed.title).toBe('Test API');
      expect(parsed.version).toBe('1.0.0');
      expect(parsed.base_url).toBe('https://api.example.com');
      expect(parsed.endpoint_count).toBe(4);
      expect(parsed.security_schemes).toContain('bearerAuth');
    });

    it('should handle load error', async () => {
      parser.load.mockRejectedValueOnce(new Error('File not found'));

      const handler = toolHandlers.get('openapi_ingest');
      const result = await handler!({ source: '/nonexistent.yaml' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.success).toBe(false);
      expect(parsed.error).toBe('File not found');
    });

    it('should handle URL source', async () => {
      parser.load.mockResolvedValueOnce(sampleSpec);

      const handler = toolHandlers.get('openapi_ingest');
      await handler!({ source: 'https://api.example.com/openapi.yaml' });

      expect(parser.load).toHaveBeenCalledWith(
        'https://api.example.com/openapi.yaml'
      );
    });
  });

  describe('openapi_list_endpoints tool', () => {
    it('should return error when no spec loaded', async () => {
      const handler = toolHandlers.get('openapi_list_endpoints');
      expect(handler).toBeDefined();

      const result = await handler!({});

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.error).toBe('No spec loaded. Use openapi_ingest first.');
    });

    it('should list all endpoints', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_list_endpoints');
      const result = await handler!({});

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.count).toBe(4);
      expect(parsed.endpoints.length).toBe(4);
    });

    it('should filter by method', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_list_endpoints');
      const result = await handler!({ method_filter: 'GET' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.count).toBe(2);
      expect(
        parsed.endpoints.every((e: { method: string }) => e.method === 'GET')
      ).toBe(true);
    });

    it('should filter by method case-insensitive', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_list_endpoints');
      const result = await handler!({ method_filter: 'get' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.count).toBe(2);
    });

    it('should filter by tag', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_list_endpoints');
      const result = await handler!({ tag_filter: 'auth' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.count).toBe(1);
      expect(parsed.endpoints[0].path).toBe('/auth/login');
    });

    it('should filter by path_contains', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_list_endpoints');
      const result = await handler!({ path_contains: 'users' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.count).toBe(3);
      expect(
        parsed.endpoints.every((e: { path: string }) =>
          e.path.includes('users')
        )
      ).toBe(true);
    });

    it('should combine multiple filters', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_list_endpoints');
      const result = await handler!({
        method_filter: 'POST',
        tag_filter: 'users',
      });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.count).toBe(1);
      expect(parsed.endpoints[0].path).toBe('/users');
      expect(parsed.endpoints[0].method).toBe('POST');
    });

    it('should include requires_auth indicator', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_list_endpoints');
      const result = await handler!({});

      const parsed = JSON.parse(result.content[0].text);

      const getUserEndpoint = parsed.endpoints.find(
        (e: { method: string; path: string }) =>
          e.method === 'GET' && e.path === '/users'
      );
      expect(getUserEndpoint.requires_auth).toBe(true);

      const getUserByIdEndpoint = parsed.endpoints.find(
        (e: { method: string; path: string }) =>
          e.method === 'GET' && e.path === '/users/{id}'
      );
      expect(getUserByIdEndpoint.requires_auth).toBe(false);
    });

    it('should return empty list when no matches', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_list_endpoints');
      const result = await handler!({ tag_filter: 'nonexistent' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.count).toBe(0);
      expect(parsed.endpoints).toEqual([]);
    });
  });

  describe('openapi_get_schema tool', () => {
    it('should return error when no spec loaded', async () => {
      const handler = toolHandlers.get('openapi_get_schema');
      expect(handler).toBeDefined();

      const result = await handler!({ endpoint_id: 'GET--users' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.error).toBe('No spec loaded. Use openapi_ingest first.');
    });

    it('should get endpoint by endpoint_id', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_get_schema');
      const result = await handler!({ endpoint_id: 'GET--users' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.endpoint_id).toBe('GET--users');
      expect(parsed.method).toBe('GET');
      expect(parsed.path).toBe('/users');
    });

    it('should get endpoint by method and path', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_get_schema');
      const result = await handler!({ method: 'POST', path: '/users' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.method).toBe('POST');
      expect(parsed.path).toBe('/users');
      expect(parsed.request_body).toBeDefined();
    });

    it('should handle case-insensitive method', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_get_schema');
      const result = await handler!({ method: 'post', path: '/users' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.method).toBe('POST');
    });

    it('should return error for non-existent endpoint_id', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_get_schema');
      const result = await handler!({ endpoint_id: 'NONEXISTENT' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.error).toBe('Endpoint not found');
    });

    it('should return error for non-existent method+path', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_get_schema');
      const result = await handler!({ method: 'DELETE', path: '/nonexistent' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.error).toBe('Endpoint not found');
    });

    it('should include full endpoint details', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_get_schema');
      const result = await handler!({ endpoint_id: 'POST--users' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.operation_id).toBe('createUser');
      expect(parsed.summary).toBe('Create user');
      expect(parsed.tags).toContain('users');
      expect(parsed.request_body.required).toBe(true);
      expect(parsed.security).toContain('bearerAuth');
    });
  });

  describe('openapi_generate_request tool', () => {
    it('should return error when no spec loaded', async () => {
      const handler = toolHandlers.get('openapi_generate_request');
      expect(handler).toBeDefined();

      const result = await handler!({ endpoint_id: 'GET--users' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.error).toBe('No spec loaded. Use openapi_ingest first.');
    });

    it('should generate sample request', async () => {
      setLoadedSpec(sampleSpec);
      parser.generateSampleRequest.mockReturnValueOnce({
        method: 'GET',
        url: 'https://api.example.com/users',
        headers: {},
      });

      const handler = toolHandlers.get('openapi_generate_request');
      const result = await handler!({ endpoint_id: 'GET--users' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.endpoint_id).toBe('GET--users');
      expect(parsed.sample_request.method).toBe('GET');
      expect(parsed.sample_request.url).toBe(
        'https://api.example.com/users'
      );
    });

    it('should use base_url override', async () => {
      setLoadedSpec(sampleSpec);
      parser.generateSampleRequest.mockReturnValueOnce({
        method: 'GET',
        url: 'https://custom.example.com/users',
        headers: {},
      });

      const handler = toolHandlers.get('openapi_generate_request');
      await handler!({
        endpoint_id: 'GET--users',
        base_url: 'https://custom.example.com',
      });

      expect(parser.generateSampleRequest).toHaveBeenCalledWith(
        expect.any(Object),
        'https://custom.example.com'
      );
    });

    it('should use spec base_url when no override', async () => {
      setLoadedSpec(sampleSpec);
      parser.generateSampleRequest.mockReturnValueOnce({
        method: 'GET',
        url: 'https://api.example.com/users',
        headers: {},
      });

      const handler = toolHandlers.get('openapi_generate_request');
      await handler!({ endpoint_id: 'GET--users' });

      expect(parser.generateSampleRequest).toHaveBeenCalledWith(
        expect.any(Object),
        'https://api.example.com'
      );
    });

    it('should return error for non-existent endpoint', async () => {
      setLoadedSpec(sampleSpec);

      const handler = toolHandlers.get('openapi_generate_request');
      const result = await handler!({ endpoint_id: 'NONEXISTENT' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.error).toBe('Endpoint not found');
    });

    it('should generate request with body for POST', async () => {
      setLoadedSpec(sampleSpec);
      parser.generateSampleRequest.mockReturnValueOnce({
        method: 'POST',
        url: 'https://api.example.com/users',
        headers: { 'Content-Type': 'application/json' },
        body: '{"name":"example"}',
      });

      const handler = toolHandlers.get('openapi_generate_request');
      const result = await handler!({ endpoint_id: 'POST--users' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.sample_request.body).toBeDefined();
      expect(parsed.sample_request.headers['Content-Type']).toBe(
        'application/json'
      );
    });

    it('should generate request with path parameters', async () => {
      setLoadedSpec(sampleSpec);
      parser.generateSampleRequest.mockReturnValueOnce({
        method: 'GET',
        url: 'https://api.example.com/users/1',
        headers: {},
      });

      const handler = toolHandlers.get('openapi_generate_request');
      const result = await handler!({ endpoint_id: 'GET--users--id-' });

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.sample_request.url).toBe(
        'https://api.example.com/users/1'
      );
    });
  });

  describe('Tool registration', () => {
    it('should register all four tools', async () => {
      expect(toolHandlers.has('openapi_ingest')).toBe(true);
      expect(toolHandlers.has('openapi_list_endpoints')).toBe(true);
      expect(toolHandlers.has('openapi_get_schema')).toBe(true);
      expect(toolHandlers.has('openapi_generate_request')).toBe(true);
    });
  });

  describe('State management', () => {
    it('should persist loaded spec across tool calls', async () => {
      parser.load.mockResolvedValueOnce(sampleSpec);

      // First call - ingest
      const ingestHandler = toolHandlers.get('openapi_ingest');
      await ingestHandler!({ source: '/path/to/spec.yaml' });

      // Second call - list endpoints should work
      const listHandler = toolHandlers.get('openapi_list_endpoints');
      const result = await listHandler!({});

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.error).toBeUndefined();
      expect(parsed.count).toBe(4);
    });

    it('should clear spec on new ingest', async () => {
      // First spec
      parser.load.mockResolvedValueOnce(sampleSpec);
      const ingestHandler = toolHandlers.get('openapi_ingest');
      await ingestHandler!({ source: '/path/to/spec1.yaml' });

      // Second spec (different)
      const newSpec: ParsedSpec = {
        ...sampleSpec,
        title: 'New API',
        endpoints: [sampleSpec.endpoints[0]],
      };
      parser.load.mockResolvedValueOnce(newSpec);
      await ingestHandler!({ source: '/path/to/spec2.yaml' });

      // List should show new spec's endpoints
      const listHandler = toolHandlers.get('openapi_list_endpoints');
      const result = await listHandler!({});

      const parsed = JSON.parse(result.content[0].text);
      expect(parsed.count).toBe(1);
    });
  });
});
