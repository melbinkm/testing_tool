/**
 * OpenAPI Parser
 *
 * Parses OpenAPI/Swagger specifications and extracts endpoint information
 * for penetration testing purposes.
 */

import * as fs from 'fs/promises';
import * as yaml from 'js-yaml';
import type { OpenAPIV3 } from 'openapi-types';

export interface ParsedParameter {
  name: string;
  in: 'query' | 'header' | 'path' | 'cookie';
  required: boolean;
  schema: unknown;
  description?: string;
}

export interface ParsedRequestBody {
  required: boolean;
  content_types: string[];
  schema: unknown;
}

export interface ParsedResponse {
  status_code: string;
  description: string;
  schema?: unknown;
}

export interface ParsedEndpoint {
  endpoint_id: string;
  method: string;
  path: string;
  operation_id?: string;
  summary?: string;
  description?: string;
  tags: string[];
  parameters: ParsedParameter[];
  request_body?: ParsedRequestBody;
  responses: Record<string, ParsedResponse>;
  security: string[];
}

export interface ParsedSpec {
  title: string;
  version: string;
  base_url: string;
  endpoints: ParsedEndpoint[];
  security_schemes: Record<string, unknown>;
}

export class OpenAPIParser {
  private spec: OpenAPIV3.Document | null = null;

  /**
   * Load and parse OpenAPI spec from file path or URL
   */
  async load(source: string): Promise<ParsedSpec> {
    let rawSpec: string;

    if (source.startsWith('http://') || source.startsWith('https://')) {
      const response = await fetch(source);
      if (!response.ok) {
        throw new Error(`Failed to fetch spec: ${response.status} ${response.statusText}`);
      }
      rawSpec = await response.text();
    } else {
      rawSpec = await fs.readFile(source, 'utf-8');
    }

    return this.parseRawSpec(rawSpec, source);
  }

  /**
   * Parse a raw spec string (JSON or YAML)
   */
  parseRawSpec(rawSpec: string, source: string = ''): ParsedSpec {
    // Detect YAML or JSON
    const isYaml =
      source.endsWith('.yaml') ||
      source.endsWith('.yml') ||
      rawSpec.trim().startsWith('openapi:') ||
      rawSpec.trim().startsWith('swagger:');

    const spec = isYaml
      ? (yaml.load(rawSpec) as OpenAPIV3.Document)
      : (JSON.parse(rawSpec) as OpenAPIV3.Document);

    this.spec = spec;

    return this.parse();
  }

  /**
   * Parse the loaded spec into structured endpoints
   */
  private parse(): ParsedSpec {
    if (!this.spec) {
      throw new Error('No spec loaded');
    }

    const endpoints: ParsedEndpoint[] = [];

    // Extract base URL from servers
    const baseUrl = this.spec.servers?.[0]?.url || '';

    // Parse all paths
    for (const [path, pathItem] of Object.entries(this.spec.paths || {})) {
      if (!pathItem) continue;

      const methods = [
        'get',
        'post',
        'put',
        'delete',
        'patch',
        'head',
        'options',
      ] as const;

      for (const method of methods) {
        const operation = (pathItem as Record<string, unknown>)[
          method
        ] as OpenAPIV3.OperationObject | undefined;
        if (!operation) continue;

        const endpointId = `${method.toUpperCase()}-${path.replace(/[^a-zA-Z0-9]/g, '-')}`;

        endpoints.push({
          endpoint_id: endpointId,
          method: method.toUpperCase(),
          path,
          operation_id: operation.operationId,
          summary: operation.summary,
          description: operation.description,
          tags: operation.tags || [],
          parameters: this.parseParameters([
            ...((pathItem as OpenAPIV3.PathItemObject).parameters || []),
            ...(operation.parameters || []),
          ]),
          request_body: this.parseRequestBody(operation.requestBody),
          responses: this.parseResponses(operation.responses || {}),
          security: this.parseSecurity(
            operation.security || this.spec!.security || []
          ),
        });
      }
    }

    return {
      title: this.spec.info?.title || 'Unknown API',
      version: this.spec.info?.version || '0.0.0',
      base_url: baseUrl,
      endpoints,
      security_schemes: (this.spec.components?.securitySchemes as Record<string, unknown>) || {},
    };
  }

  /**
   * Parse parameters from path and operation
   */
  private parseParameters(
    params: (OpenAPIV3.ParameterObject | OpenAPIV3.ReferenceObject)[]
  ): ParsedParameter[] {
    return params
      .filter((p): p is OpenAPIV3.ParameterObject => !('$ref' in p))
      .map((p) => ({
        name: p.name,
        in: p.in as 'query' | 'header' | 'path' | 'cookie',
        required: p.required || false,
        schema: p.schema,
        description: p.description,
      }));
  }

  /**
   * Parse request body from operation
   */
  private parseRequestBody(
    body?: OpenAPIV3.RequestBodyObject | OpenAPIV3.ReferenceObject
  ): ParsedRequestBody | undefined {
    if (!body || '$ref' in body) return undefined;

    return {
      required: body.required || false,
      content_types: Object.keys(body.content || {}),
      schema: body.content?.['application/json']?.schema,
    };
  }

  /**
   * Parse responses from operation
   */
  private parseResponses(
    responses: OpenAPIV3.ResponsesObject
  ): Record<string, ParsedResponse> {
    const result: Record<string, ParsedResponse> = {};

    for (const [code, response] of Object.entries(responses)) {
      if (!response || '$ref' in response) continue;

      result[code] = {
        status_code: code,
        description: response.description,
        schema: response.content?.['application/json']?.schema,
      };
    }

    return result;
  }

  /**
   * Parse security requirements
   */
  private parseSecurity(
    security: OpenAPIV3.SecurityRequirementObject[]
  ): string[] {
    return security.flatMap((req) => Object.keys(req));
  }

  /**
   * Generate a sample HTTP request for an endpoint
   */
  generateSampleRequest(
    endpoint: ParsedEndpoint,
    baseUrl: string
  ): {
    method: string;
    url: string;
    headers: Record<string, string>;
    body?: string;
  } {
    let path = endpoint.path;
    const headers: Record<string, string> = {};
    const queryParams: string[] = [];

    // Fill path parameters
    for (const param of endpoint.parameters) {
      if (param.in === 'path') {
        path = path.replace(
          `{${param.name}}`,
          this.generateSampleValue(param.schema, param.name)
        );
      } else if (param.in === 'query') {
        queryParams.push(
          `${param.name}=${this.generateSampleValue(param.schema, param.name)}`
        );
      } else if (param.in === 'header') {
        headers[param.name] = this.generateSampleValue(
          param.schema,
          param.name
        );
      }
    }

    let url = `${baseUrl}${path}`;
    if (queryParams.length > 0) {
      url += `?${queryParams.join('&')}`;
    }

    const result: {
      method: string;
      url: string;
      headers: Record<string, string>;
      body?: string;
    } = {
      method: endpoint.method,
      url,
      headers,
    };

    // Generate request body if needed
    if (endpoint.request_body?.schema) {
      headers['Content-Type'] = 'application/json';
      result.body = JSON.stringify(
        this.generateSampleObject(endpoint.request_body.schema)
      );
    }

    return result;
  }

  /**
   * Generate a sample value based on schema type
   */
  generateSampleValue(schema: unknown, name: string): string {
    if (!schema || typeof schema !== 'object') return 'example';

    const s = schema as {
      type?: string;
      format?: string;
      example?: unknown;
      enum?: unknown[];
    };

    if (s.example !== undefined) return String(s.example);
    if (s.enum && s.enum.length > 0) return String(s.enum[0]);

    switch (s.type) {
      case 'integer':
        return '1';
      case 'number':
        return '1.0';
      case 'boolean':
        return 'true';
      case 'string':
        if (s.format === 'uuid')
          return '550e8400-e29b-41d4-a716-446655440000';
        if (s.format === 'email') return 'test@example.com';
        if (s.format === 'date') return '2024-01-01';
        if (s.format === 'date-time') return '2024-01-01T00:00:00Z';
        if (name.toLowerCase().includes('id')) return '123';
        return 'example';
      default:
        return 'example';
    }
  }

  /**
   * Generate a sample object from schema
   */
  generateSampleObject(schema: unknown): unknown {
    if (!schema || typeof schema !== 'object') return {};

    const s = schema as {
      type?: string;
      properties?: Record<string, unknown>;
      items?: unknown;
      example?: unknown;
    };

    if (s.example !== undefined) return s.example;

    if (s.type === 'array' && s.items) {
      return [this.generateSampleObject(s.items)];
    }

    if (s.type === 'object' && s.properties) {
      const result: Record<string, unknown> = {};
      for (const [key, prop] of Object.entries(s.properties)) {
        result[key] = this.generateSampleValue(prop, key);
      }
      return result;
    }

    // Handle object without explicit type but with properties
    if (s.properties) {
      const result: Record<string, unknown> = {};
      for (const [key, prop] of Object.entries(s.properties)) {
        result[key] = this.generateSampleValue(prop, key);
      }
      return result;
    }

    return {};
  }

  /**
   * Get the currently loaded spec
   */
  getLoadedSpec(): OpenAPIV3.Document | null {
    return this.spec;
  }
}
