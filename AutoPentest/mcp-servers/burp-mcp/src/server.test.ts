import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Mock the MCP SDK before importing server
vi.mock('@modelcontextprotocol/sdk/server/mcp.js', () => {
  const toolHandlers: Map<string, Function> = new Map();

  return {
    McpServer: vi.fn().mockImplementation(() => ({
      tool: vi.fn(
        (
          name: string,
          _description: string,
          _schema: object,
          handler: Function
        ) => {
          toolHandlers.set(name, handler);
        }
      ),
      connect: vi.fn().mockResolvedValue(undefined),
      getToolHandler: (name: string) => toolHandlers.get(name),
    })),
  };
});

vi.mock('@modelcontextprotocol/sdk/server/stdio.js', () => ({
  StdioServerTransport: vi.fn().mockImplementation(() => ({})),
}));

// Mock fetch globally
const mockFetch = vi.fn();
vi.stubGlobal('fetch', mockFetch);

// Mock console.error to suppress startup messages
const mockConsoleError = vi.spyOn(console, 'error').mockImplementation(() => {});

describe('Burp MCP Server', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Reset fetch mock for each test
    mockFetch.mockReset();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('burp_get_status tool', () => {
    it('should return connected status when Burp is available', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify({ version: '2024.1.1' })),
      });

      // Dynamic import to get fresh instance
      const { BurpApiClient } = await import('./burp-api-client.js');
      const client = new BurpApiClient({
        baseUrl: 'http://127.0.0.1:1337',
        apiKey: 'test-key',
      });

      const version = await client.getVersion();

      expect(version).toEqual({ version: '2024.1.1' });
    });

    it('should handle connection error gracefully', async () => {
      mockFetch.mockRejectedValueOnce(new Error('Connection refused'));

      const { BurpApiClient } = await import('./burp-api-client.js');
      const client = new BurpApiClient({
        baseUrl: 'http://127.0.0.1:1337',
        apiKey: 'test-key',
      });

      await expect(client.getVersion()).rejects.toThrow('Connection refused');
    });
  });

  describe('burp_get_history tool', () => {
    it('should return proxy history', async () => {
      const mockHistory = [
        {
          index: 1,
          host: 'example.com',
          port: 443,
          protocol: 'https',
          method: 'GET',
          path: '/api/test',
          status: 200,
          length: 1234,
          mime_type: 'application/json',
          comment: '',
          time: '2024-01-15T10:30:00Z',
        },
      ];

      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockHistory)),
      });

      const { BurpApiClient } = await import('./burp-api-client.js');
      const client = new BurpApiClient({
        baseUrl: 'http://127.0.0.1:1337',
        apiKey: 'test-key',
      });

      const history = await client.getProxyHistory();

      expect(history).toEqual(mockHistory);
    });

    it('should filter by host when host_filter is provided', async () => {
      const mockHistory = [
        {
          index: 1,
          host: 'example.com',
          port: 443,
          protocol: 'https',
          method: 'GET',
          path: '/api/test',
          status: 200,
          length: 1234,
          mime_type: 'application/json',
          comment: '',
          time: '2024-01-15T10:30:00Z',
        },
        {
          index: 2,
          host: 'other.com',
          port: 80,
          protocol: 'http',
          method: 'GET',
          path: '/other',
          status: 200,
          length: 456,
          mime_type: 'text/html',
          comment: '',
          time: '2024-01-15T10:31:00Z',
        },
      ];

      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockHistory)),
      });

      const { BurpApiClient } = await import('./burp-api-client.js');
      const client = new BurpApiClient({
        baseUrl: 'http://127.0.0.1:1337',
        apiKey: 'test-key',
      });

      const history = await client.getProxyHistory();
      const filtered = history.filter((h) =>
        h.host.toLowerCase().includes('example')
      );

      expect(filtered).toHaveLength(1);
      expect(filtered[0].host).toBe('example.com');
    });
  });

  describe('burp_get_findings tool', () => {
    it('should return scanner issues', async () => {
      const mockIssues = [
        {
          serial_number: '1234567890',
          type: 'sql_injection',
          name: 'SQL Injection',
          host: 'example.com',
          path: '/api/users',
          severity: 'high',
          confidence: 'certain',
          issue_background: 'SQL injection...',
          remediation_background: 'Use parameterized queries',
          issue_detail: 'Parameter id is vulnerable',
          remediation_detail: 'Use prepared statements',
        },
      ];

      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockIssues)),
      });

      const { BurpApiClient } = await import('./burp-api-client.js');
      const client = new BurpApiClient({
        baseUrl: 'http://127.0.0.1:1337',
        apiKey: 'test-key',
      });

      const issues = await client.getIssues();

      expect(issues).toEqual(mockIssues);
    });

    it('should filter by severity', async () => {
      const mockIssues = [
        {
          serial_number: '1',
          type: 'sql_injection',
          name: 'SQL Injection',
          host: 'example.com',
          path: '/api/users',
          severity: 'high',
          confidence: 'certain',
          issue_background: '',
          remediation_background: '',
          issue_detail: '',
          remediation_detail: '',
        },
        {
          serial_number: '2',
          type: 'info_disclosure',
          name: 'Information Disclosure',
          host: 'example.com',
          path: '/api/version',
          severity: 'low',
          confidence: 'firm',
          issue_background: '',
          remediation_background: '',
          issue_detail: '',
          remediation_detail: '',
        },
      ];

      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockIssues)),
      });

      const { BurpApiClient } = await import('./burp-api-client.js');
      const client = new BurpApiClient({
        baseUrl: 'http://127.0.0.1:1337',
        apiKey: 'test-key',
      });

      const issues = await client.getIssues();
      const filtered = issues.filter(
        (i) => i.severity.toLowerCase() === 'high'
      );

      expect(filtered).toHaveLength(1);
      expect(filtered[0].name).toBe('SQL Injection');
    });
  });

  describe('burp_scope_check tool', () => {
    it('should return true when URL is in scope', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify({ in_scope: true })),
      });

      const { BurpApiClient } = await import('./burp-api-client.js');
      const client = new BurpApiClient({
        baseUrl: 'http://127.0.0.1:1337',
        apiKey: 'test-key',
      });

      const result = await client.isInScope('https://example.com/api');

      expect(result).toBe(true);
    });

    it('should return false when URL is not in scope', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify({ in_scope: false })),
      });

      const { BurpApiClient } = await import('./burp-api-client.js');
      const client = new BurpApiClient({
        baseUrl: 'http://127.0.0.1:1337',
        apiKey: 'test-key',
      });

      const result = await client.isInScope('https://other.com');

      expect(result).toBe(false);
    });
  });

  describe('burp_export_evidence tool', () => {
    it('should export history item as evidence', async () => {
      const mockHistory = [
        {
          index: 1,
          host: 'example.com',
          port: 443,
          protocol: 'https',
          method: 'GET',
          path: '/api/test',
          status: 200,
          length: 1234,
          mime_type: 'application/json',
          comment: '',
          time: '2024-01-15T10:30:00Z',
        },
      ];

      const mockRequest =
        'GET /api/test HTTP/1.1\r\n' +
        'Host: example.com\r\n' +
        'X-Engagement-ID: ENG-001\r\n' +
        '\r\n';

      const mockResponse =
        'HTTP/1.1 200 OK\r\n' +
        'Content-Type: application/json\r\n' +
        '\r\n' +
        '{"data": "test"}';

      // First call for getProxyHistory
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockHistory)),
      });

      // Second call for request
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockRequest)),
      });

      // Third call for response
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockResponse)),
      });

      const { BurpApiClient } = await import('./burp-api-client.js');
      const { EvidenceExporter } = await import('./evidence-exporter.js');

      const client = new BurpApiClient({
        baseUrl: 'http://127.0.0.1:1337',
        apiKey: 'test-key',
      });
      const exporter = new EvidenceExporter(client);

      const evidence = await exporter.exportHistoryItem(1);

      expect(evidence.history_index).toBe(1);
      expect(evidence.host).toBe('example.com');
      expect(evidence.method).toBe('GET');
      expect(evidence.status).toBe(200);
      expect(evidence.correlation_ids?.engagement_id).toBe('ENG-001');
    });

    it('should throw error for non-existent history item', async () => {
      const mockHistory = [
        {
          index: 1,
          host: 'example.com',
          port: 443,
          protocol: 'https',
          method: 'GET',
          path: '/api/test',
          status: 200,
          length: 1234,
          mime_type: 'application/json',
          comment: '',
          time: '2024-01-15T10:30:00Z',
        },
      ];

      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockHistory)),
      });

      const { BurpApiClient } = await import('./burp-api-client.js');
      const { EvidenceExporter } = await import('./evidence-exporter.js');

      const client = new BurpApiClient({
        baseUrl: 'http://127.0.0.1:1337',
        apiKey: 'test-key',
      });
      const exporter = new EvidenceExporter(client);

      await expect(exporter.exportHistoryItem(999)).rejects.toThrow(
        'History item 999 not found'
      );
    });
  });

  describe('Environment configuration', () => {
    it('should use default URL when BURP_API_URL is not set', () => {
      // The default is 'http://127.0.0.1:1337'
      const defaultUrl = 'http://127.0.0.1:1337';
      expect(defaultUrl).toBe('http://127.0.0.1:1337');
    });

    it('should use empty string as default API key', () => {
      const defaultKey = '';
      expect(defaultKey).toBe('');
    });
  });
});

// Cleanup
afterEach(() => {
  mockConsoleError.mockRestore();
});
