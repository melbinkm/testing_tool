import { describe, it, expect, vi, beforeEach } from 'vitest';
import { EvidenceExporter } from './evidence-exporter.js';
import { BurpApiClient, BurpProxyHistoryItem } from './burp-api-client.js';

describe('EvidenceExporter', () => {
  let exporter: EvidenceExporter;
  let mockClient: {
    getProxyHistory: ReturnType<typeof vi.fn>;
    getProxyHistoryItem: ReturnType<typeof vi.fn>;
  };

  const mockHistoryItems: BurpProxyHistoryItem[] = [
    {
      index: 1,
      host: 'example.com',
      port: 443,
      protocol: 'https',
      method: 'GET',
      path: '/api/users',
      status: 200,
      length: 1234,
      mime_type: 'application/json',
      comment: '',
      time: '2024-01-15T10:30:00Z',
    },
    {
      index: 2,
      host: 'api.example.com',
      port: 443,
      protocol: 'https',
      method: 'POST',
      path: '/api/login',
      status: 401,
      length: 456,
      mime_type: 'application/json',
      comment: 'Failed login',
      time: '2024-01-15T10:31:00Z',
    },
    {
      index: 3,
      host: 'other.com',
      port: 80,
      protocol: 'http',
      method: 'GET',
      path: '/test',
      status: 500,
      length: 789,
      mime_type: 'text/html',
      comment: '',
      time: '2024-01-15T10:32:00Z',
    },
  ];

  beforeEach(() => {
    mockClient = {
      getProxyHistory: vi.fn(),
      getProxyHistoryItem: vi.fn(),
    };
    exporter = new EvidenceExporter(mockClient as unknown as BurpApiClient);
  });

  describe('parseHeaders', () => {
    it('should parse headers from CRLF-separated HTTP message', () => {
      const raw =
        'GET /api/test HTTP/1.1\r\n' +
        'Host: example.com\r\n' +
        'Content-Type: application/json\r\n' +
        'X-Custom-Header: custom-value\r\n' +
        '\r\n' +
        'body content';

      const headers = exporter.parseHeaders(raw);

      expect(headers).toEqual({
        host: 'example.com',
        'content-type': 'application/json',
        'x-custom-header': 'custom-value',
      });
    });

    it('should parse headers from LF-separated HTTP message', () => {
      const raw =
        'GET /api/test HTTP/1.1\n' +
        'Host: example.com\n' +
        'Content-Type: text/plain\n' +
        '\n' +
        'body content';

      const headers = exporter.parseHeaders(raw);

      expect(headers).toEqual({
        host: 'example.com',
        'content-type': 'text/plain',
      });
    });

    it('should convert header names to lowercase', () => {
      const raw =
        'HTTP/1.1 200 OK\r\n' +
        'Content-Type: application/json\r\n' +
        'X-CUSTOM-HEADER: VALUE\r\n' +
        '\r\n';

      const headers = exporter.parseHeaders(raw);

      expect(headers['content-type']).toBe('application/json');
      expect(headers['x-custom-header']).toBe('VALUE');
    });

    it('should handle headers with colons in values', () => {
      const raw =
        'HTTP/1.1 200 OK\r\n' +
        'Location: https://example.com:8080/path\r\n' +
        '\r\n';

      const headers = exporter.parseHeaders(raw);

      expect(headers['location']).toBe('https://example.com:8080/path');
    });

    it('should trim whitespace from header values', () => {
      const raw =
        'GET / HTTP/1.1\r\n' +
        'Host:   example.com   \r\n' +
        'Accept:  text/html  \r\n' +
        '\r\n';

      const headers = exporter.parseHeaders(raw);

      expect(headers['host']).toBe('example.com');
      expect(headers['accept']).toBe('text/html');
    });

    it('should return empty object for message without headers', () => {
      const raw = 'GET / HTTP/1.1\r\n\r\n';

      const headers = exporter.parseHeaders(raw);

      expect(headers).toEqual({});
    });
  });

  describe('extractBody', () => {
    it('should extract body from CRLF-separated HTTP message', () => {
      const raw =
        'HTTP/1.1 200 OK\r\n' +
        'Content-Type: application/json\r\n' +
        '\r\n' +
        '{"status": "success"}';

      const body = exporter.extractBody(raw);

      expect(body).toBe('{"status": "success"}');
    });

    it('should extract body from LF-separated HTTP message', () => {
      const raw =
        'HTTP/1.1 200 OK\n' +
        'Content-Type: text/plain\n' +
        '\n' +
        'Hello, World!';

      const body = exporter.extractBody(raw);

      expect(body).toBe('Hello, World!');
    });

    it('should handle body with multiple blank lines', () => {
      const raw =
        'HTTP/1.1 200 OK\r\n' +
        'Content-Type: text/plain\r\n' +
        '\r\n' +
        'Line 1\r\n' +
        '\r\n' +
        'Line 3';

      const body = exporter.extractBody(raw);

      expect(body).toBe('Line 1\n\nLine 3');
    });

    it('should return undefined for message without body', () => {
      const raw = 'HTTP/1.1 204 No Content\r\nConnection: close\r\n';

      const body = exporter.extractBody(raw);

      expect(body).toBeUndefined();
    });
  });

  describe('exportHistoryItem', () => {
    it('should export history item with full details', async () => {
      const mockRequest =
        'GET /api/users HTTP/1.1\r\n' +
        'Host: example.com\r\n' +
        'X-Engagement-ID: ENG-001\r\n' +
        'X-Action-ID: ACT-123\r\n' +
        'X-Identity-ID: ID-456\r\n' +
        '\r\n';

      const mockResponse =
        'HTTP/1.1 200 OK\r\n' +
        'Content-Type: application/json\r\n' +
        '\r\n' +
        '{"users": []}';

      mockClient.getProxyHistory.mockResolvedValueOnce(mockHistoryItems);
      mockClient.getProxyHistoryItem.mockResolvedValueOnce({
        request: mockRequest,
        response: mockResponse,
      });

      const evidence = await exporter.exportHistoryItem(1);

      expect(evidence).toEqual({
        history_index: 1,
        host: 'example.com',
        method: 'GET',
        path: '/api/users',
        status: 200,
        timestamp: '2024-01-15T10:30:00Z',
        request_raw: mockRequest,
        response_raw: mockResponse,
        request_headers: {
          host: 'example.com',
          'x-engagement-id': 'ENG-001',
          'x-action-id': 'ACT-123',
          'x-identity-id': 'ID-456',
        },
        response_headers: {
          'content-type': 'application/json',
        },
        request_body: undefined,
        response_body: '{"users": []}',
        correlation_ids: {
          engagement_id: 'ENG-001',
          action_id: 'ACT-123',
          identity_id: 'ID-456',
        },
      });
    });

    it('should throw error when history item not found', async () => {
      mockClient.getProxyHistory.mockResolvedValueOnce(mockHistoryItems);

      await expect(exporter.exportHistoryItem(999)).rejects.toThrow(
        'History item 999 not found'
      );
    });

    it('should handle missing correlation IDs', async () => {
      const mockRequest =
        'GET /api/test HTTP/1.1\r\n' + 'Host: example.com\r\n' + '\r\n';

      const mockResponse = 'HTTP/1.1 200 OK\r\n\r\n';

      mockClient.getProxyHistory.mockResolvedValueOnce(mockHistoryItems);
      mockClient.getProxyHistoryItem.mockResolvedValueOnce({
        request: mockRequest,
        response: mockResponse,
      });

      const evidence = await exporter.exportHistoryItem(1);

      expect(evidence.correlation_ids).toEqual({
        engagement_id: undefined,
        action_id: undefined,
        identity_id: undefined,
      });
    });
  });

  describe('exportFiltered', () => {
    beforeEach(() => {
      // Set up mock for each history item's full details
      const mockRequests: Record<number, { request: string; response: string }> = {
        1: {
          request:
            'GET /api/users HTTP/1.1\r\nHost: example.com\r\nX-Engagement-ID: ENG-001\r\n\r\n',
          response: 'HTTP/1.1 200 OK\r\n\r\n{"users":[]}',
        },
        2: {
          request:
            'POST /api/login HTTP/1.1\r\nHost: api.example.com\r\nX-Engagement-ID: ENG-002\r\n\r\n',
          response: 'HTTP/1.1 401 Unauthorized\r\n\r\n{"error":"invalid"}',
        },
        3: {
          request: 'GET /test HTTP/1.1\r\nHost: other.com\r\n\r\n',
          response: 'HTTP/1.1 500 Error\r\n\r\n',
        },
      };

      mockClient.getProxyHistory.mockImplementation((limit?: number) => {
        if (limit && mockHistoryItems.length > limit) {
          return Promise.resolve(mockHistoryItems.slice(-limit));
        }
        return Promise.resolve(mockHistoryItems);
      });

      mockClient.getProxyHistoryItem.mockImplementation((index: number) => {
        return Promise.resolve(mockRequests[index]);
      });
    });

    it('should filter by host', async () => {
      const results = await exporter.exportFiltered({ host: 'example.com' });

      expect(results).toHaveLength(2);
      expect(results.map((r) => r.host)).toEqual([
        'example.com',
        'api.example.com',
      ]);
    });

    it('should filter by status codes', async () => {
      const results = await exporter.exportFiltered({
        status_codes: [200, 500],
      });

      expect(results).toHaveLength(2);
      expect(results.map((r) => r.status)).toEqual([200, 500]);
    });

    it('should filter by engagement_id', async () => {
      const results = await exporter.exportFiltered({
        engagement_id: 'ENG-001',
      });

      expect(results).toHaveLength(1);
      expect(results[0].correlation_ids?.engagement_id).toBe('ENG-001');
    });

    it('should apply limit', async () => {
      const results = await exporter.exportFiltered({ limit: 2 });

      expect(results).toHaveLength(2);
    });

    it('should combine multiple filters', async () => {
      const results = await exporter.exportFiltered({
        host: 'example.com',
        status_codes: [200],
      });

      expect(results).toHaveLength(1);
      expect(results[0].host).toBe('example.com');
      expect(results[0].status).toBe(200);
    });

    it('should return empty array when no items match', async () => {
      const results = await exporter.exportFiltered({
        host: 'nonexistent.com',
      });

      expect(results).toEqual([]);
    });

    it('should handle errors for individual items gracefully', async () => {
      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      mockClient.getProxyHistoryItem.mockImplementation((index: number) => {
        if (index === 2) {
          return Promise.reject(new Error('Failed to fetch item'));
        }
        return Promise.resolve({
          request: 'GET / HTTP/1.1\r\nHost: test.com\r\n\r\n',
          response: 'HTTP/1.1 200 OK\r\n\r\n',
        });
      });

      const results = await exporter.exportFiltered({});

      // Should have 2 results (items 1 and 3, not 2 which failed)
      expect(results).toHaveLength(2);
      expect(consoleSpy).toHaveBeenCalledWith(
        'Failed to export item 2:',
        expect.any(Error)
      );

      consoleSpy.mockRestore();
    });
  });
});
