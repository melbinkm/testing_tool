/**
 * Evidence Exporter
 *
 * Exports Burp proxy history items as structured evidence for
 * penetration testing documentation and audit trails.
 */

import { BurpApiClient, BurpProxyHistoryItem } from './burp-api-client.js';

export interface CorrelationIds {
  engagement_id?: string;
  action_id?: string;
  identity_id?: string;
}

export interface EvidenceItem {
  history_index: number;
  host: string;
  method: string;
  path: string;
  status: number;
  timestamp: string;
  request_raw: string;
  response_raw: string;
  request_headers: Record<string, string>;
  response_headers: Record<string, string>;
  request_body?: string;
  response_body?: string;
  correlation_ids?: CorrelationIds;
}

export interface EvidenceFilter {
  host?: string;
  engagement_id?: string;
  status_codes?: number[];
  limit?: number;
}

export class EvidenceExporter {
  private client: BurpApiClient;

  constructor(client: BurpApiClient) {
    this.client = client;
  }

  /**
   * Export a single history item as evidence
   * @param index - History item index
   */
  async exportHistoryItem(index: number): Promise<EvidenceItem> {
    const history = await this.client.getProxyHistory();
    const item = history.find((h: BurpProxyHistoryItem) => h.index === index);

    if (!item) {
      throw new Error(`History item ${index} not found`);
    }

    const { request, response } = await this.client.getProxyHistoryItem(index);

    // Parse headers from raw request/response
    const requestHeaders = this.parseHeaders(request);
    const responseHeaders = this.parseHeaders(response);

    // Extract correlation IDs from request headers
    const correlationIds: CorrelationIds = {
      engagement_id: requestHeaders['x-engagement-id'],
      action_id: requestHeaders['x-action-id'],
      identity_id: requestHeaders['x-identity-id'],
    };

    return {
      history_index: index,
      host: item.host,
      method: item.method,
      path: item.path,
      status: item.status,
      timestamp: item.time,
      request_raw: request,
      response_raw: response,
      request_headers: requestHeaders,
      response_headers: responseHeaders,
      request_body: this.extractBody(request),
      response_body: this.extractBody(response),
      correlation_ids: correlationIds,
    };
  }

  /**
   * Export multiple history items filtered by criteria
   * @param filter - Filter criteria
   */
  async exportFiltered(filter: EvidenceFilter): Promise<EvidenceItem[]> {
    const history = await this.client.getProxyHistory(filter.limit);
    const results: EvidenceItem[] = [];

    for (const item of history) {
      // Apply host filter
      if (filter.host && !item.host.includes(filter.host)) {
        continue;
      }

      // Apply status code filter
      if (filter.status_codes && !filter.status_codes.includes(item.status)) {
        continue;
      }

      try {
        const evidence = await this.exportHistoryItem(item.index);

        // Apply engagement_id filter
        if (
          filter.engagement_id &&
          evidence.correlation_ids?.engagement_id !== filter.engagement_id
        ) {
          continue;
        }

        results.push(evidence);
      } catch (error) {
        console.error(`Failed to export item ${item.index}:`, error);
      }
    }

    return results;
  }

  /**
   * Parse HTTP headers from raw HTTP message
   * @param raw - Raw HTTP message (request or response)
   */
  parseHeaders(raw: string): Record<string, string> {
    const headers: Record<string, string> = {};

    // Handle both CRLF and LF line endings
    const normalizedRaw = raw.replace(/\r\n/g, '\n');
    const lines = normalizedRaw.split('\n');

    // Skip first line (request line or status line)
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      if (line === '') break; // End of headers

      const colonIndex = line.indexOf(':');
      if (colonIndex > 0) {
        const name = line.substring(0, colonIndex).trim().toLowerCase();
        const value = line.substring(colonIndex + 1).trim();
        headers[name] = value;
      }
    }

    return headers;
  }

  /**
   * Extract body from raw HTTP message
   * @param raw - Raw HTTP message (request or response)
   */
  extractBody(raw: string): string | undefined {
    // Handle both CRLF and LF line endings
    const normalizedRaw = raw.replace(/\r\n/g, '\n');

    // Body starts after double newline
    const parts = normalizedRaw.split('\n\n');
    if (parts.length > 1) {
      const body = parts.slice(1).join('\n\n');
      // Return undefined for empty body
      return body || undefined;
    }
    return undefined;
  }
}
