/**
 * Burp Suite REST API Client
 *
 * Provides integration with Burp Suite Professional's REST API for:
 * - Proxy history retrieval
 * - Scanner findings
 * - Scope management
 * - Request forwarding
 */

export interface BurpProxyHistoryItem {
  index: number;
  host: string;
  port: number;
  protocol: string;
  method: string;
  path: string;
  status: number;
  length: number;
  mime_type: string;
  comment: string;
  time: string;
}

export interface BurpIssue {
  serial_number: string;
  type: string;
  name: string;
  host: string;
  path: string;
  severity: string;
  confidence: string;
  issue_background: string;
  remediation_background: string;
  issue_detail: string;
  remediation_detail: string;
}

export interface BurpRequest {
  host: string;
  port: number;
  useHttps: boolean;
  request: string;
}

export interface BurpApiClientOptions {
  baseUrl: string;
  apiKey: string;
}

export class BurpApiClient {
  private baseUrl: string;
  private apiKey: string;

  constructor(options: BurpApiClientOptions) {
    this.baseUrl = options.baseUrl.replace(/\/$/, '');
    this.apiKey = options.apiKey;
  }

  private async request<T>(
    method: string,
    endpoint: string,
    body?: unknown
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;

    const headers: Record<string, string> = {
      Authorization: this.apiKey,
      'Content-Type': 'application/json',
    };

    const response = await fetch(url, {
      method,
      headers,
      body: body ? JSON.stringify(body) : undefined,
    });

    if (!response.ok) {
      throw new Error(
        `Burp API error: ${response.status} ${response.statusText}`
      );
    }

    const text = await response.text();
    return text ? (JSON.parse(text) as T) : (null as T);
  }

  /**
   * Get proxy history
   * @param limit - Maximum number of history items to return (returns most recent)
   */
  async getProxyHistory(limit?: number): Promise<BurpProxyHistoryItem[]> {
    const history = await this.request<BurpProxyHistoryItem[]>(
      'GET',
      '/v0.1/proxy/history'
    );

    if (limit && history.length > limit) {
      return history.slice(-limit);
    }

    return history;
  }

  /**
   * Get proxy history item details (full request/response)
   * @param index - History item index
   */
  async getProxyHistoryItem(
    index: number
  ): Promise<{ request: string; response: string }> {
    const [request, response] = await Promise.all([
      this.request<string>('GET', `/v0.1/proxy/history/${index}/request`),
      this.request<string>('GET', `/v0.1/proxy/history/${index}/response`),
    ]);

    return { request, response };
  }

  /**
   * Get scanner issues
   */
  async getIssues(): Promise<BurpIssue[]> {
    return await this.request<BurpIssue[]>('GET', '/v0.1/scan/issues');
  }

  /**
   * Send request to target via Burp
   * @param request - Request to send
   */
  async sendRequest(request: BurpRequest): Promise<{ response: string }> {
    return await this.request<{ response: string }>(
      'POST',
      '/v0.1/send',
      request
    );
  }

  /**
   * Check if URL is in Burp scope
   * @param url - URL to check
   */
  async isInScope(url: string): Promise<boolean> {
    try {
      const result = await this.request<{ in_scope: boolean }>(
        'GET',
        `/v0.1/scope/in?url=${encodeURIComponent(url)}`
      );
      return result.in_scope;
    } catch {
      return false;
    }
  }

  /**
   * Add URL to Burp scope
   * @param url - URL to add
   */
  async addToScope(url: string): Promise<void> {
    await this.request<void>(
      'PUT',
      `/v0.1/scope?url=${encodeURIComponent(url)}`
    );
  }

  /**
   * Get Burp version/status
   */
  async getVersion(): Promise<{ version: string }> {
    return await this.request<{ version: string }>('GET', '/v0.1/version');
  }
}
