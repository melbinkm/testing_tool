import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { BurpApiClient, BurpProxyHistoryItem, BurpIssue } from './burp-api-client.js';

describe('BurpApiClient', () => {
  let client: BurpApiClient;
  let mockFetch: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    mockFetch = vi.fn();
    vi.stubGlobal('fetch', mockFetch);
    client = new BurpApiClient({
      baseUrl: 'http://127.0.0.1:1337',
      apiKey: 'test-api-key',
    });
  });

  afterEach(() => {
    vi.unstubAllGlobals();
  });

  describe('constructor', () => {
    it('should trim trailing slash from baseUrl', () => {
      const clientWithSlash = new BurpApiClient({
        baseUrl: 'http://127.0.0.1:1337/',
        apiKey: 'test-key',
      });
      // Access private property through any for testing
      expect((clientWithSlash as unknown as { baseUrl: string }).baseUrl).toBe(
        'http://127.0.0.1:1337'
      );
    });
  });

  describe('getVersion', () => {
    it('should return Burp version', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify({ version: '2024.1.1' })),
      });

      const result = await client.getVersion();

      expect(result).toEqual({ version: '2024.1.1' });
      expect(mockFetch).toHaveBeenCalledWith(
        'http://127.0.0.1:1337/v0.1/version',
        expect.objectContaining({
          method: 'GET',
          headers: {
            Authorization: 'test-api-key',
            'Content-Type': 'application/json',
          },
        })
      );
    });

    it('should throw error on non-ok response', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 401,
        statusText: 'Unauthorized',
      });

      await expect(client.getVersion()).rejects.toThrow(
        'Burp API error: 401 Unauthorized'
      );
    });
  });

  describe('getProxyHistory', () => {
    const mockHistory: BurpProxyHistoryItem[] = [
      {
        index: 1,
        host: 'example.com',
        port: 443,
        protocol: 'https',
        method: 'GET',
        path: '/api/test',
        status: 200,
        length: 1234,
        mime_type: 'application/json',
        comment: '',
        time: '2024-01-15T10:30:00Z',
      },
      {
        index: 2,
        host: 'example.com',
        port: 443,
        protocol: 'https',
        method: 'POST',
        path: '/api/login',
        status: 401,
        length: 456,
        mime_type: 'application/json',
        comment: 'Login attempt',
        time: '2024-01-15T10:31:00Z',
      },
    ];

    it('should return proxy history', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockHistory)),
      });

      const result = await client.getProxyHistory();

      expect(result).toEqual(mockHistory);
      expect(mockFetch).toHaveBeenCalledWith(
        'http://127.0.0.1:1337/v0.1/proxy/history',
        expect.any(Object)
      );
    });

    it('should limit results when limit is specified', async () => {
      const largeHistory = Array.from({ length: 100 }, (_, i) => ({
        ...mockHistory[0],
        index: i + 1,
      }));

      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(largeHistory)),
      });

      const result = await client.getProxyHistory(10);

      expect(result).toHaveLength(10);
      // Should return the last 10 items
      expect(result[0].index).toBe(91);
      expect(result[9].index).toBe(100);
    });

    it('should return all items when limit exceeds history length', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockHistory)),
      });

      const result = await client.getProxyHistory(100);

      expect(result).toEqual(mockHistory);
    });
  });

  describe('getProxyHistoryItem', () => {
    it('should return request and response for history item', async () => {
      const mockRequest = 'GET /api/test HTTP/1.1\r\nHost: example.com\r\n\r\n';
      const mockResponse =
        'HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{"status":"ok"}';

      mockFetch
        .mockResolvedValueOnce({
          ok: true,
          text: () => Promise.resolve(JSON.stringify(mockRequest)),
        })
        .mockResolvedValueOnce({
          ok: true,
          text: () => Promise.resolve(JSON.stringify(mockResponse)),
        });

      const result = await client.getProxyHistoryItem(1);

      expect(result).toEqual({
        request: mockRequest,
        response: mockResponse,
      });
      expect(mockFetch).toHaveBeenCalledTimes(2);
      expect(mockFetch).toHaveBeenCalledWith(
        'http://127.0.0.1:1337/v0.1/proxy/history/1/request',
        expect.any(Object)
      );
      expect(mockFetch).toHaveBeenCalledWith(
        'http://127.0.0.1:1337/v0.1/proxy/history/1/response',
        expect.any(Object)
      );
    });
  });

  describe('getIssues', () => {
    const mockIssues: BurpIssue[] = [
      {
        serial_number: '1234567890',
        type: 'sql_injection',
        name: 'SQL Injection',
        host: 'example.com',
        path: '/api/users',
        severity: 'high',
        confidence: 'certain',
        issue_background: 'SQL injection is a vulnerability...',
        remediation_background: 'Use parameterized queries...',
        issue_detail: 'Parameter "id" is vulnerable',
        remediation_detail: 'Use prepared statements',
      },
    ];

    it('should return scanner issues', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockIssues)),
      });

      const result = await client.getIssues();

      expect(result).toEqual(mockIssues);
      expect(mockFetch).toHaveBeenCalledWith(
        'http://127.0.0.1:1337/v0.1/scan/issues',
        expect.any(Object)
      );
    });
  });

  describe('sendRequest', () => {
    it('should send request through Burp', async () => {
      const mockResponse = { response: 'HTTP/1.1 200 OK\r\n\r\nSuccess' };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify(mockResponse)),
      });

      const result = await client.sendRequest({
        host: 'example.com',
        port: 443,
        useHttps: true,
        request: 'GET /test HTTP/1.1\r\nHost: example.com\r\n\r\n',
      });

      expect(result).toEqual(mockResponse);
      expect(mockFetch).toHaveBeenCalledWith(
        'http://127.0.0.1:1337/v0.1/send',
        expect.objectContaining({
          method: 'POST',
          body: JSON.stringify({
            host: 'example.com',
            port: 443,
            useHttps: true,
            request: 'GET /test HTTP/1.1\r\nHost: example.com\r\n\r\n',
          }),
        })
      );
    });
  });

  describe('isInScope', () => {
    it('should return true when URL is in scope', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify({ in_scope: true })),
      });

      const result = await client.isInScope('https://example.com/api');

      expect(result).toBe(true);
      expect(mockFetch).toHaveBeenCalledWith(
        'http://127.0.0.1:1337/v0.1/scope/in?url=https%3A%2F%2Fexample.com%2Fapi',
        expect.any(Object)
      );
    });

    it('should return false when URL is not in scope', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(JSON.stringify({ in_scope: false })),
      });

      const result = await client.isInScope('https://other-domain.com');

      expect(result).toBe(false);
    });

    it('should return false on error', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
      });

      const result = await client.isInScope('https://example.com');

      expect(result).toBe(false);
    });
  });

  describe('addToScope', () => {
    it('should add URL to scope', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(''),
      });

      await client.addToScope('https://example.com');

      expect(mockFetch).toHaveBeenCalledWith(
        'http://127.0.0.1:1337/v0.1/scope?url=https%3A%2F%2Fexample.com',
        expect.objectContaining({
          method: 'PUT',
        })
      );
    });

    it('should properly encode special characters in URL', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(''),
      });

      await client.addToScope('https://example.com/path?param=value&other=test');

      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining(
          'url=https%3A%2F%2Fexample.com%2Fpath%3Fparam%3Dvalue%26other%3Dtest'
        ),
        expect.any(Object)
      );
    });
  });

  describe('error handling', () => {
    it('should handle empty response body', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        text: () => Promise.resolve(''),
      });

      const result = await client.addToScope('https://example.com');

      expect(result).toBeUndefined();
    });

    it('should throw on network error', async () => {
      mockFetch.mockRejectedValueOnce(new Error('Network error'));

      await expect(client.getVersion()).rejects.toThrow('Network error');
    });
  });
});
