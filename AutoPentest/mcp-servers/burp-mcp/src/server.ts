/**
 * Burp Suite MCP Server
 *
 * Provides MCP tools for integrating with Burp Suite Professional:
 * - burp_get_history: Retrieve proxy history
 * - burp_get_findings: Get scanner findings
 * - burp_export_evidence: Export history item as evidence
 * - burp_scope_check: Check if URL is in scope
 * - burp_get_status: Get Burp connection status
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';
import { BurpApiClient } from './burp-api-client.js';
import { EvidenceExporter } from './evidence-exporter.js';

// Configuration
const BURP_API_URL = process.env.BURP_API_URL || 'http://127.0.0.1:1337';
const BURP_API_KEY = process.env.BURP_API_KEY || '';

// Initialize clients
const burpClient = new BurpApiClient({
  baseUrl: BURP_API_URL,
  apiKey: BURP_API_KEY,
});
const evidenceExporter = new EvidenceExporter(burpClient);

// Verify connection on startup
async function verifyConnection(): Promise<void> {
  try {
    const version = await burpClient.getVersion();
    console.error(`[burp-mcp] Connected to Burp Suite ${version.version}`);
  } catch {
    console.error(
      `[burp-mcp] Warning: Could not connect to Burp API at ${BURP_API_URL}`
    );
  }
}

// Create MCP Server
const server = new McpServer({
  name: 'burp',
  version: '1.0.0',
});

// Tool: Get proxy history
server.registerTool(
  'burp_get_history',
  {
    description:
      'Retrieve Burp Suite proxy history. Returns recent requests/responses captured by the proxy.',
    inputSchema: z.object({
      limit: z
        .number()
        .optional()
        .describe('Maximum number of history items to return (default: 50)'),
      host_filter: z
        .string()
        .optional()
        .describe('Filter by host (partial match)'),
    }).shape,
  },
  async (args: { limit?: number; host_filter?: string }) => {
    try {
      let history = await burpClient.getProxyHistory(args.limit || 50);

      if (args.host_filter) {
        history = history.filter((h) =>
          h.host.toLowerCase().includes(args.host_filter!.toLowerCase())
        );
      }

      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify(
              {
                count: history.length,
                items: history.map((h) => ({
                  index: h.index,
                  method: h.method,
                  host: h.host,
                  path: h.path,
                  status: h.status,
                  length: h.length,
                  time: h.time,
                })),
              },
              null,
              2
            ),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({
              error: error instanceof Error ? error.message : 'Unknown error',
              hint: 'Ensure Burp Suite is running with REST API enabled',
            }),
          },
        ],
      };
    }
  }
);

// Tool: Get scanner findings
server.registerTool(
  'burp_get_findings',
  {
    description: 'Retrieve passive scanner findings from Burp Suite.',
    inputSchema: z.object({
      severity_filter: z
        .enum(['high', 'medium', 'low', 'information'])
        .optional()
        .describe('Filter by severity (high, medium, low, information)'),
    }).shape,
  },
  async (args: { severity_filter?: string }) => {
    try {
      let issues = await burpClient.getIssues();

      if (args.severity_filter) {
        issues = issues.filter(
          (i) =>
            i.severity.toLowerCase() === args.severity_filter!.toLowerCase()
        );
      }

      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify(
              {
                count: issues.length,
                issues: issues.map((i) => ({
                  serial: i.serial_number,
                  name: i.name,
                  host: i.host,
                  path: i.path,
                  severity: i.severity,
                  confidence: i.confidence,
                  detail: i.issue_detail?.substring(0, 200),
                })),
              },
              null,
              2
            ),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({
              error: error instanceof Error ? error.message : 'Unknown error',
            }),
          },
        ],
      };
    }
  }
);

// Tool: Export evidence
server.registerTool(
  'burp_export_evidence',
  {
    description:
      'Export a proxy history item as evidence with full request/response details.',
    inputSchema: z.object({
      history_index: z
        .number()
        .describe('Index of the history item to export'),
    }).shape,
  },
  async (args: { history_index: number }) => {
    try {
      const evidence = await evidenceExporter.exportHistoryItem(
        args.history_index
      );

      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify(
              {
                success: true,
                evidence: {
                  ...evidence,
                  // Truncate large bodies for display
                  request_raw: evidence.request_raw.substring(0, 2000),
                  response_raw: evidence.response_raw.substring(0, 5000),
                },
              },
              null,
              2
            ),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({
              success: false,
              error: error instanceof Error ? error.message : 'Unknown error',
            }),
          },
        ],
      };
    }
  }
);

// Tool: Check if URL is in Burp scope
server.registerTool(
  'burp_scope_check',
  {
    description: 'Check if a URL is in Burp Suite target scope.',
    inputSchema: z.object({
      url: z.string().describe('URL to check'),
    }).shape,
  },
  async (args: { url: string }) => {
    try {
      const inScope = await burpClient.isInScope(args.url);

      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({
              url: args.url,
              in_scope: inScope,
            }),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({
              error: error instanceof Error ? error.message : 'Unknown error',
            }),
          },
        ],
      };
    }
  }
);

// Tool: Get Burp status
server.registerTool(
  'burp_get_status',
  {
    description: 'Get Burp Suite connection status and version.',
    inputSchema: z.object({}).shape,
  },
  async () => {
    try {
      const version = await burpClient.getVersion();

      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({
              connected: true,
              version: version.version,
              api_url: BURP_API_URL,
            }),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({
              connected: false,
              error: error instanceof Error ? error.message : 'Unknown error',
              api_url: BURP_API_URL,
            }),
          },
        ],
      };
    }
  }
);

// Start the server
async function main(): Promise<void> {
  await verifyConnection();
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('[burp-mcp] MCP server started');
}

main().catch((error: unknown) => {
  console.error('[burp-mcp] Fatal error:', error);
  process.exit(1);
});

// Export for testing
export { server, burpClient, evidenceExporter, BURP_API_URL };
