"""
Unit tests for budget_tracker.py with database persistence.

Tests budget tracking, rate limiting, and DB persistence across restarts.
"""
import unittest
import asyncio
import time
import sys
from datetime import datetime
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent / 'modules'))


class MockPool:
    """Mock asyncpg pool for budget tracker testing."""

    def __init__(self):
        self.budget_states = {}  # assessment_id -> budget state
        self.conn = MockConnection(self)

    def acquire(self):
        return self

    async def __aenter__(self):
        return self.conn

    async def __aexit__(self, *args):
        pass


class MockConnection:
    """Mock asyncpg connection for budget state operations."""

    def __init__(self, pool: MockPool):
        self.pool = pool

    async def fetchrow(self, query, *args):
        """Mock fetchrow for SELECT queries."""
        assessment_id = args[0] if args else None

        if "wm_budget_state" in query and assessment_id:
            if assessment_id in self.pool.budget_states:
                state = self.pool.budget_states[assessment_id]
                return {
                    "total_requests": state.get("total_requests", 0),
                    "requests_by_target": state.get("requests_by_target", {}),
                    "recent_requests": state.get("recent_requests", []),
                    "start_time": datetime.fromtimestamp(state.get("start_time", time.time()))
                }
        return None

    async def execute(self, query, *args):
        """Mock execute for INSERT/UPDATE queries."""
        if "wm_budget_state" in query and ("INSERT" in query or "ON CONFLICT" in query):
            assessment_id = args[0] if args else None
            if assessment_id:
                self.pool.budget_states[assessment_id] = {
                    "total_requests": args[1] if len(args) > 1 else 0,
                    "requests_by_target": args[2] if len(args) > 2 else {},
                    "recent_requests": args[3] if len(args) > 3 else [],
                    "start_time": args[4] if len(args) > 4 else time.time(),
                }
        return "OK"


class TestBudgetTracker(unittest.TestCase):
    """Test cases for BudgetTracker with DB persistence."""

    def setUp(self):
        """Set up test fixtures."""
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        self.pool = MockPool()

    def tearDown(self):
        """Tear down test fixtures."""
        self.loop.close()

    def _create_constraints(self, max_requests=1000, max_per_target=100, rps=10000):
        """Helper to create test constraints."""
        from lib.scope_types import ScopeConstraints, Budget, RateLimits, Timeouts

        return ScopeConstraints(
            budget=Budget(
                max_total_requests=max_requests,
                max_requests_per_target=max_per_target,
                max_scan_duration_hours=24
            ),
            rate_limits=RateLimits(
                requests_per_second=rps,
                max_concurrent=5,
                burst_limit=rps * 2
            ),
            timeouts=Timeouts(
                connect_timeout_ms=10000,
                read_timeout_ms=30000,
                total_timeout_ms=60000
            )
        )

    def test_budget_tracker_basic_tracking(self):
        """Test basic request tracking without DB."""
        from lib.budget_tracker import BudgetTracker

        async def run_test():
            constraints = self._create_constraints(max_requests=100)
            tracker = BudgetTracker(constraints)

            # Record some requests
            await tracker.record_request(target="example.com")
            await tracker.record_request(target="example.com")
            await tracker.record_request(target="test.com")

            # Check status
            status = tracker.get_status()
            self.assertEqual(status.total_requests, 3)
            self.assertEqual(status.remaining_requests, 97)
            self.assertEqual(status.requests_by_target["example.com"], 2)
            self.assertEqual(status.requests_by_target["test.com"], 1)

        self.loop.run_until_complete(run_test())

    def test_budget_tracker_max_requests_exceeded(self):
        """Test that budget exceeded error is raised."""
        from lib.budget_tracker import BudgetTracker
        from lib.scope_types import BudgetExceededError

        async def run_test():
            constraints = self._create_constraints(max_requests=5)
            tracker = BudgetTracker(constraints)

            # Record up to limit
            for i in range(5):
                await tracker.record_request()

            # Next request should raise error
            with self.assertRaises(BudgetExceededError) as cm:
                await tracker.record_request()

            self.assertEqual(cm.exception.budget_type, "total")

        self.loop.run_until_complete(run_test())

    def test_budget_tracker_per_target_limit(self):
        """Test per-target budget limit enforcement."""
        from lib.budget_tracker import BudgetTracker
        from lib.scope_types import BudgetExceededError

        async def run_test():
            constraints = self._create_constraints(
                max_requests=1000,
                max_per_target=3
            )
            tracker = BudgetTracker(constraints)

            # Record up to per-target limit
            for i in range(3):
                await tracker.record_request(target="example.com")

            # Next request to same target should raise error
            with self.assertRaises(BudgetExceededError):
                await tracker.record_request(target="example.com")

            # But request to different target should work
            await tracker.record_request(target="other.com")
            self.assertEqual(tracker.get_total_request_count(), 4)

        self.loop.run_until_complete(run_test())

    def test_budget_tracker_db_persistence(self):
        """Test that budget state persists to database."""
        from lib.budget_tracker import BudgetTracker

        async def run_test():
            constraints = self._create_constraints()
            tracker = BudgetTracker(
                constraints,
                assessment_id=1,
                pool=self.pool
            )
            await tracker.initialize()

            # Record some requests
            for i in range(15):  # More than batch size (10)
                await tracker.record_request(target="example.com")

            # Force persist
            await tracker._persist_state()

            # Verify state was saved to DB
            self.assertIn(1, self.pool.budget_states)
            state = self.pool.budget_states[1]
            self.assertEqual(state["total_requests"], 15)
            self.assertEqual(state["requests_by_target"]["example.com"], 15)

        self.loop.run_until_complete(run_test())

    def test_budget_tracker_load_state_from_db(self):
        """Test loading existing budget state from database."""
        from lib.budget_tracker import BudgetTracker

        async def run_test():
            # Pre-populate DB with state
            self.pool.budget_states[1] = {
                "total_requests": 50,
                "requests_by_target": {"example.com": 30, "test.com": 20},
                "recent_requests": [],
                "start_time": time.time()
            }

            # Create tracker and load state
            constraints = self._create_constraints()
            tracker = BudgetTracker(
                constraints,
                assessment_id=1,
                pool=self.pool
            )
            await tracker.initialize()

            # Verify state was loaded
            status = tracker.get_status()
            self.assertEqual(status.total_requests, 50)
            self.assertEqual(status.requests_by_target["example.com"], 30)
            self.assertEqual(status.requests_by_target["test.com"], 20)
            self.assertEqual(status.remaining_requests, 950)

        self.loop.run_until_complete(run_test())

    def test_budget_tracker_restart_scenario(self):
        """Test that budget state survives restart."""
        from lib.budget_tracker import BudgetTracker

        async def run_test():
            constraints = self._create_constraints()

            # First instance: record requests and persist
            tracker1 = BudgetTracker(
                constraints,
                assessment_id=1,
                pool=self.pool
            )
            await tracker1.initialize()

            for i in range(25):
                await tracker1.record_request(target="example.com")

            await tracker1._persist_state()

            # Simulate restart: create new instance
            tracker2 = BudgetTracker(
                constraints,
                assessment_id=1,
                pool=self.pool
            )
            await tracker2.initialize()

            # Verify state was loaded
            status = tracker2.get_status()
            self.assertEqual(status.total_requests, 25)
            self.assertEqual(status.requests_by_target["example.com"], 25)

            # Verify can continue recording
            await tracker2.record_request(target="example.com")
            self.assertEqual(tracker2.get_total_request_count(), 26)

        self.loop.run_until_complete(run_test())

    def test_budget_tracker_per_assessment_isolation(self):
        """Test that budget is isolated between assessments."""
        from lib.budget_tracker import BudgetTracker

        async def run_test():
            constraints = self._create_constraints()

            # Create trackers for two assessments
            tracker1 = BudgetTracker(constraints, assessment_id=1, pool=self.pool)
            tracker2 = BudgetTracker(constraints, assessment_id=2, pool=self.pool)

            await tracker1.initialize()
            await tracker2.initialize()

            # Record requests for assessment 1
            for i in range(50):
                await tracker1.record_request()

            await tracker1._persist_state()

            # Record requests for assessment 2
            for i in range(30):
                await tracker2.record_request()

            await tracker2._persist_state()

            # Verify isolation
            status1 = tracker1.get_status()
            status2 = tracker2.get_status()

            self.assertEqual(status1.total_requests, 50)
            self.assertEqual(status2.total_requests, 30)

            # Verify DB states are separate
            self.assertIn(1, self.pool.budget_states)
            self.assertIn(2, self.pool.budget_states)
            self.assertEqual(self.pool.budget_states[1]["total_requests"], 50)
            self.assertEqual(self.pool.budget_states[2]["total_requests"], 30)

        self.loop.run_until_complete(run_test())

    def test_budget_tracker_reset(self):
        """Test resetting budget tracker."""
        from lib.budget_tracker import BudgetTracker

        async def run_test():
            constraints = self._create_constraints()
            tracker = BudgetTracker(
                constraints,
                assessment_id=1,
                pool=self.pool
            )
            await tracker.initialize()

            # Record requests
            for i in range(10):
                await tracker.record_request(target="example.com")

            self.assertEqual(tracker.get_total_request_count(), 10)

            # Reset
            await tracker.reset()

            # Verify reset
            self.assertEqual(tracker.get_total_request_count(), 0)
            status = tracker.get_status()
            self.assertEqual(status.total_requests, 0)
            self.assertEqual(len(status.requests_by_target), 0)

            # Verify DB was updated
            await tracker._persist_state()
            state = self.pool.budget_states[1]
            self.assertEqual(state["total_requests"], 0)

        self.loop.run_until_complete(run_test())


if __name__ == "__main__":
    unittest.main()
