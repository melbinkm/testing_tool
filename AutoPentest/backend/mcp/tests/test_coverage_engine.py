"""
Tests for the Deterministic Coverage Engine.

Covers:
- World model DB: relationships table, coverage_matrix table, graph BFS/path
- Coverage tracker: endpoint classification, tool resolution, priority, matrix build
- Phase orchestrator: gate conditions, metrics, phase transitions
- Payload libraries: count verification, filtering
"""

from __future__ import annotations

import asyncio
import json
import os
import sys
import tempfile
import unittest

# Add modules to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "modules"))

# Mock mcp.types before importing anything that depends on it
import types as pytypes
mock_mcp = pytypes.ModuleType("mcp")
mock_mcp_types = pytypes.ModuleType("mcp.types")

class MockTool:
    def __init__(self, name="", description="", inputSchema=None):
        self.name = name
        self.description = description
        self.inputSchema = inputSchema or {}

class MockTextContent:
    def __init__(self, type="text", text=""):
        self.type = type
        self.text = text

mock_mcp_types.Tool = MockTool
mock_mcp_types.TextContent = MockTextContent
sys.modules["mcp"] = mock_mcp
sys.modules["mcp.types"] = mock_mcp_types


def run_async(coro):
    """Helper to run async code in sync tests."""
    return asyncio.get_event_loop().run_until_complete(coro)


# ---------------------------------------------------------------------------
# World Model Database Tests
# ---------------------------------------------------------------------------

class TestWorldModelDB(unittest.TestCase):
    """Test the relationships and coverage_matrix tables + methods."""

    def setUp(self):
        self.tmpdir = tempfile.mkdtemp()
        self.db_path = os.path.join(self.tmpdir, "test-wm.db")

    def tearDown(self):
        import shutil
        shutil.rmtree(self.tmpdir, ignore_errors=True)

    def _make_db(self):
        from lib.world_model_db import WorldModelDatabase
        db = WorldModelDatabase(db_path=self.db_path)
        run_async(db.init())
        return db

    # -- Schema creation --

    def test_schema_creates_tables(self):
        db = self._make_db()
        # Check relationships table exists
        row = run_async(db._fetchone(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='relationships'"
        ))
        self.assertIsNotNone(row)
        # Check coverage_matrix table exists
        row = run_async(db._fetchone(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='coverage_matrix'"
        ))
        self.assertIsNotNone(row)
        run_async(db.close())

    # -- Relationships --

    def test_add_relationship(self):
        db = self._make_db()
        rel = run_async(db.add_relationship(
            source_type="asset", source_id="a1",
            target_type="endpoint", target_id="e1",
            rel_type="has_endpoint",
        ))
        self.assertIn("id", rel)
        self.assertEqual(rel["source_type"], "asset")
        self.assertEqual(rel["target_type"], "endpoint")
        self.assertEqual(rel["rel_type"], "has_endpoint")
        run_async(db.close())

    def test_add_relationship_idempotent(self):
        db = self._make_db()
        run_async(db.add_relationship("asset", "a1", "endpoint", "e1", "has_endpoint"))
        run_async(db.add_relationship("asset", "a1", "endpoint", "e1", "has_endpoint"))
        rels = run_async(db.query_relationships(
            source_type="asset", source_id="a1", rel_type="has_endpoint"
        ))
        self.assertEqual(len(rels), 1)
        run_async(db.close())

    def test_add_relationship_invalid_type(self):
        db = self._make_db()
        with self.assertRaises(ValueError):
            run_async(db.add_relationship("invalid", "a1", "endpoint", "e1", "has_endpoint"))
        with self.assertRaises(ValueError):
            run_async(db.add_relationship("asset", "a1", "endpoint", "e1", "invalid_rel"))
        run_async(db.close())

    def test_query_relationships(self):
        db = self._make_db()
        run_async(db.add_relationship("asset", "a1", "endpoint", "e1", "has_endpoint"))
        run_async(db.add_relationship("asset", "a1", "endpoint", "e2", "has_endpoint"))
        run_async(db.add_relationship("finding", "f1", "hypothesis", "h1", "confirms"))

        rels = run_async(db.query_relationships(source_type="asset", source_id="a1"))
        self.assertEqual(len(rels), 2)

        rels = run_async(db.query_relationships(rel_type="confirms"))
        self.assertEqual(len(rels), 1)
        run_async(db.close())

    # -- Graph BFS --

    def test_get_neighbors_single_hop(self):
        db = self._make_db()
        run_async(db.add_relationship("asset", "a1", "endpoint", "e1", "has_endpoint"))
        run_async(db.add_relationship("asset", "a1", "endpoint", "e2", "has_endpoint"))

        result = run_async(db.get_neighbors("asset", "a1", depth=1))
        self.assertEqual(len(result["nodes"]), 2)
        self.assertEqual(len(result["edges"]), 2)
        run_async(db.close())

    def test_get_neighbors_multi_hop(self):
        db = self._make_db()
        run_async(db.add_relationship("asset", "a1", "endpoint", "e1", "has_endpoint"))
        run_async(db.add_relationship("endpoint", "e1", "finding", "f1", "has_finding"))

        result = run_async(db.get_neighbors("asset", "a1", depth=2))
        self.assertEqual(len(result["nodes"]), 2)  # e1 and f1
        self.assertEqual(len(result["edges"]), 2)
        run_async(db.close())

    def test_get_neighbors_direction_outgoing(self):
        db = self._make_db()
        run_async(db.add_relationship("asset", "a1", "endpoint", "e1", "has_endpoint"))
        run_async(db.add_relationship("finding", "f1", "asset", "a1", "targets"))

        result = run_async(db.get_neighbors("asset", "a1", direction="outgoing", depth=1))
        # Should only find e1 (outgoing from a1)
        self.assertEqual(len(result["nodes"]), 1)
        run_async(db.close())

    def test_get_neighbors_depth_capped(self):
        db = self._make_db()
        result = run_async(db.get_neighbors("asset", "a1", depth=10))
        # Depth should be capped at 4
        self.assertEqual(result["depth"], 4)
        run_async(db.close())

    # -- Graph shortest path --

    def test_get_attack_path_direct(self):
        db = self._make_db()
        run_async(db.add_relationship("asset", "a1", "endpoint", "e1", "has_endpoint"))

        path = run_async(db.get_attack_path("asset", "a1", "endpoint", "e1"))
        self.assertIsNotNone(path)
        self.assertEqual(len(path), 1)
        self.assertEqual(path[0]["rel_type"], "has_endpoint")
        run_async(db.close())

    def test_get_attack_path_two_hops(self):
        db = self._make_db()
        run_async(db.add_relationship("asset", "a1", "endpoint", "e1", "has_endpoint"))
        run_async(db.add_relationship("endpoint", "e1", "finding", "f1", "has_finding"))

        path = run_async(db.get_attack_path("asset", "a1", "finding", "f1"))
        self.assertIsNotNone(path)
        self.assertEqual(len(path), 2)
        run_async(db.close())

    def test_get_attack_path_no_path(self):
        db = self._make_db()
        run_async(db.add_relationship("asset", "a1", "endpoint", "e1", "has_endpoint"))

        path = run_async(db.get_attack_path("asset", "a1", "finding", "f_nonexistent"))
        self.assertIsNone(path)
        run_async(db.close())

    # -- Coverage matrix --

    def test_coverage_init_rows(self):
        db = self._make_db()
        # Create a test endpoint first
        ep = run_async(db.add_asset(kind="domain", name="test.com"))
        endpoint = run_async(db.add_endpoint(
            asset_id=ep["id"], method="GET", path="/api/users",
            parameters={"query": {"id": "string"}},
        ))

        rows = [{
            "endpoint_id": endpoint["id"],
            "vuln_class": "sqli",
            "tool_name": "fuzz_parameter",
            "tool_args": {"url": "https://test.com/api/users"},
            "priority": 70,
        }, {
            "endpoint_id": endpoint["id"],
            "vuln_class": "xss",
            "tool_name": "fuzz_parameter",
            "tool_args": {"url": "https://test.com/api/users"},
            "priority": 60,
        }]

        result = run_async(db.coverage_init_rows(rows))
        self.assertEqual(result["created"], 2)
        self.assertEqual(result["skipped_existing"], 0)
        run_async(db.close())

    def test_coverage_init_rows_idempotent(self):
        db = self._make_db()
        ep = run_async(db.add_asset(kind="domain", name="test.com"))
        endpoint = run_async(db.add_endpoint(
            asset_id=ep["id"], method="GET", path="/api/users"
        ))

        rows = [{"endpoint_id": endpoint["id"], "vuln_class": "sqli",
                 "tool_name": "fuzz_parameter", "tool_args": {}, "priority": 50}]

        run_async(db.coverage_init_rows(rows))
        result2 = run_async(db.coverage_init_rows(rows))
        self.assertEqual(result2["created"], 0)
        self.assertEqual(result2["skipped_existing"], 1)
        run_async(db.close())

    def test_coverage_next(self):
        db = self._make_db()
        ep = run_async(db.add_asset(kind="domain", name="test.com"))
        endpoint = run_async(db.add_endpoint(
            asset_id=ep["id"], method="POST", path="/api/login",
            parameters={"body": {"username": "string", "password": "string"}},
        ))

        rows = [
            {"endpoint_id": endpoint["id"], "vuln_class": "sqli",
             "tool_name": "fuzz_parameter", "tool_args": {}, "priority": 80},
            {"endpoint_id": endpoint["id"], "vuln_class": "xss",
             "tool_name": "fuzz_parameter", "tool_args": {}, "priority": 60},
        ]
        run_async(db.coverage_init_rows(rows))

        cells = run_async(db.coverage_next(limit=5))
        self.assertEqual(len(cells), 2)
        # Higher priority first
        self.assertEqual(cells[0]["vuln_class"], "sqli")
        self.assertEqual(cells[0]["priority"], 80)
        # Should include endpoint info
        self.assertIn("endpoint", cells[0])
        self.assertEqual(cells[0]["endpoint"]["method"], "POST")
        run_async(db.close())

    def test_coverage_mark(self):
        db = self._make_db()
        ep = run_async(db.add_asset(kind="domain", name="test.com"))
        endpoint = run_async(db.add_endpoint(
            asset_id=ep["id"], method="GET", path="/test"
        ))

        run_async(db.coverage_init_rows([{
            "endpoint_id": endpoint["id"], "vuln_class": "sqli",
            "tool_name": "fuzz_parameter", "tool_args": {}, "priority": 50,
        }]))

        cells = run_async(db.coverage_next(limit=1))
        cell_id = cells[0]["id"]

        updated = run_async(db.coverage_mark(
            cell_id=cell_id, status="vulnerable",
            finding_id="f123", result_summary="SQL injection found",
        ))
        self.assertEqual(updated["status"], "vulnerable")
        self.assertEqual(updated["finding_id"], "f123")
        self.assertIsNotNone(updated["completed_at"])
        run_async(db.close())

    def test_coverage_mark_invalid_status(self):
        db = self._make_db()
        with self.assertRaises(ValueError):
            run_async(db.coverage_mark("nonexistent", "invalid_status"))
        run_async(db.close())

    def test_coverage_report(self):
        db = self._make_db()
        ep = run_async(db.add_asset(kind="domain", name="test.com"))
        endpoint = run_async(db.add_endpoint(
            asset_id=ep["id"], method="GET", path="/test"
        ))

        rows = [
            {"endpoint_id": endpoint["id"], "vuln_class": "sqli",
             "tool_name": "fuzz_parameter", "tool_args": {}, "priority": 70},
            {"endpoint_id": endpoint["id"], "vuln_class": "xss",
             "tool_name": "fuzz_parameter", "tool_args": {}, "priority": 60},
        ]
        run_async(db.coverage_init_rows(rows))

        # Mark one cell
        cells = run_async(db.coverage_next(vuln_class="sqli", limit=1))
        run_async(db.coverage_mark(cells[0]["id"], "passed"))

        report = run_async(db.coverage_report())
        self.assertEqual(report["total_cells"], 2)
        self.assertEqual(report["by_status"]["passed"], 1)
        self.assertEqual(report["by_status"]["pending"], 1)
        self.assertEqual(report["coverage_pct"], 50.0)
        self.assertEqual(len(report["gaps"]), 1)
        run_async(db.close())

    def test_coverage_query_types(self):
        db = self._make_db()
        ep = run_async(db.add_asset(kind="domain", name="test.com"))
        endpoint = run_async(db.add_endpoint(
            asset_id=ep["id"], method="GET", path="/test"
        ))
        run_async(db.coverage_init_rows([
            {"endpoint_id": endpoint["id"], "vuln_class": "sqli",
             "tool_name": "fuzz_parameter", "tool_args": {}, "priority": 80},
        ]))

        # Test each query type
        for qt in ["untested_endpoints", "coverage_by_vuln_class",
                    "findings_by_endpoint", "vulnerable_endpoints",
                    "high_priority_gaps"]:
            results = run_async(db.coverage_query(qt))
            self.assertIsInstance(results, list)

        # Test invalid query type
        with self.assertRaises(ValueError):
            run_async(db.coverage_query("invalid_type"))

        run_async(db.close())


# ---------------------------------------------------------------------------
# Coverage Tracker Tests
# ---------------------------------------------------------------------------

class TestCoverageTracker(unittest.TestCase):
    """Test the coverage tracker logic."""

    def test_classify_endpoint_with_params(self):
        from lib.coverage_tracker import CoverageTracker

        endpoint = {
            "id": "e1",
            "method": "POST",
            "path": "/api/users",
            "parameters": {"body": {"username": "string", "password": "string"}},
            "auth_required": True,
        }
        classes = CoverageTracker.classify_endpoint(endpoint)
        # Should include param-based + auth-based + always classes
        self.assertIn("sqli", classes)
        self.assertIn("xss", classes)
        self.assertIn("idor", classes)
        self.assertIn("auth_bypass", classes)
        self.assertIn("info_disclosure", classes)
        self.assertIn("nuclei", classes)

    def test_classify_endpoint_minimal(self):
        from lib.coverage_tracker import CoverageTracker

        endpoint = {
            "id": "e2",
            "method": "GET",
            "path": "/health",
            "parameters": {},
            "auth_required": False,
        }
        classes = CoverageTracker.classify_endpoint(endpoint)
        # Should have only the "always" classes
        self.assertIn("info_disclosure", classes)
        self.assertIn("misconfig", classes)
        self.assertIn("nuclei", classes)
        # Should NOT have param-based classes
        self.assertNotIn("sqli", classes)
        self.assertNotIn("xss", classes)

    def test_classify_endpoint_path_params(self):
        from lib.coverage_tracker import CoverageTracker

        endpoint = {
            "id": "e3",
            "method": "GET",
            "path": "/api/users/{id}/profile",
            "parameters": {},
            "auth_required": False,
        }
        classes = CoverageTracker.classify_endpoint(endpoint)
        self.assertIn("idor", classes)
        self.assertIn("ssrf", classes)

    def test_resolve_tool_call_sqli(self):
        from lib.coverage_tracker import CoverageTracker

        endpoint = {
            "method": "POST",
            "path": "/api/login",
            "parameters": {"body": {"username": "string"}},
        }
        result = CoverageTracker.resolve_tool_call(endpoint, "sqli", "https://example.com")
        self.assertEqual(result["tool_name"], "fuzz_parameter")
        self.assertEqual(result["arguments"]["url"], "https://example.com/api/login")
        self.assertIn("injection", result["arguments"]["payload_types"])

    def test_resolve_tool_call_nuclei(self):
        from lib.coverage_tracker import CoverageTracker

        endpoint = {"method": "GET", "path": "/api/v1/info", "parameters": {}}
        result = CoverageTracker.resolve_tool_call(endpoint, "nuclei", "https://example.com")
        self.assertEqual(result["tool_name"], "nuclei_scan_template")
        self.assertEqual(result["arguments"]["targets"], ["https://example.com/api/v1/info"])

    def test_resolve_tool_call_auth_diff(self):
        from lib.coverage_tracker import CoverageTracker

        endpoint = {"method": "GET", "path": "/api/admin", "parameters": {}}
        result = CoverageTracker.resolve_tool_call(endpoint, "idor", "https://example.com")
        self.assertEqual(result["tool_name"], "auth_diff_test")
        self.assertEqual(result["arguments"]["url"], "https://example.com/api/admin")

    def test_compute_priority_base(self):
        from lib.coverage_tracker import CoverageTracker

        endpoint = {"method": "GET", "path": "/test", "parameters": {},
                     "auth_required": False}
        priority = CoverageTracker.compute_priority(endpoint, "info_disclosure")
        # base=50, -10 for low severity = 40
        self.assertEqual(priority, 40)

    def test_compute_priority_high(self):
        from lib.coverage_tracker import CoverageTracker

        endpoint = {
            "method": "POST", "path": "/api/login",
            "parameters": {"body": {"user": "s", "pass": "s", "token": "s"}},
            "auth_required": True,
        }
        priority = CoverageTracker.compute_priority(endpoint, "sqli")
        # base=50 + 20(auth) + 10(POST) + 10(high sev) + 15(3 params capped) = 105 -> capped at 100
        self.assertEqual(priority, 100)

    def test_build_matrix(self):
        from lib.coverage_tracker import CoverageTracker

        endpoints = [
            {
                "id": "e1",
                "method": "POST",
                "path": "/api/login",
                "parameters": {"body": {"username": "string"}},
                "auth_required": False,
            },
            {
                "id": "e2",
                "method": "GET",
                "path": "/health",
                "parameters": {},
                "auth_required": False,
            },
        ]
        rows = CoverageTracker.build_matrix(endpoints, "https://example.com")
        self.assertGreater(len(rows), 0)
        # All rows should have required fields
        for row in rows:
            self.assertIn("endpoint_id", row)
            self.assertIn("vuln_class", row)
            self.assertIn("tool_name", row)
            self.assertIn("tool_args", row)
            self.assertIn("priority", row)

    def test_build_matrix_filtered(self):
        from lib.coverage_tracker import CoverageTracker

        endpoints = [{
            "id": "e1", "method": "POST", "path": "/api/login",
            "parameters": {"body": {"username": "string"}},
            "auth_required": False,
        }]
        rows = CoverageTracker.build_matrix(endpoints, "https://example.com",
                                             vuln_classes=["sqli", "xss"])
        vuln_classes = {r["vuln_class"] for r in rows}
        self.assertTrue(vuln_classes.issubset({"sqli", "xss"}))

    def test_build_matrix_deterministic(self):
        from lib.coverage_tracker import CoverageTracker

        endpoints = [{
            "id": "e1", "method": "GET", "path": "/api/test",
            "parameters": {"query": {"q": "string"}},
            "auth_required": False,
        }]
        rows1 = CoverageTracker.build_matrix(endpoints, "https://example.com")
        rows2 = CoverageTracker.build_matrix(endpoints, "https://example.com")

        # Same input → same output
        self.assertEqual(len(rows1), len(rows2))
        for r1, r2 in zip(rows1, rows2):
            self.assertEqual(r1["endpoint_id"], r2["endpoint_id"])
            self.assertEqual(r1["vuln_class"], r2["vuln_class"])
            self.assertEqual(r1["tool_name"], r2["tool_name"])
            self.assertEqual(r1["priority"], r2["priority"])


# ---------------------------------------------------------------------------
# Phase Orchestrator Tests
# ---------------------------------------------------------------------------

class TestPhaseOrchestrator(unittest.TestCase):
    """Test the phase orchestrator gate conditions and transitions."""

    def setUp(self):
        self.tmpdir = tempfile.mkdtemp()
        self.db_path = os.path.join(self.tmpdir, "test-wm.db")

    def tearDown(self):
        import shutil
        shutil.rmtree(self.tmpdir, ignore_errors=True)

    def _make_db(self):
        from lib.world_model_db import WorldModelDatabase
        db = WorldModelDatabase(db_path=self.db_path)
        run_async(db.init())
        return db

    def test_check_gates_phase1(self):
        from lib.phase_orchestrator import PhaseOrchestrator
        db = self._make_db()
        orch = PhaseOrchestrator(db)
        # Phase 1 has no gates
        result = orch.check_gates(1, {})
        self.assertTrue(result["met"])
        run_async(db.close())

    def test_check_gates_phase2_not_met(self):
        from lib.phase_orchestrator import PhaseOrchestrator
        db = self._make_db()
        orch = PhaseOrchestrator(db)
        metrics = {"assets": 1, "endpoints": 2}
        result = orch.check_gates(2, metrics)
        self.assertFalse(result["met"])
        unmet = [c for c in result["conditions"] if not c["met"]]
        self.assertGreater(len(unmet), 0)
        run_async(db.close())

    def test_check_gates_phase2_met(self):
        from lib.phase_orchestrator import PhaseOrchestrator
        db = self._make_db()
        orch = PhaseOrchestrator(db)
        metrics = {"assets": 5, "endpoints": 10}
        result = orch.check_gates(2, metrics)
        self.assertTrue(result["met"])
        run_async(db.close())

    def test_check_gates_phase4(self):
        from lib.phase_orchestrator import PhaseOrchestrator
        db = self._make_db()
        orch = PhaseOrchestrator(db)
        metrics = {"confirmed_hypotheses": 2, "findings": 3}
        result = orch.check_gates(4, metrics)
        self.assertTrue(result["met"])
        run_async(db.close())

    def test_get_metrics(self):
        from lib.phase_orchestrator import PhaseOrchestrator
        db = self._make_db()
        # Add some data
        run_async(db.add_asset(kind="domain", name="test.com"))
        run_async(db.add_asset(kind="subdomain", name="api.test.com"))
        asset = run_async(db.add_asset(kind="domain", name="example.com"))
        run_async(db.add_endpoint(asset_id=asset["id"], method="GET", path="/test"))

        orch = PhaseOrchestrator(db)
        metrics = run_async(orch.get_metrics())
        self.assertEqual(metrics["assets"], 3)
        self.assertEqual(metrics["endpoints"], 1)
        run_async(db.close())

    def test_get_status(self):
        from lib.phase_orchestrator import PhaseOrchestrator
        db = self._make_db()
        orch = PhaseOrchestrator(db)

        status = run_async(orch.get_status())
        self.assertEqual(status["current_phase"], 1)
        self.assertEqual(status["phase_name"], "Reconnaissance")
        self.assertIn("metrics", status)
        self.assertIn("phases", status)
        self.assertEqual(len(status["phases"]), 5)
        run_async(db.close())

    def test_advance_sequential(self):
        from lib.phase_orchestrator import PhaseOrchestrator
        db = self._make_db()
        # Add enough data to pass phase 2 gates
        for i in range(5):
            asset = run_async(db.add_asset(kind="domain", name=f"test{i}.com"))
            for j in range(3):
                run_async(db.add_endpoint(
                    asset_id=asset["id"], method="GET", path=f"/api/v{j}"
                ))

        orch = PhaseOrchestrator(db)
        result = run_async(orch.advance(target_phase=2))
        self.assertTrue(result["success"])
        self.assertEqual(result["current_phase"], 2)
        run_async(db.close())

    def test_advance_skip_not_allowed(self):
        from lib.phase_orchestrator import PhaseOrchestrator
        db = self._make_db()
        orch = PhaseOrchestrator(db)
        # Can't skip from phase 1 to phase 3
        result = run_async(orch.advance(target_phase=3))
        self.assertFalse(result["success"])
        run_async(db.close())

    def test_advance_force(self):
        from lib.phase_orchestrator import PhaseOrchestrator
        db = self._make_db()
        orch = PhaseOrchestrator(db)
        # Force advance without meeting gates
        result = run_async(orch.advance(target_phase=2, force=True))
        self.assertTrue(result["success"])
        self.assertTrue(result.get("forced", False))
        run_async(db.close())

    def test_advance_invalid_phase(self):
        from lib.phase_orchestrator import PhaseOrchestrator
        db = self._make_db()
        orch = PhaseOrchestrator(db)
        result = run_async(orch.advance(target_phase=6))
        self.assertFalse(result["success"])
        run_async(db.close())


# ---------------------------------------------------------------------------
# Payload Library Tests
# ---------------------------------------------------------------------------

class TestPayloadLibraries(unittest.TestCase):
    """Test payload library counts and filtering."""

    def test_xss_payloads_count(self):
        try:
            from lib.xss_payloads import get_all_payloads_flat, get_xss_payloads
            payloads = get_all_payloads_flat()
            self.assertGreaterEqual(len(payloads), 20)

            # Test filtering
            reflected = get_xss_payloads(technique="reflected")
            self.assertGreater(len(reflected), 0)
            for p in reflected:
                self.assertEqual(p.technique, "reflected")
        except ImportError:
            self.skipTest("xss_payloads not yet created")

    def test_ssrf_payloads_count(self):
        try:
            from lib.ssrf_payloads import get_all_payloads_flat, get_ssrf_payloads
            payloads = get_all_payloads_flat()
            self.assertGreaterEqual(len(payloads), 15)

            internal = get_ssrf_payloads(technique="internal_ip")
            self.assertGreater(len(internal), 0)
        except ImportError:
            self.skipTest("ssrf_payloads not yet created")

    def test_path_traversal_payloads_count(self):
        try:
            from lib.path_traversal_payloads import get_all_payloads_flat, get_path_traversal_payloads
            payloads = get_all_payloads_flat()
            self.assertGreaterEqual(len(payloads), 15)

            basic = get_path_traversal_payloads(technique="basic")
            self.assertGreater(len(basic), 0)
        except ImportError:
            self.skipTest("path_traversal_payloads not yet created")

    def test_ssti_payloads_count(self):
        try:
            from lib.ssti_payloads import get_all_payloads_flat, get_ssti_payloads
            payloads = get_all_payloads_flat()
            self.assertGreaterEqual(len(payloads), 15)

            jinja2 = get_ssti_payloads(engine="jinja2")
            self.assertGreater(len(jinja2), 0)
        except ImportError:
            self.skipTest("ssti_payloads not yet created")

    def test_sql_payloads_existing(self):
        """Verify existing SQL payloads still work."""
        from lib.sql_payloads import get_all_payloads_flat, get_sql_payloads
        payloads = get_all_payloads_flat()
        self.assertGreaterEqual(len(payloads), 80)

        mysql = get_sql_payloads(db_type="mysql")
        self.assertGreater(len(mysql), 0)


# ---------------------------------------------------------------------------
# Constants Validation Tests
# ---------------------------------------------------------------------------

class TestConstants(unittest.TestCase):
    """Validate that constants are consistent across modules."""

    def test_coverage_statuses(self):
        from lib.world_model_db import COVERAGE_STATUSES
        expected = ("pending", "in_progress", "passed", "vulnerable", "skipped", "error")
        self.assertEqual(COVERAGE_STATUSES, expected)

    def test_vuln_classes(self):
        from lib.world_model_db import VULN_CLASSES
        self.assertEqual(len(VULN_CLASSES), 12)
        self.assertIn("sqli", VULN_CLASSES)
        self.assertIn("nuclei", VULN_CLASSES)

    def test_valid_entity_types(self):
        from lib.world_model_db import VALID_ENTITY_TYPES
        self.assertIn("asset", VALID_ENTITY_TYPES)
        self.assertIn("finding", VALID_ENTITY_TYPES)

    def test_valid_rel_types(self):
        from lib.world_model_db import VALID_REL_TYPES
        self.assertIn("has_endpoint", VALID_REL_TYPES)
        self.assertIn("has_finding", VALID_REL_TYPES)
        self.assertIn("confirms", VALID_REL_TYPES)

    def test_json_columns_include_new_tables(self):
        from lib.world_model_db import _JSON_COLUMNS
        self.assertIn("relationships", _JSON_COLUMNS)
        self.assertIn("coverage_matrix", _JSON_COLUMNS)
        self.assertEqual(_JSON_COLUMNS["relationships"], ["metadata"])
        self.assertEqual(_JSON_COLUMNS["coverage_matrix"], ["tool_args"])


# ---------------------------------------------------------------------------
# Integration: Full Coverage Flow
# ---------------------------------------------------------------------------

class TestCoverageIntegration(unittest.TestCase):
    """End-to-end test: endpoints → build matrix → next → mark → report."""

    def setUp(self):
        self.tmpdir = tempfile.mkdtemp()
        self.db_path = os.path.join(self.tmpdir, "test-wm.db")

    def tearDown(self):
        import shutil
        shutil.rmtree(self.tmpdir, ignore_errors=True)

    def _make_db(self):
        from lib.world_model_db import WorldModelDatabase
        db = WorldModelDatabase(db_path=self.db_path)
        run_async(db.init())
        return db

    def test_full_coverage_flow(self):
        from lib.coverage_tracker import CoverageTracker

        db = self._make_db()

        # 1. Create assets and endpoints
        asset = run_async(db.add_asset(kind="domain", name="test.com"))
        ep1 = run_async(db.add_endpoint(
            asset_id=asset["id"], method="POST", path="/api/login",
            parameters={"body": {"username": "string", "password": "string"}},
            auth_required=True,
        ))
        ep2 = run_async(db.add_endpoint(
            asset_id=asset["id"], method="GET", path="/api/health",
        ))

        # 2. Build coverage matrix
        endpoints = run_async(db.query(table="endpoints"))
        rows = CoverageTracker.build_matrix(endpoints, "https://test.com")
        self.assertGreater(len(rows), 0)

        # 3. Init rows
        result = run_async(db.coverage_init_rows(rows))
        total_created = result["created"]
        self.assertGreater(total_created, 0)

        # 4. Get next cells
        cells = run_async(db.coverage_next(limit=50))
        self.assertEqual(len(cells), total_created)

        # 5. Mark some cells
        marked_count = 0
        for cell in cells[:3]:
            run_async(db.coverage_mark(cell["id"], "passed"))
            marked_count += 1

        # 6. Mark one as vulnerable
        if len(cells) > 3:
            run_async(db.coverage_mark(
                cells[3]["id"], "vulnerable",
                finding_id="f-test", result_summary="Found vuln",
            ))
            marked_count += 1

        # 7. Check report
        report = run_async(db.coverage_report())
        self.assertEqual(report["total_cells"], total_created)
        self.assertGreater(report["coverage_pct"], 0)

        # 8. Verify determinism
        rows2 = CoverageTracker.build_matrix(endpoints, "https://test.com")
        self.assertEqual(len(rows), len(rows2))

        run_async(db.close())


if __name__ == "__main__":
    unittest.main()
