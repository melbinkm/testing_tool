"""
Tests for the Sequence Runner - business logic testing framework.

Covers:
- Template resolution ({{var}} placeholders)
- JSON path extraction ($.data.token, $.items[0].id)
- Regex extraction (regex:pattern)
- Header extraction (header:name)
- Expectation checking (status, body_contains, body_not_contains)
- Workflow bypass variants (skip_step, replay_step, reorder, direct_access)
- DataOwnershipTester response comparison
- CredentialReuseTester auth detection
"""

from __future__ import annotations

import asyncio
import json
import os
import sys
import unittest
from unittest.mock import AsyncMock, MagicMock, patch

# Add modules to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "modules"))

# Mock mcp.types before importing anything that depends on it
import types as pytypes
mock_mcp = pytypes.ModuleType("mcp")
mock_mcp_types = pytypes.ModuleType("mcp.types")

class MockTool:
    def __init__(self, name="", description="", inputSchema=None):
        self.name = name
        self.description = description
        self.inputSchema = inputSchema or {}

class MockTextContent:
    def __init__(self, type="text", text=""):
        self.type = type
        self.text = text

mock_mcp_types.Tool = MockTool
mock_mcp_types.TextContent = MockTextContent
sys.modules["mcp"] = mock_mcp
sys.modules["mcp.types"] = mock_mcp_types


def run_async(coro):
    """Helper to run async code in sync tests."""
    return asyncio.get_event_loop().run_until_complete(coro)


# ---------------------------------------------------------------------------
# Import the module under test
# ---------------------------------------------------------------------------

from lib.sequence_runner import (
    RequestStep,
    StepResult,
    SequenceResult,
    SequenceRunner,
    DataOwnershipTester,
    CredentialReuseTester,
    _walk_json_path,
)


# ---------------------------------------------------------------------------
# Mock HTTP Client
# ---------------------------------------------------------------------------

class MockHttpClient:
    """Mock HttpClient that returns configurable responses per URL."""

    def __init__(self):
        self.responses = {}
        self.call_log = []

    def set_response(self, url, status=200, body="", headers=None):
        """Configure the response for a given URL."""
        self.responses[url] = {
            "success": True,
            "response": {
                "status": status,
                "body": body,
                "headers": headers or {},
            },
        }

    def set_error(self, url, message="Request failed"):
        """Configure an error response for a given URL."""
        self.responses[url] = {
            "success": False,
            "error": {"message": message},
        }

    async def send(self, request, identity_id=None):
        url = request.get("url", "")
        self.call_log.append({"request": request, "identity_id": identity_id})

        # Match by URL, fallback to wildcard
        if url in self.responses:
            return self.responses[url]
        if "*" in self.responses:
            return self.responses["*"]

        return {
            "success": True,
            "response": {
                "status": 200,
                "body": "{}",
                "headers": {},
            },
        }


# ---------------------------------------------------------------------------
# Template Resolution Tests
# ---------------------------------------------------------------------------

class TestTemplateResolution(unittest.TestCase):
    """Test {{var}} placeholder resolution."""

    def test_simple_replacement(self):
        result = SequenceRunner._resolve_template(
            "https://example.com/api/users/{{user_id}}", {"user_id": "42"}
        )
        self.assertEqual(result, "https://example.com/api/users/42")

    def test_multiple_placeholders(self):
        result = SequenceRunner._resolve_template(
            "{{base_url}}/api/{{version}}/users",
            {"base_url": "https://example.com", "version": "v2"},
        )
        self.assertEqual(result, "https://example.com/api/v2/users")

    def test_no_placeholders(self):
        result = SequenceRunner._resolve_template(
            "https://example.com/static", {}
        )
        self.assertEqual(result, "https://example.com/static")

    def test_missing_variable_raises_key_error(self):
        with self.assertRaises(KeyError) as ctx:
            SequenceRunner._resolve_template(
                "https://example.com/{{missing}}", {}
            )
        self.assertIn("missing", str(ctx.exception))

    def test_placeholder_in_body(self):
        result = SequenceRunner._resolve_template(
            '{"token": "{{auth_token}}", "data": "{{payload}}"}',
            {"auth_token": "abc123", "payload": "test"},
        )
        parsed = json.loads(result)
        self.assertEqual(parsed["token"], "abc123")
        self.assertEqual(parsed["data"], "test")

    def test_repeated_placeholder(self):
        result = SequenceRunner._resolve_template(
            "{{x}}-{{x}}-{{x}}", {"x": "a"}
        )
        self.assertEqual(result, "a-a-a")


# ---------------------------------------------------------------------------
# JSON Path Extraction Tests
# ---------------------------------------------------------------------------

class TestJsonPathExtraction(unittest.TestCase):
    """Test _walk_json_path() function."""

    def test_simple_path(self):
        data = {"data": {"token": "abc123"}}
        self.assertEqual(_walk_json_path(data, "$.data.token"), "abc123")

    def test_root_path(self):
        data = {"key": "val"}
        self.assertEqual(_walk_json_path(data, "$"), data)

    def test_nested_path(self):
        data = {"a": {"b": {"c": {"d": "deep"}}}}
        self.assertEqual(_walk_json_path(data, "$.a.b.c.d"), "deep")

    def test_array_index(self):
        data = {"items": [{"id": 1}, {"id": 2}, {"id": 3}]}
        self.assertEqual(_walk_json_path(data, "$.items[0].id"), 1)
        self.assertEqual(_walk_json_path(data, "$.items[2].id"), 3)

    def test_array_index_out_of_bounds(self):
        data = {"items": [{"id": 1}]}
        self.assertIsNone(_walk_json_path(data, "$.items[5].id"))

    def test_missing_key(self):
        data = {"a": {"b": 1}}
        self.assertIsNone(_walk_json_path(data, "$.a.c"))

    def test_non_dict_traversal(self):
        data = {"a": "string_value"}
        self.assertIsNone(_walk_json_path(data, "$.a.b"))

    def test_numeric_value(self):
        data = {"count": 42}
        self.assertEqual(_walk_json_path(data, "$.count"), 42)

    def test_empty_path(self):
        data = {"key": "val"}
        result = _walk_json_path(data, "$")
        self.assertEqual(result, data)

    def test_boolean_value(self):
        data = {"success": True}
        self.assertEqual(_walk_json_path(data, "$.success"), True)


# ---------------------------------------------------------------------------
# Variable Extraction Tests (all rule types)
# ---------------------------------------------------------------------------

class TestVariableExtraction(unittest.TestCase):
    """Test SequenceRunner._extract_variables() with all rule types."""

    def test_json_path_extraction(self):
        body = json.dumps({"data": {"token": "jwt-abc", "user": {"id": 42}}})
        extracted = SequenceRunner._extract_variables(
            body, {},
            {"token": "$.data.token", "uid": "$.data.user.id"},
        )
        self.assertEqual(extracted["token"], "jwt-abc")
        self.assertEqual(extracted["uid"], "42")

    def test_regex_extraction(self):
        body = 'csrf_token="abc123def456"; path=/'
        extracted = SequenceRunner._extract_variables(
            body, {},
            {"csrf": 'regex:csrf_token="([^"]+)"'},
        )
        self.assertEqual(extracted["csrf"], "abc123def456")

    def test_header_extraction(self):
        headers = {"X-Request-Id": "req-123", "Content-Type": "application/json"}
        extracted = SequenceRunner._extract_variables(
            "{}", headers,
            {"req_id": "header:X-Request-Id", "ct": "header:content-type"},
        )
        self.assertEqual(extracted["req_id"], "req-123")
        self.assertEqual(extracted["ct"], "application/json")

    def test_missing_header(self):
        extracted = SequenceRunner._extract_variables(
            "{}", {},
            {"missing": "header:X-Nonexistent"},
        )
        self.assertNotIn("missing", extracted)

    def test_regex_no_match(self):
        extracted = SequenceRunner._extract_variables(
            "no match here", {},
            {"val": "regex:notfound_([a-z]+)"},
        )
        self.assertNotIn("val", extracted)

    def test_json_path_on_non_json_body(self):
        extracted = SequenceRunner._extract_variables(
            "plain text body", {},
            {"val": "$.data.token"},
        )
        self.assertNotIn("val", extracted)

    def test_mixed_rules(self):
        body = json.dumps({"token": "abc"})
        headers = {"Set-Cookie": "session=xyz"}
        extracted = SequenceRunner._extract_variables(
            body, headers,
            {
                "tok": "$.token",
                "cookie": "header:set-cookie",
                "tok_re": 'regex:"token":\\s*"([^"]+)"',
            },
        )
        self.assertEqual(extracted["tok"], "abc")
        self.assertEqual(extracted["cookie"], "session=xyz")
        self.assertEqual(extracted["tok_re"], "abc")


# ---------------------------------------------------------------------------
# Expectation Checking Tests
# ---------------------------------------------------------------------------

class TestExpectationChecking(unittest.TestCase):
    """Test SequenceRunner._check_expectations()."""

    def test_status_check_pass(self):
        results = SequenceRunner._check_expectations(200, "", {"status": 200})
        self.assertEqual(len(results), 1)
        self.assertTrue(results[0]["passed"])

    def test_status_check_fail(self):
        results = SequenceRunner._check_expectations(403, "", {"status": 200})
        self.assertFalse(results[0]["passed"])
        self.assertEqual(results[0]["actual"], 403)

    def test_body_contains_pass(self):
        results = SequenceRunner._check_expectations(
            200, '{"success": true}', {"body_contains": ["success"]}
        )
        self.assertTrue(results[0]["passed"])

    def test_body_contains_fail(self):
        results = SequenceRunner._check_expectations(
            200, '{"error": "not found"}', {"body_contains": ["success"]}
        )
        self.assertFalse(results[0]["passed"])

    def test_body_not_contains_pass(self):
        results = SequenceRunner._check_expectations(
            200, '{"status": "ok"}', {"body_not_contains": ["error"]}
        )
        self.assertTrue(results[0]["passed"])

    def test_body_not_contains_fail(self):
        results = SequenceRunner._check_expectations(
            200, '{"error": "bad"}', {"body_not_contains": ["error"]}
        )
        self.assertFalse(results[0]["passed"])

    def test_multiple_assertions(self):
        results = SequenceRunner._check_expectations(
            200,
            '{"data": "ok"}',
            {
                "status": 200,
                "body_contains": ["data", "ok"],
                "body_not_contains": ["error"],
            },
        )
        self.assertEqual(len(results), 4)  # 1 status + 2 contains + 1 not_contains
        self.assertTrue(all(r["passed"] for r in results))

    def test_empty_expectations(self):
        results = SequenceRunner._check_expectations(200, "body", {})
        self.assertEqual(len(results), 0)


# ---------------------------------------------------------------------------
# Full Sequence Execution Tests
# ---------------------------------------------------------------------------

class TestSequenceExecution(unittest.TestCase):
    """Test SequenceRunner.execute() end-to-end."""

    def test_simple_two_step_sequence(self):
        client = MockHttpClient()
        client.set_response(
            "https://example.com/api/login",
            status=200,
            body=json.dumps({"token": "jwt-123"}),
        )
        client.set_response(
            "https://example.com/api/data",
            status=200,
            body=json.dumps({"items": [1, 2, 3]}),
        )

        runner = SequenceRunner(client)
        steps = [
            RequestStep(
                name="Login",
                method="POST",
                url_template="https://example.com/api/login",
                body_template='{"user":"admin","pass":"secret"}',
                extract={"token": "$.token"},
                expect={"status": 200},
            ),
            RequestStep(
                name="Fetch data",
                method="GET",
                url_template="https://example.com/api/data",
                headers={"Authorization": "Bearer {{token}}"},
                expect={"status": 200, "body_contains": ["items"]},
            ),
        ]

        result = run_async(runner.execute(steps))
        self.assertTrue(result.success)
        self.assertEqual(result.steps_completed, 2)
        self.assertEqual(result.variables["token"], "jwt-123")
        self.assertIsNone(result.failed_step)

    def test_step_failure_stops_sequence(self):
        client = MockHttpClient()
        client.set_response(
            "https://example.com/api/login",
            status=401,
            body='{"error":"unauthorized"}',
        )

        runner = SequenceRunner(client)
        steps = [
            RequestStep(
                name="Login",
                method="POST",
                url_template="https://example.com/api/login",
                expect={"status": 200},
                on_failure="stop",
            ),
            RequestStep(
                name="Never reached",
                method="GET",
                url_template="https://example.com/api/data",
            ),
        ]

        result = run_async(runner.execute(steps))
        self.assertFalse(result.success)
        self.assertEqual(result.steps_completed, 1)
        self.assertEqual(result.failed_step, "Login")

    def test_on_failure_continue(self):
        client = MockHttpClient()
        client.set_response(
            "https://example.com/step1", status=500, body="error"
        )
        client.set_response(
            "https://example.com/step2", status=200, body="ok"
        )

        runner = SequenceRunner(client)
        steps = [
            RequestStep(
                name="Failing step",
                method="GET",
                url_template="https://example.com/step1",
                expect={"status": 200},
                on_failure="continue",
            ),
            RequestStep(
                name="Next step",
                method="GET",
                url_template="https://example.com/step2",
                expect={"status": 200},
            ),
        ]

        result = run_async(runner.execute(steps))
        self.assertFalse(result.success)  # Overall fails because step1 failed
        self.assertEqual(result.steps_completed, 2)  # Both executed
        self.assertEqual(result.failed_step, "Failing step")

    def test_variable_chaining(self):
        client = MockHttpClient()
        client.set_response(
            "https://example.com/auth",
            status=200,
            body=json.dumps({"session": "sess-abc"}),
        )
        client.set_response(
            "https://example.com/api/profile?session=sess-abc",
            status=200,
            body=json.dumps({"user": "admin"}),
        )

        runner = SequenceRunner(client)
        steps = [
            RequestStep(
                name="Auth",
                method="POST",
                url_template="https://example.com/auth",
                extract={"session": "$.session"},
            ),
            RequestStep(
                name="Profile",
                method="GET",
                url_template="https://example.com/api/profile?session={{session}}",
            ),
        ]

        result = run_async(runner.execute(steps))
        self.assertTrue(result.success)
        self.assertEqual(result.variables["session"], "sess-abc")

        # Verify the URL was correctly resolved
        calls = client.call_log
        self.assertEqual(len(calls), 2)
        self.assertIn("session=sess-abc", calls[1]["request"]["url"])

    def test_scope_validation_blocks_request(self):
        client = MockHttpClient()
        mock_validator = MagicMock()
        mock_result = MagicMock()
        mock_result.valid = False
        mock_result.reason = "Target out of scope"
        mock_validator.validate_target.return_value = mock_result

        runner = SequenceRunner(client, scope_validator=mock_validator)
        steps = [
            RequestStep(
                name="Out of scope",
                method="GET",
                url_template="https://evil.com/api",
            ),
        ]

        result = run_async(runner.execute(steps))
        self.assertFalse(result.success)
        self.assertIn("out of scope", result.step_results[0].error.lower())
        self.assertEqual(len(client.call_log), 0)  # No HTTP call made

    def test_initial_variables(self):
        client = MockHttpClient()
        client.set_response("https://example.com/api/test-value", status=200, body="{}")

        runner = SequenceRunner(client)
        steps = [
            RequestStep(
                name="Use initial var",
                method="GET",
                url_template="https://example.com/api/{{initial}}",
            ),
        ]

        result = run_async(runner.execute(steps, variables={"initial": "test-value"}))
        self.assertTrue(result.success)
        self.assertEqual(client.call_log[0]["request"]["url"], "https://example.com/api/test-value")

    def test_http_error_handling(self):
        client = MockHttpClient()
        client.set_error("https://example.com/api/fail", message="Connection refused")

        runner = SequenceRunner(client)
        steps = [
            RequestStep(
                name="Failing request",
                method="GET",
                url_template="https://example.com/api/fail",
            ),
        ]

        result = run_async(runner.execute(steps))
        self.assertFalse(result.success)
        self.assertIn("Connection refused", result.step_results[0].error)


# ---------------------------------------------------------------------------
# Workflow Bypass Tests
# ---------------------------------------------------------------------------

class TestWorkflowBypass(unittest.TestCase):
    """Test workflow bypass detection (skip_step, replay, reorder, direct_access)."""

    def _make_runner_and_steps(self, all_succeed=True):
        """Create a runner with 3-step sequence and configurable success."""
        client = MockHttpClient()
        client.set_response("*", status=200, body='{"ok":true}')

        runner = SequenceRunner(client)
        steps = [
            RequestStep(name="Step 1 - Auth", method="POST",
                        url_template="https://example.com/login",
                        expect={"status": 200} if all_succeed else {}),
            RequestStep(name="Step 2 - Verify", method="POST",
                        url_template="https://example.com/verify",
                        expect={"status": 200} if all_succeed else {}),
            RequestStep(name="Step 3 - Complete", method="POST",
                        url_template="https://example.com/complete",
                        expect={"status": 200} if all_succeed else {}),
        ]
        return runner, steps, client

    def test_skip_step_detects_vulnerability(self):
        runner, steps, _ = self._make_runner_and_steps(all_succeed=True)
        result = run_async(runner.execute_workflow_bypass(steps, "skip_step"))

        self.assertGreater(result["variants_tested"], 0)
        # All succeed -> all are potential vulnerabilities
        self.assertGreater(len(result["vulnerabilities_found"]), 0)
        for vuln in result["vulnerabilities_found"]:
            self.assertEqual(vuln["type"], "workflow_bypass")
            self.assertEqual(vuln["bypass_type"], "skip_step")

    def test_skip_step_with_explicit_indices(self):
        runner, steps, _ = self._make_runner_and_steps(all_succeed=True)
        result = run_async(runner.execute_workflow_bypass(
            steps, "skip_step", skip_indices=[1]
        ))
        self.assertEqual(result["variants_tested"], 1)

    def test_replay_step_detects_vulnerability(self):
        runner, steps, _ = self._make_runner_and_steps(all_succeed=True)
        result = run_async(runner.execute_workflow_bypass(steps, "replay_step"))

        self.assertEqual(result["variants_tested"], 1)
        self.assertGreater(len(result["vulnerabilities_found"]), 0)
        self.assertEqual(result["vulnerabilities_found"][0]["bypass_type"], "replay_step")

    def test_reorder_detects_vulnerability(self):
        runner, steps, _ = self._make_runner_and_steps(all_succeed=True)
        result = run_async(runner.execute_workflow_bypass(steps, "reorder"))

        self.assertEqual(result["variants_tested"], 1)
        self.assertGreater(len(result["vulnerabilities_found"]), 0)
        self.assertEqual(result["vulnerabilities_found"][0]["bypass_type"], "reorder")

    def test_reorder_needs_3_steps(self):
        runner, _, _ = self._make_runner_and_steps()
        two_steps = [
            RequestStep(name="A", method="GET", url_template="https://example.com/a"),
            RequestStep(name="B", method="GET", url_template="https://example.com/b"),
        ]
        result = run_async(runner.execute_workflow_bypass(two_steps, "reorder"))
        self.assertEqual(result["variants_tested"], 1)
        self.assertEqual(len(result["vulnerabilities_found"]), 0)

    def test_direct_access_detects_vulnerability(self):
        runner, steps, _ = self._make_runner_and_steps(all_succeed=True)
        result = run_async(runner.execute_workflow_bypass(steps, "direct_access"))

        self.assertEqual(result["variants_tested"], 1)
        self.assertGreater(len(result["vulnerabilities_found"]), 0)
        self.assertEqual(result["vulnerabilities_found"][0]["bypass_type"], "direct_access")

    def test_direct_access_needs_2_steps(self):
        runner, _, _ = self._make_runner_and_steps()
        one_step = [
            RequestStep(name="Only", method="GET", url_template="https://example.com/only"),
        ]
        result = run_async(runner.execute_workflow_bypass(one_step, "direct_access"))
        self.assertEqual(result["variants_tested"], 1)
        self.assertEqual(len(result["vulnerabilities_found"]), 0)

    def test_unknown_bypass_type(self):
        runner, steps, _ = self._make_runner_and_steps()
        result = run_async(runner.execute_workflow_bypass(steps, "nonexistent"))
        self.assertEqual(result["variants_tested"], 0)


# ---------------------------------------------------------------------------
# DataOwnershipTester Tests
# ---------------------------------------------------------------------------

class TestDataOwnershipTester(unittest.TestCase):
    """Test data ownership verification logic."""

    def _make_tester(self):
        client = MockHttpClient()
        mock_identity_store = MagicMock()
        mock_identity_store.get_identity.return_value = None
        return DataOwnershipTester(client, mock_identity_store), client

    def test_compare_responses_identical_json(self):
        tester, _ = self._make_tester()
        owner_resp = {"body": '{"name":"Alice","secret":"abc"}', "status": 200}
        other_resp = {"body": '{"name":"Alice","secret":"abc"}', "status": 200}
        result = tester._compare_responses(owner_resp, other_resp)
        self.assertTrue(result["leaked"])
        self.assertIn("name", result["leaked_fields"])
        self.assertIn("secret", result["leaked_fields"])

    def test_compare_responses_different(self):
        tester, _ = self._make_tester()
        owner_resp = {"body": '{"name":"Alice","email":"alice@example.com"}', "status": 200}
        other_resp = {"body": '{"error":"forbidden"}', "status": 403}
        result = tester._compare_responses(owner_resp, other_resp)
        self.assertFalse(result["leaked"])

    def test_compare_responses_partial_leak(self):
        tester, _ = self._make_tester()
        owner_resp = {"body": json.dumps({"id": 1, "name": "Alice", "ssn": "123-45-6789"}), "status": 200}
        other_resp = {"body": json.dumps({"id": 1, "name": "Alice", "ssn": "123-45-6789"}), "status": 200}
        result = tester._compare_responses(owner_resp, other_resp)
        self.assertTrue(result["leaked"])
        self.assertGreater(len(result["leaked_fields"]), 0)

    def test_compare_responses_raw_body_identical(self):
        tester, _ = self._make_tester()
        owner_resp = {"body": "plain text body", "status": 200}
        other_resp = {"body": "plain text body", "status": 200}
        result = tester._compare_responses(owner_resp, other_resp)
        self.assertTrue(result["leaked"])

    def test_compare_responses_raw_body_different(self):
        tester, _ = self._make_tester()
        owner_resp = {"body": "owner data", "status": 200}
        other_resp = {"body": "other data", "status": 200}
        result = tester._compare_responses(owner_resp, other_resp)
        self.assertFalse(result["leaked"])


# ---------------------------------------------------------------------------
# CredentialReuseTester Tests
# ---------------------------------------------------------------------------

class TestCredentialReuseTester(unittest.TestCase):
    """Test credential reuse detection logic."""

    def _make_tester(self):
        client = MockHttpClient()
        mock_identity_store = MagicMock()
        return CredentialReuseTester(client, mock_identity_store), client

    def test_build_credential_headers_bearer(self):
        tester, _ = self._make_tester()
        headers = tester._build_credential_headers("bearer", "abc123")
        self.assertEqual(headers["Authorization"], "Bearer abc123")

    def test_build_credential_headers_basic(self):
        tester, _ = self._make_tester()
        headers = tester._build_credential_headers("basic", "YWRtaW46c2VjcmV0")
        self.assertIn("Authorization", headers)
        self.assertTrue(headers["Authorization"].startswith("Basic "))

    def test_build_credential_headers_api_key(self):
        tester, _ = self._make_tester()
        headers = tester._build_credential_headers("api_key", "key-xyz")
        self.assertEqual(headers["X-API-Key"], "key-xyz")

    def test_build_credential_headers_cookie(self):
        tester, _ = self._make_tester()
        headers = tester._build_credential_headers("cookie", "session=abc")
        self.assertEqual(headers["Cookie"], "session=abc")

    def test_build_credential_headers_custom_header(self):
        tester, _ = self._make_tester()
        headers = tester._build_credential_headers("bearer", "tok", header_name="X-Custom-Auth")
        self.assertEqual(headers["X-Custom-Auth"], "tok")

    def test_is_authenticated_response_200(self):
        tester, _ = self._make_tester()
        self.assertTrue(tester._is_authenticated_response(200, '{"data":"ok"}'))

    def test_is_authenticated_response_401(self):
        tester, _ = self._make_tester()
        self.assertFalse(tester._is_authenticated_response(401, 'Unauthorized'))

    def test_is_authenticated_response_403(self):
        tester, _ = self._make_tester()
        self.assertFalse(tester._is_authenticated_response(403, 'Forbidden'))

    def test_is_authenticated_response_redirect(self):
        tester, _ = self._make_tester()
        # 302 with login in body suggests auth redirect
        self.assertFalse(tester._is_authenticated_response(302, 'Redirecting to /login'))


# ---------------------------------------------------------------------------
# RequestStep Dataclass Tests
# ---------------------------------------------------------------------------

class TestRequestStepDefaults(unittest.TestCase):
    """Test RequestStep default values."""

    def test_defaults(self):
        step = RequestStep(name="test", method="GET", url_template="https://example.com")
        self.assertEqual(step.headers, {})
        self.assertIsNone(step.body_template)
        self.assertIsNone(step.identity_id)
        self.assertEqual(step.extract, {})
        self.assertEqual(step.expect, {})
        self.assertEqual(step.on_failure, "stop")
        self.assertEqual(step.delay_ms, 0)

    def test_custom_values(self):
        step = RequestStep(
            name="custom",
            method="POST",
            url_template="https://example.com/api",
            headers={"X-Custom": "val"},
            body_template='{"key":"val"}',
            identity_id="user-1",
            extract={"tok": "$.token"},
            expect={"status": 200},
            on_failure="continue",
            delay_ms=500,
        )
        self.assertEqual(step.on_failure, "continue")
        self.assertEqual(step.delay_ms, 500)
        self.assertEqual(step.identity_id, "user-1")


# ---------------------------------------------------------------------------
# SequenceResult Dataclass Tests
# ---------------------------------------------------------------------------

class TestSequenceResult(unittest.TestCase):
    """Test SequenceResult dataclass."""

    def test_success_result(self):
        result = SequenceResult(
            success=True, steps_completed=3, total_steps=3,
            variables={"token": "abc"}, step_results=[],
        )
        self.assertTrue(result.success)
        self.assertIsNone(result.failed_step)

    def test_failure_result(self):
        result = SequenceResult(
            success=False, steps_completed=1, total_steps=3,
            failed_step="Step 2",
        )
        self.assertFalse(result.success)
        self.assertEqual(result.failed_step, "Step 2")


# ---------------------------------------------------------------------------
# World Model Observation Recording Tests
# ---------------------------------------------------------------------------

class TestObservationRecording(unittest.TestCase):
    """Test that observations are recorded in the world model."""

    def test_observations_recorded_when_hypothesis_provided(self):
        client = MockHttpClient()
        client.set_response("*", status=200, body='{"ok":true}')

        mock_db = MagicMock()
        mock_db.add_observation = AsyncMock()

        runner = SequenceRunner(client, db=mock_db)
        steps = [
            RequestStep(name="Step 1", method="GET",
                        url_template="https://example.com/api"),
        ]

        run_async(runner.execute(steps, hypothesis_id="hyp-1"))
        mock_db.add_observation.assert_called_once()
        call_kwargs = mock_db.add_observation.call_args
        self.assertEqual(call_kwargs.kwargs["hypothesis_id"], "hyp-1")
        self.assertEqual(call_kwargs.kwargs["obs_type"], "behavior")

    def test_no_observations_without_hypothesis(self):
        client = MockHttpClient()
        client.set_response("*", status=200, body='{"ok":true}')

        mock_db = MagicMock()
        mock_db.add_observation = AsyncMock()

        runner = SequenceRunner(client, db=mock_db)
        steps = [
            RequestStep(name="Step 1", method="GET",
                        url_template="https://example.com/api"),
        ]

        run_async(runner.execute(steps))
        mock_db.add_observation.assert_not_called()


if __name__ == "__main__":
    unittest.main()
