"""
Unit tests for scope_loader_db.py - Database-backed scope loading
"""
import unittest
import asyncio
from datetime import datetime
from unittest.mock import MagicMock, AsyncMock, patch

# Mock asyncpg before importing scope_loader_db
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent / 'modules'))


class MockPool:
    """Mock asyncpg connection pool for testing."""

    def __init__(self):
        self.conn = MockConnection()

    def acquire(self):
        return self

    async def __aenter__(self):
        return self.conn

    async def __aexit__(self, *args):
        pass


class MockConnection:
    """Mock asyncpg connection for testing."""

    def __init__(self):
        self.data = {}
        self.execute_calls = []
        self.fetch_calls = []

    async def fetchval(self, query, *args):
        """Mock fetchval for SELECT queries that return single value."""
        result = await self.fetchrow(query, *args)
        if result and isinstance(result, dict):
            # Return first value from dict
            return list(result.values())[0]
        return result

    async def fetchrow(self, query, *args):
        """Mock fetchrow for SELECT queries."""
        self.fetch_calls.append((query, args))

        # Handle scope config queries
        if "wm_scope_config" in query and "is_active = TRUE" in query:
            assessment_id = args[0] if args else None
            if assessment_id == 1:
                # Return valid scope data with all required fields
                return {
                    "scope_data": {
                        "schema_version": "1.0",
                        "engagement": {
                            "id": "test-engagement",
                            "name": "Test",
                            "client": "Test Client",
                            "start_date": "2024-01-01",
                            "end_date": "2024-12-31",
                            "timezone": "UTC"
                        },
                        "allowlist": {
                            "domains": ["example.com"],
                            "ip_ranges": ["192.168.1.0/24"],
                        },
                        "constraints": {
                            "budget": {
                                "max_total_requests": 1000,
                                "max_requests_per_target": 100,
                                "max_scan_duration_hours": 24
                            },
                            "rate_limits": {
                                "requests_per_second": 10,
                                "max_concurrent": 5,
                                "burst_limit": 20
                            },
                            "timeouts": {
                                "connect_timeout_ms": 10000,
                                "read_timeout_ms": 30000,
                                "total_timeout_ms": 60000
                            }
                        },
                        "approval_policy": {
                            "mode": "AUTO_APPROVE",
                            "timeout_seconds": 300,
                            "default_action": "DENY",
                            "escalation": {
                                "on_timeout": "DENY",
                                "on_error": "DENY",
                                "notify": False
                            }
                        }
                    }
                }
            return None  # No scope for other IDs

        # Handle version queries
        if "MAX(version)" in query:
            assessment_id = args[0] if args else None
            return 1 if assessment_id == 1 else 0

        return None

    async def fetch(self, query, *args):
        """Mock fetch for SELECT queries returning multiple rows."""
        self.fetch_calls.append((query, args))

        # Handle scope history queries
        if "wm_scope_config" in query and "ORDER BY version DESC" in query:
            assessment_id = args[0] if args else None
            if assessment_id == 1:
                return [
                    {
                        "id": 1,
                        "version": 1,
                        "is_active": True,
                        "created_at": datetime.now(),
                        "created_by": "test",
                        "notes": "Initial scope",
                        "engagement_id": "test-engagement"
                    }
                ]
            return []

        return []

    async def execute(self, query, *args):
        """Mock execute for INSERT/UPDATE/DELETE queries."""
        self.execute_calls.append((query, args))

        # Handle scope config inserts
        if "INSERT INTO wm_scope_config" in query:
            return "INSERT 0 1"

        # Handle scope config updates (deactivation)
        if "UPDATE wm_scope_config" in query and "is_active = FALSE" in query:
            return "UPDATE 1"

        # Handle scope config deletes
        if "DELETE FROM wm_scope_config" in query:
            return "DELETE 1"

        return "OK"

    def transaction(self):
        return self

    async def __aenter__(self):
        return self

    async def __aexit__(self, *args):
        pass


class TestScopeLoaderDB(unittest.TestCase):
    """Test cases for database-backed scope loading."""

    def setUp(self):
        """Set up test fixtures."""
        self.pool = MockPool()
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)

    def tearDown(self):
        """Tear down test fixtures."""
        self.loop.close()

    def test_load_scope_from_db_valid_assessment(self):
        """Test loading scope for a valid assessment ID."""
        from lib.scope_loader_db import load_scope_from_db

        async def run_test():
            scope = await load_scope_from_db(1, self.pool)
            self.assertIsNotNone(scope)
            self.assertEqual(scope.engagement.id, "test-engagement")
            self.assertEqual(scope.allowlist.domains, ["example.com"])
            self.assertEqual(scope.constraints.budget.max_total_requests, 1000)

        self.loop.run_until_complete(run_test())

    def test_load_scope_from_db_invalid_assessment(self):
        """Test loading scope for an invalid assessment ID."""
        from lib.scope_loader_db import load_scope_from_db

        async def run_test():
            scope = await load_scope_from_db(999, self.pool)
            self.assertIsNone(scope)

        self.loop.run_until_complete(run_test())

    def test_save_scope_to_db(self):
        """Test saving scope to database."""
        from lib.scope_loader_db import save_scope_to_db, load_scope_from_db

        async def run_test():
            # First load to get a valid scope object
            scope = await load_scope_from_db(1, self.pool)
            self.assertIsNotNone(scope)

            # Save it for a different assessment
            version = await save_scope_to_db(
                assessment_id=2,
                scope=scope,
                pool=self.pool,
                created_by="test_user",
                notes="Test scope save"
            )

            self.assertEqual(version, 1)  # First version

            # Verify execute was called with INSERT
            conn = self.pool.conn
            insert_calls = [c for c in conn.execute_calls if "INSERT INTO wm_scope_config" in c[0]]
            self.assertGreater(len(insert_calls), 0)

        self.loop.run_until_complete(run_test())

    def test_save_scope_deactivates_old_versions(self):
        """Test that saving scope deactivates previous versions."""
        from lib.scope_loader_db import save_scope_to_db, load_scope_from_db

        async def run_test():
            scope = await load_scope_from_db(1, self.pool)
            self.assertIsNotNone(scope)

            # Save new version
            await save_scope_to_db(1, scope, self.pool, created_by="test")

            # Verify UPDATE was called to deactivate old versions
            conn = self.pool.conn
            update_calls = [c for c in conn.execute_calls if "is_active = FALSE" in c[0]]
            self.assertGreater(len(update_calls), 0)

        self.loop.run_until_complete(run_test())

    def test_get_scope_history(self):
        """Test retrieving scope version history."""
        from lib.scope_loader_db import get_scope_history

        async def run_test():
            history = await get_scope_history(1, self.pool, limit=50)
            self.assertIsInstance(history, list)
            self.assertEqual(len(history), 1)
            self.assertEqual(history[0]["version"], 1)
            self.assertTrue(history[0]["is_active"])

        self.loop.run_until_complete(run_test())

    def test_get_scope_history_empty(self):
        """Test retrieving scope history for assessment with no scope."""
        from lib.scope_loader_db import get_scope_history

        async def run_test():
            history = await get_scope_history(999, self.pool)
            self.assertIsInstance(history, list)
            self.assertEqual(len(history), 0)

        self.loop.run_until_complete(run_test())

    def test_delete_scope_version(self):
        """Test deleting a non-active scope version."""
        from lib.scope_loader_db import delete_scope_version

        async def run_test():
            # Try to delete version 2 (non-active)
            result = await delete_scope_version(1, 2, self.pool)
            self.assertTrue(result)  # Mock always returns success

            # Verify DELETE was called
            conn = self.pool.conn
            delete_calls = [c for c in conn.execute_calls if "DELETE FROM wm_scope_config" in c[0]]
            self.assertGreater(len(delete_calls), 0)

        self.loop.run_until_complete(run_test())


if __name__ == "__main__":
    unittest.main()
