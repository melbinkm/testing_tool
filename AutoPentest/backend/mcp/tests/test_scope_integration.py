"""
Integration tests for per-assessment scope isolation.

Tests multi-assessment scenarios, budget isolation, and file fallback.
"""
import unittest
import asyncio
import sys
from datetime import datetime
from typing import Dict, Any
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent / 'modules'))


class MockPool:
    """Mock asyncpg pool with per-assessment data storage."""

    def __init__(self):
        # Store scope configs per assessment
        self.scope_configs: Dict[int, Dict[str, Any]] = {}
        # Store budget states per assessment
        self.budget_states: Dict[int, Dict[str, Any]] = {}
        self.conn = MockConnection(self)

    def acquire(self):
        return self

    async def __aenter__(self):
        return self.conn

    async def __aexit__(self, *args):
        pass


class MockConnection:
    """Mock asyncpg connection with in-memory data storage."""

    def __init__(self, pool: MockPool):
        self.pool = pool

    async def fetchval(self, query, *args):
        """Mock fetchval for SELECT queries that return single value."""
        result = await self.fetchrow(query, *args)
        if result and isinstance(result, dict):
            # Return first value from dict
            return list(result.values())[0]
        return result

    async def fetchrow(self, query, *args):
        """Mock fetchrow."""
        assessment_id = args[0] if args else None

        # Handle scope config queries
        if "wm_scope_config" in query and "is_active = TRUE" in query:
            if assessment_id in self.pool.scope_configs:
                return {"scope_data": self.pool.scope_configs[assessment_id]}
            return None

        # Handle budget state queries
        if "wm_budget_state" in query:
            if assessment_id in self.pool.budget_states:
                state = self.pool.budget_states[assessment_id]
                return {
                    "total_requests": state.get("total_requests", 0),
                    "requests_by_target": state.get("requests_by_target", {}),
                    "recent_requests": state.get("recent_requests", []),
                    "start_time": datetime.now()
                }
            return None

        # Handle version queries
        if "MAX(version)" in query:
            return 1 if assessment_id in self.pool.scope_configs else 0

        return None

    async def fetch(self, query, *args):
        """Mock fetch."""
        return []

    async def execute(self, query, *args):
        """Mock execute."""
        # Handle budget state inserts/updates
        if "wm_budget_state" in query:
            if "INSERT" in query or "ON CONFLICT" in query:
                assessment_id = args[0] if args else None
                if assessment_id:
                    self.pool.budget_states[assessment_id] = {
                        "total_requests": args[1] if len(args) > 1 else 0,
                        "requests_by_target": args[2] if len(args) > 2 else {},
                        "recent_requests": args[3] if len(args) > 3 else [],
                    }
                return "INSERT 0 1"

        # Handle scope config inserts
        if "INSERT INTO wm_scope_config" in query:
            assessment_id = args[0] if args else None
            scope_data = args[2] if len(args) > 2 else {}
            if assessment_id:
                self.pool.scope_configs[assessment_id] = scope_data
            return "INSERT 0 1"

        return "OK"

    def transaction(self):
        return self

    async def __aenter__(self):
        return self

    async def __aexit__(self, *args):
        pass


class TestScopeIsolation(unittest.TestCase):
    """Test cases for per-assessment scope isolation."""

    def setUp(self):
        """Set up test fixtures."""
        self.pool = MockPool()
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)

    def tearDown(self):
        """Tear down test fixtures."""
        self.loop.close()

    def _create_test_scope(self, engagement_id: str, allowed_domains: list):
        """Helper to create a complete test scope configuration."""
        return {
            "schema_version": "1.0",
            "engagement": {
                "id": engagement_id,
                "name": f"Test {engagement_id}",
                "client": "Test Client",
                "start_date": "2024-01-01",
                "end_date": "2024-12-31",
                "timezone": "UTC"
            },
            "allowlist": {
                "domains": allowed_domains,
                "ip_ranges": [],
            },
            "constraints": {
                "budget": {
                    "max_total_requests": 1000,
                    "max_requests_per_target": 100,
                    "max_scan_duration_hours": 24
                },
                "rate_limits": {
                    "requests_per_second": 10,
                    "max_concurrent": 5,
                    "burst_limit": 20
                },
                "timeouts": {
                    "connect_timeout_ms": 10000,
                    "read_timeout_ms": 30000,
                    "total_timeout_ms": 60000
                }
            },
            "approval_policy": {
                "mode": "AUTO_APPROVE",
                "timeout_seconds": 300,
                "default_action": "DENY",
                "escalation": {
                    "on_timeout": "DENY",
                    "on_error": "DENY",
                    "notify": False
                }
            }
        }

    def test_multi_assessment_scope_isolation(self):
        """Test that two assessments have isolated scopes."""
        from lib.scope_loader_db import save_scope_to_db
        from lib.scope_types import EngagementScope

        async def run_test():
            # Create two different scope configurations
            scope1_data = self._create_test_scope("assessment1", ["app1.com"])
            scope2_data = self._create_test_scope("assessment2", ["app2.com"])

            scope1 = EngagementScope(**scope1_data)
            scope2 = EngagementScope(**scope2_data)

            # Save scopes for different assessments
            await save_scope_to_db(1, scope1, self.pool, created_by="test")
            await save_scope_to_db(2, scope2, self.pool, created_by="test")

            # Verify they're stored separately
            self.assertIn(1, self.pool.scope_configs)
            self.assertIn(2, self.pool.scope_configs)

            # Verify scopes are different
            config1 = self.pool.scope_configs[1]
            config2 = self.pool.scope_configs[2]

            self.assertEqual(config1["allowlist"]["domains"], ["app1.com"])
            self.assertEqual(config2["allowlist"]["domains"], ["app2.com"])

        self.loop.run_until_complete(run_test())

    def test_multi_assessment_budget_isolation(self):
        """Test that budget tracking is isolated per assessment."""
        from lib.budget_tracker import BudgetTracker
        from lib.scope_types import ScopeConstraints, Budget, RateLimits, Timeouts

        async def run_test():
            # Create constraints
            constraints = ScopeConstraints(
                budget=Budget(
                    max_total_requests=100,
                    max_requests_per_target=50,
                    max_scan_duration_hours=24
                ),
                rate_limits=RateLimits(
                    requests_per_second=10000,
                    max_concurrent=5,
                    burst_limit=20000
                ),
                timeouts=Timeouts(
                    connect_timeout_ms=10000,
                    read_timeout_ms=30000,
                    total_timeout_ms=60000
                )
            )

            # Create budget trackers for two assessments
            tracker1 = BudgetTracker(constraints, assessment_id=1, pool=self.pool)
            tracker2 = BudgetTracker(constraints, assessment_id=2, pool=self.pool)

            await tracker1.initialize()
            await tracker2.initialize()

            # Record requests for assessment 1
            for i in range(50):
                await tracker1.record_request(target="app1.com")

            # Persist state
            await tracker1._persist_state()

            # Verify assessment 1 has 50 requests
            status1 = tracker1.get_status()
            self.assertEqual(status1.total_requests, 50)

            # Verify assessment 2 still has 0 requests (isolated)
            status2 = tracker2.get_status()
            self.assertEqual(status2.total_requests, 0)

            # Verify budget states are stored separately
            self.assertIn(1, self.pool.budget_states)
            self.assertIn(2, self.pool.budget_states)
            self.assertEqual(self.pool.budget_states[1]["total_requests"], 50)
            self.assertEqual(self.pool.budget_states[2]["total_requests"], 0)

        self.loop.run_until_complete(run_test())

    def test_budget_persists_across_restart(self):
        """Test that budget state survives server restart."""
        from lib.budget_tracker import BudgetTracker
        from lib.scope_types import ScopeConstraints, Budget, RateLimits, Timeouts

        async def run_test():
            constraints = ScopeConstraints(
                budget=Budget(
                    max_total_requests=1000,
                    max_requests_per_target=100,
                    max_scan_duration_hours=24
                ),
                rate_limits=RateLimits(
                    requests_per_second=10000,
                    max_concurrent=5,
                    burst_limit=20000
                ),
                timeouts=Timeouts(
                    connect_timeout_ms=10000,
                    read_timeout_ms=30000,
                    total_timeout_ms=60000
                )
            )

            # Create tracker and record requests
            tracker1 = BudgetTracker(constraints, assessment_id=1, pool=self.pool)
            await tracker1.initialize()

            for i in range(100):
                await tracker1.record_request(target="example.com")

            # Persist final state
            await tracker1._persist_state()

            # Verify 100 requests recorded
            status1 = tracker1.get_status()
            self.assertEqual(status1.total_requests, 100)

            # Simulate restart: create new tracker instance for same assessment
            tracker2 = BudgetTracker(constraints, assessment_id=1, pool=self.pool)
            await tracker2.initialize()

            # Verify state was loaded from DB
            status2 = tracker2.get_status()
            self.assertEqual(status2.total_requests, 100)
            self.assertEqual(status2.remaining_requests, 900)

        self.loop.run_until_complete(run_test())

    def test_assessment_scope_provider_caching(self):
        """Test that AssessmentScopeProvider caches correctly."""
        from service import AssessmentScopeProvider
        from lib.scope_loader_db import save_scope_to_db
        from lib.scope_types import EngagementScope

        async def run_test():
            # Create scope provider
            provider = AssessmentScopeProvider(self.pool)

            # Create and save scope
            scope_data = self._create_test_scope("test", ["example.com"])
            scope = EngagementScope(**scope_data)
            await save_scope_to_db(1, scope, self.pool)

            # Get scope twice
            scope1 = await provider.get_scope(1)
            scope2 = await provider.get_scope(1)

            # Verify both loaded successfully
            self.assertIsNotNone(scope1)
            self.assertIsNotNone(scope2)

            # Verify they have the same data
            self.assertEqual(scope1.engagement.id, "test")
            self.assertEqual(scope2.engagement.id, "test")

            # Get validator for cached scope
            validator = await provider.get_validator(1)
            self.assertIsNotNone(validator)

            # Verify validation works
            result = validator.validate_target("https://example.com/test")
            self.assertTrue(result.valid)

            result2 = validator.validate_target("https://other.com/test")
            self.assertFalse(result2.valid)

        self.loop.run_until_complete(run_test())


if __name__ == "__main__":
    unittest.main()
