"""
Tests for the HTTP Client with scope validation, rate limiting, and budget enforcement.

Covers:
- HttpClient.send(): success, correlation headers, budget exhaustion, timeout, generic error,
  custom timeout, proxy config, identity_id
- HttpClient.send_batch(): all success, mixed results, budget during batch
- HttpClient.get_stats() / reset_stats(): initial stats, after requests, reset
- Scope validation: OutOfScopeRequestError when validator rejects URL
"""

from __future__ import annotations

import asyncio
import os
import sys
import unittest
from unittest.mock import AsyncMock, MagicMock, patch

# Add modules to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "modules"))

# Mock mcp.types before importing anything that depends on it
import types as pytypes

mock_mcp = pytypes.ModuleType("mcp")
mock_mcp_types = pytypes.ModuleType("mcp.types")


class MockTool:
    def __init__(self, name="", description="", inputSchema=None):
        self.name = name
        self.description = description
        self.inputSchema = inputSchema or {}


class MockTextContent:
    def __init__(self, type="text", text=""):
        self.type = type
        self.text = text


mock_mcp_types.Tool = MockTool
mock_mcp_types.TextContent = MockTextContent
sys.modules["mcp"] = mock_mcp
sys.modules["mcp.types"] = mock_mcp_types


def run_async(coro):
    """Helper to run async code in sync tests."""
    loop = asyncio.new_event_loop()
    try:
        return loop.run_until_complete(coro)
    finally:
        loop.close()


from lib.http_client import (
    HttpClient,
    HttpClientError,
    BudgetExhaustedError,
    RequestTimeoutError,
    OutOfScopeRequestError,
)


def _make_client(max_total_requests=1000, scope_validator=None, **overrides):
    """Create an HttpClient with sensible test defaults."""
    config = {
        "engagement_id": "test-engagement",
        "proxy_url": None,
        "max_rps": 1000.0,  # High RPS to avoid rate-limit waits in tests
        "max_concurrent": 10,
        "default_timeout": 5000,
        "max_total_requests": max_total_requests,
    }
    config.update(overrides)
    return HttpClient(config=config, scope_validator=scope_validator)


def _mock_httpx_response(status_code=200, text="OK", headers=None):
    """Create a mock httpx.Response."""
    resp = MagicMock()
    resp.status_code = status_code
    resp.reason_phrase = "OK"
    resp.text = text
    resp.headers = headers or {"content-type": "text/plain"}
    return resp


class TestHttpClientSend(unittest.TestCase):
    """Tests for HttpClient.send()."""

    @patch("lib.http_client.httpx.AsyncClient")
    def test_send_success(self, mock_async_client_cls):
        """Successful request returns success=True with response data."""
        mock_response = _mock_httpx_response(200, "Hello")
        mock_client_instance = AsyncMock()
        mock_client_instance.request = AsyncMock(return_value=mock_response)
        mock_client_instance.__aenter__ = AsyncMock(return_value=mock_client_instance)
        mock_client_instance.__aexit__ = AsyncMock(return_value=False)
        mock_async_client_cls.return_value = mock_client_instance

        client = _make_client()
        result = run_async(client.send({"method": "GET", "url": "http://example.com"}))

        self.assertTrue(result["success"])
        self.assertEqual(result["response"]["status"], 200)
        self.assertIn("correlation_ids", result)

    @patch("lib.http_client.httpx.AsyncClient")
    def test_send_correlation_headers(self, mock_async_client_cls):
        """Requests include correlation headers (X-Engagement-ID, X-Action-ID, X-Request-ID)."""
        mock_response = _mock_httpx_response()
        mock_client_instance = AsyncMock()
        mock_client_instance.request = AsyncMock(return_value=mock_response)
        mock_client_instance.__aenter__ = AsyncMock(return_value=mock_client_instance)
        mock_client_instance.__aexit__ = AsyncMock(return_value=False)
        mock_async_client_cls.return_value = mock_client_instance

        client = _make_client()
        result = run_async(client.send({"method": "GET", "url": "http://example.com"}))

        sent_headers = result["request"]["headers"]
        self.assertIn("X-Engagement-ID", sent_headers)
        self.assertIn("X-Action-ID", sent_headers)
        self.assertIn("X-Request-ID", sent_headers)
        self.assertEqual(sent_headers["X-Engagement-ID"], "test-engagement")

    def test_send_budget_exhaustion(self):
        """BudgetExhaustedError is raised when budget is exceeded."""
        client = _make_client(max_total_requests=0)

        with self.assertRaises(BudgetExhaustedError):
            run_async(client.send({"method": "GET", "url": "http://example.com"}))

    @patch("lib.http_client.httpx.AsyncClient")
    def test_send_timeout_error(self, mock_async_client_cls):
        """RequestTimeoutError is raised on timeout."""
        import httpx

        mock_client_instance = AsyncMock()
        mock_client_instance.request = AsyncMock(side_effect=httpx.TimeoutException("timed out"))
        mock_client_instance.__aenter__ = AsyncMock(return_value=mock_client_instance)
        mock_client_instance.__aexit__ = AsyncMock(return_value=False)
        mock_async_client_cls.return_value = mock_client_instance

        client = _make_client()

        with self.assertRaises(RequestTimeoutError):
            run_async(client.send({"method": "GET", "url": "http://example.com"}))

    @patch("lib.http_client.httpx.AsyncClient")
    def test_send_generic_error(self, mock_async_client_cls):
        """Generic exceptions return success=False with error details."""
        mock_client_instance = AsyncMock()
        mock_client_instance.request = AsyncMock(side_effect=ConnectionError("refused"))
        mock_client_instance.__aenter__ = AsyncMock(return_value=mock_client_instance)
        mock_client_instance.__aexit__ = AsyncMock(return_value=False)
        mock_async_client_cls.return_value = mock_client_instance

        client = _make_client()
        result = run_async(client.send({"method": "GET", "url": "http://example.com"}))

        self.assertFalse(result["success"])
        self.assertEqual(result["error"]["code"], "REQUEST_ERROR")

    @patch("lib.http_client.httpx.AsyncClient")
    def test_send_custom_timeout(self, mock_async_client_cls):
        """Per-request timeout override is respected."""
        mock_response = _mock_httpx_response()
        mock_client_instance = AsyncMock()
        mock_client_instance.request = AsyncMock(return_value=mock_response)
        mock_client_instance.__aenter__ = AsyncMock(return_value=mock_client_instance)
        mock_client_instance.__aexit__ = AsyncMock(return_value=False)
        mock_async_client_cls.return_value = mock_client_instance

        client = _make_client()
        result = run_async(client.send({
            "method": "GET",
            "url": "http://example.com",
            "timeout": 60000,
        }))

        self.assertTrue(result["success"])
        # Verify httpx.Timeout was called with 60 seconds
        call_kwargs = mock_async_client_cls.call_args
        # The timeout is passed to httpx.AsyncClient constructor
        self.assertIsNotNone(call_kwargs)

    @patch("lib.http_client.httpx.AsyncClient")
    def test_send_proxy_config(self, mock_async_client_cls):
        """Proxy URL is passed to httpx.AsyncClient when configured."""
        mock_response = _mock_httpx_response()
        mock_client_instance = AsyncMock()
        mock_client_instance.request = AsyncMock(return_value=mock_response)
        mock_client_instance.__aenter__ = AsyncMock(return_value=mock_client_instance)
        mock_client_instance.__aexit__ = AsyncMock(return_value=False)
        mock_async_client_cls.return_value = mock_client_instance

        client = _make_client(proxy_url="http://127.0.0.1:8080")
        result = run_async(client.send({"method": "GET", "url": "http://example.com"}))

        self.assertTrue(result["success"])
        # Verify proxy was passed to AsyncClient
        call_kwargs = mock_async_client_cls.call_args[1]
        self.assertEqual(call_kwargs.get("proxy"), "http://127.0.0.1:8080")

    @patch("lib.http_client.httpx.AsyncClient")
    def test_send_identity_id(self, mock_async_client_cls):
        """Identity ID is included in correlation headers when provided."""
        mock_response = _mock_httpx_response()
        mock_client_instance = AsyncMock()
        mock_client_instance.request = AsyncMock(return_value=mock_response)
        mock_client_instance.__aenter__ = AsyncMock(return_value=mock_client_instance)
        mock_client_instance.__aexit__ = AsyncMock(return_value=False)
        mock_async_client_cls.return_value = mock_client_instance

        client = _make_client()
        result = run_async(client.send(
            {"method": "GET", "url": "http://example.com"},
            identity_id="user-123",
        ))

        self.assertTrue(result["success"])
        self.assertEqual(result["correlation_ids"]["identity_id"], "user-123")
        self.assertIn("X-Identity-ID", result["request"]["headers"])


class TestHttpClientBatch(unittest.TestCase):
    """Tests for HttpClient.send_batch()."""

    @patch("lib.http_client.httpx.AsyncClient")
    def test_batch_all_success(self, mock_async_client_cls):
        """All requests in batch succeed."""
        mock_response = _mock_httpx_response()
        mock_client_instance = AsyncMock()
        mock_client_instance.request = AsyncMock(return_value=mock_response)
        mock_client_instance.__aenter__ = AsyncMock(return_value=mock_client_instance)
        mock_client_instance.__aexit__ = AsyncMock(return_value=False)
        mock_async_client_cls.return_value = mock_client_instance

        client = _make_client()
        items = [
            {"request": {"method": "GET", "url": "http://example.com/1"}},
            {"request": {"method": "GET", "url": "http://example.com/2"}},
        ]
        result = run_async(client.send_batch(items))

        self.assertEqual(result["total"], 2)
        self.assertEqual(result["successful"], 2)
        self.assertEqual(result["failed"], 0)

    @patch("lib.http_client.httpx.AsyncClient")
    def test_batch_mixed_results(self, mock_async_client_cls):
        """Batch handles mix of success and failure."""
        mock_response = _mock_httpx_response()
        call_count = 0

        async def mixed_request(*args, **kwargs):
            nonlocal call_count
            call_count += 1
            if call_count % 2 == 0:
                raise ConnectionError("refused")
            return mock_response

        mock_client_instance = AsyncMock()
        mock_client_instance.request = mixed_request
        mock_client_instance.__aenter__ = AsyncMock(return_value=mock_client_instance)
        mock_client_instance.__aexit__ = AsyncMock(return_value=False)
        mock_async_client_cls.return_value = mock_client_instance

        client = _make_client()
        items = [
            {"request": {"method": "GET", "url": "http://example.com/1"}},
            {"request": {"method": "GET", "url": "http://example.com/2"}},
        ]
        result = run_async(client.send_batch(items))

        self.assertEqual(result["total"], 2)
        # At least one should succeed, at least one fail
        self.assertGreater(result["successful"] + result["failed"], 0)

    def test_batch_budget_during_batch(self):
        """Budget enforcement works within a batch."""
        client = _make_client(max_total_requests=1)

        items = [
            {"request": {"method": "GET", "url": "http://example.com/1"}},
            {"request": {"method": "GET", "url": "http://example.com/2"}},
        ]
        result = run_async(client.send_batch(items))

        # At least one should fail due to budget
        self.assertGreater(result["failed"], 0)


class TestHttpClientStats(unittest.TestCase):
    """Tests for HttpClient stats and budget helpers."""

    def test_initial_stats(self):
        """Initial stats show zero requests and full budget."""
        client = _make_client(max_total_requests=500)
        stats = client.get_stats()

        self.assertEqual(stats["total_requests"], 0)
        self.assertEqual(stats["successful_requests"], 0)
        self.assertEqual(stats["failed_requests"], 0)
        self.assertEqual(stats["remaining_budget"], 500)
        self.assertEqual(stats["engagement_id"], "test-engagement")

    @patch("lib.http_client.httpx.AsyncClient")
    def test_stats_after_requests(self, mock_async_client_cls):
        """Stats update correctly after requests."""
        mock_response = _mock_httpx_response()
        mock_client_instance = AsyncMock()
        mock_client_instance.request = AsyncMock(return_value=mock_response)
        mock_client_instance.__aenter__ = AsyncMock(return_value=mock_client_instance)
        mock_client_instance.__aexit__ = AsyncMock(return_value=False)
        mock_async_client_cls.return_value = mock_client_instance

        client = _make_client(max_total_requests=100)
        run_async(client.send({"method": "GET", "url": "http://example.com"}))

        stats = client.get_stats()
        self.assertEqual(stats["total_requests"], 1)
        self.assertEqual(stats["successful_requests"], 1)
        self.assertEqual(stats["remaining_budget"], 99)

    def test_reset_stats(self):
        """reset_stats() clears all counters."""
        client = _make_client()
        # Manually increment to simulate requests
        client._total_requests = 10
        client._successful_requests = 8
        client._failed_requests = 2

        client.reset_stats()

        stats = client.get_stats()
        self.assertEqual(stats["total_requests"], 0)
        self.assertEqual(stats["successful_requests"], 0)
        self.assertEqual(stats["failed_requests"], 0)


class TestHttpClientScope(unittest.TestCase):
    """Tests for scope validation in HttpClient."""

    def test_out_of_scope_raises_error(self):
        """OutOfScopeRequestError is raised when scope validator rejects URL."""
        # Create a mock scope validator
        mock_validator = MagicMock()
        mock_result = MagicMock()
        mock_result.valid = False
        mock_result.reason = "Domain not in allowlist"
        mock_validator.validate_target.return_value = mock_result

        client = _make_client(scope_validator=mock_validator)

        with self.assertRaises(OutOfScopeRequestError) as ctx:
            run_async(client.send({"method": "GET", "url": "http://evil.com"}))

        self.assertIn("evil.com", str(ctx.exception))
        self.assertEqual(ctx.exception.code, "OUT_OF_SCOPE")
        mock_validator.validate_target.assert_called_once_with("http://evil.com")


if __name__ == "__main__":
    unittest.main()
