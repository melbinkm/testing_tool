"""
Test credential auto-testing feature.

Tests the integration between credentials_add and test_credential helper
to validate that discovered credentials are automatically tested.
"""
import unittest
from unittest.mock import AsyncMock, Mock, patch
import json
import sys
import os

# Add parent directory to path for module imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))


class TestCredentialAutoTesting(unittest.IsolatedAsyncioTestCase):
    """Test credential auto-testing functionality."""

    async def test_credentials_add_with_auto_test_valid(self):
        """Test that valid credentials are tested and create CRITICAL finding."""
        from modules.tools_credentials import _handle_credentials_add

        # Mock mcp_service
        mcp_service = Mock()
        mcp_service.current_assessment_id = 5
        mcp_service.backend_url = "http://backend:8000/api"
        mcp_service.http_client = AsyncMock()

        # Mock successful credential creation
        mcp_service.http_client.post.return_value.raise_for_status = Mock()
        mcp_service.http_client.post.return_value.json.return_value = {
            "id": 1,
            "name": "Admin Default",
            "credential_type": "basic_auth",
        }

        # Mock safe_add_card for finding creation
        mcp_service.safe_add_card = AsyncMock()

        arguments = {
            "credential_type": "basic_auth",
            "name": "Admin Default",
            "username": "admin",
            "password": "admin123",
            "target": "http://app:5000",
            "auto_test": True,
        }

        # Mock test_credential to return valid
        with patch("modules.tools_auth_tester.test_credential") as mock_test:
            mock_test.return_value = {
                "valid": True,
                "status_code": 302,
                "session_token": "abc123",
                "redirect_url": "http://app:5000/dashboard",
            }

            result = await _handle_credentials_add(arguments, mcp_service)

            # Verify test_credential was called
            mock_test.assert_called_once_with(
                target_url="http://app:5000",
                username="admin",
                password="admin123",
                method="form",
                login_path="/login",
            )

            # Verify finding was created
            mcp_service.safe_add_card.assert_called_once()
            call_kwargs = mcp_service.safe_add_card.call_args.kwargs
            self.assertEqual(call_kwargs["card_type"], "finding")
            self.assertEqual(call_kwargs["severity"], "CRITICAL")
            self.assertEqual(call_kwargs["status"], "confirmed")
            self.assertIn("Valid Default Credentials", call_kwargs["title"])

            # Verify response contains test result
            response_text = result[0].text
            self.assertIn("✅ VALID", response_text)
            self.assertIn("Login successful", response_text)

    async def test_credentials_add_with_auto_test_invalid(self):
        """Test that invalid credentials are tested but don't create findings."""
        from modules.tools_credentials import _handle_credentials_add

        mcp_service = Mock()
        mcp_service.current_assessment_id = 5
        mcp_service.backend_url = "http://backend:8000/api"
        mcp_service.http_client = AsyncMock()

        mcp_service.http_client.post.return_value.raise_for_status = Mock()
        mcp_service.http_client.post.return_value.json.return_value = {"id": 1}

        mcp_service.safe_add_card = AsyncMock()

        arguments = {
            "credential_type": "basic_auth",
            "name": "Test Cred",
            "username": "test",
            "password": "wrong",
            "target": "http://app:5000",
            "auto_test": True,
        }

        with patch("modules.tools_auth_tester.test_credential") as mock_test:
            mock_test.return_value = {
                "valid": False,
                "status_code": 401,
                "error": None,
            }

            result = await _handle_credentials_add(arguments, mcp_service)

            # Verify test was called
            mock_test.assert_called_once()

            # Verify NO finding was created
            mcp_service.safe_add_card.assert_not_called()

            # Verify response indicates failure
            response_text = result[0].text
            self.assertIn("❌ INVALID", response_text)

    async def test_credentials_add_auto_test_disabled(self):
        """Test that auto_test=false skips credential testing."""
        from modules.tools_credentials import _handle_credentials_add

        mcp_service = Mock()
        mcp_service.current_assessment_id = 5
        mcp_service.backend_url = "http://backend:8000/api"
        mcp_service.http_client = AsyncMock()

        mcp_service.http_client.post.return_value.raise_for_status = Mock()
        mcp_service.http_client.post.return_value.json.return_value = {"id": 1}

        arguments = {
            "credential_type": "basic_auth",
            "name": "Untested Cred",
            "username": "admin",
            "password": "admin",
            "target": "http://app:5000",
            "auto_test": False,
        }

        with patch("modules.tools_auth_tester.test_credential") as mock_test:
            result = await _handle_credentials_add(arguments, mcp_service)

            # Verify test was NOT called
            mock_test.assert_not_called()

            # Response should not mention test results
            response_text = result[0].text
            self.assertNotIn("Credential Test", response_text)

    async def test_credentials_add_bearer_token_no_test(self):
        """Test that non-basic_auth credentials are not auto-tested."""
        from modules.tools_credentials import _handle_credentials_add

        mcp_service = Mock()
        mcp_service.current_assessment_id = 5
        mcp_service.backend_url = "http://backend:8000/api"
        mcp_service.http_client = AsyncMock()

        mcp_service.http_client.post.return_value.raise_for_status = Mock()
        mcp_service.http_client.post.return_value.json.return_value = {"id": 1}

        arguments = {
            "credential_type": "bearer_token",
            "name": "API Token",
            "token": "abc123xyz",
            "target": "http://api:8080",
            "auto_test": True,  # Should be ignored for bearer tokens
        }

        with patch("modules.tools_auth_tester.test_credential") as mock_test:
            result = await _handle_credentials_add(arguments, mcp_service)

            # Bearer tokens should NOT trigger test_credential
            mock_test.assert_not_called()


class TestCredentialTester(unittest.IsolatedAsyncioTestCase):
    """Test the test_credential helper function."""

    async def test_form_login_success(self):
        """Test successful form-based login."""
        from modules.tools_auth_tester import test_credential

        with patch("modules.tools_auth_tester.httpx.AsyncClient") as MockClient:
            # Mock successful login with redirect + session cookie
            mock_response = Mock()
            mock_response.status_code = 302
            mock_response.text = '<html>Redirecting...</html>'
            mock_response.url = "http://app:5000/dashboard"
            mock_response.cookies = {"session": "abc123"}

            mock_client = AsyncMock()
            mock_client.__aenter__.return_value = mock_client
            mock_client.post.return_value = mock_response
            MockClient.return_value = mock_client

            result = await test_credential(
                target_url="http://app:5000",
                username="admin",
                password="admin123",
                method="form",
            )

            self.assertTrue(result["valid"])
            self.assertEqual(result["status_code"], 302)
            self.assertEqual(result["session_token"], "abc123")

    async def test_form_login_failure(self):
        """Test failed login with invalid credentials."""
        from modules.tools_auth_tester import test_credential

        with patch("modules.tools_auth_tester.httpx.AsyncClient") as MockClient:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.text = '<html><div class="error">Invalid username or password</div></html>'
            mock_response.url = "http://app:5000/login"  # Stayed on login page
            mock_response.cookies = {}

            mock_client = AsyncMock()
            mock_client.__aenter__.return_value = mock_client
            mock_client.post.return_value = mock_response
            MockClient.return_value = mock_client

            result = await test_credential(
                target_url="http://app:5000",
                username="admin",
                password="wrong",
                method="form",
            )

            self.assertFalse(result["valid"])
            self.assertIn("Invalid", result["response_body"])

    async def test_connection_error(self):
        """Test handling of connection errors."""
        from modules.tools_auth_tester import test_credential
        import httpx

        with patch("modules.tools_auth_tester.httpx.AsyncClient") as MockClient:
            mock_client = AsyncMock()
            mock_client.__aenter__.return_value = mock_client
            mock_client.post.side_effect = httpx.ConnectError("Connection refused")
            MockClient.return_value = mock_client

            result = await test_credential(
                target_url="http://unreachable:9999",
                username="admin",
                password="admin",
                method="form",
            )

            self.assertFalse(result["valid"])
            self.assertIn("error", result)
            self.assertIn("Connection refused", result["error"])


if __name__ == "__main__":
    unittest.main()
