"""
Tests for the PayloadGenerator.

Covers:
- Basic payload type listing and retrieval
- Schema-aware payload generation for various parameter types
- DB-specific SQL injection payload retrieval
"""

from __future__ import annotations

import os
import sys
import unittest

# Add modules to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "modules"))

# Mock mcp.types before importing anything that depends on it
import types as pytypes
mock_mcp = pytypes.ModuleType("mcp")
mock_mcp_types = pytypes.ModuleType("mcp.types")

class MockTool:
    def __init__(self, name="", description="", inputSchema=None):
        self.name = name
        self.description = description
        self.inputSchema = inputSchema or {}

class MockTextContent:
    def __init__(self, type="text", text=""):
        self.type = type
        self.text = text

mock_mcp_types.Tool = MockTool
mock_mcp_types.TextContent = MockTextContent
sys.modules["mcp"] = mock_mcp
sys.modules["mcp.types"] = mock_mcp_types

from lib.payload_generator import PayloadGenerator


# ---------------------------------------------------------------------------
# TestPayloadGeneratorBasic
# ---------------------------------------------------------------------------
class TestPayloadGeneratorBasic(unittest.TestCase):
    """Basic tests for PayloadGenerator type listing and retrieval."""

    def setUp(self):
        self.gen = PayloadGenerator()

    def test_get_payload_types(self):
        """get_payload_types returns a list with at least 6 known types."""
        types = self.gen.get_payload_types()
        self.assertIsInstance(types, list)
        self.assertGreaterEqual(len(types), 6)
        for expected in ("boundary", "type_confusion", "injection", "format", "overflow", "sqli_db"):
            self.assertIn(expected, types)

    def test_boundary_payloads_exist(self):
        """get_payloads_by_type('boundary') returns non-empty list with required keys."""
        payloads = self.gen.get_payloads_by_type("boundary")
        self.assertIsInstance(payloads, list)
        self.assertGreater(len(payloads), 0)
        for p in payloads:
            self.assertIn("value", p)
            self.assertIn("type", p)

    def test_injection_payloads_exist(self):
        """get_payloads_by_type('injection') returns non-empty list with type='injection'."""
        payloads = self.gen.get_payloads_by_type("injection")
        self.assertIsInstance(payloads, list)
        self.assertGreater(len(payloads), 0)
        for p in payloads:
            self.assertEqual(p["type"], "injection")

    def test_unknown_type_returns_empty(self):
        """get_payloads_by_type('nonexistent') returns an empty list."""
        payloads = self.gen.get_payloads_by_type("nonexistent")
        self.assertIsInstance(payloads, list)
        self.assertEqual(len(payloads), 0)

    def test_max_payloads_limit(self):
        """PayloadGenerator(max_payloads=5).get_payloads() returns at most 5 items."""
        gen = PayloadGenerator(max_payloads=5)
        payloads = gen.get_payloads()
        self.assertLessEqual(len(payloads), 5)


# ---------------------------------------------------------------------------
# TestPayloadGeneratorSchemaAware
# ---------------------------------------------------------------------------
class TestPayloadGeneratorSchemaAware(unittest.TestCase):
    """Tests for schema-aware payload generation."""

    def setUp(self):
        self.gen = PayloadGenerator(max_payloads=500)

    def test_string_param_generates_payloads(self):
        """generate_for_parameter with type='string' returns a non-empty list."""
        payloads = self.gen.generate_for_parameter({"type": "string"})
        self.assertIsInstance(payloads, list)
        self.assertGreater(len(payloads), 0)

    def test_integer_with_min_max(self):
        """generate_for_parameter with integer min/max includes boundary values -1 and 101."""
        param = {"type": "integer", "minimum": 0, "maximum": 100}
        payloads = self.gen.generate_for_parameter(param)
        values = [p["value"] for p in payloads]
        self.assertIn(-1, values, "Expected boundary value -1 (below minimum 0)")
        self.assertIn(101, values, "Expected boundary value 101 (above maximum 100)")

    def test_enum_param(self):
        """generate_for_parameter with enum includes a payload mentioning invalid_enum_value."""
        param = {"type": "string", "enum": ["a", "b"]}
        payloads = self.gen.generate_for_parameter(param)
        descriptions = [p.get("description", "") for p in payloads]
        has_invalid_enum = any("invalid_enum" in d.lower() or "invalid enum" in d.lower() for d in descriptions)
        self.assertTrue(has_invalid_enum, "Expected a payload with 'invalid_enum_value' in its description")

    def test_string_length_constraints(self):
        """generate_for_parameter with minLength/maxLength includes relevant boundary payloads."""
        param = {"type": "string", "minLength": 3, "maxLength": 10}
        payloads = self.gen.generate_for_parameter(param)
        descriptions = [p.get("description", "") for p in payloads]
        has_min_length = any("minLength" in d or "minlength" in d.lower() for d in descriptions)
        has_max_length = any("maxLength" in d or "maxlength" in d.lower() for d in descriptions)
        self.assertTrue(has_min_length, "Expected a payload description mentioning 'minLength'")
        self.assertTrue(has_max_length, "Expected a payload description mentioning 'maxLength'")


# ---------------------------------------------------------------------------
# TestPayloadGeneratorDb
# ---------------------------------------------------------------------------
class TestPayloadGeneratorDb(unittest.TestCase):
    """Tests for DB-specific SQL injection payload retrieval."""

    def setUp(self):
        self.gen = PayloadGenerator()

    def test_generic_db_payloads(self):
        """get_db_payloads('generic') returns a list (may be empty if sql_payloads not importable)."""
        result = self.gen.get_db_payloads("generic")
        self.assertIsInstance(result, list)

    def test_mysql_db_payloads(self):
        """get_db_payloads('mysql') returns a list."""
        result = self.gen.get_db_payloads("mysql")
        self.assertIsInstance(result, list)

    def test_technique_filter(self):
        """get_db_payloads('generic', technique='union') returns a list."""
        result = self.gen.get_db_payloads("generic", technique="union")
        self.assertIsInstance(result, list)


if __name__ == "__main__":
    unittest.main()
