#!/usr/bin/env python3
"""
AutoPentest MCP Server - Main Entry Point
Unified MCP Server for AI-Powered Penetration Testing

Merges 10 TypeScript MCP servers + AutoPentest Python MCP into a single server
with 152 tools sharing state (assessments, scope, evidence).
"""
import asyncio
import json
import sys
import signal
import logging
import time
from pathlib import Path

try:
    from mcp.server.models import InitializationOptions
    from mcp.server import NotificationOptions, Server
    from mcp.server.stdio import stdio_server
    from mcp.types import Tool, TextContent, Resource

    # Add parent directory to path for utils import
    sys.path.insert(0, str(Path(__file__).parent.parent))

    # Import structured logging
    from utils.logger import setup_logging, get_logger
    from config import settings

    # Setup logging for MCP server
    setup_logging(
        log_level=settings.LOG_LEVEL,
        log_format="json",
        log_dir=settings.LOG_DIR,
        enable_file_logging=False,
        enable_console_logging=False,
        max_bytes=settings.LOG_FILE_MAX_BYTES,
        backup_count=settings.LOG_FILE_BACKUP_COUNT
    )

    # Silence MCP SDK loggers to prevent stdout pollution
    for logger_name in ["mcp", "mcp.server", "mcp.server.stdio", "anyio", "httpx", "httpcore"]:
        sdk_logger = logging.getLogger(logger_name)
        sdk_logger.setLevel(logging.CRITICAL)
        sdk_logger.handlers = []
        sdk_logger.addHandler(logging.NullHandler())
        sdk_logger.propagate = False

    logger = get_logger(__name__)

    # Add modules directory to path
    sys.path.insert(0, str(Path(__file__).parent / "modules"))

    # Import core service and resources
    from modules.service import AutoPentestService
    from modules.resources import get_resources, handle_resource_read

    # Import tool modules - AutoPentest core tools (Phase 2)
    from modules.tools_assessment import get_assessment_tools, handle_assessment_tool
    from modules.tools_cards import get_cards_tools, handle_cards_tool
    from modules.tools_recon import get_recon_tools, handle_recon_tool
    from modules.tools_execution import get_execution_tools, handle_execution_tool
    from modules.tools_scanning import get_scanning_tools, handle_scanning_tool
    from modules.tools_credentials import get_credentials_tools, handle_credentials_tool

    # Import tool modules - Ported from TypeScript (Phase 3-5)
    from modules.tools_scope import get_scope_tools, handle_scope_tool
    from modules.tools_http import get_http_tools, handle_http_tool
    from modules.tools_fuzzer import get_fuzzer_tools, handle_fuzzer_tool
    from modules.tools_nuclei import get_nuclei_tools, handle_nuclei_tool
    from modules.tools_openapi import get_openapi_tools, handle_openapi_tool
    from modules.tools_validator import get_validator_tools, handle_validator_tool
    from modules.tools_evidence import get_evidence_tools, handle_evidence_tool
    from modules.tools_auth_tester import get_auth_tester_tools, handle_auth_tester_tool
    from modules.tools_world_model import get_world_model_tools, handle_world_model_tool
    from modules.tools_browser import get_browser_tools, handle_browser_tool
    from modules.tools_risk import get_risk_tools, handle_risk_tool

    # Import tool modules - Coverage engine + Recon pipeline (Phase 6+)
    from modules.tools_coverage import get_coverage_tools, handle_coverage_tool
    from modules.tools_recon_pipeline import get_recon_pipeline_tools, handle_recon_pipeline_tool

    # Import tool modules - Endpoint analysis engine
    from modules.tools_endpoint_analysis import get_endpoint_analysis_tools, handle_endpoint_analysis_tool

    # Import tool modules - Crawler + Business logic sequences
    from modules.tools_crawler import get_crawler_tools, handle_crawler_tool
    from modules.tools_sequences import get_sequence_tools, handle_sequence_tool

    # Import tool modules - Comprehensive testing engine (Phase 7)
    from modules.tools_testing_engine import get_testing_engine_tools, handle_testing_engine_tool

    # Import tool modules - LLM-in-the-loop pentest tools
    from modules.tools_pentest import get_pentest_tools, handle_pentest_tool

    # Import tool modules - SAST (static application security testing)
    from modules.tools_sast import get_sast_tools, handle_sast_tool

    # Import tool modules - Code audit (LLM-powered full code review)
    from modules.tools_code_audit import get_code_audit_tools, handle_code_audit_tool

    # Import tool modules - GraphQL security testing
    from modules.tools_graphql import get_graphql_tools, handle_graphql_tool

    # Import tool modules - Autonomous execution mode
    from modules.tools_auto_run import get_auto_run_tools, handle_auto_run_tool

except Exception as e:
    import traceback
    print(f"FATAL MCP INIT ERROR: {e}", file=sys.stderr)
    traceback.print_exc(file=sys.stderr)
    sys.exit(1)

# ========== Registry-based tool dispatch ==========

# All tool module pairs: (get_tools_func, handler_func)
TOOL_MODULES = [
    # AutoPentest core tools (18 tools, includes 2 orchestration tools)
    (get_assessment_tools, handle_assessment_tool),   # 7 tools (4+3 checkpoint)
    (get_cards_tools, handle_cards_tool),
    (get_recon_tools, handle_recon_tool),
    (get_execution_tools, handle_execution_tool),
    (get_scanning_tools, handle_scanning_tool),
    (get_credentials_tools, handle_credentials_tool),
    # Ported from TypeScript MCP servers
    (get_scope_tools, handle_scope_tool),           # 6 tools
    (get_http_tools, handle_http_tool),             # 3 tools
    (get_fuzzer_tools, handle_fuzzer_tool),          # 3 tools
    (get_nuclei_tools, handle_nuclei_tool),          # 3 tools
    (get_openapi_tools, handle_openapi_tool),        # 6 tools
    (get_validator_tools, handle_validator_tool),     # 4 tools
    (get_evidence_tools, handle_evidence_tool),      # 5 tools
    (get_auth_tester_tools, handle_auth_tester_tool),# 3 tools
    (get_world_model_tools, handle_world_model_tool),# 16 tools
    (get_browser_tools, handle_browser_tool),        # 15 tools
    (get_risk_tools, handle_risk_tool),              # 3 tools
    # Coverage engine + Recon pipeline
    (get_coverage_tools, handle_coverage_tool),        # 6 tools
    (get_recon_pipeline_tools, handle_recon_pipeline_tool),  # 4 tools
    # Endpoint analysis engine
    (get_endpoint_analysis_tools, handle_endpoint_analysis_tool),  # 3 tools
    # Web crawler + Business logic sequences
    (get_crawler_tools, handle_crawler_tool),          # 3 tools
    (get_sequence_tools, handle_sequence_tool),         # 5 tools
    # Comprehensive testing engine (42-class coverage + orchestration)
    (get_testing_engine_tools, handle_testing_engine_tool),  # 7 tools
    # LLM-in-the-loop pentest tools
    (get_pentest_tools, handle_pentest_tool),           # 8 tools
    # SAST (static application security testing)
    (get_sast_tools, handle_sast_tool),                 # 13 tools
    # Code audit (LLM-powered full code review)
    (get_code_audit_tools, handle_code_audit_tool),     # 4 tools
    # GraphQL security testing
    (get_graphql_tools, handle_graphql_tool),             # 5 tools
    # Autonomous execution mode
    (get_auto_run_tools, handle_auto_run_tool),         # 1 tool
]

# Build dispatch map: tool_name -> handler_func
TOOL_REGISTRY = {}
ALL_TOOLS = []

for get_tools_func, handler_func in TOOL_MODULES:
    tools = get_tools_func()
    ALL_TOOLS.extend(tools)
    for tool in tools:
        TOOL_REGISTRY[tool.name] = handler_func

# Index for O(1) lookup by name
ALL_TOOLS_BY_NAME = {tool.name: tool for tool in ALL_TOOLS}

# Escape hatch meta-tool
_LIST_ALL_TOOL = Tool(
    name="list_all_tools",
    description=(
        "Show ALL available tools regardless of phase filtering. "
        "By default only phase-relevant tools are shown. Call this to temporarily see everything."
    ),
    inputSchema={"type": "object", "properties": {}, "additionalProperties": False},
)

# ========== MCP Server Setup ==========

server = Server("autopentest-mcp")
mcp_service = AutoPentestService()


@server.list_resources()
async def handle_list_resources() -> list[Resource]:
    """List available resources"""
    return get_resources()


@server.read_resource()
async def handle_read_resource(uri) -> str:
    """Read resource content"""
    return await handle_resource_read(str(uri), mcp_service)


@server.list_tools()
async def handle_list_tools() -> list[Tool]:
    """List available tools, filtered by current assessment phase."""
    # Check show-all flag (one-shot)
    if getattr(mcp_service, '_show_all_tools', False):
        mcp_service._show_all_tools = False
        return ALL_TOOLS + [_LIST_ALL_TOOL]

    # No assessment loaded â†’ show all
    if not mcp_service.current_assessment_id:
        return ALL_TOOLS

    # Check phase cache (30s TTL to avoid DB hit per list_tools call)
    import time as _time
    cache_phase = getattr(mcp_service, '_phase_cache', None)
    cache_ts = getattr(mcp_service, '_phase_cache_ts', 0)
    if cache_phase is not None and (_time.time() - cache_ts) < 30:
        current_phase = cache_phase
    else:
        try:
            from modules.lib.phase_orchestrator import PhaseOrchestrator
            from modules.lib.world_model_db import get_world_model_db
            db = await get_world_model_db(mcp_service.current_assessment_id)
            orch = PhaseOrchestrator(db, activity_logger=getattr(mcp_service, 'activity_logger', None))
            current_phase = await orch._get_current_phase()
            mcp_service._phase_cache = current_phase
            mcp_service._phase_cache_ts = _time.time()
        except Exception:
            return ALL_TOOLS  # Fallback: show all on error

    from modules.lib.tool_metadata import get_visible_tools_for_phase
    visible_names = get_visible_tools_for_phase(current_phase)
    filtered = [tool for tool in ALL_TOOLS if tool.name in visible_names]
    filtered.append(_LIST_ALL_TOOL)
    return filtered


def _sanitize_params(params: dict) -> dict:
    """Redact sensitive values from tool parameters before logging."""
    _SENSITIVE_KEYS = {"password", "token", "secret", "api_key", "credential", "auth"}
    sanitized = {}
    for k, v in params.items():
        if any(sk in k.lower() for sk in _SENSITIVE_KEYS):
            sanitized[k] = "***REDACTED***"
        elif isinstance(v, str) and len(v) > 500:
            sanitized[k] = v[:500] + "...(truncated)"
        else:
            sanitized[k] = v
    return sanitized


@server.call_tool()
async def handle_call_tool_wrapper(name: str, arguments: dict) -> list[TextContent]:
    """Handle tool calls - registry-based dispatch with activity logging"""
    start_time = time.time()

    try:
        await mcp_service.initialize()

        # Handle list_all_tools meta-tool
        if name == "list_all_tools":
            mcp_service._show_all_tools = True
            from modules.lib.tool_metadata import get_visible_tools_for_phase
            current_filtered_count = len(get_visible_tools_for_phase(getattr(mcp_service, '_phase_cache', 0)))
            return [TextContent(type="text", text=json.dumps({
                "status": "ok",
                "message": f"All {len(ALL_TOOLS)} tools will be visible on next tool listing.",
                "current_filtered_count": current_filtered_count
            }))]

        handler = TOOL_REGISTRY.get(name)
        if not handler:
            return [TextContent(type="text", text=f"Unknown tool: `{name}`")]

        # Log tool start
        if mcp_service.activity_logger:
            try:
                await mcp_service.activity_logger.log_tool_execution(
                    tool_name=name,
                    parameters=_sanitize_params(arguments or {}),
                    status="started",
                )
            except Exception:
                pass  # Never block tool execution for logging

        result = await handler(name, arguments, mcp_service)

        # Invalidate phase cache on phase advance
        if name in ("orchestration_advance", "orchestration_auto_run"):
            mcp_service._phase_cache = None
            mcp_service._phase_cache_ts = 0

        # Log tool completion
        if mcp_service.activity_logger:
            try:
                elapsed = int((time.time() - start_time) * 1000)
                # Truncate result for logging
                result_text = str(result)[:2048] if result else ""
                await mcp_service.activity_logger.log_tool_execution(
                    tool_name=name,
                    parameters=_sanitize_params(arguments or {}),
                    status="completed",
                    result=result_text,
                    execution_time_ms=elapsed,
                )
            except Exception:
                pass

        return result

    except Exception as e:
        # Log tool failure
        if mcp_service.activity_logger:
            try:
                elapsed = int((time.time() - start_time) * 1000)
                await mcp_service.activity_logger.log_tool_execution(
                    tool_name=name,
                    parameters=_sanitize_params(arguments or {}),
                    status="failed",
                    error=str(e),
                    execution_time_ms=elapsed,
                )
            except Exception:
                pass

        logger.error(f"Tool execution error: {e}", exc_info=True)
        return [TextContent(type="text", text=f"Error: {str(e)}")]


async def main():
    """Main server function"""

    def signal_handler(signum, frame):
        logger.info("Shutting down MCP server", signal=signum)
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    logger.info(
        "MCP server starting",
        server="autopentest-mcp",
        project="AutoPentest - Unified MCP Penetration Testing Server",
        version="1.0.0-alpha",
        tool_count=len(ALL_TOOLS),
        log_level=settings.LOG_LEVEL
    )

    # Initialize MCP service
    await mcp_service.initialize()

    try:
        async with stdio_server() as (read_stream, write_stream):
            await server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="autopentest-mcp",
                    server_version="1.0.0-alpha",
                    capabilities=server.get_capabilities(
                        notification_options=NotificationOptions(),
                        experimental_capabilities={}
                    )
                )
            )
    except Exception as e:
        logger.error("MCP server error", error=str(e), exc_info=True)
        raise
    finally:
        await mcp_service.cleanup()
        logger.info("MCP server shutdown complete")


if __name__ == "__main__":
    asyncio.run(main())
