"""
World Model Tools - wm_add_asset, wm_add_endpoint, wm_add_identity,
wm_add_hypothesis, wm_update_hypothesis, wm_add_finding, wm_update_finding,
wm_add_observation, wm_query, wm_store, wm_recall, wm_add_plan, wm_update_plan.

Ported from the world-model-mcp TypeScript server to Python, following the
same pattern as tools_evidence.py and tools_scope.py.
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict, List

from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _json_content(data: Any) -> List[TextContent]:
    """Return a single-element TextContent list with *data* as JSON."""
    return [TextContent(type="text", text=json.dumps(data, indent=2, default=str))]


def _error_content(message: str) -> List[TextContent]:
    """Return a JSON error object wrapped in TextContent."""
    return [TextContent(type="text", text=json.dumps({"success": False, "error": message}, indent=2))]


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_world_model_tools() -> List[Tool]:
    """Return the sixteen world-model tools (13 original + 3 graph)."""
    return [
        # 1 ---- wm_add_asset -----------------------------------------------
        Tool(
            name="wm_add_asset",
            description=(
                "Add a target asset (domain, subdomain, IP, service, or application) "
                "to the world model."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "kind": {
                        "type": "string",
                        "enum": ["domain", "subdomain", "ip", "service", "application"],
                        "description": "Kind of asset",
                    },
                    "name": {
                        "type": "string",
                        "description": "Asset name or identifier (e.g. 'example.com', '10.0.0.1')",
                    },
                    "metadata": {
                        "type": "object",
                        "description": "Optional metadata (JSON object)",
                        "additionalProperties": True,
                    },
                    "tags": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Optional tags for categorisation",
                    },
                },
                "required": ["kind", "name"],
            },
        ),

        # 2 ---- wm_add_endpoint --------------------------------------------
        Tool(
            name="wm_add_endpoint",
            description="Add an API endpoint to an existing asset in the world model.",
            inputSchema={
                "type": "object",
                "properties": {
                    "asset_id": {
                        "type": "string",
                        "description": "ID of the parent asset",
                    },
                    "method": {
                        "type": "string",
                        "description": "HTTP method (GET, POST, PUT, DELETE, etc.)",
                    },
                    "path": {
                        "type": "string",
                        "description": "URL path (e.g. '/api/v1/users')",
                    },
                    "parameters": {
                        "type": "object",
                        "description": "Parameter schema or examples (JSON object)",
                        "additionalProperties": True,
                    },
                    "auth_required": {
                        "type": "boolean",
                        "description": "Whether the endpoint requires authentication (default: false)",
                    },
                    "metadata": {
                        "type": "object",
                        "description": "Optional metadata (JSON object)",
                        "additionalProperties": True,
                    },
                },
                "required": ["asset_id", "method", "path"],
            },
        ),

        # 3 ---- wm_add_identity --------------------------------------------
        Tool(
            name="wm_add_identity",
            description="Add a test identity or credential to the world model.",
            inputSchema={
                "type": "object",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Identity name (e.g. 'admin-user', 'api-key-readonly')",
                    },
                    "auth_type": {
                        "type": "string",
                        "description": "Authentication type (e.g. 'bearer', 'basic', 'cookie', 'api_key')",
                    },
                    "scope": {
                        "type": "string",
                        "description": "Scope or role of the identity (e.g. 'admin', 'user', 'readonly')",
                    },
                    "permissions": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of permissions or capabilities",
                    },
                    "metadata": {
                        "type": "object",
                        "description": "Optional metadata (JSON object)",
                        "additionalProperties": True,
                    },
                },
                "required": ["name", "auth_type", "scope"],
            },
        ),

        # 4 ---- wm_add_hypothesis -------------------------------------------
        Tool(
            name="wm_add_hypothesis",
            description=(
                "Create a security hypothesis to test. Hypotheses track what you "
                "suspect and drive the testing process."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "title": {
                        "type": "string",
                        "description": "Short title (e.g. 'IDOR on /api/users/{id}')",
                    },
                    "description": {
                        "type": "string",
                        "description": "Detailed description of the hypothesis",
                    },
                    "severity": {
                        "type": "string",
                        "enum": ["info", "low", "medium", "high", "critical"],
                        "description": "Expected severity if confirmed",
                    },
                    "target_id": {
                        "type": "string",
                        "description": "Optional ID of the target asset or endpoint",
                    },
                },
                "required": ["title", "description", "severity"],
            },
        ),

        # 5 ---- wm_update_hypothesis ----------------------------------------
        Tool(
            name="wm_update_hypothesis",
            description="Update a hypothesis status and/or append evidence.",
            inputSchema={
                "type": "object",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "Hypothesis ID to update",
                    },
                    "status": {
                        "type": "string",
                        "enum": ["proposed", "testing", "confirmed", "rejected"],
                        "description": "New status",
                    },
                    "evidence": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Evidence IDs to append (observation IDs, artifact IDs, etc.)",
                    },
                },
                "required": ["id"],
            },
        ),

        # 6 ---- wm_add_finding ----------------------------------------------
        Tool(
            name="wm_add_finding",
            description="Record a confirmed security finding linked to a hypothesis.",
            inputSchema={
                "type": "object",
                "properties": {
                    "hypothesis_id": {
                        "type": "string",
                        "description": "ID of the hypothesis this finding confirms",
                    },
                    "title": {
                        "type": "string",
                        "description": "Finding title (e.g. 'SQL Injection in login form')",
                    },
                    "severity": {
                        "type": "string",
                        "enum": ["info", "low", "medium", "high", "critical"],
                        "description": "Finding severity",
                    },
                    "confidence": {
                        "type": "number",
                        "minimum": 0,
                        "maximum": 1,
                        "description": "Confidence level from 0.0 to 1.0",
                    },
                    "evidence_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "IDs of supporting evidence (observations, artifacts)",
                    },
                    "remediation": {
                        "type": "string",
                        "description": "Recommended remediation steps",
                    },
                    "metadata": {
                        "type": "object",
                        "description": "Optional metadata (CVSS, CWE, references, etc.)",
                        "additionalProperties": True,
                    },
                },
                "required": ["hypothesis_id", "title", "severity", "confidence"],
            },
        ),

        # 7 ---- wm_update_finding -------------------------------------------
        Tool(
            name="wm_update_finding",
            description="Update a finding's status, confidence, or remediation.",
            inputSchema={
                "type": "object",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "Finding ID to update",
                    },
                    "status": {
                        "type": "string",
                        "enum": ["draft", "confirmed", "reported", "remediated"],
                        "description": "New finding status",
                    },
                    "confidence": {
                        "type": "number",
                        "minimum": 0,
                        "maximum": 1,
                        "description": "Updated confidence level",
                    },
                    "remediation": {
                        "type": "string",
                        "description": "Updated remediation steps",
                    },
                },
                "required": ["id"],
            },
        ),

        # 8 ---- wm_add_observation ------------------------------------------
        Tool(
            name="wm_add_observation",
            description=(
                "Add an observation (request, response, behavior, anomaly) "
                "to a hypothesis."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "hypothesis_id": {
                        "type": "string",
                        "description": "ID of the hypothesis this observation belongs to",
                    },
                    "type": {
                        "type": "string",
                        "enum": ["request", "response", "behavior", "anomaly"],
                        "description": "Type of observation",
                    },
                    "content": {
                        "type": "string",
                        "description": "Observation content (raw data, description, etc.)",
                    },
                    "metadata": {
                        "type": "object",
                        "description": "Optional metadata (JSON object)",
                        "additionalProperties": True,
                    },
                },
                "required": ["hypothesis_id", "type", "content"],
            },
        ),

        # 9 ---- wm_query ---------------------------------------------------
        Tool(
            name="wm_query",
            description=(
                "Query the world model. Search any table (assets, endpoints, "
                "identities, hypotheses, observations, findings) with optional filters."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "table": {
                        "type": "string",
                        "enum": [
                            "assets", "endpoints", "identities",
                            "hypotheses", "observations", "findings",
                            "plans",
                        ],
                        "description": "Table to query",
                    },
                    "filters": {
                        "type": "object",
                        "description": (
                            "Column=value filters (e.g. {\"kind\": \"domain\"}, "
                            "{\"status\": \"confirmed\"})"
                        ),
                        "additionalProperties": True,
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Maximum rows to return (default: 100)",
                    },
                    "offset": {
                        "type": "integer",
                        "description": "Number of rows to skip (default: 0)",
                    },
                    "id": {
                        "type": "string",
                        "description": "If provided, fetch a single record by ID (ignores filters/limit/offset)",
                    },
                    "stats": {
                        "type": "boolean",
                        "description": "If true, return row counts for all tables (ignores other params)",
                    },
                },
                "required": ["table"],
            },
        ),

        # 10 ---- wm_store --------------------------------------------------
        Tool(
            name="wm_store",
            description=(
                "Store knowledge in the world model for later retrieval. Use for scan "
                "output, page content, HTTP exchanges, command results, or any data worth "
                "preserving. Content is auto-chunked if large and full-text indexed for "
                "fast search."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "source_tool": {
                        "type": "string",
                        "description": "Name of the tool that produced this content",
                    },
                    "category": {
                        "type": "string",
                        "enum": [
                            "scan_output", "page_content", "http_exchange",
                            "fuzz_result", "command_output", "error",
                            "form_data", "navigation", "timing", "other",
                        ],
                        "description": "Knowledge category for filtering",
                    },
                    "title": {
                        "type": "string",
                        "description": "Short descriptive title",
                    },
                    "content": {
                        "type": "string",
                        "description": "The content to store",
                    },
                    "target": {
                        "type": "string",
                        "description": "Target identifier (URL, IP, domain, etc.)",
                    },
                    "metadata": {
                        "type": "object",
                        "description": "Additional metadata (JSON object)",
                        "additionalProperties": True,
                    },
                    "tags": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Tags for filtering",
                    },
                },
                "required": ["source_tool", "category", "title", "content"],
            },
        ),

        # 11 ---- wm_recall -------------------------------------------------
        Tool(
            name="wm_recall",
            description=(
                "Search and retrieve stored knowledge from the world model. Supports "
                "full-text search (keyword query with FTS5), semantic search (embedding "
                "similarity), and filtering by category/target/source. Use this to recall "
                "scan results, page content, HTTP exchanges, or any previously stored knowledge."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "Search query (FTS5 full-text search + semantic similarity)",
                    },
                    "category": {
                        "type": "string",
                        "enum": [
                            "scan_output", "page_content", "http_exchange",
                            "fuzz_result", "command_output", "error",
                            "form_data", "navigation", "timing", "other",
                        ],
                        "description": "Filter by category",
                    },
                    "target": {
                        "type": "string",
                        "description": "Filter by target (URL, IP, domain)",
                    },
                    "source_tool": {
                        "type": "string",
                        "description": "Filter by source tool name",
                    },
                    "tags": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Filter by tags (any match)",
                    },
                    "since": {
                        "type": "string",
                        "description": "Filter by creation time (ISO-8601, e.g. '2024-01-01T00:00:00')",
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Maximum results to return (default: 20)",
                    },
                    "offset": {
                        "type": "integer",
                        "description": "Number of results to skip (default: 0)",
                    },
                    "full_chunks": {
                        "type": "boolean",
                        "description": "Include all chunks (default: false, head chunks only)",
                    },
                    "include_content": {
                        "type": "boolean",
                        "description": "Include full content in results (default: true)",
                    },
                    "id": {
                        "type": "string",
                        "description": "Retrieve a specific knowledge entry by ID (with all chunks)",
                    },
                    "stats": {
                        "type": "boolean",
                        "description": "Return knowledge store statistics (ignores other params)",
                    },
                },
            },
        ),

        # 12 ---- wm_add_plan -----------------------------------------------
        Tool(
            name="wm_add_plan",
            description=(
                "Create a testing plan with structured steps. Use before starting "
                "a multi-step attack sequence. Steps track progress through the plan."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "title": {
                        "type": "string",
                        "description": "Plan title (e.g. 'SQL Injection testing on /api/login')",
                    },
                    "goal": {
                        "type": "string",
                        "description": "What this plan aims to achieve",
                    },
                    "steps": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "description": {
                                    "type": "string",
                                    "description": "Step description",
                                },
                            },
                            "required": ["description"],
                        },
                        "description": "Ordered list of steps to execute",
                    },
                },
                "required": ["title", "goal", "steps"],
            },
        ),

        # 13 ---- wm_update_plan --------------------------------------------
        Tool(
            name="wm_update_plan",
            description=(
                "Update a plan step status or add reflection notes. Use after "
                "completing or skipping steps to track progress and lessons learned."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "Plan ID",
                    },
                    "step_index": {
                        "type": "integer",
                        "description": "Step index to update (0-based)",
                    },
                    "step_status": {
                        "type": "string",
                        "enum": ["pending", "in_progress", "done", "skipped"],
                        "description": "New status for the step",
                    },
                    "step_result": {
                        "type": "string",
                        "description": "Result or output of the step",
                    },
                    "reflection": {
                        "type": "string",
                        "description": "Reflection on what was learned (appended to plan)",
                    },
                    "status": {
                        "type": "string",
                        "enum": ["active", "completed", "abandoned"],
                        "description": "Overall plan status",
                    },
                },
                "required": ["id"],
            },
        ),

        # 14 ---- wm_add_relationship ----------------------------------------
        Tool(
            name="wm_add_relationship",
            description=(
                "Add a typed edge between two entities in the attack-surface graph. "
                "Idempotent (INSERT OR IGNORE). Use to link assets, endpoints, "
                "findings, hypotheses, and identities."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "source_type": {
                        "type": "string",
                        "enum": ["asset", "endpoint", "identity", "hypothesis", "finding"],
                        "description": "Type of the source entity",
                    },
                    "source_id": {
                        "type": "string",
                        "description": "ID of the source entity",
                    },
                    "target_type": {
                        "type": "string",
                        "enum": ["asset", "endpoint", "identity", "hypothesis", "finding"],
                        "description": "Type of the target entity",
                    },
                    "target_id": {
                        "type": "string",
                        "description": "ID of the target entity",
                    },
                    "rel_type": {
                        "type": "string",
                        "enum": [
                            "domain_has_subdomain", "resolves_to", "has_endpoint",
                            "has_finding", "tested_by", "targets", "confirms",
                        ],
                        "description": "Relationship type",
                    },
                    "metadata": {
                        "type": "object",
                        "description": "Optional metadata for the edge",
                        "additionalProperties": True,
                    },
                },
                "required": ["source_type", "source_id", "target_type", "target_id", "rel_type"],
            },
        ),

        # 15 ---- wm_get_neighbors -------------------------------------------
        Tool(
            name="wm_get_neighbors",
            description=(
                "BFS traversal from any entity in the attack-surface graph. "
                "Returns connected nodes and edges up to a given depth."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_type": {
                        "type": "string",
                        "enum": ["asset", "endpoint", "identity", "hypothesis", "finding"],
                        "description": "Type of the starting entity",
                    },
                    "entity_id": {
                        "type": "string",
                        "description": "ID of the starting entity",
                    },
                    "rel_types": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Filter to specific relationship types (optional)",
                    },
                    "direction": {
                        "type": "string",
                        "enum": ["outgoing", "incoming", "both"],
                        "description": "Edge direction to follow (default: both)",
                    },
                    "depth": {
                        "type": "integer",
                        "minimum": 1,
                        "maximum": 4,
                        "description": "BFS depth (default: 1, max: 4)",
                    },
                },
                "required": ["entity_type", "entity_id"],
            },
        ),

        # 16 ---- wm_find_path -----------------------------------------------
        Tool(
            name="wm_find_path",
            description=(
                "Find the shortest path between two entities in the attack-surface "
                "graph. Returns the list of relationship edges forming the path."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "from_type": {
                        "type": "string",
                        "enum": ["asset", "endpoint", "identity", "hypothesis", "finding"],
                        "description": "Type of the starting entity",
                    },
                    "from_id": {
                        "type": "string",
                        "description": "ID of the starting entity",
                    },
                    "to_type": {
                        "type": "string",
                        "enum": ["asset", "endpoint", "identity", "hypothesis", "finding"],
                        "description": "Type of the target entity",
                    },
                    "to_id": {
                        "type": "string",
                        "description": "ID of the target entity",
                    },
                    "max_depth": {
                        "type": "integer",
                        "minimum": 1,
                        "maximum": 8,
                        "description": "Maximum search depth (default: 8)",
                    },
                },
                "required": ["from_type", "from_id", "to_type", "to_id"],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_world_model_tool(
    name: str,
    arguments: dict,
    mcp_service: Any = None,
) -> List[TextContent]:
    """Dispatch a world-model tool call to the appropriate handler.

    Parameters
    ----------
    name : str
        Tool name (one of the nine wm_* tools).
    arguments : dict
        Arguments supplied by the caller.
    mcp_service :
        The MCP service instance (unused by world-model tools but kept
        for interface parity with other tool modules).
    """
    try:
        if name == "wm_add_asset":
            return await _handle_add_asset(arguments, mcp_service)
        elif name == "wm_add_endpoint":
            return await _handle_add_endpoint(arguments, mcp_service)
        elif name == "wm_add_identity":
            return await _handle_add_identity(arguments, mcp_service)
        elif name == "wm_add_hypothesis":
            return await _handle_add_hypothesis(arguments, mcp_service)
        elif name == "wm_update_hypothesis":
            return await _handle_update_hypothesis(arguments, mcp_service)
        elif name == "wm_add_finding":
            return await _handle_add_finding(arguments, mcp_service)
        elif name == "wm_update_finding":
            return await _handle_update_finding(arguments, mcp_service)
        elif name == "wm_add_observation":
            return await _handle_add_observation(arguments, mcp_service)
        elif name == "wm_query":
            return await _handle_query(arguments, mcp_service)
        elif name == "wm_store":
            return await _handle_wm_store(arguments, mcp_service)
        elif name == "wm_recall":
            return await _handle_wm_recall(arguments, mcp_service)
        elif name == "wm_add_plan":
            return await _handle_add_plan(arguments, mcp_service)
        elif name == "wm_update_plan":
            return await _handle_update_plan(arguments, mcp_service)
        elif name == "wm_add_relationship":
            return await _handle_add_relationship(arguments, mcp_service)
        elif name == "wm_get_neighbors":
            return await _handle_get_neighbors(arguments, mcp_service)
        elif name == "wm_find_path":
            return await _handle_find_path(arguments, mcp_service)
    except _NoAssessmentError:
        return _error_content(
            "No assessment loaded. Use 'load_assessment' first before using world model tools."
        )
    except Exception as exc:
        logger.error("World-model tool %s failed: %s", name, exc, exc_info=True)
        return _error_content(f"Error in {name}: {exc}")

    return _error_content(f"Unknown world-model tool: {name}")


# ---------------------------------------------------------------------------
# Lazy database initialisation
# ---------------------------------------------------------------------------

class _NoAssessmentError(Exception):
    """Raised when a world model tool is called without a loaded assessment."""
    pass


async def _get_db(mcp_service=None):
    """Return the world-model database for the current assessment."""
    if mcp_service is None or mcp_service.current_assessment_id is None:
        raise _NoAssessmentError()
    from lib.world_model_db import get_world_model_db
    return await get_world_model_db(mcp_service.current_assessment_id)


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_add_asset(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_add_asset."""
    kind = arguments.get("kind")
    if not kind or not isinstance(kind, str):
        return _error_content("kind is required and must be a string")

    name = arguments.get("name")
    if not name or not isinstance(name, str):
        return _error_content("name is required and must be a string")

    metadata = arguments.get("metadata") or {}
    if not isinstance(metadata, dict):
        metadata = {}

    tags = arguments.get("tags") or []
    if not isinstance(tags, list):
        tags = []

    db = await _get_db(mcp_service)
    asset = await db.add_asset(kind=kind, name=name, metadata=metadata, tags=tags)

    # Sync asset to backend recon
    if mcp_service:
        _ASSET_TYPE_MAP = {
            "domain": "subdomain", "subdomain": "subdomain",
            "ip": "service", "service": "service", "application": "technology",
        }
        await mcp_service.safe_add_recon(
            data_type=_ASSET_TYPE_MAP.get(kind, kind),
            name=name,
            details={"kind": kind, "tags": tags, "wm_id": asset.get("id", "")},
            phase="reconnaissance",
        )

    return _json_content({
        "success": True,
        "asset": asset,
        "message": f"Asset '{name}' ({kind}) added to world model.",
    })


async def _handle_add_endpoint(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_add_endpoint."""
    asset_id = arguments.get("asset_id")
    if not asset_id or not isinstance(asset_id, str):
        return _error_content("asset_id is required and must be a string")

    method = arguments.get("method")
    if not method or not isinstance(method, str):
        return _error_content("method is required and must be a string")

    path = arguments.get("path")
    if not path or not isinstance(path, str):
        return _error_content("path is required and must be a string")

    parameters = arguments.get("parameters") or {}
    if not isinstance(parameters, dict):
        parameters = {}

    auth_required = arguments.get("auth_required") is True

    metadata = arguments.get("metadata") or {}
    if not isinstance(metadata, dict):
        metadata = {}

    db = await _get_db(mcp_service)
    endpoint = await db.add_endpoint(
        asset_id=asset_id,
        method=method.upper(),
        path=path,
        parameters=parameters,
        auth_required=auth_required,
        metadata=metadata,
    )

    # Sync endpoint to backend recon
    if mcp_service:
        await mcp_service.safe_add_recon(
            data_type="endpoint",
            name=f"{method.upper()} {path}",
            details={
                "method": method.upper(),
                "path": path,
                "auth_required": auth_required,
                "wm_id": endpoint.get("id", ""),
            },
            phase="reconnaissance",
        )

    # Auto-create graph edge: asset → endpoint
    try:
        await db.add_relationship(
            source_type="asset", source_id=asset_id,
            target_type="endpoint", target_id=endpoint["id"],
            rel_type="has_endpoint",
        )
    except Exception as rel_exc:
        logger.warning("Auto-relationship (has_endpoint) failed: %s", rel_exc)

    return _json_content({
        "success": True,
        "endpoint": endpoint,
        "message": f"Endpoint {method.upper()} {path} added to asset {asset_id}.",
    })


async def _handle_add_identity(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_add_identity."""
    name = arguments.get("name")
    if not name or not isinstance(name, str):
        return _error_content("name is required and must be a string")

    auth_type = arguments.get("auth_type")
    if not auth_type or not isinstance(auth_type, str):
        return _error_content("auth_type is required and must be a string")

    scope = arguments.get("scope")
    if not scope or not isinstance(scope, str):
        return _error_content("scope is required and must be a string")

    permissions = arguments.get("permissions") or []
    if not isinstance(permissions, list):
        permissions = []

    metadata = arguments.get("metadata") or {}
    if not isinstance(metadata, dict):
        metadata = {}

    db = await _get_db(mcp_service)
    identity = await db.add_identity(
        name=name,
        auth_type=auth_type,
        scope=scope,
        permissions=permissions,
        metadata=metadata,
    )

    return _json_content({
        "success": True,
        "identity": identity,
        "message": f"Identity '{name}' ({auth_type}, scope={scope}) added.",
    })


async def _handle_add_hypothesis(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_add_hypothesis."""
    title = arguments.get("title")
    if not title or not isinstance(title, str):
        return _error_content("title is required and must be a string")

    description = arguments.get("description")
    if not description or not isinstance(description, str):
        return _error_content("description is required and must be a string")

    severity = arguments.get("severity")
    if not severity or not isinstance(severity, str):
        return _error_content("severity is required and must be a string")

    target_id = arguments.get("target_id")
    if target_id is not None and not isinstance(target_id, str):
        target_id = None

    db = await _get_db(mcp_service)
    hypothesis = await db.add_hypothesis(
        title=title,
        description=description,
        severity=severity,
        target_id=target_id,
    )

    # Auto-create graph edge: hypothesis → target (if target_id provided)
    if target_id:
        try:
            await db.add_relationship(
                source_type="hypothesis", source_id=hypothesis["id"],
                target_type="endpoint", target_id=target_id,
                rel_type="targets",
            )
        except Exception as rel_exc:
            logger.warning("Auto-relationship (targets) failed: %s", rel_exc)

    return _json_content({
        "success": True,
        "hypothesis": hypothesis,
        "message": f"Hypothesis '{title}' created with status 'proposed'.",
    })


async def _handle_update_hypothesis(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_update_hypothesis."""
    hypothesis_id = arguments.get("id")
    if not hypothesis_id or not isinstance(hypothesis_id, str):
        return _error_content("id is required and must be a string")

    status = arguments.get("status")
    if status is not None and not isinstance(status, str):
        return _error_content("status must be a string")

    evidence = arguments.get("evidence")
    if evidence is not None and not isinstance(evidence, list):
        return _error_content("evidence must be an array of strings")

    if status is None and evidence is None:
        return _error_content("At least one of status or evidence must be provided")

    db = await _get_db(mcp_service)
    hypothesis = await db.update_hypothesis(
        hypothesis_id=hypothesis_id,
        status=status,
        evidence=evidence,
    )

    return _json_content({
        "success": True,
        "hypothesis": hypothesis,
        "message": f"Hypothesis {hypothesis_id} updated.",
    })


async def _handle_add_finding(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_add_finding."""
    hypothesis_id = arguments.get("hypothesis_id")
    if not hypothesis_id or not isinstance(hypothesis_id, str):
        return _error_content("hypothesis_id is required and must be a string")

    title = arguments.get("title")
    if not title or not isinstance(title, str):
        return _error_content("title is required and must be a string")

    severity = arguments.get("severity")
    if not severity or not isinstance(severity, str):
        return _error_content("severity is required and must be a string")

    confidence = arguments.get("confidence")
    if confidence is None or not isinstance(confidence, (int, float)):
        return _error_content("confidence is required and must be a number (0.0 - 1.0)")

    evidence_ids = arguments.get("evidence_ids") or []
    if not isinstance(evidence_ids, list):
        evidence_ids = []

    remediation = arguments.get("remediation")
    if remediation is not None and not isinstance(remediation, str):
        remediation = None

    metadata = arguments.get("metadata") or {}
    if not isinstance(metadata, dict):
        metadata = {}

    db = await _get_db(mcp_service)
    finding = await db.add_finding(
        hypothesis_id=hypothesis_id,
        title=title,
        severity=severity,
        confidence=float(confidence),
        evidence_ids=evidence_ids,
        remediation=remediation,
        metadata=metadata,
    )

    # Auto-create graph edge: finding → hypothesis
    try:
        await db.add_relationship(
            source_type="finding", source_id=finding["id"],
            target_type="hypothesis", target_id=hypothesis_id,
            rel_type="confirms",
        )
    except Exception as rel_exc:
        logger.warning("Auto-relationship (confirms) failed: %s", rel_exc)

    # Sync finding to backend as a card
    if mcp_service:
        _SEV_MAP = {"critical": "CRITICAL", "high": "HIGH", "medium": "MEDIUM", "low": "LOW", "info": "INFO"}
        await mcp_service.safe_add_card(
            card_type="finding",
            title=title,
            severity=_SEV_MAP.get(severity, "INFO"),
            status="confirmed" if float(confidence) >= 0.7 else "potential",
            technical_analysis=f"Hypothesis: {hypothesis_id}\nConfidence: {confidence}",
            notes=remediation or "",
            context=f"Source: world_model, WM ID: {finding.get('id', '')}",
        )

    return _json_content({
        "success": True,
        "finding": finding,
        "message": f"Finding '{title}' ({severity}, confidence={confidence}) recorded.",
    })


async def _handle_update_finding(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_update_finding."""
    finding_id = arguments.get("id")
    if not finding_id or not isinstance(finding_id, str):
        return _error_content("id is required and must be a string")

    status = arguments.get("status")
    if status is not None and not isinstance(status, str):
        return _error_content("status must be a string")

    confidence = arguments.get("confidence")
    if confidence is not None and not isinstance(confidence, (int, float)):
        return _error_content("confidence must be a number (0.0 - 1.0)")

    remediation = arguments.get("remediation")
    if remediation is not None and not isinstance(remediation, str):
        return _error_content("remediation must be a string")

    if status is None and confidence is None and remediation is None:
        return _error_content("At least one of status, confidence, or remediation must be provided")

    db = await _get_db(mcp_service)
    finding = await db.update_finding(
        finding_id=finding_id,
        status=status,
        confidence=float(confidence) if confidence is not None else None,
        remediation=remediation,
    )

    return _json_content({
        "success": True,
        "finding": finding,
        "message": f"Finding {finding_id} updated.",
    })


async def _handle_add_observation(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_add_observation."""
    hypothesis_id = arguments.get("hypothesis_id")
    if not hypothesis_id or not isinstance(hypothesis_id, str):
        return _error_content("hypothesis_id is required and must be a string")

    obs_type = arguments.get("type")
    if not obs_type or not isinstance(obs_type, str):
        return _error_content("type is required and must be a string")

    content = arguments.get("content")
    if not content or not isinstance(content, str):
        return _error_content("content is required and must be a string")

    metadata = arguments.get("metadata") or {}
    if not isinstance(metadata, dict):
        metadata = {}

    db = await _get_db(mcp_service)
    observation = await db.add_observation(
        hypothesis_id=hypothesis_id,
        obs_type=obs_type,
        content=content,
        metadata=metadata,
    )

    return _json_content({
        "success": True,
        "observation": observation,
        "message": f"Observation ({obs_type}) added to hypothesis {hypothesis_id}.",
    })


async def _handle_query(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_query - flexible querying of the world model."""
    # Check for stats mode first
    if arguments.get("stats") is True:
        db = await _get_db(mcp_service)
        stats = await db.get_stats()
        return _json_content({
            "success": True,
            "stats": stats,
            "message": "World model statistics.",
        })

    table = arguments.get("table")
    if not table or not isinstance(table, str):
        return _error_content("table is required and must be a string")

    # Check for single-record lookup by ID
    record_id = arguments.get("id")
    if record_id and isinstance(record_id, str):
        db = await _get_db(mcp_service)
        record = await db.get_by_id(table, record_id)
        if record is None:
            return _error_content(f"Record not found: {record_id} in {table}")
        return _json_content({
            "success": True,
            "table": table,
            "record": record,
        })

    # General query with filters
    filters = arguments.get("filters") or {}
    if not isinstance(filters, dict):
        filters = {}

    limit = arguments.get("limit", 100)
    if not isinstance(limit, int) or limit < 1:
        limit = 100

    offset = arguments.get("offset", 0)
    if not isinstance(offset, int) or offset < 0:
        offset = 0

    db = await _get_db(mcp_service)
    results = await db.query(table=table, filters=filters, limit=limit, offset=offset)

    return _json_content({
        "success": True,
        "table": table,
        "count": len(results),
        "limit": limit,
        "offset": offset,
        "filters": filters,
        "results": results,
    })


async def _handle_wm_store(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_store - store knowledge in the world model."""
    source_tool = arguments.get("source_tool")
    if not source_tool or not isinstance(source_tool, str):
        return _error_content("source_tool is required and must be a string")

    category = arguments.get("category")
    if not category or not isinstance(category, str):
        return _error_content("category is required and must be a string")

    title = arguments.get("title")
    if not title or not isinstance(title, str):
        return _error_content("title is required and must be a string")

    content = arguments.get("content")
    if not content or not isinstance(content, str):
        return _error_content("content is required and must be a string")

    target = arguments.get("target", "")
    if not isinstance(target, str):
        target = ""

    metadata = arguments.get("metadata") or {}
    if not isinstance(metadata, dict):
        metadata = {}

    tags = arguments.get("tags") or []
    if not isinstance(tags, list):
        tags = []

    db = await _get_db(mcp_service)

    # Generate embedding (best-effort)
    embedding = None
    try:
        from lib.embedder import get_embedder
        embedder = get_embedder()
        embed_text = f"{title}\n{content[:512]}" if len(content) > 512 else f"{title}\n{content}"
        embedding = embedder.embed(embed_text)
    except Exception:
        pass

    result = await db.store_knowledge(
        source_tool=source_tool,
        category=category,
        title=title,
        content=content,
        target=target,
        metadata=metadata,
        tags=tags,
        embedding=embedding,
    )

    return _json_content({
        "success": True,
        **result,
        "message": f"Knowledge stored: '{title}' ({category}, {result['chunk_count']} chunk(s), {result['content_size']} bytes)",
    })


async def _handle_wm_recall(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_recall - search and retrieve stored knowledge."""
    # Check for stats mode
    if arguments.get("stats") is True:
        db = await _get_db(mcp_service)
        stats = await db.knowledge_stats()
        return _json_content({
            "success": True,
            "stats": stats,
            "message": "Knowledge store statistics.",
        })

    # Check for single-record lookup by ID
    record_id = arguments.get("id")
    if record_id and isinstance(record_id, str):
        db = await _get_db(mcp_service)
        chunks = await db.get_knowledge_chunks(record_id)
        if not chunks:
            return _error_content(f"Knowledge entry not found: {record_id}")

        # Reassemble content from chunks
        full_content = "".join(c.get("content", "") for c in chunks)
        head = chunks[0].copy()
        head["content"] = full_content
        head.pop("embedding", None)

        return _json_content({
            "success": True,
            "entry": head,
            "chunk_count": len(chunks),
        })

    # Search / browse mode
    query = arguments.get("query")
    if query is not None and not isinstance(query, str):
        query = str(query)

    category = arguments.get("category")
    target = arguments.get("target")
    source_tool = arguments.get("source_tool")
    tags = arguments.get("tags")
    since = arguments.get("since")
    limit = arguments.get("limit", 20)
    offset = arguments.get("offset", 0)
    full_chunks = arguments.get("full_chunks", False)
    include_content = arguments.get("include_content", True)

    if not isinstance(limit, int) or limit < 1:
        limit = 20
    if not isinstance(offset, int) or offset < 0:
        offset = 0

    db = await _get_db(mcp_service)

    # Generate query embedding for semantic search
    query_embedding = None
    if query:
        try:
            from lib.embedder import get_embedder
            embedder = get_embedder()
            query_embedding = embedder.embed(query)
        except Exception:
            pass

    results = await db.recall_knowledge(
        query=query,
        query_embedding=query_embedding,
        category=category,
        target=target,
        source_tool=source_tool,
        tags=tags,
        since=since,
        limit=limit,
        offset=offset,
        full_chunks=full_chunks,
        include_content=include_content,
    )

    return _json_content({
        "success": True,
        "query": query,
        "count": len(results),
        "limit": limit,
        "offset": offset,
        "results": results,
    })


async def _handle_add_plan(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_add_plan - create a structured testing plan."""
    title = arguments.get("title")
    if not title or not isinstance(title, str):
        return _error_content("title is required and must be a string")

    goal = arguments.get("goal")
    if not goal or not isinstance(goal, str):
        return _error_content("goal is required and must be a string")

    steps = arguments.get("steps")
    if not steps or not isinstance(steps, list) or len(steps) == 0:
        return _error_content("steps is required and must be a non-empty array")

    db = await _get_db(mcp_service)
    plan = await db.add_plan(title=title, goal=goal, steps=steps)

    return _json_content({
        "success": True,
        "plan": plan,
        "message": f"Plan '{title}' created with {len(plan['steps'])} steps.",
    })


async def _handle_update_plan(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_update_plan - update step status or add reflection."""
    plan_id = arguments.get("id")
    if not plan_id or not isinstance(plan_id, str):
        return _error_content("id is required and must be a string")

    step_index = arguments.get("step_index")
    if step_index is not None and not isinstance(step_index, int):
        return _error_content("step_index must be an integer")

    step_status = arguments.get("step_status")
    if step_status is not None and not isinstance(step_status, str):
        return _error_content("step_status must be a string")

    step_result = arguments.get("step_result")
    if step_result is not None and not isinstance(step_result, str):
        return _error_content("step_result must be a string")

    reflection = arguments.get("reflection")
    if reflection is not None and not isinstance(reflection, str):
        return _error_content("reflection must be a string")

    status = arguments.get("status")
    if status is not None and not isinstance(status, str):
        return _error_content("status must be a string")

    # Must provide at least one update field
    if all(v is None for v in [step_index, reflection, status]):
        return _error_content(
            "At least one of step_index, reflection, or status must be provided"
        )

    db = await _get_db(mcp_service)
    plan = await db.update_plan(
        plan_id=plan_id,
        step_index=step_index,
        step_status=step_status,
        step_result=step_result,
        reflection=reflection,
        status=status,
    )

    return _json_content({
        "success": True,
        "plan": plan,
        "message": f"Plan {plan_id} updated.",
    })


# ---------------------------------------------------------------------------
# Graph tool handlers
# ---------------------------------------------------------------------------

async def _handle_add_relationship(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_add_relationship - add a typed edge between entities."""
    source_type = arguments.get("source_type")
    if not source_type or not isinstance(source_type, str):
        return _error_content("source_type is required and must be a string")

    source_id = arguments.get("source_id")
    if not source_id or not isinstance(source_id, str):
        return _error_content("source_id is required and must be a string")

    target_type = arguments.get("target_type")
    if not target_type or not isinstance(target_type, str):
        return _error_content("target_type is required and must be a string")

    target_id = arguments.get("target_id")
    if not target_id or not isinstance(target_id, str):
        return _error_content("target_id is required and must be a string")

    rel_type = arguments.get("rel_type")
    if not rel_type or not isinstance(rel_type, str):
        return _error_content("rel_type is required and must be a string")

    metadata = arguments.get("metadata") or {}
    if not isinstance(metadata, dict):
        metadata = {}

    db = await _get_db(mcp_service)
    rel = await db.add_relationship(
        source_type=source_type,
        source_id=source_id,
        target_type=target_type,
        target_id=target_id,
        rel_type=rel_type,
        metadata=metadata,
    )

    return _json_content({
        "success": True,
        "relationship": rel,
        "message": f"Relationship {source_type}:{source_id} --[{rel_type}]--> {target_type}:{target_id} added.",
    })


async def _handle_get_neighbors(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_get_neighbors - BFS traversal from an entity."""
    entity_type = arguments.get("entity_type")
    if not entity_type or not isinstance(entity_type, str):
        return _error_content("entity_type is required and must be a string")

    entity_id = arguments.get("entity_id")
    if not entity_id or not isinstance(entity_id, str):
        return _error_content("entity_id is required and must be a string")

    rel_types = arguments.get("rel_types")
    if rel_types is not None and not isinstance(rel_types, list):
        rel_types = None

    direction = arguments.get("direction", "both")
    if direction not in ("outgoing", "incoming", "both"):
        direction = "both"

    depth = arguments.get("depth", 1)
    if not isinstance(depth, int) or depth < 1:
        depth = 1

    db = await _get_db(mcp_service)
    result = await db.get_neighbors(
        entity_type=entity_type,
        entity_id=entity_id,
        rel_types=rel_types,
        direction=direction,
        depth=depth,
    )

    return _json_content({
        "success": True,
        "node_count": len(result["nodes"]),
        "edge_count": len(result["edges"]),
        **result,
        "message": f"Found {len(result['nodes'])} neighbors, {len(result['edges'])} edges at depth {depth}.",
    })


async def _handle_find_path(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle wm_find_path - shortest path between two entities."""
    from_type = arguments.get("from_type")
    if not from_type or not isinstance(from_type, str):
        return _error_content("from_type is required and must be a string")

    from_id = arguments.get("from_id")
    if not from_id or not isinstance(from_id, str):
        return _error_content("from_id is required and must be a string")

    to_type = arguments.get("to_type")
    if not to_type or not isinstance(to_type, str):
        return _error_content("to_type is required and must be a string")

    to_id = arguments.get("to_id")
    if not to_id or not isinstance(to_id, str):
        return _error_content("to_id is required and must be a string")

    max_depth = arguments.get("max_depth", 8)
    if not isinstance(max_depth, int) or max_depth < 1:
        max_depth = 8

    db = await _get_db(mcp_service)
    path = await db.get_attack_path(
        from_type=from_type,
        from_id=from_id,
        to_type=to_type,
        to_id=to_id,
        max_depth=max_depth,
    )

    if path is None:
        return _json_content({
            "success": True,
            "found": False,
            "path": [],
            "length": 0,
            "message": f"No path found from {from_type}:{from_id} to {to_type}:{to_id} (max depth {max_depth}).",
        })

    return _json_content({
        "success": True,
        "found": True,
        "path": path,
        "length": len(path),
        "message": f"Path found: {len(path)} hop(s) from {from_type}:{from_id} to {to_type}:{to_id}.",
    })
