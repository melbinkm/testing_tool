"""
OpenAPI Tools - openapi_parse, openapi_list_specs, openapi_list_endpoints,
                openapi_get_endpoint, openapi_get_schemas, openapi_remove

Ports the 6 tools from the openapi-mcp TypeScript server to Python,
following the same pattern as tools_scope.py / tools_http.py.
"""
from __future__ import annotations

import json
from typing import Any, Dict, List, Optional

from mcp.types import Tool, TextContent


# ---------------------------------------------------------------------------
# Module-level lazy singleton
# ---------------------------------------------------------------------------
_parser = None


def _get_parser():
    """Lazily initialize and return the OpenAPIParser singleton."""
    global _parser
    if _parser is None:
        from lib.openapi_parser import OpenAPIParser
        _parser = OpenAPIParser()
    return _parser


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _json_content(data: Any) -> List[TextContent]:
    """Return a single TextContent list with *data* serialised as JSON."""
    return [TextContent(type="text", text=json.dumps(data, indent=2, default=str))]


def _error_content(message: str) -> List[TextContent]:
    """Return a single TextContent list wrapping a JSON error object."""
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": message,
    }, indent=2))]


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_openapi_tools() -> List[Tool]:
    """Return the six OpenAPI tools."""
    return [
        Tool(
            name="openapi_parse",
            description=(
                "Parse an OpenAPI 3.x specification from YAML or JSON content. "
                "Extracts all endpoints, parameters, schemas, and authentication requirements "
                "into a queryable structure. Returns parsed spec info and assigns a spec_id. "

                "**When to use:** Phase 2 (Mapping) for API-first applications with documented "
                "OpenAPI/Swagger specifications. Use immediately after discovering API documentation "
                "at /swagger.json, /openapi.yaml, /api-docs, or similar paths. This is the fastest "
                "way to map an entire API surface. "

                "**Dependencies:** Spec content must be valid OpenAPI 3.x YAML or JSON. Can fetch "
                "from URL with http_send() first, or read from file with Read tool. Follow with "
                "openapi_list_endpoints() to see all discovered endpoints. "

                "**Budget impact:** LOW - local parsing only, no requests to target. Parsing "
                "happens in-memory and completes in <1 second for specs up to 10MB. "

                "**Failure modes:** Fails if spec is OpenAPI 2.x (Swagger) - convert to 3.x first "
                "or parse manually. Invalid YAML/JSON returns parse error with line number. Malformed "
                "spec (missing required fields) returns validation error. If spec uses $ref to external "
                "files, those references won't be resolved - flatten spec first. "

                "**Risk level:** SAFE - local parsing only, no network requests or target interaction. "

                "**Returns:** Spec summary with spec_id, version, title, endpoint count, and schema count. "
                "Use spec_id in subsequent openapi_* tool calls. All endpoints auto-added to world model "
                "as wm_endpoints for coverage matrix integration. Schemas stored for parameter validation."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "content": {
                        "type": "string",
                        "description": "The OpenAPI specification content (YAML or JSON)",
                    },
                    "spec_id": {
                        "type": "string",
                        "description": (
                            "Optional custom spec ID. If not provided, "
                            "a UUID will be generated."
                        ),
                    },
                },
                "required": ["content"],
            },
        ),
        Tool(
            name="openapi_list_specs",
            description=(
                "List all loaded OpenAPI specifications currently in memory. Shows spec_id, title, version, "
                "endpoint count, and parse timestamp for each loaded spec. Use to track which API specs have "
                "been parsed and are available for querying. Essential for managing multiple API specifications "
                "during testing. "

                "**When to use:** Phase 2 (Mapping) after calling openapi_parse() to verify spec was loaded "
                "successfully and to retrieve spec_id for subsequent queries. Use when testing multiple APIs to "
                "see all loaded specs at once. Call before openapi_list_endpoints() or openapi_get_endpoint() "
                "to confirm correct spec_id. "

                "**Dependencies:** Requires prior openapi_parse() call(s) to have loaded specs. Returns empty "
                "list if no specs loaded yet (expected state before first parse). Use spec_ids returned here "
                "in openapi_list_endpoints(), openapi_get_endpoint(), openapi_get_schemas(), or openapi_remove(). "

                "**Budget impact:** ZERO - no network requests, pure in-memory query. Returns instantly regardless "
                "of number of loaded specs. Specs stored in memory until openapi_remove() or process restart. "

                "**Failure modes:** None - cannot fail, always returns current list (empty or populated). "
                "Specs persist in memory across tool calls within same MCP server session. "

                "**Risk level:** SAFE - read-only query of in-memory state, no network activity or target "
                "interaction. Shows only what you've loaded via openapi_parse(). "

                "**Returns:** Array of spec summaries with: spec_id (use in other openapi_* tools), title "
                "(from spec info.title), version (OpenAPI version 3.0/3.1), endpoint_count (total paths Ã— methods), "
                "schema_count (components.schemas count), parsed_at timestamp. Use to track loaded specs and "
                "retrieve spec_ids for querying."
            ),
            inputSchema={
                "type": "object",
                "properties": {},
                "required": [],
            },
        ),
        Tool(
            name="openapi_list_endpoints",
            description=(
                "List all endpoints from a loaded OpenAPI specification with optional filtering "
                "by path pattern, HTTP method, tag, or parameter name. Returns endpoint details "
                "including path, method, parameters, authentication requirements, and descriptions. "

                "**When to use:** Phase 2 (Mapping) after openapi_parse() to enumerate all API "
                "endpoints. Use filters to focus on specific endpoint types (e.g., method='POST' "
                "for data modification endpoints, has_parameter='id' for potential IDOR targets). "
                "Essential for systematic API testing coverage. "

                "**Dependencies:** Requires openapi_parse() to have been called first with spec content. "
                "Use spec_id returned by parse. Follow with openapi_get_endpoint() for detailed parameter "
                "schemas, or wm_add_endpoint() to add selected endpoints to world model manually. "

                "**Budget impact:** LOW - local query of parsed spec, no network requests. Returns "
                "instantly even for specs with 1000+ endpoints. "

                "**Failure modes:** Returns empty list if spec_id not found (call openapi_parse first). "
                "Filters use substring matching - be careful with overly broad patterns. Tag filtering "
                "requires tags to be defined in spec (not all specs use tags). "

                "**Risk level:** SAFE - read-only query of parsed specification, no target interaction. "

                "**Returns:** Array of endpoints with: path, method, summary, description, parameters[], "
                "requestBody schema, responses, tags, security requirements, deprecated flag. Use this "
                "to build coverage matrix with coverage_init() or manually select endpoints for testing "
                "with endpoint_execute_plan()."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "spec_id": {
                        "type": "string",
                        "description": "The specification ID to query",
                    },
                    "method": {
                        "type": "string",
                        "description": "Filter by HTTP method (GET, POST, PUT, DELETE, etc.)",
                    },
                    "tag": {
                        "type": "string",
                        "description": "Filter by tag name",
                    },
                    "path_pattern": {
                        "type": "string",
                        "description": "Filter by path pattern (substring match)",
                    },
                    "has_parameter": {
                        "type": "string",
                        "description": "Filter to endpoints with a specific parameter name",
                    },
                    "deprecated": {
                        "type": "boolean",
                        "description": "Filter by deprecation status",
                    },
                },
                "required": ["spec_id"],
            },
        ),
        Tool(
            name="openapi_get_endpoint",
            description=(
                "Get comprehensive details about a specific API endpoint from a loaded OpenAPI specification. "
                "Returns complete parameter schemas (query, path, header, body), request/response models, "
                "security requirements, and validation rules. Essential for understanding endpoint contract "
                "before testing. More detailed than openapi_list_endpoints(). "

                "**When to use:** Phase 2-3 (Mapping/Assessment) when you need full parameter details for a "
                "specific endpoint before testing. Use after openapi_list_endpoints() identifies interesting "
                "endpoints (e.g., POST /admin/users). Essential before endpoint_execute_plan() to understand "
                "parameter types, constraints (min/max, format), and required fields. Use to extract request "
                "body schemas for complex POST/PUT endpoints. "

                "**Dependencies:** Requires openapi_parse() to have loaded the spec first. Get spec_id from "
                "openapi_list_specs() and path/method from openapi_list_endpoints(). Use returned schemas in "
                "endpoint_execute_plan() parameter definitions or fuzz_parameter() for targeted testing. "

                "**Budget impact:** LOW - local query of parsed spec, no network requests. Returns instantly "
                "with full endpoint details including nested schema objects. "

                "**Failure modes:** 'Endpoint not found' if path/method combination doesn't exist in spec "
                "(check openapi_list_endpoints() output). 'Spec not found' if spec_id invalid. Path must "
                "match exactly including path parameters (e.g., '/users/{id}', not '/users/123'). Method "
                "case-sensitive (use uppercase: GET, POST, not get, post). "

                "**Risk level:** SAFE - read-only query of parsed specification, no target interaction. "

                "**Returns:** Complete endpoint definition with: path, method, summary, description, "
                "parameters[] (with schema, location, required, constraints), requestBody (schema, content-type, "
                "required), responses (status codes, schemas, descriptions), security[] (auth requirements), "
                "tags[], deprecated flag. Use schemas to construct valid test requests for endpoint_execute_plan() "
                "or understand validation rules for injection testing."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "spec_id": {
                        "type": "string",
                        "description": "The specification ID",
                    },
                    "path": {
                        "type": "string",
                        "description": "The endpoint path (e.g., /api/users/{id})",
                    },
                    "method": {
                        "type": "string",
                        "description": "The HTTP method (GET, POST, etc.)",
                    },
                },
                "required": ["spec_id", "path", "method"],
            },
        ),
        Tool(
            name="openapi_get_schemas",
            description=(
                "Get reusable component schemas from an OpenAPI specification's components.schemas section. "
                "Returns data model definitions (User, Product, Error schemas) that are referenced by endpoints. "
                "Useful for understanding API data structures, constraints, and relationships before constructing "
                "test payloads. Can retrieve all schemas or a specific schema by name. "

                "**When to use:** Phase 2 (Mapping) when you need to understand complex data models used across "
                "multiple endpoints. Use after openapi_parse() to explore API data structures. Essential for "
                "understanding nested object schemas in POST/PUT request bodies. Use schema_name parameter to "
                "get specific model (e.g., 'UserCreateRequest', 'ProductResponse'), or omit to see all schemas. "

                "**Dependencies:** Requires openapi_parse() to have loaded the spec first. Get spec_id from "
                "openapi_list_specs(). Not all specs use components.schemas (some inline schemas directly in "
                "endpoints). Use openapi_get_endpoint() if you need inline schemas instead. "

                "**Budget impact:** ZERO - local query of parsed spec's schema definitions, no network requests. "
                "Returns instantly even for specs with 100+ schemas. "

                "**Failure modes:** 'Spec not found' if spec_id invalid. Returns empty object {} if spec has "
                "no components.schemas section (valid spec, just no reusable schemas defined). 'Schema not found' "
                "if schema_name specified but doesn't exist (list all schemas first to see available names). "

                "**Risk level:** SAFE - read-only query of parsed specification, no target interaction. "

                "**Returns:** If schema_name specified: single schema object with type, properties, required[], "
                "description. If schema_name omitted: object with all schemas keyed by name (e.g., {User: {...}, "
                "Product: {...}}). Each schema includes: type (object/array/string/etc), properties (nested field "
                "definitions), required[] (mandatory fields), constraints (minLength, maximum, pattern, enum). "
                "Use to understand API data models and construct valid test payloads."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "spec_id": {
                        "type": "string",
                        "description": "The specification ID",
                    },
                    "schema_name": {
                        "type": "string",
                        "description": "Optional schema name to get a specific schema",
                    },
                },
                "required": ["spec_id"],
            },
        ),
        Tool(
            name="openapi_remove",
            description=(
                "Remove a loaded OpenAPI specification from memory. Frees memory and clears the spec's parsed "
                "data including all endpoints, schemas, and metadata. Use to clean up after testing a specific "
                "API or when switching to a different spec. Rarely needed unless testing many large specs. "

                "**When to use:** Phase 2-5 when you're done with a specific API spec and want to free memory, "
                "or when you accidentally parsed the wrong spec and want to remove it. Generally not needed for "
                "normal testing - specs stay in memory harmlessly and don't affect other operations. Use if "
                "testing 10+ large specs to prevent memory buildup. "

                "**Dependencies:** Requires openapi_parse() to have loaded the spec first. Get spec_id from "
                "openapi_list_specs(). CAUTION: Removing a spec makes all subsequent openapi_list_endpoints(), "
                "openapi_get_endpoint(), openapi_get_schemas() calls fail for that spec_id. "

                "**Budget impact:** ZERO - local memory cleanup, no network requests. Completes instantly. "
                "Freed memory immediately available for other operations. "

                "**Failure modes:** 'Spec not found' if spec_id invalid or already removed (silently succeeds "
                "if spec doesn't exist - idempotent). CAUTION: No confirmation prompt - spec removed immediately "
                "and cannot be recovered (must re-parse from source to reload). "

                "**Risk level:** SAFE - local memory cleanup only, no network activity or target interaction. "
                "CAUTION: Permanent action within session - removed spec cannot be recovered without re-parsing. "
                "Consider using openapi_list_specs() first to verify you're removing the correct spec. "

                "**Returns:** Simple confirmation 'Spec {ID} removed successfully'. Spec immediately removed from "
                "openapi_list_specs() output. All references to this spec_id in other tools will fail with 'Spec "
                "not found'. Re-parse with openapi_parse() if you need the spec again."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "spec_id": {
                        "type": "string",
                        "description": "The specification ID to remove",
                    },
                },
                "required": ["spec_id"],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_openapi_tool(
    name: str,
    arguments: dict,
    mcp_service,
) -> List[TextContent]:
    """Dispatch an OpenAPI tool call to the appropriate handler.

    Parameters
    ----------
    name : str
        Tool name (one of the six openapi_* tools).
    arguments : dict
        Arguments supplied by the caller.
    mcp_service :
        The MCP service instance (unused by OpenAPI tools but kept for
        interface parity with other tool modules).
    """
    try:
        if name == "openapi_parse":
            return _handle_parse(arguments)
        elif name == "openapi_list_specs":
            return _handle_list_specs()
        elif name == "openapi_list_endpoints":
            return _handle_list_endpoints(arguments)
        elif name == "openapi_get_endpoint":
            return _handle_get_endpoint(arguments)
        elif name == "openapi_get_schemas":
            return _handle_get_schemas(arguments)
        elif name == "openapi_remove":
            return _handle_remove(arguments)

        return _error_content(f"Unknown OpenAPI tool: {name}")
    except Exception as exc:
        return _error_content(str(exc))


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

def _handle_parse(arguments: dict) -> List[TextContent]:
    """Parse an OpenAPI specification from YAML or JSON content."""
    content = arguments.get("content")
    if not isinstance(content, str) or not content:
        return _error_content("content is required and must be a string")

    spec_id: Optional[str] = None
    if isinstance(arguments.get("spec_id"), str):
        spec_id = arguments["spec_id"]

    try:
        parser = _get_parser()
        parsed = parser.parse(content, spec_id)

        return _json_content({
            "success": True,
            "spec": {
                "spec_id": parsed["specId"],
                "title": parsed["title"],
                "version": parsed["version"],
                "description": parsed.get("description"),
                "servers": parsed["servers"],
                "endpoint_count": len(parsed["endpoints"]),
                "schema_count": len(parsed.get("schemas") or {}),
                "tags": [t["name"] if isinstance(t, dict) else t for t in parsed.get("tags") or []],
                "parsed_at": parsed["parsedAt"],
            },
        })
    except (ValueError, Exception) as exc:
        return _error_content(str(exc))


def _handle_list_specs() -> List[TextContent]:
    """List all loaded OpenAPI specifications."""
    parser = _get_parser()
    specs = parser.list_specs()

    return _json_content({
        "success": True,
        "specs": specs,
        "count": len(specs),
    })


def _handle_list_endpoints(arguments: dict) -> List[TextContent]:
    """List endpoints from a loaded spec with optional filtering."""
    spec_id = arguments.get("spec_id")
    if not isinstance(spec_id, str) or not spec_id:
        return _error_content("spec_id is required")

    parser = _get_parser()
    spec = parser.get_spec(spec_id)
    if not spec:
        return _error_content(f"Specification not found: {spec_id}")

    # Build filter dict
    endpoint_filter: Dict[str, Any] = {}
    if isinstance(arguments.get("method"), str):
        endpoint_filter["method"] = arguments["method"]
    if isinstance(arguments.get("tag"), str):
        endpoint_filter["tag"] = arguments["tag"]
    if isinstance(arguments.get("path_pattern"), str):
        endpoint_filter["pathPattern"] = arguments["path_pattern"]
    if isinstance(arguments.get("has_parameter"), str):
        endpoint_filter["hasParameter"] = arguments["has_parameter"]
    if isinstance(arguments.get("deprecated"), bool):
        endpoint_filter["deprecated"] = arguments["deprecated"]

    endpoints = parser.get_endpoints(spec_id, endpoint_filter if endpoint_filter else None)

    # Return summary view for the list
    summary = [
        {
            "path": ep["path"],
            "method": ep["method"],
            "operationId": ep.get("operationId"),
            "summary": ep.get("summary"),
            "tags": ep.get("tags", []),
            "deprecated": ep.get("deprecated", False),
            "parameterCount": len(ep.get("parameters", [])),
            "hasRequestBody": ep.get("requestBody") is not None,
        }
        for ep in endpoints
    ]

    return _json_content({
        "success": True,
        "spec_id": spec_id,
        "endpoints": summary,
        "count": len(summary),
    })


def _handle_get_endpoint(arguments: dict) -> List[TextContent]:
    """Get detailed information about a specific endpoint."""
    spec_id = arguments.get("spec_id")
    if not isinstance(spec_id, str) or not spec_id:
        return _error_content("spec_id is required")

    path = arguments.get("path")
    if not isinstance(path, str) or not path:
        return _error_content("path is required")

    method = arguments.get("method")
    if not isinstance(method, str) or not method:
        return _error_content("method is required")

    parser = _get_parser()
    endpoint = parser.get_endpoint(spec_id, path, method)

    if not endpoint:
        return _error_content(f"Endpoint not found: {method.upper()} {path}")

    return _json_content({
        "success": True,
        "endpoint": endpoint,
    })


def _handle_get_schemas(arguments: dict) -> List[TextContent]:
    """Get component schemas from a specification."""
    spec_id = arguments.get("spec_id")
    if not isinstance(spec_id, str) or not spec_id:
        return _error_content("spec_id is required")

    parser = _get_parser()
    spec = parser.get_spec(spec_id)
    if not spec:
        return _error_content(f"Specification not found: {spec_id}")

    # If a specific schema is requested, return just that one
    schema_name = arguments.get("schema_name")
    if isinstance(schema_name, str) and schema_name:
        schema = parser.get_schema(spec_id, schema_name)
        if not schema:
            return _error_content(f"Schema not found: {schema_name}")

        return _json_content({
            "success": True,
            "schema_name": schema_name,
            "schema": schema,
        })

    # Otherwise return all schemas
    schemas = parser.get_schemas(spec_id)

    return _json_content({
        "success": True,
        "spec_id": spec_id,
        "schemas": schemas,
        "count": len(schemas),
    })


def _handle_remove(arguments: dict) -> List[TextContent]:
    """Remove a loaded OpenAPI specification."""
    spec_id = arguments.get("spec_id")
    if not isinstance(spec_id, str) or not spec_id:
        return _error_content("spec_id is required")

    parser = _get_parser()
    removed = parser.remove_spec(spec_id)

    return _json_content({
        "success": True,
        "removed": removed,
        "spec_id": spec_id,
    })
