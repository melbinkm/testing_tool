"""
OpenAPI Tools - openapi_parse, openapi_list_specs, openapi_list_endpoints,
                openapi_get_endpoint, openapi_get_schemas, openapi_remove

Ports the 6 tools from the openapi-mcp TypeScript server to Python,
following the same pattern as tools_scope.py / tools_http.py.
"""
from __future__ import annotations

import json
from typing import Any, Dict, List, Optional

from mcp.types import Tool, TextContent


# ---------------------------------------------------------------------------
# Module-level lazy singleton
# ---------------------------------------------------------------------------
_parser = None


def _get_parser():
    """Lazily initialize and return the OpenAPIParser singleton."""
    global _parser
    if _parser is None:
        from lib.openapi_parser import OpenAPIParser
        _parser = OpenAPIParser()
    return _parser


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _json_content(data: Any) -> List[TextContent]:
    """Return a single TextContent list with *data* serialised as JSON."""
    return [TextContent(type="text", text=json.dumps(data, indent=2, default=str))]


def _error_content(message: str) -> List[TextContent]:
    """Return a single TextContent list wrapping a JSON error object."""
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": message,
    }, indent=2))]


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_openapi_tools() -> List[Tool]:
    """Return the six OpenAPI tools."""
    return [
        Tool(
            name="openapi_parse",
            description=(
                "Parse an OpenAPI 3.x specification from YAML or JSON content. "
                "Returns parsed spec info and assigns a spec_id for subsequent queries."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "content": {
                        "type": "string",
                        "description": "The OpenAPI specification content (YAML or JSON)",
                    },
                    "spec_id": {
                        "type": "string",
                        "description": (
                            "Optional custom spec ID. If not provided, "
                            "a UUID will be generated."
                        ),
                    },
                },
                "required": ["content"],
            },
        ),
        Tool(
            name="openapi_list_specs",
            description="List all loaded OpenAPI specifications",
            inputSchema={
                "type": "object",
                "properties": {},
                "required": [],
            },
        ),
        Tool(
            name="openapi_list_endpoints",
            description=(
                "List endpoints from a loaded OpenAPI specification "
                "with optional filtering"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "spec_id": {
                        "type": "string",
                        "description": "The specification ID to query",
                    },
                    "method": {
                        "type": "string",
                        "description": "Filter by HTTP method (GET, POST, PUT, DELETE, etc.)",
                    },
                    "tag": {
                        "type": "string",
                        "description": "Filter by tag name",
                    },
                    "path_pattern": {
                        "type": "string",
                        "description": "Filter by path pattern (substring match)",
                    },
                    "has_parameter": {
                        "type": "string",
                        "description": "Filter to endpoints with a specific parameter name",
                    },
                    "deprecated": {
                        "type": "boolean",
                        "description": "Filter by deprecation status",
                    },
                },
                "required": ["spec_id"],
            },
        ),
        Tool(
            name="openapi_get_endpoint",
            description="Get detailed information about a specific endpoint",
            inputSchema={
                "type": "object",
                "properties": {
                    "spec_id": {
                        "type": "string",
                        "description": "The specification ID",
                    },
                    "path": {
                        "type": "string",
                        "description": "The endpoint path (e.g., /api/users/{id})",
                    },
                    "method": {
                        "type": "string",
                        "description": "The HTTP method (GET, POST, etc.)",
                    },
                },
                "required": ["spec_id", "path", "method"],
            },
        ),
        Tool(
            name="openapi_get_schemas",
            description="Get component schemas from a specification",
            inputSchema={
                "type": "object",
                "properties": {
                    "spec_id": {
                        "type": "string",
                        "description": "The specification ID",
                    },
                    "schema_name": {
                        "type": "string",
                        "description": "Optional schema name to get a specific schema",
                    },
                },
                "required": ["spec_id"],
            },
        ),
        Tool(
            name="openapi_remove",
            description="Remove a loaded OpenAPI specification",
            inputSchema={
                "type": "object",
                "properties": {
                    "spec_id": {
                        "type": "string",
                        "description": "The specification ID to remove",
                    },
                },
                "required": ["spec_id"],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_openapi_tool(
    name: str,
    arguments: dict,
    mcp_service,
) -> List[TextContent]:
    """Dispatch an OpenAPI tool call to the appropriate handler.

    Parameters
    ----------
    name : str
        Tool name (one of the six openapi_* tools).
    arguments : dict
        Arguments supplied by the caller.
    mcp_service :
        The MCP service instance (unused by OpenAPI tools but kept for
        interface parity with other tool modules).
    """
    try:
        if name == "openapi_parse":
            return _handle_parse(arguments)
        elif name == "openapi_list_specs":
            return _handle_list_specs()
        elif name == "openapi_list_endpoints":
            return _handle_list_endpoints(arguments)
        elif name == "openapi_get_endpoint":
            return _handle_get_endpoint(arguments)
        elif name == "openapi_get_schemas":
            return _handle_get_schemas(arguments)
        elif name == "openapi_remove":
            return _handle_remove(arguments)

        return _error_content(f"Unknown OpenAPI tool: {name}")
    except Exception as exc:
        return _error_content(str(exc))


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

def _handle_parse(arguments: dict) -> List[TextContent]:
    """Parse an OpenAPI specification from YAML or JSON content."""
    content = arguments.get("content")
    if not isinstance(content, str) or not content:
        return _error_content("content is required and must be a string")

    spec_id: Optional[str] = None
    if isinstance(arguments.get("spec_id"), str):
        spec_id = arguments["spec_id"]

    try:
        parser = _get_parser()
        parsed = parser.parse(content, spec_id)

        return _json_content({
            "success": True,
            "spec": {
                "spec_id": parsed["specId"],
                "title": parsed["title"],
                "version": parsed["version"],
                "description": parsed.get("description"),
                "servers": parsed["servers"],
                "endpoint_count": len(parsed["endpoints"]),
                "schema_count": len(parsed.get("schemas") or {}),
                "tags": [t["name"] if isinstance(t, dict) else t for t in parsed.get("tags") or []],
                "parsed_at": parsed["parsedAt"],
            },
        })
    except (ValueError, Exception) as exc:
        return _error_content(str(exc))


def _handle_list_specs() -> List[TextContent]:
    """List all loaded OpenAPI specifications."""
    parser = _get_parser()
    specs = parser.list_specs()

    return _json_content({
        "success": True,
        "specs": specs,
        "count": len(specs),
    })


def _handle_list_endpoints(arguments: dict) -> List[TextContent]:
    """List endpoints from a loaded spec with optional filtering."""
    spec_id = arguments.get("spec_id")
    if not isinstance(spec_id, str) or not spec_id:
        return _error_content("spec_id is required")

    parser = _get_parser()
    spec = parser.get_spec(spec_id)
    if not spec:
        return _error_content(f"Specification not found: {spec_id}")

    # Build filter dict
    endpoint_filter: Dict[str, Any] = {}
    if isinstance(arguments.get("method"), str):
        endpoint_filter["method"] = arguments["method"]
    if isinstance(arguments.get("tag"), str):
        endpoint_filter["tag"] = arguments["tag"]
    if isinstance(arguments.get("path_pattern"), str):
        endpoint_filter["pathPattern"] = arguments["path_pattern"]
    if isinstance(arguments.get("has_parameter"), str):
        endpoint_filter["hasParameter"] = arguments["has_parameter"]
    if isinstance(arguments.get("deprecated"), bool):
        endpoint_filter["deprecated"] = arguments["deprecated"]

    endpoints = parser.get_endpoints(spec_id, endpoint_filter if endpoint_filter else None)

    # Return summary view for the list
    summary = [
        {
            "path": ep["path"],
            "method": ep["method"],
            "operationId": ep.get("operationId"),
            "summary": ep.get("summary"),
            "tags": ep.get("tags", []),
            "deprecated": ep.get("deprecated", False),
            "parameterCount": len(ep.get("parameters", [])),
            "hasRequestBody": ep.get("requestBody") is not None,
        }
        for ep in endpoints
    ]

    return _json_content({
        "success": True,
        "spec_id": spec_id,
        "endpoints": summary,
        "count": len(summary),
    })


def _handle_get_endpoint(arguments: dict) -> List[TextContent]:
    """Get detailed information about a specific endpoint."""
    spec_id = arguments.get("spec_id")
    if not isinstance(spec_id, str) or not spec_id:
        return _error_content("spec_id is required")

    path = arguments.get("path")
    if not isinstance(path, str) or not path:
        return _error_content("path is required")

    method = arguments.get("method")
    if not isinstance(method, str) or not method:
        return _error_content("method is required")

    parser = _get_parser()
    endpoint = parser.get_endpoint(spec_id, path, method)

    if not endpoint:
        return _error_content(f"Endpoint not found: {method.upper()} {path}")

    return _json_content({
        "success": True,
        "endpoint": endpoint,
    })


def _handle_get_schemas(arguments: dict) -> List[TextContent]:
    """Get component schemas from a specification."""
    spec_id = arguments.get("spec_id")
    if not isinstance(spec_id, str) or not spec_id:
        return _error_content("spec_id is required")

    parser = _get_parser()
    spec = parser.get_spec(spec_id)
    if not spec:
        return _error_content(f"Specification not found: {spec_id}")

    # If a specific schema is requested, return just that one
    schema_name = arguments.get("schema_name")
    if isinstance(schema_name, str) and schema_name:
        schema = parser.get_schema(spec_id, schema_name)
        if not schema:
            return _error_content(f"Schema not found: {schema_name}")

        return _json_content({
            "success": True,
            "schema_name": schema_name,
            "schema": schema,
        })

    # Otherwise return all schemas
    schemas = parser.get_schemas(spec_id)

    return _json_content({
        "success": True,
        "spec_id": spec_id,
        "schemas": schemas,
        "count": len(schemas),
    })


def _handle_remove(arguments: dict) -> List[TextContent]:
    """Remove a loaded OpenAPI specification."""
    spec_id = arguments.get("spec_id")
    if not isinstance(spec_id, str) or not spec_id:
        return _error_content("spec_id is required")

    parser = _get_parser()
    removed = parser.remove_spec(spec_id)

    return _json_content({
        "success": True,
        "removed": removed,
        "spec_id": spec_id,
    })
