"""
Fuzzer Tools - fuzz_endpoint, fuzz_parameter, fuzz_list_payloads
Ported from fuzzer-mcp TypeScript server to Python.
"""
import json
import logging
import os
from typing import List
from urllib.parse import urlparse

from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")

# Lazy-initialized singletons
_schema_fuzzer = None
_payload_generator = None

# Configuration from environment variables
MAX_PAYLOADS = int(os.environ.get("MAX_PAYLOADS", "100"))
MAX_REQUESTS_PER_ENDPOINT = int(os.environ.get("MAX_REQUESTS_PER_ENDPOINT", "500"))
RATE_LIMIT = int(os.environ.get("RATE_LIMIT", "10"))

VALID_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE"]
VALID_PAYLOAD_TYPES = ["boundary", "type_confusion", "injection", "format", "overflow", "sqli_db"]
VALID_PARAMETER_LOCATIONS = ["query", "path", "header", "body", "cookie"]


def _get_schema_fuzzer():
    """Lazily initialize and return the SchemaFuzzer singleton."""
    global _schema_fuzzer
    if _schema_fuzzer is None:
        from lib.schema_fuzzer import SchemaFuzzer
        _schema_fuzzer = SchemaFuzzer()
    return _schema_fuzzer


def _get_payload_generator():
    """Lazily initialize and return the PayloadGenerator singleton."""
    global _payload_generator
    if _payload_generator is None:
        from lib.payload_generator import PayloadGenerator
        _payload_generator = PayloadGenerator()
    return _payload_generator


def get_fuzzer_tools() -> List[Tool]:
    """Get fuzzer tool definitions."""
    return [
        Tool(
            name="fuzz_endpoint",
            description="Fuzz all parameters of an API endpoint with various payload types. HIGH RISK.",
            inputSchema={
                "type": "object",
                "properties": {
                    "endpoint": {
                        "type": "string",
                        "description": "The API endpoint URL to fuzz"
                    },
                    "method": {
                        "type": "string",
                        "enum": VALID_METHODS,
                        "description": "HTTP method to use"
                    },
                    "parameters": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "name": {
                                    "type": "string",
                                    "description": "Parameter name"
                                },
                                "location": {
                                    "type": "string",
                                    "description": "Parameter location (query, path, header, body, cookie)"
                                },
                                "type": {
                                    "type": "string",
                                    "description": "Parameter data type"
                                },
                                "format": {
                                    "type": "string",
                                    "description": "Parameter format (e.g., date-time, email, uuid)"
                                },
                                "required": {
                                    "type": "boolean",
                                    "description": "Whether the parameter is required"
                                },
                                "minimum": {
                                    "type": "number",
                                    "description": "Minimum value for numeric parameters"
                                },
                                "maximum": {
                                    "type": "number",
                                    "description": "Maximum value for numeric parameters"
                                },
                                "minLength": {
                                    "type": "integer",
                                    "description": "Minimum length for string parameters"
                                },
                                "maxLength": {
                                    "type": "integer",
                                    "description": "Maximum length for string parameters"
                                }
                            }
                        },
                        "description": "List of parameters to fuzz"
                    },
                    "payload_types": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": VALID_PAYLOAD_TYPES
                        },
                        "description": "Types of fuzz payloads to use"
                    },
                    "headers": {
                        "type": "object",
                        "description": "Additional HTTP headers to include in requests"
                    },
                    "timeout": {
                        "type": "number",
                        "description": "Request timeout in seconds"
                    }
                },
                "required": ["endpoint", "method"]
            }
        ),
        Tool(
            name="fuzz_parameter",
            description="Fuzz a single parameter with various payload types. HIGH RISK.",
            inputSchema={
                "type": "object",
                "properties": {
                    "endpoint": {
                        "type": "string",
                        "description": "The API endpoint URL to fuzz"
                    },
                    "method": {
                        "type": "string",
                        "enum": VALID_METHODS,
                        "description": "HTTP method to use"
                    },
                    "parameter": {
                        "type": "object",
                        "properties": {
                            "name": {
                                "type": "string",
                                "description": "Parameter name"
                            },
                            "location": {
                                "type": "string",
                                "enum": VALID_PARAMETER_LOCATIONS,
                                "description": "Parameter location"
                            },
                            "type": {
                                "type": "string",
                                "description": "Parameter data type"
                            },
                            "format": {
                                "type": "string",
                                "description": "Parameter format (e.g., date-time, email, uuid)"
                            },
                            "required": {
                                "type": "boolean",
                                "description": "Whether the parameter is required"
                            },
                            "minimum": {
                                "type": "number",
                                "description": "Minimum value for numeric parameters"
                            },
                            "maximum": {
                                "type": "number",
                                "description": "Maximum value for numeric parameters"
                            },
                            "minLength": {
                                "type": "integer",
                                "description": "Minimum length for string parameters"
                            },
                            "maxLength": {
                                "type": "integer",
                                "description": "Maximum length for string parameters"
                            }
                        },
                        "description": "The parameter definition to fuzz"
                    },
                    "payload_types": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": VALID_PAYLOAD_TYPES
                        },
                        "description": "Types of fuzz payloads to use"
                    },
                    "max_payloads": {
                        "type": "number",
                        "description": "Maximum number of payloads to generate"
                    },
                    "headers": {
                        "type": "object",
                        "description": "Additional HTTP headers to include in requests"
                    },
                    "db_type": {
                        "type": "string",
                        "enum": ["mysql", "postgresql", "mssql", "oracle", "sqlite", "generic"],
                        "description": "Database type for sqli_db payloads (default: generic)"
                    },
                    "technique": {
                        "type": "string",
                        "enum": ["union", "error_based", "blind_boolean", "blind_time", "stacked"],
                        "description": "SQL injection technique filter for sqli_db payloads"
                    }
                },
                "required": ["endpoint", "method", "parameter"]
            }
        ),
        Tool(
            name="fuzz_list_payloads",
            description="List available fuzz payload types and examples. LOW RISK - read-only.",
            inputSchema={
                "type": "object",
                "properties": {
                    "type": {
                        "type": "string",
                        "enum": VALID_PAYLOAD_TYPES,
                        "description": "Filter by specific payload type (optional, lists all if not specified)"
                    }
                }
            }
        ),
    ]


async def handle_fuzzer_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route fuzzer tool calls to the appropriate handler."""
    if name == "fuzz_endpoint":
        return await _handle_fuzz_endpoint(arguments, mcp_service)
    elif name == "fuzz_parameter":
        return await _handle_fuzz_parameter(arguments, mcp_service)
    elif name == "fuzz_list_payloads":
        return await _handle_fuzz_list_payloads(arguments, mcp_service)
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": f"Unknown fuzzer tool: {name}"
    }))]


def _validate_endpoint_url(endpoint: str) -> str | None:
    """Validate that the endpoint is a well-formed URL. Returns error message or None."""
    try:
        parsed = urlparse(endpoint)
        if not parsed.scheme or not parsed.netloc:
            return f"Invalid endpoint URL: {endpoint}. Must include scheme (http/https) and host."
        if parsed.scheme not in ("http", "https"):
            return f"Invalid URL scheme: {parsed.scheme}. Must be http or https."
        return None
    except Exception as e:
        return f"Failed to parse endpoint URL: {str(e)}"


def _validate_method(method: str) -> str | None:
    """Validate HTTP method. Returns error message or None."""
    if method not in VALID_METHODS:
        return f"Invalid HTTP method: {method}. Must be one of: {', '.join(VALID_METHODS)}"
    return None


def _error_response(error_msg: str) -> List[TextContent]:
    """Return a standardized error response as JSON."""
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": error_msg
    }))]


async def _handle_fuzz_endpoint(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle fuzz_endpoint - Fuzz all parameters of an API endpoint."""
    endpoint = arguments.get("endpoint", "")
    method = arguments.get("method", "")
    parameters = arguments.get("parameters", [])
    payload_types = arguments.get("payload_types", VALID_PAYLOAD_TYPES)
    headers = arguments.get("headers", {})
    timeout = arguments.get("timeout")

    # Validate endpoint URL
    url_error = _validate_endpoint_url(endpoint)
    if url_error:
        return _error_response(url_error)

    # Validate HTTP method
    method_error = _validate_method(method)
    if method_error:
        return _error_response(method_error)

    # Validate payload types
    for pt in payload_types:
        if pt not in VALID_PAYLOAD_TYPES:
            return _error_response(
                f"Invalid payload type: {pt}. Must be one of: {', '.join(VALID_PAYLOAD_TYPES)}"
            )

    # Parse and validate parameters
    parsed_parameters = []
    for param in parameters:
        if not isinstance(param, dict):
            return _error_response("Each parameter must be an object.")
        parsed_parameters.append({
            "name": param.get("name", ""),
            "location": param.get("location", "query"),
            "type": param.get("type", "string"),
            "format": param.get("format"),
            "required": param.get("required", False),
            "minimum": param.get("minimum"),
            "maximum": param.get("maximum"),
            "minLength": param.get("minLength"),
            "maxLength": param.get("maxLength"),
        })

    try:
        schema_fuzzer = _get_schema_fuzzer()
        result = schema_fuzzer.fuzz_endpoint(
            endpoint=endpoint,
            method=method,
            parameters=parsed_parameters,
            payload_types=payload_types,
            headers=headers,
            timeout=timeout,
            max_requests=MAX_REQUESTS_PER_ENDPOINT,
            rate_limit=RATE_LIMIT,
            mock_mode=True,
        )

        # Auto-save anomalies as observation cards
        await _autosave_fuzz_anomalies(result, endpoint, mcp_service)

        # Auto-capture full fuzz results to knowledge store
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="fuzz_endpoint", category="fuzz_result",
            title=f"Fuzz {method} {endpoint}",
            content=json.dumps(result, default=str),
            target=endpoint,
            tags=["fuzzer"],
        )

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "endpoint": endpoint,
            "method": method,
            "parameters_count": len(parsed_parameters),
            "payload_types": payload_types,
            "result": result
        }, default=str))]

    except Exception as e:
        return _error_response(f"Fuzzing failed for endpoint {endpoint}: {str(e)}")


async def _handle_fuzz_parameter(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle fuzz_parameter - Fuzz a single parameter."""
    endpoint = arguments.get("endpoint", "")
    method = arguments.get("method", "")
    parameter = arguments.get("parameter", {})
    payload_types = arguments.get("payload_types", VALID_PAYLOAD_TYPES)
    max_payloads = arguments.get("max_payloads", MAX_PAYLOADS)
    headers = arguments.get("headers", {})

    # Validate endpoint URL
    url_error = _validate_endpoint_url(endpoint)
    if url_error:
        return _error_response(url_error)

    # Validate HTTP method
    method_error = _validate_method(method)
    if method_error:
        return _error_response(method_error)

    # Validate parameter object
    if not isinstance(parameter, dict) or not parameter.get("name"):
        return _error_response("Parameter must be an object with at least a 'name' field.")

    # Validate parameter location if provided
    param_location = parameter.get("location", "query")
    if param_location not in VALID_PARAMETER_LOCATIONS:
        return _error_response(
            f"Invalid parameter location: {param_location}. "
            f"Must be one of: {', '.join(VALID_PARAMETER_LOCATIONS)}"
        )

    # Validate payload types
    for pt in payload_types:
        if pt not in VALID_PAYLOAD_TYPES:
            return _error_response(
                f"Invalid payload type: {pt}. Must be one of: {', '.join(VALID_PAYLOAD_TYPES)}"
            )

    # Cap max_payloads to configured limit
    if max_payloads > MAX_PAYLOADS:
        max_payloads = MAX_PAYLOADS

    parsed_parameter = {
        "name": parameter.get("name", ""),
        "location": param_location,
        "type": parameter.get("type", "string"),
        "format": parameter.get("format"),
        "required": parameter.get("required", False),
        "minimum": parameter.get("minimum"),
        "maximum": parameter.get("maximum"),
        "minLength": parameter.get("minLength"),
        "maxLength": parameter.get("maxLength"),
    }

    try:
        schema_fuzzer = _get_schema_fuzzer()
        result = schema_fuzzer.fuzz_parameter(
            endpoint=endpoint,
            method=method,
            parameter=parsed_parameter,
            payload_types=payload_types,
            max_payloads=max_payloads,
            headers=headers,
            rate_limit=RATE_LIMIT,
            mock_mode=True,
        )

        # Auto-save anomalies as observation cards
        await _autosave_fuzz_anomalies(result, endpoint, mcp_service)

        # Auto-capture full fuzz results to knowledge store
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="fuzz_parameter", category="fuzz_result",
            title=f"Fuzz param {parsed_parameter['name']} on {method} {endpoint}",
            content=json.dumps(result, default=str),
            target=endpoint,
            tags=["fuzzer"],
        )

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "endpoint": endpoint,
            "method": method,
            "parameter": parsed_parameter["name"],
            "payload_types": payload_types,
            "max_payloads": max_payloads,
            "result": result
        }, default=str))]

    except Exception as e:
        return _error_response(
            f"Fuzzing failed for parameter '{parameter.get('name', 'unknown')}' "
            f"on {endpoint}: {str(e)}"
        )


async def _handle_fuzz_list_payloads(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle fuzz_list_payloads - List available payload types and examples."""
    filter_type = arguments.get("type")

    # Validate filter type if provided
    if filter_type and filter_type not in VALID_PAYLOAD_TYPES:
        return _error_response(
            f"Invalid payload type: {filter_type}. "
            f"Must be one of: {', '.join(VALID_PAYLOAD_TYPES)}"
        )

    try:
        payload_generator = _get_payload_generator()

        # Risk levels for each payload type
        risk_levels = {
            "boundary": "MEDIUM",
            "type_confusion": "MEDIUM",
            "injection": "HIGH",
            "format": "LOW",
            "overflow": "HIGH",
            "sqli_db": "HIGH",
        }

        payload_types_info = []

        types_to_list = [filter_type] if filter_type else VALID_PAYLOAD_TYPES

        for pt in types_to_list:
            description = payload_generator.get_type_description(pt)
            examples = payload_generator.get_type_examples(pt)
            info = {
                "type": pt,
                "description": description,
                "risk_level": risk_levels.get(pt, "UNKNOWN"),
                "examples": examples,
            }
            # Add DB-specific metadata for sqli_db
            if pt == "sqli_db":
                try:
                    from lib.sql_payloads import get_all_db_types, get_all_techniques
                    info["db_types"] = get_all_db_types()
                    info["techniques"] = get_all_techniques()
                except ImportError:
                    pass
            payload_types_info.append(info)

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "payload_types": payload_types_info,
            "total_types": len(payload_types_info),
        }, default=str))]

    except Exception as e:
        return _error_response(f"Failed to list payload types: {str(e)}")


async def _autosave_fuzz_anomalies(result, endpoint: str, mcp_service) -> None:
    """Extract anomalies from fuzzing results and save as observation cards."""
    if not mcp_service:
        return

    try:
        anomalies = result.get("anomalies", [])
        if not anomalies and isinstance(result, dict):
            # Some fuzzer results nest anomalies under "results"
            for r in result.get("results", []):
                if isinstance(r, dict):
                    anomalies.extend(r.get("anomalies", []))

        for anomaly in anomalies:
            if not isinstance(anomaly, dict):
                continue
            anomaly_type = anomaly.get("type", "unknown")
            await mcp_service.safe_add_card(
                card_type="observation",
                title=f"Fuzz anomaly: {anomaly_type} on {endpoint}",
                severity="MEDIUM",
                target_service=endpoint,
                notes=json.dumps(anomaly, default=str)[:2000],
                context="Source: fuzzer",
            )
    except Exception as e:
        logger.warning(f"_autosave_fuzz_anomalies failed: {e}")
