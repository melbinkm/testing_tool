"""
Fuzzer Tools - fuzz_endpoint, fuzz_parameter, fuzz_list_payloads
Ported from fuzzer-mcp TypeScript server to Python.
"""
import json
import logging
import os
from typing import List
from urllib.parse import urlparse

from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")


async def _validate_scope(target: str, mcp_service) -> str | None:
    """Check target against per-assessment scope. Returns error message or None."""
    if not mcp_service.current_assessment_id:
        return None  # No assessment selected, skip validation
    if not mcp_service.scope_provider:
        return None  # Scope provider not initialized, skip validation

    try:
        validator = await mcp_service.scope_provider.get_validator(
            mcp_service.current_assessment_id
        )
        if validator is None:
            return None  # No scope configured, skip validation
        result = validator.validate_target(target)
        if not result.valid:
            return f"Target out of scope: {target} — {result.reason}"
    except Exception as e:
        logger.warning(f"Scope validation failed: {e}")
        pass
    return None


# Lazy-initialized singletons
_schema_fuzzer = None
_payload_generator = None

# Configuration from environment variables
MAX_PAYLOADS = int(os.environ.get("MAX_PAYLOADS", "100"))
MAX_REQUESTS_PER_ENDPOINT = int(os.environ.get("MAX_REQUESTS_PER_ENDPOINT", "500"))
RATE_LIMIT = int(os.environ.get("RATE_LIMIT", "10"))

VALID_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE"]
VALID_PAYLOAD_TYPES = ["boundary", "type_confusion", "injection", "format", "overflow", "sqli_db"]
VALID_PARAMETER_LOCATIONS = ["query", "path", "header", "body", "cookie"]


def _get_schema_fuzzer():
    """Lazily initialize and return the SchemaFuzzer singleton."""
    global _schema_fuzzer
    if _schema_fuzzer is None:
        from lib.schema_fuzzer import SchemaFuzzer
        _schema_fuzzer = SchemaFuzzer()
    return _schema_fuzzer


def _get_payload_generator():
    """Lazily initialize and return the PayloadGenerator singleton."""
    global _payload_generator
    if _payload_generator is None:
        from lib.payload_generator import PayloadGenerator
        _payload_generator = PayloadGenerator()
    return _payload_generator


def get_fuzzer_tools() -> List[Tool]:
    """Get fuzzer tool definitions."""
    return [
        Tool(
            name="fuzz_endpoint",
            description=(
                "Fuzz all parameters of an API endpoint simultaneously with comprehensive payload sets (boundary, "
                "type confusion, injection, format strings, buffer overflow, SQL injection). Tests entire endpoint "
                "attack surface in one operation. Generates up to 500 requests per endpoint. HIGH RISK - sends "
                "actual attack payloads. Alternative to fuzz_parameter() for broad vulnerability scanning. "

                "**When to use:** Phase 3 (Assessment) when you have complete parameter definitions from "
                "openapi_parse() and want comprehensive testing of all parameters at once. Prefer fuzz_parameter() "
                "for focused testing of specific suspicious parameters. Use this for API endpoints with multiple "
                "parameters (>3) where you want to test them all efficiently. Good for initial broad scanning "
                "before focusing on interesting parameters. "

                "**Dependencies:** Requires scope_validate_target() and scope_check_budget() first (expensive "
                "operation). Needs parameter definitions - get from openapi_list_endpoints() or endpoint_probe(). "
                "Use fuzz_list_payloads() to understand payload categories before selecting payload_types. Follow "
                "with validate_repro() for any suspicious responses detected. "

                "**Budget impact:** VERY HIGH - 200-500 requests per endpoint depending on parameter count and "
                "payload_types selected. Formula: ~50-100 payloads × number of parameters. 3 parameters with all "
                "payload types = ~300 requests. 5 parameters = ~500 requests. Respect MAX_REQUESTS_PER_ENDPOINT "
                "limit (default 500). Use payload_types parameter to limit scope (e.g., only ['sqli_db', 'injection']). "

                "**Failure modes:** 'Target out of scope' if scope_validate_target() not called first. 'Budget "
                "exceeded' if too many parameters or insufficient budget remaining. WAF may block aggressive "
                "payloads (403/429) - returns partial results. Parameter location misidentification common - "
                "verify with endpoint_probe() first. Time-based tests may timeout - increase timeout parameter. "

                "**Risk level:** HIGH RISK - Sends actual attack payloads across all parameters simultaneously. "
                "May: trigger application errors, corrupt data (successful SQLi), cause DoS (resource-intensive "
                "payloads), trigger IDS/WAF alerts, get IP banned. More aggressive than fuzz_parameter() due to "
                "volume. Only use on authorized targets with permission for comprehensive attack testing. "

                "**Returns:** Comprehensive test results with: total requests sent, parameters tested, anomalies "
                "detected (suspicious responses), result summary by parameter (vulnerable/passed/error), detailed "
                "results array. Automatically saves anomalies as observation cards and stores full results in "
                "knowledge store (wm_recall to retrieve later). Use suspicious responses to guide fuzz_parameter() "
                "focused testing."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "endpoint": {
                        "type": "string",
                        "description": "The API endpoint URL to fuzz"
                    },
                    "method": {
                        "type": "string",
                        "enum": VALID_METHODS,
                        "description": "HTTP method to use"
                    },
                    "parameters": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "name": {
                                    "type": "string",
                                    "description": "Parameter name"
                                },
                                "location": {
                                    "type": "string",
                                    "description": "Parameter location (query, path, header, body, cookie)"
                                },
                                "type": {
                                    "type": "string",
                                    "description": "Parameter data type"
                                },
                                "format": {
                                    "type": "string",
                                    "description": "Parameter format (e.g., date-time, email, uuid)"
                                },
                                "required": {
                                    "type": "boolean",
                                    "description": "Whether the parameter is required"
                                },
                                "minimum": {
                                    "type": "number",
                                    "description": "Minimum value for numeric parameters"
                                },
                                "maximum": {
                                    "type": "number",
                                    "description": "Maximum value for numeric parameters"
                                },
                                "minLength": {
                                    "type": "integer",
                                    "description": "Minimum length for string parameters"
                                },
                                "maxLength": {
                                    "type": "integer",
                                    "description": "Maximum length for string parameters"
                                }
                            }
                        },
                        "description": "List of parameters to fuzz"
                    },
                    "payload_types": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": VALID_PAYLOAD_TYPES
                        },
                        "description": "Types of fuzz payloads to use"
                    },
                    "headers": {
                        "type": "object",
                        "description": "Additional HTTP headers to include in requests"
                    },
                    "timeout": {
                        "type": "number",
                        "description": "Request timeout in seconds"
                    }
                },
                "required": ["endpoint", "method"]
            }
        ),
        Tool(
            name="fuzz_parameter",
            description=(
                "Fuzz a single API parameter with targeted injection payloads. Tests for SQL injection, "
                "XSS, command injection, path traversal, format string bugs, type confusion, and boundary "
                "conditions. HIGH RISK - sends potentially malicious payloads. "

                "**When to use:** Phase 3 (Assessment) after identifying parameters via openapi_parse(), "
                "endpoint_probe(), or browser_discover_forms(). Focus on parameters that handle user input, "
                "especially those in WHERE clauses, eval(), exec(), file operations, or command execution. "
                "Use payload_types=['sqli_db'] with db_type for targeted SQL injection testing. "

                "**Dependencies:** Requires scope_validate_target() and scope_check_budget() first. Use "
                "fuzz_list_payloads() to see available payload categories. Follow with validate_repro() "
                "if suspicious responses detected. For database-specific SQLi, combine with tech_detection() "
                "to determine db_type (mysql, postgresql, mssql, oracle, sqlite). "

                "**Budget impact:** HIGH - 200-500 requests per parameter depending on payload selection. "
                "sqli_db payloads = ~100-200 requests. boundary + type_confusion = ~50 requests. All payload "
                "types = ~500 requests. Multiply by number of parameters tested. Use max_payloads parameter "
                "to limit request count (default: 100 per vuln class). "

                "**Failure modes:** WAF may block malicious payloads (403/429) - try evasion techniques or "
                "reduce payload aggressiveness. False positives common with error-based detection - use "
                "validate_negative_control() to confirm. Parameter location misidentification (query vs body) "
                "causes test failures - verify with endpoint_probe() first. Time-based SQLi may timeout - "
                "increase timeout parameter. "

                "**Risk level:** HIGH RISK - Sends actual attack payloads that may: trigger application errors, "
                "corrupt data (if SQLi successful), cause denial of service (resource-intensive payloads), "
                "trigger IDS alerts, get IP banned. Some payloads are destructive (DROP, DELETE). Only use "
                "on targets where you have explicit authorization to test with malicious input. "

                "**Returns:** Test results array with: payload used, response status/timing/length, error "
                "messages detected, anomalies (diff from baseline), classification (passed/vulnerable/error). "
                "Suspicious responses flagged for manual review. Use response timing differences to detect "
                "blind SQL injection. Use error messages to identify vulnerable injection points."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "endpoint": {
                        "type": "string",
                        "description": "The API endpoint URL to fuzz"
                    },
                    "method": {
                        "type": "string",
                        "enum": VALID_METHODS,
                        "description": "HTTP method to use"
                    },
                    "parameter": {
                        "type": "object",
                        "properties": {
                            "name": {
                                "type": "string",
                                "description": "Parameter name"
                            },
                            "location": {
                                "type": "string",
                                "enum": VALID_PARAMETER_LOCATIONS,
                                "description": "Parameter location"
                            },
                            "type": {
                                "type": "string",
                                "description": "Parameter data type"
                            },
                            "format": {
                                "type": "string",
                                "description": "Parameter format (e.g., date-time, email, uuid)"
                            },
                            "required": {
                                "type": "boolean",
                                "description": "Whether the parameter is required"
                            },
                            "minimum": {
                                "type": "number",
                                "description": "Minimum value for numeric parameters"
                            },
                            "maximum": {
                                "type": "number",
                                "description": "Maximum value for numeric parameters"
                            },
                            "minLength": {
                                "type": "integer",
                                "description": "Minimum length for string parameters"
                            },
                            "maxLength": {
                                "type": "integer",
                                "description": "Maximum length for string parameters"
                            }
                        },
                        "description": "The parameter definition to fuzz"
                    },
                    "payload_types": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": VALID_PAYLOAD_TYPES
                        },
                        "description": "Types of fuzz payloads to use"
                    },
                    "max_payloads": {
                        "type": "number",
                        "description": "Maximum number of payloads to generate"
                    },
                    "headers": {
                        "type": "object",
                        "description": "Additional HTTP headers to include in requests"
                    },
                    "db_type": {
                        "type": "string",
                        "enum": ["mysql", "postgresql", "mssql", "oracle", "sqlite", "generic"],
                        "description": "Database type for sqli_db payloads (default: generic)"
                    },
                    "technique": {
                        "type": "string",
                        "enum": ["union", "error_based", "blind_boolean", "blind_time", "stacked"],
                        "description": "SQL injection technique filter for sqli_db payloads"
                    }
                },
                "required": ["endpoint", "method", "parameter"]
            }
        ),
        Tool(
            name="fuzz_list_payloads",
            description=(
                "List all available fuzz payload types with descriptions, example payloads, and usage guidance. "
                "Shows the 6 payload categories supported by fuzz_parameter() and fuzz_endpoint(): boundary, "
                "type_confusion, injection, format, overflow, sqli_db. Includes sample payloads for understanding "
                "what will be sent to the target. Essential reference for choosing appropriate payload_types. "

                "**When to use:** Phase 3 (Assessment) before calling fuzz_parameter() or fuzz_endpoint() to "
                "understand available payload categories and select appropriate ones for your target. Use to: "
                "see what SQLi payloads look like (sqli_db category), understand boundary testing (min/max values, "
                "empty strings, null bytes), review injection payloads (command injection, LDAP, XML, template "
                "injection). Call without filter to see all categories, or filter by type for specific category details. "

                "**Dependencies:** NONE - standalone read-only tool. Use before fuzz_parameter() or fuzz_endpoint() "
                "to plan payload selection. Helps you choose payload_types based on parameter context (e.g., if "
                "parameter goes to database query, focus on sqli_db; if parameter used in system call, focus on "
                "injection). "

                "**Budget impact:** ZERO - no network requests, no target interaction. Queries internal payload "
                "library definitions. Completes <10ms. "

                "**Failure modes:** None - cannot fail (returns payload library content). Invalid type filter "
                "returns empty array (not an error, just no match). All 6 payload types always available (boundary, "
                "type_confusion, injection, format, overflow, sqli_db). "

                "**Risk level:** SAFE - pure documentation tool, no network activity or target interaction. Only "
                "reads internal payload library definitions. Does not generate or send any payloads. "

                "**Returns:** JSON array of payload type definitions with: type name, description, example count, "
                "sample payloads (first 5-10 examples), target vulnerability classes. Example: {type: 'sqli_db', "
                "description: 'SQL injection payloads for database testing', techniques: ['union', 'error_based', "
                "'blind_boolean', 'blind_time', 'stacked'], example_count: 150, samples: [\"' OR '1'='1\", "
                "\"1' UNION SELECT NULL--\", ...]}. Use to understand payload strategy before testing."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "type": {
                        "type": "string",
                        "enum": VALID_PAYLOAD_TYPES,
                        "description": "Filter by specific payload type (optional, lists all if not specified)"
                    }
                }
            }
        ),
    ]


async def handle_fuzzer_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route fuzzer tool calls to the appropriate handler."""
    if name == "fuzz_endpoint":
        return await _handle_fuzz_endpoint(arguments, mcp_service)
    elif name == "fuzz_parameter":
        return await _handle_fuzz_parameter(arguments, mcp_service)
    elif name == "fuzz_list_payloads":
        return await _handle_fuzz_list_payloads(arguments, mcp_service)
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": f"Unknown fuzzer tool: {name}"
    }))]


def _validate_endpoint_url(endpoint: str) -> str | None:
    """Validate that the endpoint is a well-formed URL. Returns error message or None."""
    try:
        parsed = urlparse(endpoint)
        if not parsed.scheme or not parsed.netloc:
            return f"Invalid endpoint URL: {endpoint}. Must include scheme (http/https) and host."
        if parsed.scheme not in ("http", "https"):
            return f"Invalid URL scheme: {parsed.scheme}. Must be http or https."
        return None
    except Exception as e:
        return f"Failed to parse endpoint URL: {str(e)}"


def _validate_method(method: str) -> str | None:
    """Validate HTTP method. Returns error message or None."""
    if method not in VALID_METHODS:
        return f"Invalid HTTP method: {method}. Must be one of: {', '.join(VALID_METHODS)}"
    return None


def _error_response(error_msg: str) -> List[TextContent]:
    """Return a standardized error response as JSON."""
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": error_msg
    }))]


async def _handle_fuzz_endpoint(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle fuzz_endpoint - Fuzz all parameters of an API endpoint."""
    endpoint = arguments.get("endpoint", "")
    method = arguments.get("method", "")
    parameters = arguments.get("parameters", [])
    payload_types = arguments.get("payload_types", VALID_PAYLOAD_TYPES)
    headers = arguments.get("headers", {})
    timeout = arguments.get("timeout")

    # Validate endpoint URL
    url_error = _validate_endpoint_url(endpoint)
    if url_error:
        return _error_response(url_error)

    # Scope validation
    scope_error = await _validate_scope(endpoint, mcp_service)
    if scope_error:
        return _error_response(scope_error)

    # Validate HTTP method
    method_error = _validate_method(method)
    if method_error:
        return _error_response(method_error)

    # Validate payload types
    for pt in payload_types:
        if pt not in VALID_PAYLOAD_TYPES:
            return _error_response(
                f"Invalid payload type: {pt}. Must be one of: {', '.join(VALID_PAYLOAD_TYPES)}"
            )

    # Parse and validate parameters
    parsed_parameters = []
    for param in parameters:
        if not isinstance(param, dict):
            return _error_response("Each parameter must be an object.")
        parsed_parameters.append({
            "name": param.get("name", ""),
            "location": param.get("location", "query"),
            "type": param.get("type", "string"),
            "format": param.get("format"),
            "required": param.get("required", False),
            "minimum": param.get("minimum"),
            "maximum": param.get("maximum"),
            "minLength": param.get("minLength"),
            "maxLength": param.get("maxLength"),
        })

    try:
        schema_fuzzer = _get_schema_fuzzer()
        result = schema_fuzzer.fuzz_endpoint(
            endpoint=endpoint,
            method=method,
            parameters=parsed_parameters,
            payload_types=payload_types,
            headers=headers,
            timeout=timeout,
            max_requests=MAX_REQUESTS_PER_ENDPOINT,
            rate_limit=RATE_LIMIT,
            mock_mode=True,
        )

        # Auto-save anomalies as observation cards
        await _autosave_fuzz_anomalies(result, endpoint, mcp_service)

        # Auto-capture full fuzz results to knowledge store
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="fuzz_endpoint", category="fuzz_result",
            title=f"Fuzz {method} {endpoint}",
            content=json.dumps(result, default=str),
            target=endpoint,
            tags=["fuzzer"],
        )

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "endpoint": endpoint,
            "method": method,
            "parameters_count": len(parsed_parameters),
            "payload_types": payload_types,
            "result": result
        }, default=str))]

    except Exception as e:
        return _error_response(f"Fuzzing failed for endpoint {endpoint}: {str(e)}")


async def _handle_fuzz_parameter(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle fuzz_parameter - Fuzz a single parameter."""
    endpoint = arguments.get("endpoint", "")
    method = arguments.get("method", "")
    parameter = arguments.get("parameter", {})
    payload_types = arguments.get("payload_types", VALID_PAYLOAD_TYPES)
    max_payloads = arguments.get("max_payloads", MAX_PAYLOADS)
    headers = arguments.get("headers", {})

    # Validate endpoint URL
    url_error = _validate_endpoint_url(endpoint)
    if url_error:
        return _error_response(url_error)

    # Scope validation
    scope_error = await _validate_scope(endpoint, mcp_service)
    if scope_error:
        return _error_response(scope_error)

    # Validate HTTP method
    method_error = _validate_method(method)
    if method_error:
        return _error_response(method_error)

    # Validate parameter object
    if not isinstance(parameter, dict) or not parameter.get("name"):
        return _error_response("Parameter must be an object with at least a 'name' field.")

    # Validate parameter location if provided
    param_location = parameter.get("location", "query")
    if param_location not in VALID_PARAMETER_LOCATIONS:
        return _error_response(
            f"Invalid parameter location: {param_location}. "
            f"Must be one of: {', '.join(VALID_PARAMETER_LOCATIONS)}"
        )

    # Validate payload types
    for pt in payload_types:
        if pt not in VALID_PAYLOAD_TYPES:
            return _error_response(
                f"Invalid payload type: {pt}. Must be one of: {', '.join(VALID_PAYLOAD_TYPES)}"
            )

    # Cap max_payloads to configured limit
    if max_payloads > MAX_PAYLOADS:
        max_payloads = MAX_PAYLOADS

    parsed_parameter = {
        "name": parameter.get("name", ""),
        "location": param_location,
        "type": parameter.get("type", "string"),
        "format": parameter.get("format"),
        "required": parameter.get("required", False),
        "minimum": parameter.get("minimum"),
        "maximum": parameter.get("maximum"),
        "minLength": parameter.get("minLength"),
        "maxLength": parameter.get("maxLength"),
    }

    try:
        schema_fuzzer = _get_schema_fuzzer()
        result = schema_fuzzer.fuzz_parameter(
            endpoint=endpoint,
            method=method,
            parameter=parsed_parameter,
            payload_types=payload_types,
            max_payloads=max_payloads,
            headers=headers,
            rate_limit=RATE_LIMIT,
            mock_mode=True,
        )

        # Auto-save anomalies as observation cards
        await _autosave_fuzz_anomalies(result, endpoint, mcp_service)

        # Auto-capture full fuzz results to knowledge store
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="fuzz_parameter", category="fuzz_result",
            title=f"Fuzz param {parsed_parameter['name']} on {method} {endpoint}",
            content=json.dumps(result, default=str),
            target=endpoint,
            tags=["fuzzer"],
        )

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "endpoint": endpoint,
            "method": method,
            "parameter": parsed_parameter["name"],
            "payload_types": payload_types,
            "max_payloads": max_payloads,
            "result": result
        }, default=str))]

    except Exception as e:
        return _error_response(
            f"Fuzzing failed for parameter '{parameter.get('name', 'unknown')}' "
            f"on {endpoint}: {str(e)}"
        )


async def _handle_fuzz_list_payloads(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle fuzz_list_payloads - List available payload types and examples."""
    filter_type = arguments.get("type")

    # Validate filter type if provided
    if filter_type and filter_type not in VALID_PAYLOAD_TYPES:
        return _error_response(
            f"Invalid payload type: {filter_type}. "
            f"Must be one of: {', '.join(VALID_PAYLOAD_TYPES)}"
        )

    try:
        payload_generator = _get_payload_generator()

        # Risk levels for each payload type
        risk_levels = {
            "boundary": "MEDIUM",
            "type_confusion": "MEDIUM",
            "injection": "HIGH",
            "format": "LOW",
            "overflow": "HIGH",
            "sqli_db": "HIGH",
        }

        payload_types_info = []

        types_to_list = [filter_type] if filter_type else VALID_PAYLOAD_TYPES

        for pt in types_to_list:
            description = payload_generator.get_type_description(pt)
            examples = payload_generator.get_type_examples(pt)
            info = {
                "type": pt,
                "description": description,
                "risk_level": risk_levels.get(pt, "UNKNOWN"),
                "examples": examples,
            }
            # Add DB-specific metadata for sqli_db
            if pt == "sqli_db":
                try:
                    from lib.sql_payloads import get_all_db_types, get_all_techniques
                    info["db_types"] = get_all_db_types()
                    info["techniques"] = get_all_techniques()
                except ImportError:
                    pass
            payload_types_info.append(info)

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "payload_types": payload_types_info,
            "total_types": len(payload_types_info),
        }, default=str))]

    except Exception as e:
        return _error_response(f"Failed to list payload types: {str(e)}")


async def _autosave_fuzz_anomalies(result, endpoint: str, mcp_service) -> None:
    """Extract anomalies from fuzzing results and save as observation cards."""
    if not mcp_service:
        return

    try:
        anomalies = result.get("anomalies", [])
        if not anomalies and isinstance(result, dict):
            # Some fuzzer results nest anomalies under "results"
            for r in result.get("results", []):
                if isinstance(r, dict):
                    anomalies.extend(r.get("anomalies", []))

        for anomaly in anomalies:
            if not isinstance(anomaly, dict):
                continue
            anomaly_type = anomaly.get("type", "unknown")
            await mcp_service.safe_add_card(
                card_type="observation",
                title=f"Fuzz anomaly: {anomaly_type} on {endpoint}",
                severity="MEDIUM",
                target_service=endpoint,
                notes=json.dumps(anomaly, default=str)[:2000],
                context="Source: fuzzer",
            )
    except Exception as e:
        logger.warning(f"_autosave_fuzz_anomalies failed: {e}")
