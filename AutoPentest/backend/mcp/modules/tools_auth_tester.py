"""
Auth Tester Tools - auth_get_identities, auth_diff_test, auth_replay_with_identity

Ported from auth-tester-mcp TypeScript server to Python.
Provides differential authorization testing across multiple identities
for BOLA/IDOR detection and authorization enforcement verification.
"""
from __future__ import annotations

import json
import os
from typing import Any, Dict, List, Optional

import httpx
from mcp.types import Tool, TextContent


# ---------------------------------------------------------------------------
# Lazy-initialized singletons
# ---------------------------------------------------------------------------

_identity_store = None
_diff_tester = None

IDENTITY_FILE = os.environ.get("IDENTITY_FILE", "")


def _get_identity_store():
    """Lazily initialize and return the IdentityStore singleton."""
    global _identity_store
    if _identity_store is None:
        from lib.identity_store import IdentityStore
        _identity_store = IdentityStore()
        if IDENTITY_FILE:
            _identity_store.load_from_yaml(IDENTITY_FILE)
    return _identity_store


def _get_diff_tester():
    """Lazily initialize and return the DifferentialTester singleton."""
    global _diff_tester
    if _diff_tester is None:
        from lib.diff_tester import DifferentialTester
        store = _get_identity_store()
        _diff_tester = DifferentialTester(identity_store=store)
    return _diff_tester


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_auth_tester_tools() -> List[Tool]:
    """Get auth tester tool definitions."""
    return [
        Tool(
            name="auth_get_identities",
            description=(
                "List available test identities and their scopes. "
                "Shows identity IDs, types, scopes, and access expectations. "
                "LOW RISK - read-only, no HTTP requests are made."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "scope": {
                        "type": "string",
                        "description": "Filter identities by scope (optional)"
                    }
                },
                "required": []
            }
        ),
        Tool(
            name="auth_diff_test",
            description=(
                "Run differential authorization testing on an endpoint with "
                "multiple identities. Compares responses to detect BOLA/IDOR "
                "and authorization bypass issues. "
                "HIGH RISK - sends HTTP requests to the target."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "Target endpoint URL"
                    },
                    "method": {
                        "type": "string",
                        "description": "HTTP method (GET, POST, PUT, DELETE, PATCH)",
                        "default": "GET"
                    },
                    "identity_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": (
                            "List of identity IDs to test. "
                            "If not specified, all loaded identities are used."
                        )
                    },
                    "headers": {
                        "type": "object",
                        "description": "Additional HTTP headers to include in each request (optional)"
                    },
                    "body": {
                        "type": "string",
                        "description": "Request body for POST/PUT/PATCH requests (optional)"
                    }
                },
                "required": ["url"]
            }
        ),
        Tool(
            name="auth_replay_with_identity",
            description=(
                "Replay a request using a specific identity's credentials. "
                "Sends the request with the chosen identity's auth headers/cookies "
                "and returns the full response details. "
                "HIGH RISK - sends an HTTP request to the target."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "Target URL to send the request to"
                    },
                    "method": {
                        "type": "string",
                        "description": "HTTP method (GET, POST, PUT, DELETE, PATCH)",
                        "default": "GET"
                    },
                    "identity_id": {
                        "type": "string",
                        "description": "ID of the identity whose credentials to use"
                    },
                    "headers": {
                        "type": "object",
                        "description": "Additional HTTP headers (optional)"
                    },
                    "body": {
                        "type": "string",
                        "description": "Request body for POST/PUT/PATCH requests (optional)"
                    }
                },
                "required": ["url", "identity_id"]
            }
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler routing
# ---------------------------------------------------------------------------

async def handle_auth_tester_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route auth tester tool calls to the appropriate handler."""
    if name == "auth_get_identities":
        return _handle_get_identities(arguments)
    elif name == "auth_diff_test":
        return await _handle_diff_test(arguments)
    elif name == "auth_replay_with_identity":
        return await _handle_replay_with_identity(arguments)
    return _error_response(f"Unknown auth tester tool: {name}")


# ---------------------------------------------------------------------------
# Error helper
# ---------------------------------------------------------------------------

def _error_response(error_msg: str) -> List[TextContent]:
    """Return a standardized error response as JSON."""
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": error_msg
    }))]


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

def _handle_get_identities(arguments: dict) -> List[TextContent]:
    """Handle auth_get_identities - List available identities."""
    try:
        store = _get_identity_store()
    except Exception as exc:
        return _error_response(f"Failed to load identity store: {exc}")

    if store.count == 0:
        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "identities": [],
            "count": 0,
            "message": (
                "No identities loaded. Set the IDENTITY_FILE environment variable "
                "to point to a YAML file with identity definitions."
            ),
        }, indent=2))]

    scope_filter: Optional[str] = arguments.get("scope")

    if scope_filter:
        identities = store.get_identities_for_scope(scope_filter)
    else:
        identities = store.get_identities()

    identity_dicts = [i.to_dict() for i in identities]

    # Collect unique scopes for reference
    scopes = sorted(set(i.scope for i in store.get_identities() if i.scope))

    return [TextContent(type="text", text=json.dumps({
        "success": True,
        "identities": identity_dicts,
        "count": len(identity_dicts),
        "available_scopes": scopes,
        "loaded_from": store.loaded_path or "none",
    }, indent=2))]


async def _handle_diff_test(arguments: dict) -> List[TextContent]:
    """Handle auth_diff_test - Run differential auth testing."""
    url = arguments.get("url")
    if not url:
        return _error_response("url is required")

    method: str = arguments.get("method", "GET")
    identity_ids: Optional[List[str]] = arguments.get("identity_ids")
    extra_headers: Optional[Dict[str, str]] = arguments.get("headers")
    body: Optional[str] = arguments.get("body")

    try:
        store = _get_identity_store()
    except Exception as exc:
        return _error_response(f"Failed to load identity store: {exc}")

    if store.count == 0:
        return _error_response(
            "No identities loaded. Set the IDENTITY_FILE environment variable "
            "to point to a YAML file with identity definitions."
        )

    # Resolve identities
    if identity_ids:
        identities = []
        for iid in identity_ids:
            identity = store.get_identity(iid)
            if not identity:
                return _error_response(f"Identity not found: {iid}")
            identities.append(identity)
    else:
        identities = store.get_identities()

    if len(identities) < 2:
        return _error_response(
            "At least 2 identities are required for differential testing. "
            f"Currently have: {len(identities)}"
        )

    try:
        tester = _get_diff_tester()

        # Run differential test
        results = await tester.test_endpoint(
            url=url,
            method=method,
            identities=identities,
            headers=extra_headers,
            body=body,
        )

        # Analyze results
        analysis = tester.analyze_results(results)

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "test_results": results,
            "analysis": analysis,
        }, indent=2, default=str))]

    except Exception as exc:
        return _error_response(f"Differential test failed: {exc}")


async def _handle_replay_with_identity(arguments: dict) -> List[TextContent]:
    """Handle auth_replay_with_identity - Replay request with specific identity."""
    url = arguments.get("url")
    if not url:
        return _error_response("url is required")

    identity_id = arguments.get("identity_id")
    if not identity_id:
        return _error_response("identity_id is required")

    method: str = arguments.get("method", "GET")
    extra_headers: Optional[Dict[str, str]] = arguments.get("headers")
    body: Optional[str] = arguments.get("body")

    try:
        store = _get_identity_store()
    except Exception as exc:
        return _error_response(f"Failed to load identity store: {exc}")

    identity = store.get_identity(identity_id)
    if not identity:
        available_ids = store.get_identity_ids()
        return _error_response(
            f"Identity '{identity_id}' not found. "
            f"Available identities: {', '.join(available_ids) if available_ids else 'none'}"
        )

    try:
        # Build request headers
        from lib.identity_store import IdentityStore as _IS
        auth_headers = _IS.build_auth_headers(identity)
        merged_headers: Dict[str, str] = {}
        if extra_headers:
            merged_headers.update(extra_headers)
        merged_headers.update(auth_headers)

        # Only attach body for methods that support it
        content: Optional[str] = None
        if body and method.upper() in ("POST", "PUT", "PATCH"):
            content = body

        async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
            response = await client.request(
                method=method,
                url=url,
                headers=merged_headers,
                content=content,
            )
            response_body = response.text

        # Build response
        has_access = 200 <= response.status_code < 400

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "identity_id": identity_id,
            "identity_type": identity.type,
            "identity_scope": identity.scope,
            "should_have_access": identity.should_have_access,
            "request": {
                "method": method,
                "url": url,
                "auth_headers_applied": list(auth_headers.keys()),
            },
            "response": {
                "status_code": response.status_code,
                "headers": dict(response.headers),
                "body_length": len(response_body),
                "body_preview": response_body[:2000] if response_body else "",
                "has_access": has_access,
            },
            "auth_check": {
                "expected_access": identity.should_have_access,
                "actual_access": has_access,
                "matches_expectation": has_access == identity.should_have_access,
                "verdict": (
                    "PASS - access matches expectation"
                    if has_access == identity.should_have_access
                    else (
                        "FAIL - UNAUTHORIZED ACCESS DETECTED"
                        if has_access and not identity.should_have_access
                        else "FAIL - EXPECTED ACCESS WAS DENIED"
                    )
                ),
            },
        }, indent=2, default=str))]

    except Exception as exc:
        return _error_response(f"Replay request failed: {exc}")
