"""
Auth Tester Tools - auth_get_identities, auth_diff_test, auth_replay_with_identity

Ported from auth-tester-mcp TypeScript server to Python.
Provides differential authorization testing across multiple identities
for BOLA/IDOR detection and authorization enforcement verification.
"""
from __future__ import annotations

import json
import os
from typing import Any, Dict, List, Optional

import httpx
from mcp.types import Tool, TextContent


# ---------------------------------------------------------------------------
# Lazy-initialized singletons
# ---------------------------------------------------------------------------

_identity_store = None
_diff_tester = None

IDENTITY_FILE = os.environ.get("IDENTITY_FILE", "")


def _get_identity_store():
    """Lazily initialize and return the IdentityStore singleton."""
    global _identity_store
    if _identity_store is None:
        from lib.identity_store import IdentityStore
        _identity_store = IdentityStore()
        if IDENTITY_FILE:
            _identity_store.load_from_yaml(IDENTITY_FILE)
    return _identity_store


def _get_diff_tester():
    """Lazily initialize and return the DifferentialTester singleton."""
    global _diff_tester
    if _diff_tester is None:
        from lib.diff_tester import DifferentialTester
        store = _get_identity_store()
        _diff_tester = DifferentialTester(identity_store=store)
    return _diff_tester


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_auth_tester_tools() -> List[Tool]:
    """Get auth tester tool definitions."""
    return [
        Tool(
            name="auth_get_identities",
            description=(
                "List available test identities and their scopes from IDENTITY_FILE configuration. Shows "
                "identity IDs, authentication types, privilege scopes, and expected access patterns. Essential "
                "reference for authorization testing, IDOR detection, and privilege escalation checks. Returns "
                "test accounts configured for differential authorization testing. "

                "**When to use:** Phase 2-3 (Mapping/Assessment) before authorization testing operations. Call "
                "before auth_diff_test() to see available identity_ids for comparison testing. Use before "
                "crawler_start() with identity_id to understand which credentials to use for authenticated "
                "crawling. Reference when planning IDOR tests to identify user pairs (admin vs user, user1 vs user2). "
                "Essential for discovering privileged endpoints requiring authentication. "

                "**Dependencies:** Requires IDENTITY_FILE environment variable pointing to YAML file with identity "
                "definitions (auth type, credentials, scope, expected access). No prerequisites - query only tool. "
                "Follow with auth_diff_test(identity_ids=[...]) to test authorization across returned identities. "
                "Use with validate_cross_identity() to validate IDOR findings across users. "

                "**Budget impact:** LOW - Local file read and JSON serialization, no HTTP requests. Completes "
                "in <50ms. Does NOT count against request budget. Returns metadata only (IDs, types, scopes), "
                "not raw credentials which are accessed internally when identity_id used. "

                "**Failure modes:** 'No identities loaded' if IDENTITY_FILE not set or file missing (valid for "
                "unauthenticated testing, returns empty array). 'YAML parse error' if file has invalid syntax. "
                "No other expected failures - returns whatever identities are configured (may be 0). "

                "**Risk level:** SAFE - Read-only query of configuration, no network activity or target interaction. "
                "Returns identity metadata only (IDs, scopes, types), not actual credentials (tokens, passwords). "
                "Credentials stored securely in IDENTITY_FILE and accessed internally when identity_id parameter used. "

                "**Returns:** Array of identity objects with: identity_id (use with auth_diff_test/crawler_start), "
                "auth_type (bearer/basic/cookie/api_key), scope (admin/user/readonly/custom role), expected_access "
                "(domains/resources this identity should access), metadata (custom fields). Optional scope parameter "
                "filters results (e.g., scope='admin' returns admin identities only). Use identity_ids with "
                "auth_diff_test(), crawler_start(identity_id=...), validate_cross_identity(), and http_send(identity_id=...) "
                "for authenticated testing workflows."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "scope": {
                        "type": "string",
                        "description": "Filter identities by scope (optional)"
                    }
                },
                "required": []
            }
        ),
        Tool(
            name="auth_diff_test",
            description=(
                "Run differential authorization testing on an endpoint with multiple identities. Sends same "
                "request using different user credentials and compares responses to detect BOLA (Broken Object "
                "Level Authorization), IDOR (Insecure Direct Object Reference), horizontal privilege escalation, "
                "and vertical privilege escalation vulnerabilities. Identifies access control failures where users "
                "can access resources they shouldn't. "

                "**When to use:** Phase 3 (Assessment) for testing authorization enforcement on authenticated "
                "endpoints. Target endpoints with user-specific resources (e.g., /api/users/{id}, /orders/{id}, "
                "/profile, /admin). Essential for discovering: IDOR (user1 accesses user2's data), horizontal "
                "privilege escalation (user accesses admin resources), missing authorization checks (any user "
                "accesses any resource). Use after auth_get_identities() to get available identity_ids. "

                "**Dependencies:** Requires auth_get_identities() or IDENTITY_FILE with test accounts. Optionally "
                "specify identity_ids array (defaults to all identities). Follow with validate_cross_identity() "
                "if authorization violation detected, then validate_repro() to confirm, sequence_data_ownership() "
                "to enumerate accessible IDs, and evidence_bundle() to document finding. "

                "**Budget impact:** MEDIUM - N requests where N = number of identities tested. Typical: 2-5 "
                "identities (admin, user1, user2, readonly, unauthenticated) = 2-5 requests per endpoint. For bulk "
                "IDOR enumeration across many IDs, use sequence_data_ownership() instead which is optimized for "
                "high-volume testing. "

                "**Failure modes:** 'No identities available' if IDENTITY_FILE not configured (need test accounts "
                "for authz testing). 'All identities return same response' may indicate: endpoint is public (no "
                "authz required), endpoint requires specific parameter values (try with actual IDs), WAF blocking "
                "(all get 403). 'Identity authentication failed' if credentials expired - refresh tokens in "
                "IDENTITY_FILE. 'Mixed success rates' with some identities timing out indicates instability - retry. "

                "**Risk level:** HIGH RISK - Actively tests authorization bypass with real user credentials. May "
                "access other users' sensitive data if IDOR/BOLA exists. Highly detectable in audit logs (multiple "
                "users accessing same resource rapidly). May trigger anomaly detection, account monitoring alerts, "
                "or compliance violations if test accounts access PII without authorization. Only use with explicit "
                "permission to test with multiple accounts. "

                "**Returns:** Differential test result with: url, method, identity_count (tested), responses array "
                "(per-identity status/body/timing), authorization_analysis (which identities could access when they "
                "shouldn't), access_control_matrix (expected vs actual access), violations array (detected authz "
                "failures). Includes response diffs highlighting what data leaked. Use violations to identify IDOR "
                "findings, access_control_matrix for privilege escalation detection, response diffs for data leakage "
                "analysis."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "Target endpoint URL"
                    },
                    "method": {
                        "type": "string",
                        "description": "HTTP method (GET, POST, PUT, DELETE, PATCH)",
                        "default": "GET"
                    },
                    "identity_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": (
                            "List of identity IDs to test. "
                            "If not specified, all loaded identities are used."
                        )
                    },
                    "headers": {
                        "type": "object",
                        "description": "Additional HTTP headers to include in each request (optional)"
                    },
                    "body": {
                        "type": "string",
                        "description": "Request body for POST/PUT/PATCH requests (optional)"
                    }
                },
                "required": ["url"]
            }
        ),
        Tool(
            name="auth_replay_with_identity",
            description=(
                "Replay a request using a specific identity's credentials. Sends request with chosen identity's "
                "authentication headers/cookies and returns full response details. Useful for testing endpoints "
                "as specific users, verifying role-based access, and manual authorization testing. More targeted "
                "than auth_diff_test() - tests single identity instead of comparing across multiple. "

                "**When to use:** Phase 3 (Assessment) when you need to test endpoint behavior with specific "
                "user credentials. Use cases: verify admin-only endpoint blocks non-admin (replay as user), test "
                "endpoint behavior for specific role (replay as readonly), confirm user can access own resource "
                "(replay as user1 accessing /users/user1_id), debug authentication issues (replay with different "
                "credentials to isolate problem). More focused than auth_diff_test() for targeted testing. "

                "**Dependencies:** Requires auth_get_identities() to get valid identity_id. Identity must be "
                "loaded in IDENTITY_FILE with credentials. Follow with validate_repro() if response indicates "
                "vulnerability, or auth_diff_test() if need to compare across multiple identities. Use with "
                "evidence_add_artifact() to capture request/response as evidence. "

                "**Budget impact:** LOW - 1 request per call. Same as http_send() but with automatic credential "
                "injection from identity store. Completes in <1 second for fast endpoints. Does count against "
                "request budget (check scope_check_budget() before bulk replays). "

                "**Failure modes:** 'Identity not found' if identity_id doesn't exist - call auth_get_identities() "
                "to see valid IDs. 'Authentication failed' (401/403) may indicate: credentials expired (refresh "
                "IDENTITY_FILE), identity lacks access to endpoint (expected for authz testing), auth format "
                "incorrect (verify auth_type in identity config). 'Connection refused' may indicate IP blocking "
                "from repeated authz tests. "

                "**Risk level:** HIGH RISK - Sends HTTP request with real user credentials to target. May access "
                "sensitive data if identity has permissions. Logged in audit trails with user identity. May trigger "
                "anomaly detection if unusual access pattern. Less risky than auth_diff_test() (single request vs "
                "multiple) but still active testing with credentials. Only use identities you're authorized to test with. "

                "**Returns:** HTTP response with: status_code, headers (dict), body (string), identity_id (used), "
                "auth_type (bearer/basic/cookie/api_key), timing (duration_ms), success flag. Full request/response "
                "pair suitable for evidence_add_artifact(). Use to: verify expected access patterns, confirm authz "
                "enforcement, debug authentication issues, capture authenticated responses for analysis. Compare "
                "with unauthenticated request to confirm auth makes difference."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "Target URL to send the request to"
                    },
                    "method": {
                        "type": "string",
                        "description": "HTTP method (GET, POST, PUT, DELETE, PATCH)",
                        "default": "GET"
                    },
                    "identity_id": {
                        "type": "string",
                        "description": "ID of the identity whose credentials to use"
                    },
                    "headers": {
                        "type": "object",
                        "description": "Additional HTTP headers (optional)"
                    },
                    "body": {
                        "type": "string",
                        "description": "Request body for POST/PUT/PATCH requests (optional)"
                    }
                },
                "required": ["url", "identity_id"]
            }
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler routing
# ---------------------------------------------------------------------------

async def handle_auth_tester_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route auth tester tool calls to the appropriate handler."""
    if name == "auth_get_identities":
        return _handle_get_identities(arguments)
    elif name == "auth_diff_test":
        return await _handle_diff_test(arguments, mcp_service)
    elif name == "auth_replay_with_identity":
        return await _handle_replay_with_identity(arguments, mcp_service)
    return _error_response(f"Unknown auth tester tool: {name}")


# ---------------------------------------------------------------------------
# Error helper
# ---------------------------------------------------------------------------

def _error_response(error_msg: str) -> List[TextContent]:
    """Return a standardized error response as JSON."""
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": error_msg
    }))]


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

def _handle_get_identities(arguments: dict) -> List[TextContent]:
    """Handle auth_get_identities - List available identities."""
    try:
        store = _get_identity_store()
    except Exception as exc:
        return _error_response(f"Failed to load identity store: {exc}")

    if store.count == 0:
        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "identities": [],
            "count": 0,
            "message": (
                "No identities loaded. Set the IDENTITY_FILE environment variable "
                "to point to a YAML file with identity definitions."
            ),
        }, indent=2))]

    scope_filter: Optional[str] = arguments.get("scope")

    if scope_filter:
        identities = store.get_identities_for_scope(scope_filter)
    else:
        identities = store.get_identities()

    identity_dicts = [i.to_dict() for i in identities]

    # Collect unique scopes for reference
    scopes = sorted(set(i.scope for i in store.get_identities() if i.scope))

    return [TextContent(type="text", text=json.dumps({
        "success": True,
        "identities": identity_dicts,
        "count": len(identity_dicts),
        "available_scopes": scopes,
        "loaded_from": store.loaded_path or "none",
    }, indent=2))]


async def _handle_diff_test(arguments: dict, mcp_service=None) -> List[TextContent]:
    """Handle auth_diff_test - Run differential auth testing."""
    url = arguments.get("url")
    if not url:
        return _error_response("url is required")

    method: str = arguments.get("method", "GET")
    identity_ids: Optional[List[str]] = arguments.get("identity_ids")
    extra_headers: Optional[Dict[str, str]] = arguments.get("headers")
    body: Optional[str] = arguments.get("body")

    try:
        store = _get_identity_store()
    except Exception as exc:
        return _error_response(f"Failed to load identity store: {exc}")

    if store.count == 0:
        return _error_response(
            "No identities loaded. Set the IDENTITY_FILE environment variable "
            "to point to a YAML file with identity definitions."
        )

    # Resolve identities
    if identity_ids:
        identities = []
        for iid in identity_ids:
            identity = store.get_identity(iid)
            if not identity:
                return _error_response(f"Identity not found: {iid}")
            identities.append(identity)
    else:
        identities = store.get_identities()

    if len(identities) < 2:
        return _error_response(
            "At least 2 identities are required for differential testing. "
            f"Currently have: {len(identities)}"
        )

    try:
        # Create audited HttpClient and pass to DifferentialTester
        from lib.http_client_factory import create_audit_http_client
        http_client = create_audit_http_client(mcp_service)

        from lib.diff_tester import DifferentialTester
        tester = DifferentialTester(identity_store=store, http_client=http_client)

        # Run differential test
        results = await tester.test_endpoint(
            url=url,
            method=method,
            identities=identities,
            headers=extra_headers,
            body=body,
        )

        # Analyze results
        analysis = tester.analyze_results(results)

        # Run exchange analysis on each response
        from lib.exchange_analyzer import get_exchange_analyzer
        analyzer = get_exchange_analyzer()
        exchange_analyses = []
        all_risk_signals = []

        for test_result in results:
            response_data = test_result.get("response", {})
            request_data = test_result.get("request", {})

            request_dict = {
                "method": request_data.get("method", method),
                "url": request_data.get("url", url),
                "headers": request_data.get("headers", {}),
                "body": request_data.get("body", "")
            }
            response_dict = {
                "status": response_data.get("status_code", 0),
                "headers": response_data.get("headers", {}),
                "body": (response_data.get("body", "") or "")[:4096]
            }

            ea_result = analyzer.analyze(request_dict, response_dict)
            exchange_analyses.append({
                "identity_id": test_result.get("identity_id"),
                "risk_signals": ea_result.risk_signals,
                "recommended_tests": ea_result.recommended_tests,
                "detected_technologies": ea_result.detected_technologies,
            })
            all_risk_signals.extend(ea_result.risk_signals)

        # Auto-persist unique risk signals
        auto_findings = 0
        if all_risk_signals and mcp_service:
            try:
                # Deduplicate risk signals by type
                unique_signals = []
                seen_types = set()
                for sig in all_risk_signals:
                    sig_type = sig.get("type", "")
                    if sig_type and sig_type not in seen_types:
                        unique_signals.append(sig)
                        seen_types.add(sig_type)

                auto_findings = await mcp_service.auto_persist_risk_signals(unique_signals, url)
            except Exception:
                pass

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "test_results": results,
            "analysis": analysis,
            "exchange_analyses": exchange_analyses,
            "auto_findings_created": auto_findings,
        }, indent=2, default=str))]

    except Exception as exc:
        return _error_response(f"Differential test failed: {exc}")


async def _handle_replay_with_identity(arguments: dict, mcp_service=None) -> List[TextContent]:
    """Handle auth_replay_with_identity - Replay request with specific identity."""
    url = arguments.get("url")
    if not url:
        return _error_response("url is required")

    identity_id = arguments.get("identity_id")
    if not identity_id:
        return _error_response("identity_id is required")

    method: str = arguments.get("method", "GET")
    extra_headers: Optional[Dict[str, str]] = arguments.get("headers")
    body: Optional[str] = arguments.get("body")

    try:
        store = _get_identity_store()
    except Exception as exc:
        return _error_response(f"Failed to load identity store: {exc}")

    identity = store.get_identity(identity_id)
    if not identity:
        available_ids = store.get_identity_ids()
        return _error_response(
            f"Identity '{identity_id}' not found. "
            f"Available identities: {', '.join(available_ids) if available_ids else 'none'}"
        )

    try:
        # Build request headers
        from lib.identity_store import IdentityStore as _IS
        auth_headers = _IS.build_auth_headers(identity)
        merged_headers: Dict[str, str] = {}
        if extra_headers:
            merged_headers.update(extra_headers)
        merged_headers.update(auth_headers)

        # Use audited HttpClient instead of raw httpx
        from lib.http_client_factory import create_audit_http_client
        client = create_audit_http_client(mcp_service)

        result = await client.send({
            "method": method,
            "url": url,
            "headers": merged_headers,
            "body": body if body and method.upper() in ("POST", "PUT", "PATCH") else None
        })

        response = result.get("response", {})
        response_body = response.get("body", "")
        status_code = response.get("status", 0)

        # Run exchange analysis
        from lib.exchange_analyzer import get_exchange_analyzer
        analyzer = get_exchange_analyzer()
        request_dict = {"method": method, "url": url, "headers": merged_headers, "body": body or ""}
        response_dict = {
            "status": status_code,
            "headers": response.get("headers", {}),
            "body": response_body[:4096]
        }
        ea_result = analyzer.analyze(request_dict, response_dict)

        # Auto-persist any risk signals
        auto_findings = 0
        if ea_result.risk_signals and mcp_service:
            try:
                auto_findings = await mcp_service.auto_persist_risk_signals(ea_result.risk_signals, url)
            except Exception:
                pass

        # Build response
        has_access = 200 <= status_code < 400

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "identity_id": identity_id,
            "identity_type": identity.type,
            "identity_scope": identity.scope,
            "should_have_access": identity.should_have_access,
            "request": {
                "method": method,
                "url": url,
                "auth_headers_applied": list(auth_headers.keys()),
            },
            "response": {
                "status_code": status_code,
                "headers": response.get("headers", {}),
                "body_length": len(response_body),
                "body_preview": response_body[:2000] if response_body else "",
                "has_access": has_access,
            },
            "auth_check": {
                "expected_access": identity.should_have_access,
                "actual_access": has_access,
                "matches_expectation": has_access == identity.should_have_access,
                "verdict": (
                    "PASS - access matches expectation"
                    if has_access == identity.should_have_access
                    else (
                        "FAIL - UNAUTHORIZED ACCESS DETECTED"
                        if has_access and not identity.should_have_access
                        else "FAIL - EXPECTED ACCESS WAS DENIED"
                    )
                ),
            },
            "exchange_analysis": {
                "risk_signals": ea_result.risk_signals,
                "recommended_tests": ea_result.recommended_tests,
                "detected_technologies": ea_result.detected_technologies,
                "auto_findings_created": auto_findings,
            },
        }, indent=2, default=str))]

    except Exception as exc:
        return _error_response(f"Replay request failed: {exc}")


# ---------------------------------------------------------------------------
# Helper function for credential testing (used by tools_credentials.py)
# ---------------------------------------------------------------------------

async def test_credential(
    target_url: str,
    username: str,
    password: str,
    method: str = "form",
    login_path: str = "/login",
    http_client: Any = None
) -> Dict[str, Any]:
    """Test a single credential against a login endpoint.

    Args:
        target_url: Base URL of the target (e.g., "http://app:5000")
        username: Username to test
        password: Password to test
        method: Authentication method ("form", "basic", "json")
        login_path: Login endpoint path (default: "/login")
        http_client: Optional audited HTTP client for scope/audit compliance

    Returns:
        Dict with:
            - valid (bool): Whether credential is valid
            - status_code (int): HTTP status code
            - response_body (str): Response body preview
            - session_token (str): Session cookie/token if successful
            - error (str): Error message if test failed
    """
    # Normalize URL
    if not target_url.startswith(("http://", "https://")):
        target_url = f"http://{target_url}"

    # Strip trailing slash
    target_url = target_url.rstrip("/")

    # Build login URL
    if not login_path.startswith("/"):
        login_path = f"/{login_path}"
    login_url = f"{target_url}{login_path}"

    try:
        # Use audited client if provided, otherwise fallback to raw httpx
        if http_client:
            # Use audited HttpClient (scope-checked, budget-tracked, logged)
            if method == "form":
                result = await http_client.send({
                    "method": "POST",
                    "url": login_url,
                    "headers": {"Content-Type": "application/x-www-form-urlencoded"},
                    "body": f"username={username}&password={password}",
                })
            elif method == "json":
                import json as json_lib
                result = await http_client.send({
                    "method": "POST",
                    "url": login_url,
                    "headers": {"Content-Type": "application/json"},
                    "body": json_lib.dumps({"username": username, "password": password}),
                })
            elif method == "basic":
                import base64
                credentials = base64.b64encode(f"{username}:{password}".encode()).decode()
                result = await http_client.send({
                    "method": "GET",
                    "url": login_url,
                    "headers": {"Authorization": f"Basic {credentials}"},
                })
            else:
                return {
                    "valid": False,
                    "error": f"Unsupported auth method: {method}",
                }

            # Extract response from HttpClient result
            if not result.get("success"):
                return {
                    "valid": False,
                    "status_code": 0,
                    "error": result.get("error", {}).get("message", "Request failed"),
                }

            response_data = result.get("response", {})
            status_code = response_data.get("status", 0)
            response_body = (response_data.get("body") or "")[:1000]
            response_headers = response_data.get("headers", {})

            # Extract session token from Set-Cookie headers
            session_token = None
            set_cookie = response_headers.get("set-cookie", "")
            session_cookies = ["session", "PHPSESSID", "JSESSIONID", "auth_token", "access_token"]
            for cookie_name in session_cookies:
                if cookie_name in set_cookie:
                    session_token = cookie_name
                    break

            redirect_url = ""
        else:
            # Fallback to raw httpx for standalone testing
            async with httpx.AsyncClient(verify=False, timeout=15.0, follow_redirects=True) as client:
                if method == "form":
                    # HTML form login (POST with form data)
                    response = await client.post(
                        login_url,
                        data={"username": username, "password": password},
                        headers={"Content-Type": "application/x-www-form-urlencoded"},
                    )
                elif method == "json":
                    # JSON API login
                    response = await client.post(
                        login_url,
                        json={"username": username, "password": password},
                        headers={"Content-Type": "application/json"},
                    )
                elif method == "basic":
                    # HTTP Basic Auth
                    response = await client.get(
                        login_url,
                        auth=(username, password),
                    )
                else:
                    return {
                        "valid": False,
                        "error": f"Unsupported auth method: {method}",
                    }

                # Check if login was successful
                # Success indicators: 200-299 status, redirect to dashboard/home, session cookie set
                status_code = response.status_code
                response_body = response.text[:1000]  # First 1000 chars

                # Extract session token from cookies
                session_token = None
                session_cookies = ["session", "PHPSESSID", "JSESSIONID", "auth_token", "access_token"]
                for cookie_name in session_cookies:
                    if cookie_name in response.cookies:
                        session_token = response.cookies[cookie_name]
                        break

                redirect_url = str(response.url) if response.url != login_url else ""

        # Determine if valid based on multiple indicators
        valid = False

        # Positive indicators
        if 200 <= status_code < 300:
            valid = True
        elif status_code in [301, 302, 303, 307, 308] and session_token:
            # Redirect with session cookie = successful login
            valid = True
        elif session_token:
            # Session cookie set = likely successful
            valid = True

        # Negative indicators (override positive)
        if any(indicator in response_body.lower() for indicator in [
            "invalid", "incorrect", "failed", "wrong", "bad credentials",
            "authentication failed", "login failed", "unauthorized"
        ]):
            valid = False

        # Check for redirect to login page (failed login)
        if "login" in redirect_url.lower() and status_code in [200, 302]:
            valid = False

        return {
            "valid": valid,
            "status_code": status_code,
            "response_body": response_body,
            "session_token": session_token or "",
            "redirect_url": redirect_url,
            "cookies": {},
        }

    except httpx.TimeoutException:
        return {
            "valid": False,
            "error": f"Timeout connecting to {login_url}",
        }
    except httpx.ConnectError:
        return {
            "valid": False,
            "error": f"Connection refused to {login_url}",
        }
    except Exception as exc:
        return {
            "valid": False,
            "error": f"Test failed: {str(exc)}",
        }
