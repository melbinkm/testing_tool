"""
Nuclei Vulnerability Scanner Tools - nuclei_scan_single, nuclei_scan_template, nuclei_list_templates

Provides MCP tools for running Nuclei vulnerability scans with mock mode
support. Wraps NucleiRunner and TemplateManager from the lib package.

Ported from nuclei-mcp/src/server.ts
"""
from __future__ import annotations

import json
import logging
import os
from typing import Any, Dict, List, Optional
from urllib.parse import urlparse

from mcp.types import Tool, TextContent

logger = logging.getLogger("nuclei-mcp")

# ---------------------------------------------------------------------------
# Lazy-initialized singletons
# ---------------------------------------------------------------------------

_nuclei_runner = None
_template_manager = None

# Configuration from environment variables
NUCLEI_PATH = os.environ.get("NUCLEI_PATH", "nuclei")
TEMPLATES_DIR = os.environ.get("TEMPLATES_DIR", "./nuclei-templates")
RATE_LIMIT = int(os.environ.get("RATE_LIMIT", "10"))
MOCK_MODE = os.environ.get("MOCK_MODE", "").lower() == "true"

VALID_SEVERITIES = ["info", "low", "medium", "high", "critical"]


def _get_nuclei_runner():
    """Lazily initialize and return the NucleiRunner singleton."""
    global _nuclei_runner
    if _nuclei_runner is None:
        from lib.nuclei_runner import NucleiRunner, NucleiConfig
        config = NucleiConfig(
            nuclei_path=NUCLEI_PATH,
            templates_dir=TEMPLATES_DIR,
            rate_limit=RATE_LIMIT,
            mock_mode=MOCK_MODE,
        )
        _nuclei_runner = NucleiRunner(config)
    return _nuclei_runner


def _get_template_manager():
    """Lazily initialize and return the TemplateManager singleton."""
    global _template_manager
    if _template_manager is None:
        from lib.template_manager import TemplateManager
        _template_manager = TemplateManager(TEMPLATES_DIR)
    return _template_manager


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_nuclei_tools() -> List[Tool]:
    """Get Nuclei tool definitions."""
    return [
        Tool(
            name="nuclei_scan_single",
            description=(
                "Scan a single URL with a specific Nuclei template. "
                "HIGH RISK - requires scope validation before use."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target": {
                        "type": "string",
                        "description": "The target URL to scan (must be in scope)",
                    },
                    "template_id": {
                        "type": "string",
                        "description": "The Nuclei template ID to use for scanning",
                    },
                    "timeout": {
                        "type": "number",
                        "description": "Scan timeout in milliseconds (default: 30000)",
                    },
                },
                "required": ["target", "template_id"],
            },
        ),
        Tool(
            name="nuclei_scan_template",
            description=(
                "Run Nuclei templates against a list of targets. "
                "HIGH RISK - requires scope validation before use."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "targets": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of target URLs to scan (all must be in scope)",
                    },
                    "template_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of template IDs to run (optional)",
                    },
                    "tags": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Filter templates by tags (optional)",
                    },
                    "severity": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": VALID_SEVERITIES,
                        },
                        "description": "Filter templates by severity levels (optional)",
                    },
                    "timeout": {
                        "type": "number",
                        "description": "Scan timeout in milliseconds per target (default: 30000)",
                    },
                },
                "required": ["targets"],
            },
        ),
        Tool(
            name="nuclei_list_templates",
            description=(
                "List available Nuclei templates with optional filtering. "
                "LOW RISK - read-only operation."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "severity": {
                        "oneOf": [
                            {
                                "type": "string",
                                "enum": VALID_SEVERITIES,
                            },
                            {
                                "type": "array",
                                "items": {
                                    "type": "string",
                                    "enum": VALID_SEVERITIES,
                                },
                            },
                        ],
                        "description": "Filter by severity level(s)",
                    },
                    "tags": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": 'Filter by tags (e.g., "cve", "rce", "xss")',
                    },
                    "author": {
                        "type": "string",
                        "description": "Filter by author name",
                    },
                    "search": {
                        "type": "string",
                        "description": "Search term to filter templates by ID, name, or description",
                    },
                    "limit": {
                        "type": "number",
                        "description": "Maximum number of templates to return",
                    },
                },
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_nuclei_tool(
    name: str, arguments: dict, mcp_service: Any
) -> List[TextContent]:
    """Route nuclei tool calls to the appropriate handler."""
    if name == "nuclei_scan_single":
        return await _handle_scan_single(arguments, mcp_service)
    elif name == "nuclei_scan_template":
        return await _handle_scan_template(arguments, mcp_service)
    elif name == "nuclei_list_templates":
        return await _handle_list_templates(arguments, mcp_service)
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": f"Unknown nuclei tool: {name}",
    }))]


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _validate_url(url: str) -> Optional[str]:
    """Validate that *url* is a well-formed URL.  Returns error message or None."""
    try:
        parsed = urlparse(url)
        if not parsed.scheme or not parsed.netloc:
            return f"Invalid target URL format: {url}"
        return None
    except Exception:
        return f"Invalid target URL format: {url}"


def _error_response(error_msg: str) -> List[TextContent]:
    """Return a standardised JSON error response."""
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": error_msg,
    }))]


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_scan_single(
    arguments: dict, mcp_service: Any
) -> List[TextContent]:
    """Handle nuclei_scan_single - scan a single URL with one template."""
    target = arguments.get("target")
    template_id = arguments.get("template_id")

    # Validate required parameters
    if not target or not isinstance(target, str):
        return _error_response("target is required and must be a string")

    if not template_id or not isinstance(template_id, str):
        return _error_response("template_id is required and must be a string")

    # Validate URL format
    url_error = _validate_url(target)
    if url_error:
        return _error_response(url_error)

    # Check if template exists (warn but don't block - may be a custom path)
    tm = _get_template_manager()
    if not tm.template_exists(template_id):
        logger.warning(
            "Template '%s' not found in template manager", template_id
        )

    # Run the scan
    runner = _get_nuclei_runner()
    result = await runner.scan_single(target, template_id)

    response: Dict[str, Any] = {
        "success": result["success"],
        "result": result,
    }
    if result.get("mock_mode"):
        response["warning"] = "Running in mock mode - results are simulated"

    # Auto-save findings to backend
    if result["success"] and mcp_service:
        findings = result.get("findings", [])
        if not findings and result.get("matched"):
            # Some runners return a flat result as a single finding
            findings = [result]
        for finding in findings:
            sev = (finding.get("severity") or "INFO").upper()
            tmpl = finding.get("template_id") or finding.get("template-id") or template_id
            await mcp_service.safe_add_card(
                card_type="finding",
                title=f"Nuclei: {tmpl} on {target}",
                severity=sev,
                status="confirmed",
                target_service=target,
                technical_analysis=finding.get("description", ""),
                proof=json.dumps(finding, default=str)[:2000],
                context=f"Source: nuclei, template: {template_id}",
            )

    return [TextContent(type="text", text=json.dumps(response, indent=2, default=str))]


async def _handle_scan_template(
    arguments: dict, mcp_service: Any
) -> List[TextContent]:
    """Handle nuclei_scan_template - run templates against a list of targets."""
    targets = arguments.get("targets")

    # Validate required parameters
    if not targets or not isinstance(targets, list) or len(targets) == 0:
        return _error_response("targets is required and must be a non-empty array")

    # Validate all target URLs
    for t in targets:
        url_error = _validate_url(t)
        if url_error:
            return _error_response(url_error)

    template_ids: Optional[List[str]] = arguments.get("template_ids")
    tags: Optional[List[str]] = arguments.get("tags")
    severity: Optional[List[str]] = arguments.get("severity")

    # Run the scan
    runner = _get_nuclei_runner()
    results = await runner.scan_with_templates(
        targets,
        template_ids=template_ids,
        tags=tags,
        severity=severity,
    )

    all_success = all(r["success"] for r in results)
    total_findings = sum(len(r.get("findings", [])) for r in results)
    mock_mode = any(r.get("mock_mode") for r in results)

    response: Dict[str, Any] = {
        "success": all_success,
        "results": results,
        "summary": {
            "total_targets": len(targets),
            "successful_scans": sum(1 for r in results if r["success"]),
            "failed_scans": sum(1 for r in results if not r["success"]),
            "total_findings": total_findings,
        },
    }
    if mock_mode:
        response["warning"] = "Running in mock mode - results are simulated"

    # Auto-save all findings to backend
    if mcp_service:
        for scan_result in results:
            if not scan_result.get("success"):
                continue
            scan_target = scan_result.get("target", "unknown")
            for finding in scan_result.get("findings", []):
                sev = (finding.get("severity") or "INFO").upper()
                tmpl = finding.get("template_id") or finding.get("template-id") or "unknown"
                await mcp_service.safe_add_card(
                    card_type="finding",
                    title=f"Nuclei: {tmpl} on {scan_target}",
                    severity=sev,
                    status="confirmed",
                    target_service=scan_target,
                    technical_analysis=finding.get("description", ""),
                    proof=json.dumps(finding, default=str)[:2000],
                    context=f"Source: nuclei, template: {tmpl}",
                )

    return [TextContent(type="text", text=json.dumps(response, indent=2, default=str))]


async def _handle_list_templates(
    arguments: dict, mcp_service: Any
) -> List[TextContent]:
    """Handle nuclei_list_templates - list available templates with filtering."""
    severity = arguments.get("severity")
    tags = arguments.get("tags")
    author = arguments.get("author")
    search = arguments.get("search")
    limit = arguments.get("limit")

    tm = _get_template_manager()
    result = tm.list_templates(
        severity=severity,
        tags=tags,
        author=author,
        search=search,
        limit=limit,
    )

    mock_mode = tm.is_mock_mode()

    response: Dict[str, Any] = {
        "success": result["success"],
        "templates": result["templates"],
        "total_count": result["total_count"],
        "filtered_count": result["filtered_count"],
        "returned_count": len(result["templates"]),
    }
    if mock_mode:
        response["warning"] = "Running in mock mode - templates are simulated"
    if result.get("error"):
        response["error"] = result["error"]

    return [TextContent(type="text", text=json.dumps(response, indent=2, default=str))]
