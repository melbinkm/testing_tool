"""
Nuclei Vulnerability Scanner Tools - nuclei_scan_single, nuclei_scan_template, nuclei_list_templates

Provides MCP tools for running Nuclei vulnerability scans with mock mode
support. Wraps NucleiRunner and TemplateManager from the lib package.

Ported from nuclei-mcp/src/server.ts
"""
from __future__ import annotations

import json
import logging
import os
from typing import Any, Dict, List, Optional
from urllib.parse import urlparse

from mcp.types import Tool, TextContent

logger = logging.getLogger("nuclei-mcp")


async def _validate_scope(target: str, mcp_service) -> Optional[str]:
    """Check target against per-assessment scope. Returns error message or None."""
    if not mcp_service.current_assessment_id:
        return None  # No assessment selected, skip validation
    if not mcp_service.scope_provider:
        return None  # Scope provider not initialized, skip validation

    try:
        validator = await mcp_service.scope_provider.get_validator(
            mcp_service.current_assessment_id
        )
        if validator is None:
            return None  # No scope configured, skip validation
        result = validator.validate_target(target)
        if not result.valid:
            return f"Target out of scope: {target} — {result.reason}"
    except Exception as e:
        logger.warning(f"Scope validation failed: {e}")
        pass
    return None


# ---------------------------------------------------------------------------
# Lazy-initialized singletons
# ---------------------------------------------------------------------------

_nuclei_runner = None
_template_manager = None

# Configuration from environment variables
NUCLEI_PATH = os.environ.get("NUCLEI_PATH", "nuclei")
TEMPLATES_DIR = os.environ.get("TEMPLATES_DIR", "./nuclei-templates")
RATE_LIMIT = int(os.environ.get("RATE_LIMIT", "10"))
MOCK_MODE = os.environ.get("MOCK_MODE", "").lower() == "true"

VALID_SEVERITIES = ["info", "low", "medium", "high", "critical"]


def _get_nuclei_runner():
    """Lazily initialize and return the NucleiRunner singleton."""
    global _nuclei_runner
    if _nuclei_runner is None:
        from lib.nuclei_runner import NucleiRunner, NucleiConfig
        config = NucleiConfig(
            nuclei_path=NUCLEI_PATH,
            templates_dir=TEMPLATES_DIR,
            rate_limit=RATE_LIMIT,
            mock_mode=MOCK_MODE,
        )
        _nuclei_runner = NucleiRunner(config)
    return _nuclei_runner


def _get_template_manager():
    """Lazily initialize and return the TemplateManager singleton."""
    global _template_manager
    if _template_manager is None:
        from lib.template_manager import TemplateManager
        _template_manager = TemplateManager(TEMPLATES_DIR)
    return _template_manager


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_nuclei_tools() -> List[Tool]:
    """Get Nuclei tool definitions."""
    return [
        Tool(
            name="nuclei_scan_single",
            description=(
                "Scan a single URL with one specific Nuclei template. Focused vulnerability check for targeted "
                "testing of a known issue (e.g., test only CVE-2021-44228 log4j on one endpoint). Lighter weight "
                "than nuclei_scan_template() which runs multiple templates. Use when you have intelligence "
                "suggesting a specific vulnerability exists. HIGH RISK - active exploitation attempt. "

                "**When to use:** Phase 3 (Assessment) when you have strong indicators of a specific vulnerability "
                "(version banner suggests CVE, error message reveals technology, similar finding on related "
                "endpoint). Use after nuclei_list_templates() to identify exact template_id for the CVE/vuln you "
                "suspect. Prefer this over nuclei_scan_template() when you want surgical testing without scanning "
                "everything. Good for follow-up testing after manual discovery. "

                "**Dependencies:** Requires scope_validate_target() first. Use nuclei_list_templates() to get "
                "template_id (e.g., search='CVE-2021-44228' to find log4j template ID). Follow tech_detection() "
                "to identify technology version before choosing template. After findings, use validate_repro() "
                "to confirm exploitability. "

                "**Budget impact:** LOW - typically 1-10 requests per template (depends on template complexity). "
                "Much cheaper than nuclei_scan_template() which runs hundreds of templates. Multi-step templates "
                "(with payloads) may send 5-10 requests. Simple detection templates = 1-2 requests. "

                "**Failure modes:** 'Target out of scope' if scope_validate_target() not called. 'Template not "
                "found' if template_id invalid - use nuclei_list_templates() to verify. WAF may block known "
                "signatures (403/429) - template may have built-in evasion. Timeout on slow targets - increase "
                "timeout parameter. False positive if template poorly calibrated (validate findings manually). "

                "**Risk level:** HIGH RISK - Active exploitation attempt for known vulnerability. Even though it's "
                "a single template, some templates test for RCE/SQLi with actual payloads. May trigger IDS/IPS "
                "alerts, especially for critical CVE templates. Use with caution on production systems. "

                "**Returns:** JSON result with: matched boolean, severity, template_id, description, matched_at "
                "(URL), extracted_results (captured data), request/response details, CVSS score, CWE/CVE IDs. "
                "Auto-saved as finding card if matched. Use to quickly verify specific suspected vulnerabilities "
                "before deeper manual testing."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target": {
                        "type": "string",
                        "description": "The target URL to scan (must be in scope)",
                    },
                    "template_id": {
                        "type": "string",
                        "description": "The Nuclei template ID to use for scanning",
                    },
                    "timeout": {
                        "type": "number",
                        "description": "Scan timeout in milliseconds (default: 30000)",
                    },
                },
                "required": ["target", "template_id"],
            },
        ),
        Tool(
            name="nuclei_scan_template",
            description=(
                "Run Nuclei vulnerability scanner templates against target URLs. Detects known CVEs, "
                "misconfigurations, default credentials, and technology-specific vulnerabilities using "
                "community-maintained templates. HIGH RISK - generates high request volume. "

                "**When to use:** Phase 3 (Assessment) after completing reconnaissance and tech detection. "
                "Use tech_detection() results to filter templates by tag (e.g., 'wordpress', 'apache'). "
                "Best for finding known vulnerabilities quickly. Call nuclei_list_templates() first to see "
                "available templates. Essential for CVE scanning and misconfiguration detection. "

                "**Dependencies:** Requires scope_validate_target() for all targets AND scope_check_budget() "
                "before execution. Follow tech_detection() to get technology context for tag filtering. Use "
                "nuclei_list_templates() to preview template count. After findings, call validate_repro() "
                "to confirm they're reproducible. "

                "**Budget impact:** HIGH - 100-1000 requests per target depending on template selection. "
                "Full scan with all templates = ~2000 requests/target. With tags=['cve'] = ~500 requests. "
                "With severity=['critical','high'] = ~300 requests. ALWAYS check budget first! "

                "**Failure modes:** WAF may block Nuclei user-agent (returns 403/429) - some templates have "
                "evasion techniques built-in. Template not found errors if custom template_ids specified "
                "(use nuclei_list_templates to verify). Timeout on slow targets - reduce template count or "
                "increase timeout parameter. False positives common for 'info' severity - validate manually. "

                "**Risk level:** HIGH RISK - Active exploitation attempts for known vulnerabilities. Detectable "
                "by IDS/IPS due to known attack signatures. May trigger security alerts or account lockouts. "
                "Some templates test for RCE/SQLi with actual payloads (not just detection). Use with caution. "

                "**Returns:** Findings array with: template_id, severity (info/low/medium/high/critical), "
                "matched URL, description, remediation, CVSS score, CWE-ID, CVE-ID (if applicable), request/response "
                "details. Auto-saved as findings cards to backend. Use to quickly identify known vulnerabilities "
                "before manual testing."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "targets": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of target URLs to scan (all must be in scope)",
                    },
                    "template_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of template IDs to run (optional)",
                    },
                    "tags": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Filter templates by tags (optional)",
                    },
                    "severity": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": VALID_SEVERITIES,
                        },
                        "description": "Filter templates by severity levels (optional)",
                    },
                    "timeout": {
                        "type": "number",
                        "description": "Scan timeout in milliseconds per target (default: 30000)",
                    },
                },
                "required": ["targets"],
            },
        ),
        Tool(
            name="nuclei_list_templates",
            description=(
                "List available Nuclei vulnerability templates from the community template repository. Supports "
                "filtering by severity, tags, author, and search terms. Essential for understanding what "
                "vulnerabilities can be tested with nuclei_scan_template() or nuclei_scan_single(). Returns "
                "template metadata including ID, name, severity, tags, description, and CVSS score. "

                "**When to use:** Phase 3 (Assessment) before calling nuclei_scan_template() or nuclei_scan_single() "
                "to: preview template count for budget estimation (e.g., tags=['wordpress'] shows how many "
                "WordPress-specific templates exist), find specific CVE template by search='CVE-2021-44228', "
                "filter by severity=['critical','high'] to focus on serious issues, explore technology-specific "
                "templates with tags (tags=['apache','nginx','iis']). Call without filters to see full catalog. "

                "**Dependencies:** NONE - standalone read-only tool. Use before nuclei_scan_template() to plan "
                "scan scope and estimate budget. Combine with tech_detection() results to filter by relevant "
                "tags (e.g., if tech_detection found WordPress 5.8, search for WordPress templates). "

                "**Budget impact:** ZERO - no network requests, no target interaction. Queries local Nuclei "
                "template directory (nuclei-templates repo cloned locally). Returns up to limit templates "
                "(default all matching). Completes <500ms for full catalog query. "

                "**Failure modes:** Empty results if filters too restrictive (no templates match) - broaden "
                "filters or remove them. Templates directory not found if TEMPLATES_DIR misconfigured (returns "
                "empty, not error). Invalid severity values rejected by schema. Tag/author filters case-sensitive. "

                "**Risk level:** SAFE - pure documentation tool, no network activity or target interaction. Only "
                "reads local template metadata files. Does not execute any templates or contact targets. "

                "**Returns:** JSON array of template objects with: id (e.g., 'CVE-2021-44228'), name, severity "
                "(info/low/medium/high/critical), tags array (e.g., ['cve','rce','log4j']), author, description, "
                "cvss_score (if applicable), cwe_ids, cve_ids. Use to: estimate budget (count × targets = "
                "requests), identify specific template_ids for nuclei_scan_single(), filter templates by "
                "technology/severity for nuclei_scan_template()."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "severity": {
                        "oneOf": [
                            {
                                "type": "string",
                                "enum": VALID_SEVERITIES,
                            },
                            {
                                "type": "array",
                                "items": {
                                    "type": "string",
                                    "enum": VALID_SEVERITIES,
                                },
                            },
                        ],
                        "description": "Filter by severity level(s)",
                    },
                    "tags": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": 'Filter by tags (e.g., "cve", "rce", "xss")',
                    },
                    "author": {
                        "type": "string",
                        "description": "Filter by author name",
                    },
                    "search": {
                        "type": "string",
                        "description": "Search term to filter templates by ID, name, or description",
                    },
                    "limit": {
                        "type": "number",
                        "description": "Maximum number of templates to return",
                    },
                },
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_nuclei_tool(
    name: str, arguments: dict, mcp_service: Any
) -> List[TextContent]:
    """Route nuclei tool calls to the appropriate handler."""
    if name == "nuclei_scan_single":
        return await _handle_scan_single(arguments, mcp_service)
    elif name == "nuclei_scan_template":
        return await _handle_scan_template(arguments, mcp_service)
    elif name == "nuclei_list_templates":
        return await _handle_list_templates(arguments, mcp_service)
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": f"Unknown nuclei tool: {name}",
    }))]


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _validate_url(url: str) -> Optional[str]:
    """Validate that *url* is a well-formed URL.  Returns error message or None."""
    try:
        parsed = urlparse(url)
        if not parsed.scheme or not parsed.netloc:
            return f"Invalid target URL format: {url}"
        return None
    except Exception:
        return f"Invalid target URL format: {url}"


def _error_response(error_msg: str) -> List[TextContent]:
    """Return a standardised JSON error response."""
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": error_msg,
    }))]


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_scan_single(
    arguments: dict, mcp_service: Any
) -> List[TextContent]:
    """Handle nuclei_scan_single - scan a single URL with one template."""
    target = arguments.get("target")
    template_id = arguments.get("template_id")

    # Validate required parameters
    if not target or not isinstance(target, str):
        return _error_response("target is required and must be a string")

    if not template_id or not isinstance(template_id, str):
        return _error_response("template_id is required and must be a string")

    # Validate URL format
    url_error = _validate_url(target)
    if url_error:
        return _error_response(url_error)

    # Scope validation
    scope_error = await _validate_scope(target, mcp_service)
    if scope_error:
        return _error_response(scope_error)

    # Check if template exists (warn but don't block - may be a custom path)
    tm = _get_template_manager()
    if not tm.template_exists(template_id):
        logger.warning(
            "Template '%s' not found in template manager", template_id
        )

    # Run the scan
    runner = _get_nuclei_runner()
    result = await runner.scan_single(target, template_id)

    response: Dict[str, Any] = {
        "success": result["success"],
        "result": result,
    }
    if result.get("mock_mode"):
        response["warning"] = "Running in mock mode - results are simulated"

    # Auto-save findings to backend
    if result["success"] and mcp_service:
        findings = result.get("findings", [])
        if not findings and result.get("matched"):
            # Some runners return a flat result as a single finding
            findings = [result]
        for finding in findings:
            sev = (finding.get("severity") or "INFO").upper()
            tmpl = finding.get("template_id") or finding.get("template-id") or template_id
            await mcp_service.safe_add_card(
                card_type="finding",
                title=f"Nuclei: {tmpl} on {target}",
                severity=sev,
                status="confirmed",
                target_service=target,
                technical_analysis=finding.get("description", ""),
                proof=json.dumps(finding, default=str)[:2000],
                context=f"Source: nuclei, template: {template_id}",
            )

    return [TextContent(type="text", text=json.dumps(response, indent=2, default=str))]


async def _handle_scan_template(
    arguments: dict, mcp_service: Any
) -> List[TextContent]:
    """Handle nuclei_scan_template - run templates against a list of targets."""
    targets = arguments.get("targets")

    # Validate required parameters
    if not targets or not isinstance(targets, list) or len(targets) == 0:
        return _error_response("targets is required and must be a non-empty array")

    # Validate all target URLs
    for t in targets:
        url_error = _validate_url(t)
        if url_error:
            return _error_response(url_error)

    # Scope validation for each target
    for t in targets:
        scope_error = await _validate_scope(t, mcp_service)
        if scope_error:
            return _error_response(scope_error)

    template_ids: Optional[List[str]] = arguments.get("template_ids")
    tags: Optional[List[str]] = arguments.get("tags")
    severity: Optional[List[str]] = arguments.get("severity")

    # Run the scan
    runner = _get_nuclei_runner()
    results = await runner.scan_with_templates(
        targets,
        template_ids=template_ids,
        tags=tags,
        severity=severity,
    )

    all_success = all(r["success"] for r in results)
    total_findings = sum(len(r.get("findings", [])) for r in results)
    mock_mode = any(r.get("mock_mode") for r in results)

    response: Dict[str, Any] = {
        "success": all_success,
        "results": results,
        "summary": {
            "total_targets": len(targets),
            "successful_scans": sum(1 for r in results if r["success"]),
            "failed_scans": sum(1 for r in results if not r["success"]),
            "total_findings": total_findings,
        },
    }
    if mock_mode:
        response["warning"] = "Running in mock mode - results are simulated"

    # Auto-save all findings to backend
    if mcp_service:
        for scan_result in results:
            if not scan_result.get("success"):
                continue
            scan_target = scan_result.get("target", "unknown")
            for finding in scan_result.get("findings", []):
                sev = (finding.get("severity") or "INFO").upper()
                tmpl = finding.get("template_id") or finding.get("template-id") or "unknown"
                await mcp_service.safe_add_card(
                    card_type="finding",
                    title=f"Nuclei: {tmpl} on {scan_target}",
                    severity=sev,
                    status="confirmed",
                    target_service=scan_target,
                    technical_analysis=finding.get("description", ""),
                    proof=json.dumps(finding, default=str)[:2000],
                    context=f"Source: nuclei, template: {tmpl}",
                )

    return [TextContent(type="text", text=json.dumps(response, indent=2, default=str))]


async def _handle_list_templates(
    arguments: dict, mcp_service: Any
) -> List[TextContent]:
    """Handle nuclei_list_templates - list available templates with filtering."""
    severity = arguments.get("severity")
    tags = arguments.get("tags")
    author = arguments.get("author")
    search = arguments.get("search")
    limit = arguments.get("limit")

    tm = _get_template_manager()
    result = tm.list_templates(
        severity=severity,
        tags=tags,
        author=author,
        search=search,
        limit=limit,
    )

    mock_mode = tm.is_mock_mode()

    response: Dict[str, Any] = {
        "success": result["success"],
        "templates": result["templates"],
        "total_count": result["total_count"],
        "filtered_count": result["filtered_count"],
        "returned_count": len(result["templates"]),
    }
    if mock_mode:
        response["warning"] = "Running in mock mode - templates are simulated"
    if result.get("error"):
        response["error"] = result["error"]

    return [TextContent(type="text", text=json.dumps(response, indent=2, default=str))]
