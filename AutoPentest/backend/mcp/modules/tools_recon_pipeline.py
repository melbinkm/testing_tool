"""
Recon Pipeline Tools - recon_pipeline_run, recon_pipeline_status, recon_pipeline_results.

Orchestrates the 6-stage automated reconnaissance pipeline.
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict, List

from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")


from lib.tool_helpers import _json_content, _error_content


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_recon_pipeline_tools() -> List[Tool]:
    """Return the four recon pipeline tools."""
    return [
        # 1 ---- recon_pipeline_run -----------------------------------------
        Tool(
            name="recon_pipeline_run",
            description=(
                "Execute the full 6-stage automated reconnaissance pipeline in sequence: "
                "(1) subdomain enumeration, (2) Nmap service scan, (3) tech detection, "
                "(4) SSL analysis, (5) directory discovery, (6) Nuclei vulnerability scan. "
                "Idempotent — safely resumes from last completed stage on retry. "

                "**When to use:** Phase 1 (Recon) as first action after loading assessment. "
                "This is the most efficient way to perform comprehensive reconnaissance instead "
                "of calling individual tools manually. Use this for thorough discovery of a new "
                "target domain. Runs in parallel where possible (controlled by max_parallel). "

                "**Dependencies:** Requires assessment loaded and target_domain in scope. "
                "Validates scope automatically before starting. Follow with coverage_init() to "
                "build testing matrix from discovered endpoints, then crawler_start() for "
                "authenticated pages. "

                "**Budget impact:** HIGH - Full pipeline generates 500-2000 requests depending on "
                "target size. Subdomain enum (passive) → Nmap (~100 requests/host) → tech detection "
                "(~3 requests/host) → SSL (~1 request/host) → directory scan (~500 requests/host) → "
                "Nuclei (~100-1000 requests/host). Call scope_check_budget() first if budget is limited. "

                "**Failure modes:** Pipeline continues on stage failures and logs errors. If subdomain "
                "enum returns 0 results, pipeline still scans primary domain. Nmap may timeout on "
                "heavily filtered hosts (increase timeout via skip_stages). Directory scan may return "
                "empty on non-standard path naming (run authenticated crawler instead). Nuclei may "
                "trigger WAF blocks (reduce templates via skip_stages). Check status with "
                "recon_pipeline_status() during long runs. "

                "**Risk level:** CAUTION to HIGH RISK - Active scanning detectable by IDS/IPS. Nmap "
                "and directory scans generate high traffic. Nuclei exploits may trigger security alerts. "
                "Use skip_stages=['nuclei_scan'] for lower-risk reconnaissance only. "

                "**Returns:** Comprehensive recon report with subdomains, services, technologies, "
                "endpoints, and findings. All data auto-populated to world model (wm_assets, wm_endpoints) "
                "and recon tables. Use recon_pipeline_results() to retrieve detailed per-stage output. "
                "State persists across sessions - resume=true (default) continues from last stage."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target_domain": {
                        "type": "string",
                        "description": "Target domain to recon (e.g. 'example.com')",
                    },
                    "max_parallel": {
                        "type": "integer",
                        "minimum": 1,
                        "maximum": 10,
                        "description": "Max parallel scans per stage (default: 3)",
                    },
                    "skip_stages": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": [
                                "subdomain_enum", "nmap_quick", "tech_detection",
                                "ssl_analysis", "directory_discovery", "nuclei_scan",
                            ],
                        },
                        "description": "Stages to skip",
                    },
                    "resume": {
                        "type": "boolean",
                        "description": "Resume from last completed stage (default: true)",
                    },
                },
                "required": ["target_domain"],
            },
        ),

        # 2 ---- recon_pipeline_status --------------------------------------
        Tool(
            name="recon_pipeline_status",
            description=(
                "Check the progress and completion status of a running or completed recon pipeline for a target "
                "domain. Shows which stages have completed, which stage is currently running, success/failure "
                "status per stage, and overall progress percentage. Essential for monitoring long-running "
                "pipelines and troubleshooting stage failures. "

                "**When to use:** Phase 1 (Recon) during or after recon_pipeline_run() to monitor progress. "
                "Use while pipeline is running (can take 5-30 minutes for large targets) to check status. "
                "Call after pipeline completes to verify all stages succeeded before proceeding to Phase 2. "
                "If pipeline was interrupted (error, timeout, manual stop), use this to see last completed stage "
                "before resuming with recon_pipeline_run(resume=true). "

                "**Dependencies:** Requires recon_pipeline_run() to have been called for this target_domain "
                "(or attempted - tracks even failed runs). Returns 'pipeline not found' if never run for this "
                "domain. No follow-up required - pure status query. Use recon_pipeline_results() to retrieve "
                "actual discovery data after completion. "

                "**Budget impact:** ZERO - local database query of pipeline state, no network requests. Returns "
                "instantly with current progress. Pipeline state persists across sessions (PostgreSQL storage). "

                "**Failure modes:** 'Pipeline not found' if target_domain never had recon_pipeline_run() called. "
                "Status may show 'running' for stuck pipelines (restart with recon_pipeline_run to recover). "
                "Stale status if pipeline crashed mid-run (shows last known stage). "

                "**Risk level:** SAFE - read-only query of pipeline state, no network activity or target "
                "interaction. Shows only what recon_pipeline_run() has done. "

                "**Returns:** JSON with: target_domain, overall_status (not_started/running/completed/failed), "
                "current_stage (currently executing stage), completed_stages[] (successfully finished), "
                "failed_stages[] (errors encountered), progress_percentage (0-100), started_at, completed_at, "
                "stage_details[] (per-stage timing and errors). Use progress_percentage to estimate completion "
                "time, failed_stages to diagnose issues, completed_stages to verify success before Phase 2 "
                "transition."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target_domain": {
                        "type": "string",
                        "description": "Target domain to check",
                    },
                },
                "required": ["target_domain"],
            },
        ),

        # 3 ---- recon_pipeline_results -------------------------------------
        Tool(
            name="recon_pipeline_results",
            description=(
                "Get comprehensive discovery results from a completed or partially completed recon pipeline. "
                "Returns all data discovered across the 6 stages: subdomains found, services/ports detected, "
                "technologies identified, SSL/TLS info, discovered endpoints/directories, and Nuclei findings. "
                "Supports filtering to specific stage. Essential for reviewing reconnaissance output. "

                "**When to use:** Phase 1-2 (Recon/Mapping) after recon_pipeline_run() completes successfully. "
                "Use to: review all discovered subdomains before scanning, see which services/ports are open, "
                "identify technologies for targeted testing (e.g., if WordPress found, run WordPress-specific "
                "tests), review Nuclei findings before manual validation, extract discovered endpoints for "
                "coverage_init(). Filter by stage to focus on specific results (e.g., stage='nuclei_scan' for "
                "only vulnerability findings). "

                "**Dependencies:** Requires recon_pipeline_run() to have completed at least one stage. Use "
                "recon_pipeline_status() first to verify pipeline completion. Returns partial results if pipeline "
                "failed mid-run (only completed stages). All discovery data also available via list_recon(), "
                "wm_query(table='assets'), wm_query(table='endpoints') - this tool provides pipeline-specific "
                "view. "

                "**Budget impact:** ZERO - local database query of stored pipeline results, no network requests. "
                "Returns instantly with all discovery data. Results stored permanently in world model and recon "
                "tables. "

                "**Failure modes:** 'Pipeline not found' if target_domain never had recon_pipeline_run() called. "
                "Empty results {} if stage filter doesn't match any completed stages. Partial results if pipeline "
                "was interrupted (only completed stages returned). Stage filter case-sensitive (use exact enum "
                "values: 'subdomain_enum', 'nmap_quick', etc.). "

                "**Risk level:** SAFE - read-only query of stored results, no network activity or target interaction. "

                "**Returns:** JSON with comprehensive discovery data: subdomains[] (subdomain_enum stage), "
                "services[] (nmap_quick: IP, port, service, version, state), technologies[] (tech_detection: "
                "name, version, confidence), ssl_info[] (ssl_analysis: issuer, expiry, vulnerabilities), "
                "endpoints[] (directory_discovery: URL, status code, content-length), findings[] (nuclei_scan: "
                "template_id, severity, matched_url, description, remediation, CVE/CWE IDs). If stage filter "
                "specified, returns only that stage's data. Use to plan Phase 2 coverage matrix and targeted "
                "testing strategies."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target_domain": {
                        "type": "string",
                        "description": "Target domain",
                    },
                    "stage": {
                        "type": "string",
                        "enum": [
                            "subdomain_enum", "nmap_quick", "tech_detection",
                            "ssl_analysis", "directory_discovery", "nuclei_scan",
                        ],
                        "description": "Filter to a specific stage (optional)",
                    },
                },
                "required": ["target_domain"],
            },
        ),
        # 4 ---- recon_generate_report (#58) -----------------------------------
        Tool(
            name="recon_generate_report",
            description=(
                "Generate a structured 9-section reconnaissance report from world model data. "
                "Sections: scope summary, technology map, authentication flow, endpoint inventory, "
                "input vectors, network map, role architecture, and vulnerability candidates. "
                "Saves report to workspaces/{assessment_id}/recon_report.md. "

                "**When to use:** End of Phase 1 (Recon) or start of Phase 2 to consolidate "
                "all discovery data into a structured document for planning testing strategy. "

                "**Dependencies:** Requires recon_pipeline_run() or manual asset/endpoint population. "

                "**Budget impact:** ZERO - reads from local database only. "

                "**Risk level:** SAFE - read-only report generation."
            ),
            inputSchema={
                "type": "object",
                "properties": {},
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_recon_pipeline_tool(
    name: str,
    arguments: dict,
    mcp_service: Any = None,
) -> List[TextContent]:
    """Dispatch a recon pipeline tool call."""
    try:
        if mcp_service is None or mcp_service.current_assessment_id is None:
            return _error_content("No assessment loaded. Use 'load_assessment' first.")

        if name == "recon_pipeline_run":
            return await _handle_run(arguments, mcp_service)
        elif name == "recon_pipeline_status":
            return await _handle_status(arguments, mcp_service)
        elif name == "recon_pipeline_results":
            return await _handle_results(arguments, mcp_service)
        elif name == "recon_generate_report":
            return await _handle_generate_report(arguments, mcp_service)
    except Exception as exc:
        logger.error("Recon pipeline tool %s failed: %s", name, exc, exc_info=True)
        return _error_content(f"Error in {name}: {exc}")

    return _error_content(f"Unknown recon pipeline tool: {name}")


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_run(arguments: dict, mcp_service: Any) -> List[TextContent]:
    """Handle recon_pipeline_run."""
    target_domain = arguments.get("target_domain")
    if not target_domain or not isinstance(target_domain, str):
        return _error_content("target_domain is required and must be a string")

    max_parallel = arguments.get("max_parallel", 3)
    if not isinstance(max_parallel, int) or max_parallel < 1:
        max_parallel = 3
    max_parallel = min(max_parallel, 10)

    skip_stages = arguments.get("skip_stages") or []
    resume = arguments.get("resume", True)

    from lib.recon_pipeline import ReconPipeline

    pipeline = ReconPipeline(mcp_service, max_parallel=max_parallel)
    result = await pipeline.run(
        target_domain=target_domain,
        skip_stages=skip_stages,
        resume=resume,
    )

    return _json_content({
        "success": True,
        **result,
        "message": (
            f"Recon pipeline completed for {target_domain}. "
            f"Found: {result['summary']['subdomains']} subdomains, "
            f"{result['summary']['services']} services, "
            f"{result['summary']['endpoints']} endpoints, "
            f"{result['summary']['findings']} findings."
        ),
    })


async def _handle_status(arguments: dict, mcp_service: Any) -> List[TextContent]:
    """Handle recon_pipeline_status."""
    target_domain = arguments.get("target_domain")
    if not target_domain or not isinstance(target_domain, str):
        return _error_content("target_domain is required and must be a string")

    from lib.recon_pipeline import ReconPipeline

    pipeline = ReconPipeline(mcp_service)
    status = await pipeline.get_status(target_domain)

    return _json_content({
        "success": True,
        **status,
    })


async def _handle_results(arguments: dict, mcp_service: Any) -> List[TextContent]:
    """Handle recon_pipeline_results."""
    target_domain = arguments.get("target_domain")
    if not target_domain or not isinstance(target_domain, str):
        return _error_content("target_domain is required and must be a string")

    stage = arguments.get("stage")

    from lib.recon_pipeline import ReconPipeline

    pipeline = ReconPipeline(mcp_service)
    results = await pipeline.get_results(target_domain, stage=stage)

    return _json_content({
        "success": True,
        **results,
    })


async def _handle_generate_report(arguments: dict, mcp_service: Any) -> List[TextContent]:
    """Handle recon_generate_report (#58)."""
    import os

    from lib.recon_report import generate_recon_report
    from lib.world_model_db import get_world_model_db

    assessment_id = mcp_service.current_assessment_id
    db = await get_world_model_db(assessment_id)

    report = await generate_recon_report(db, assessment_id)

    # Save to workspaces/{assessment_id}/recon_report.md
    workspaces_dir = mcp_service.workspace_dir
    report_dir = os.path.join(workspaces_dir, str(assessment_id))
    os.makedirs(report_dir, exist_ok=True)
    report_path = os.path.join(report_dir, "recon_report.md")

    with open(report_path, "w", encoding="utf-8") as f:
        f.write(report)

    return _json_content({
        "success": True,
        "report": report,
        "file_path": report_path,
        "message": f"Recon report generated and saved to {report_path}",
    })
