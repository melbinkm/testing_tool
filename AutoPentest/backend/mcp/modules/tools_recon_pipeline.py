"""
Recon Pipeline Tools - recon_pipeline_run, recon_pipeline_status, recon_pipeline_results.

Orchestrates the 6-stage automated reconnaissance pipeline.
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict, List

from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _json_content(data: Any) -> List[TextContent]:
    return [TextContent(type="text", text=json.dumps(data, indent=2, default=str))]


def _error_content(message: str) -> List[TextContent]:
    return [TextContent(type="text", text=json.dumps({"success": False, "error": message}, indent=2))]


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_recon_pipeline_tools() -> List[Tool]:
    """Return the three recon pipeline tools."""
    return [
        # 1 ---- recon_pipeline_run -----------------------------------------
        Tool(
            name="recon_pipeline_run",
            description=(
                "Execute the full 6-stage automated reconnaissance pipeline: "
                "subdomain enumeration, Nmap service scan, tech detection, "
                "SSL analysis, directory discovery, and Nuclei scan. "
                "Idempotent â€” resumes from where it left off."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target_domain": {
                        "type": "string",
                        "description": "Target domain to recon (e.g. 'example.com')",
                    },
                    "max_parallel": {
                        "type": "integer",
                        "minimum": 1,
                        "maximum": 10,
                        "description": "Max parallel scans per stage (default: 3)",
                    },
                    "skip_stages": {
                        "type": "array",
                        "items": {
                            "type": "string",
                            "enum": [
                                "subdomain_enum", "nmap_quick", "tech_detection",
                                "ssl_analysis", "directory_discovery", "nuclei_scan",
                            ],
                        },
                        "description": "Stages to skip",
                    },
                    "resume": {
                        "type": "boolean",
                        "description": "Resume from last completed stage (default: true)",
                    },
                },
                "required": ["target_domain"],
            },
        ),

        # 2 ---- recon_pipeline_status --------------------------------------
        Tool(
            name="recon_pipeline_status",
            description="Check the progress of a recon pipeline for a target domain.",
            inputSchema={
                "type": "object",
                "properties": {
                    "target_domain": {
                        "type": "string",
                        "description": "Target domain to check",
                    },
                },
                "required": ["target_domain"],
            },
        ),

        # 3 ---- recon_pipeline_results -------------------------------------
        Tool(
            name="recon_pipeline_results",
            description="Get full discovery results from a completed recon pipeline.",
            inputSchema={
                "type": "object",
                "properties": {
                    "target_domain": {
                        "type": "string",
                        "description": "Target domain",
                    },
                    "stage": {
                        "type": "string",
                        "enum": [
                            "subdomain_enum", "nmap_quick", "tech_detection",
                            "ssl_analysis", "directory_discovery", "nuclei_scan",
                        ],
                        "description": "Filter to a specific stage (optional)",
                    },
                },
                "required": ["target_domain"],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_recon_pipeline_tool(
    name: str,
    arguments: dict,
    mcp_service: Any = None,
) -> List[TextContent]:
    """Dispatch a recon pipeline tool call."""
    try:
        if mcp_service is None or mcp_service.current_assessment_id is None:
            return _error_content("No assessment loaded. Use 'load_assessment' first.")

        if name == "recon_pipeline_run":
            return await _handle_run(arguments, mcp_service)
        elif name == "recon_pipeline_status":
            return await _handle_status(arguments, mcp_service)
        elif name == "recon_pipeline_results":
            return await _handle_results(arguments, mcp_service)
    except Exception as exc:
        logger.error("Recon pipeline tool %s failed: %s", name, exc, exc_info=True)
        return _error_content(f"Error in {name}: {exc}")

    return _error_content(f"Unknown recon pipeline tool: {name}")


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_run(arguments: dict, mcp_service: Any) -> List[TextContent]:
    """Handle recon_pipeline_run."""
    target_domain = arguments.get("target_domain")
    if not target_domain or not isinstance(target_domain, str):
        return _error_content("target_domain is required and must be a string")

    max_parallel = arguments.get("max_parallel", 3)
    if not isinstance(max_parallel, int) or max_parallel < 1:
        max_parallel = 3
    max_parallel = min(max_parallel, 10)

    skip_stages = arguments.get("skip_stages") or []
    resume = arguments.get("resume", True)

    from lib.recon_pipeline import ReconPipeline

    pipeline = ReconPipeline(mcp_service, max_parallel=max_parallel)
    result = await pipeline.run(
        target_domain=target_domain,
        skip_stages=skip_stages,
        resume=resume,
    )

    return _json_content({
        "success": True,
        **result,
        "message": (
            f"Recon pipeline completed for {target_domain}. "
            f"Found: {result['summary']['subdomains']} subdomains, "
            f"{result['summary']['services']} services, "
            f"{result['summary']['endpoints']} endpoints, "
            f"{result['summary']['findings']} findings."
        ),
    })


async def _handle_status(arguments: dict, mcp_service: Any) -> List[TextContent]:
    """Handle recon_pipeline_status."""
    target_domain = arguments.get("target_domain")
    if not target_domain or not isinstance(target_domain, str):
        return _error_content("target_domain is required and must be a string")

    from lib.recon_pipeline import ReconPipeline

    pipeline = ReconPipeline(mcp_service)
    status = await pipeline.get_status(target_domain)

    return _json_content({
        "success": True,
        **status,
    })


async def _handle_results(arguments: dict, mcp_service: Any) -> List[TextContent]:
    """Handle recon_pipeline_results."""
    target_domain = arguments.get("target_domain")
    if not target_domain or not isinstance(target_domain, str):
        return _error_content("target_domain is required and must be a string")

    stage = arguments.get("stage")

    from lib.recon_pipeline import ReconPipeline

    pipeline = ReconPipeline(mcp_service)
    results = await pipeline.get_results(target_domain, stage=stage)

    return _json_content({
        "success": True,
        **results,
    })
