"""
Browser Tools - 24 browser automation tools for security testing.

Ported from browser-mcp TypeScript server to Python.

Tools:
  1.  browser_session_create    - Create a new browser session
  2.  browser_session_close     - Close a browser session
  3.  browser_navigate          - Navigate to a URL
  4.  browser_discover_forms    - Find all forms on page
  5.  browser_test_xss          - Test forms for XSS vulnerabilities
  6.  browser_screenshot        - Capture page screenshot
  7.  browser_get_state         - Get page cookies, URL, title, storage
  8.  browser_click             - Click element by selector
  9.  browser_fill              - Fill input by selector
  10. browser_eval              - Execute JavaScript
  11. browser_get_elements      - Get element info by selector
  12. browser_press_key         - Press keyboard key
  13. browser_wait              - Wait for condition
  14. browser_dismiss_popups    - Auto-dismiss common popups
  15. browser_type              - Type text character by character
  16. browser_login             - Execute declarative login flow
  17. browser_ws_connect        - Establish WebSocket connection via JS
  18. browser_ws_send           - Send message over WebSocket
  19. browser_ws_listen         - Listen for WebSocket messages
  20. browser_instrument_dom    - Install DOM MutationObserver
  21. browser_get_dom_mutations - Retrieve DOM mutation log
  22. browser_new_tab           - Open new browser tab
  23. browser_switch_tab        - Switch active tab
  24. browser_postmessage_test  - Test postMessage security
"""

from __future__ import annotations

import json
import logging
import os
from typing import Any, Dict, List, Optional

from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")

# ---------------------------------------------------------------------------
# Lazy-initialized singletons (per-assessment cache invalidation)
# ---------------------------------------------------------------------------

_session_manager = None
_form_analyzer = None
_xss_detector = None
_browser_cache_assessment_id = None


def _get_session_manager(assessment_id=None):
    """Lazily initialize and return the SessionManager singleton.

    Uses assessment_id if provided, else ENGAGEMENT_ID env var, else 'default'.
    Invalidates all browser singletons when assessment_id changes.
    """
    global _session_manager, _form_analyzer, _xss_detector, _browser_cache_assessment_id

    # Invalidate cache if assessment changed
    if _session_manager is not None and assessment_id != _browser_cache_assessment_id:
        _session_manager = None
        _form_analyzer = None
        _xss_detector = None
        _browser_cache_assessment_id = None

    if _session_manager is None:
        if assessment_id is not None:
            engagement_id = str(assessment_id)
        else:
            engagement_id = os.environ.get("ENGAGEMENT_ID", "default")

        from lib.browser_session import CorrelationManager, SessionManager

        # Optionally load scope validator
        scope_validator = None
        try:
            from lib.scope_loader import load_scope_from_env
            from lib.scope_validator import TargetValidator
            scope = load_scope_from_env()
            if scope:
                scope_validator = TargetValidator(scope)
        except Exception:
            logger.info("Scope validator not available for browser sessions")

        correlation = CorrelationManager(engagement_id)
        max_sessions = int(os.environ.get("MAX_BROWSER_SESSIONS", "5"))
        _session_manager = SessionManager(
            correlation_manager=correlation,
            scope_validator=scope_validator,
            max_sessions=max_sessions,
        )
        _browser_cache_assessment_id = assessment_id
    return _session_manager


def _get_form_analyzer():
    """Lazily initialize and return the FormAnalyzer singleton."""
    global _form_analyzer
    if _form_analyzer is None:
        from lib.browser_forms import FormAnalyzer
        _form_analyzer = FormAnalyzer()
    return _form_analyzer


def _get_xss_detector():
    """Lazily initialize and return the XSSDetector singleton."""
    global _xss_detector
    if _xss_detector is None:
        from lib.browser_xss import XSSDetector
        _xss_detector = XSSDetector()
    return _xss_detector


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

from lib.tool_helpers import _json_content, _error_content


def _require_active_session(session_id: Optional[str] = None):
    """Get a session, raising a clear error if none is active.

    Parameters
    ----------
    session_id : str, optional
        Specific session ID. If None, the active session is used.

    Returns
    -------
    BrowserSessionWrapper
    """
    mgr = _get_session_manager()
    if session_id:
        session = mgr.get_session(session_id)
        if not session:
            raise ValueError(f"Session not found: {session_id}")
        return session
    session = mgr.get_active_session()
    if not session:
        raise ValueError(
            "No active browser session. Use browser_session_create first."
        )
    return session


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_browser_tools() -> List[Tool]:
    """Return all 24 browser tool definitions."""
    return [
        # 1. browser_session_create
        Tool(
            name="browser_session_create",
            description=(
                "Create a new Playwright browser session with optional proxy routing, headless mode, viewport "
                "configuration, and custom User-Agent. Returns session_id for subsequent browser operations. Supports "
                "up to MAX_BROWSER_SESSIONS concurrent sessions (default 5). Essential for browser-based testing, "
                "JavaScript-heavy applications, and workflows requiring browser state management. "

                "**When to use:** Phase 2 (Mapping) at start of browser-based testing workflows. Create session "
                "BEFORE browser_navigate() or any browser_* operations. Use headless=false for debugging (see browser "
                "window), headless=true for automated testing (default, faster). Set proxy_url to route through "
                "Burp/ZAP for request inspection and modification. Multiple sessions useful for: parallel testing, "
                "session isolation, testing as different users simultaneously. "

                "**Dependencies:** No prerequisites - creates new isolated browser context. Optionally configure "
                "proxy_url (http://127.0.0.1:8080 for Burp Suite) for request interception. Follow with browser_navigate() "
                "to load target page, then browser interactions. Use browser_session_close() when done to free resources. "
                "Sessions auto-closed on server restart but explicit cleanup recommended. "

                "**Budget impact:** LOW - session creation itself no network requests. Creates isolated browser context "
                "with cookies, storage, cache. Browser startup: ~1 second headless, ~2-3 seconds headful. Session persists "
                "until explicitly closed or server restart. Each session consumes ~50-100MB RAM. "

                "**Failure modes:** 'Max sessions exceeded' if MAX_BROWSER_SESSIONS limit reached (close unused sessions "
                "with browser_session_close). 'Playwright not installed' requires Playwright browser binaries (run "
                "'playwright install'). 'Proxy connection failed' if proxy_url unreachable (verify Burp/ZAP running). "
                "Headful mode (headless=false) may fail in Docker/headless environments (use headless=true). "

                "**Risk level:** SAFE - Creates local browser instance, no target interaction yet. Browser capabilities "
                "enable JavaScript execution and full web platform access in subsequent operations. Proxy routing sends "
                "all traffic through specified proxy for inspection (use responsibly). All sessions tracked with correlation. "

                "**Returns:** Session creation result with: session_id (UUID for subsequent operations), is_active (true), "
                "headless (boolean), proxy_configured (boolean), viewport (dimensions), user_agent (string), created_at "
                "(timestamp). Store session_id for use with other browser_* tools or omit to use active session (most recent "
                "created). Use browser_session_close(session_id) when finished."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": (
                            "Custom session ID for named sessions (e.g. '5_agent_alpha' for assessment 5, agent alpha). "
                            "If a session with this ID already exists and is active, it is reused. "
                            "If omitted, a random ID is generated. Use for per-agent browser isolation."
                        ),
                    },
                    "headless": {
                        "type": "boolean",
                        "description": "Run browser in headless mode (default: true)",
                    },
                    "proxy_url": {
                        "type": "string",
                        "description": "HTTP proxy URL (e.g. http://127.0.0.1:8080 for Burp Suite)",
                    },
                    "viewport": {
                        "type": "object",
                        "properties": {
                            "width": {"type": "integer"},
                            "height": {"type": "integer"},
                        },
                        "description": "Browser viewport size",
                    },
                    "user_agent": {
                        "type": "string",
                        "description": "Custom User-Agent string",
                    },
                },
            },
        ),
        # 2. browser_session_close
        Tool(
            name="browser_session_close",
            description=(
                "Close a browser session by ID, or close the active session if no ID provided. Terminates browser "
                "process, clears cookies/storage/cache, and frees resources. Essential cleanup after browser-based "
                "testing to prevent resource exhaustion. "

                "**When to use:** Phase 2-3 (Mapping/Assessment) after completing browser workflow. Close session when: "
                "finished with target site, switching to different target, reached session limit (MAX_BROWSER_SESSIONS), "
                "need fresh state (clear cookies/storage). Good practice: close sessions promptly to free RAM (~50-100MB "
                "per session). "

                "**Dependencies:** Requires existing session from browser_session_create(). No follow-up tools - terminal "
                "operation for session lifecycle. Create new session with browser_session_create() if more testing needed. "

                "**Budget impact:** LOW - no network requests, terminates browser process and frees resources instantly. "

                "**Failure modes:** 'Session not found' if session_id doesn't exist (already closed or never created). "
                "Closing active session makes subsequent browser_* calls fail until new session created. "

                "**Risk level:** SAFE - local cleanup operation, no network activity or target interaction. "

                "**Returns:** Close confirmation with: session_id (closed), success (boolean), message. Session no longer "
                "usable after close - create new session for additional testing."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID to close (closes active session if omitted)",
                    },
                },
            },
        ),
        # 3. browser_navigate
        Tool(
            name="browser_navigate",
            description=(
                "Navigate the browser to a URL with automatic scope validation and configurable wait conditions. "
                "Loads target page in Playwright-controlled browser, executing JavaScript and rendering dynamic "
                "content. Essential for testing client-side applications, JavaScript-heavy pages, and workflows "
                "requiring browser context (cookies, storage, DOM manipulation). "

                "**When to use:** Phase 2-3 (Mapping/Assessment) as first step in browser-based testing. Use for: "
                "single-page applications (SPAs) requiring JS execution, pages with client-side routing, login pages "
                "requiring cookie/storage handling, pages with dynamic content loading, XSS testing requiring DOM "
                "verification. Call before browser_discover_forms(), browser_click(), browser_fill(), browser_screenshot(). "
                "Prefer over http_send() when JavaScript execution or browser state needed. "

                "**Dependencies:** Requires browser_session_create() to have created active session. URL automatically "
                "validated against engagement scope (scope_validate_target logic). Follow with browser_discover_forms() "
                "to map inputs, browser_get_state() to capture cookies/storage, browser_screenshot() for evidence, "
                "or browser_wait() if dynamic content loads after initial navigation. "

                "**Budget impact:** MEDIUM - 1 navigation = multiple network requests (page + resources: CSS, JS, images, "
                "API calls). Typical page: 10-50 requests. SPA: 20-100 requests. Each tracked against budget. Use "
                "wait_until='domcontentloaded' instead of 'load' to skip waiting for all resources (faster, less budget). "
                "Check scope_check_budget() before navigating to many pages. "

                "**Failure modes:** 'URL out of scope' if target not in allowlist (check scope_validate_target first). "
                "'Timeout' if page slow to load - increase timeout parameter (default 30s) or use wait_until='commit' "
                "for immediate return. 'Navigation failed' may indicate: URL doesn't exist (404), redirect out of scope "
                "(blocked), SSL/TLS errors, WAF blocking. 'No active session' requires browser_session_create() first. "

                "**Risk level:** CAUTION - Loads target page with JavaScript execution. Executes any client-side code "
                "in page (including malicious JS if present). Logged in target server logs with browser User-Agent. "
                "Detectable by analytics, fingerprinting, bot detection. Proxy support available for inspection (set "
                "proxy_url in browser_session_create). All navigation tracked with correlation IDs for audit trail. "

                "**Returns:** Navigation result with: url (final URL after redirects), title (page title), status "
                "(HTTP status code if available), timing (load duration ms), correlation_id (for tracking). Use to: "
                "verify navigation success, detect redirects (compare final URL to requested), capture page state for "
                "analysis. Follow with browser_get_state() for cookies/localStorage if authentication workflow."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "The URL to navigate to",
                    },
                    "wait_until": {
                        "type": "string",
                        "enum": ["load", "domcontentloaded", "networkidle", "commit"],
                        "description": "When to consider navigation complete (default: load)",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Navigation timeout in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["url"],
            },
        ),
        # 4. browser_discover_forms
        Tool(
            name="browser_discover_forms",
            description=(
                "Find and analyze all HTML forms on the current page. Extracts form attributes, "
                "input fields, validation rules, CSRF tokens, and submission endpoints. Identifies "
                "all input vectors for injection testing. "

                "**When to use:** Phase 2 (Mapping) after loading a page with browser_navigate(). "
                "Run on login pages, search forms, user profile pages, admin panels, and any page "
                "with user input. Essential for identifying all input vectors before vulnerability "
                "assessment. Prefer this over manual HTML parsing for complete form discovery. "

                "**Dependencies:** Requires active browser session with page already loaded via "
                "browser_navigate(). Target URL must be in scope (validated automatically on navigate). "
                "Follow with browser_test_xss() for automated testing, or browser_fill() + browser_click() "
                "for manual injection tests. "

                "**Budget impact:** LOW - no additional page loads, analysis happens in browser context. "
                "JavaScript execution to find forms completes in <1 second. "

                "**Failure modes:** JavaScript-generated forms may not be detected if they load after "
                "initial page render - use browser_wait(selector) before discovery. Shadow DOM forms "
                "and iframe forms are not detected (limitation of current implementation). Returns empty "
                "array if page has no forms (expected for API endpoints or single-page-apps without forms). "

                "**Risk level:** SAFE - read-only page introspection, no form submission or data "
                "modification. No additional network requests. "

                "**Returns:** Array of forms with: action URL, HTTP method, input fields (name, type, "
                "required, pattern, maxlength, autocomplete, placeholder), detected CSRF tokens, hidden "
                "fields, submit button text, validation rules. Use to map all input vectors and identify "
                "missing CSRF protection or weak client-side validation."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 7. browser_test_xss
        Tool(
            name="browser_test_xss",
            description=(
                "Test forms on the current page for XSS vulnerabilities by injecting payloads and detecting execution. "
                "Automatically fills forms with XSS payloads, submits, and checks for JavaScript execution using DOM "
                "alerts, script tags, and event handlers. Comprehensive automated XSS detection for reflected, stored, "
                "and DOM-based XSS. HIGH RISK - actively injects attack payloads. "

                "**When to use:** Phase 3 (Assessment) after browser_discover_forms() identifies input vectors. Automated "
                "XSS testing across all forms on page. Faster than manual browser_fill + browser_click per field. Use "
                "for: login forms, search boxes, comment fields, profile updates, any user input. "

                "**Dependencies:** Requires browser_navigate() to load page with forms, browser_discover_forms() identifies "
                "testable inputs. Follow with validate_repro() if XSS found, browser_screenshot() for visual proof, "
                "evidence_bundle() to document. Custom payloads optional (uses comprehensive default set). "

                "**Budget impact:** MEDIUM to HIGH - N form submissions where N = forms × testable fields × payloads. "
                "Default payloads: ~10 per field. Page with 2 forms, 5 inputs each, 10 payloads = 100 requests. "

                "**Failure modes:** WAF may block payloads (403/429) - indicates detection. False positives rare but "
                "check with browser_eval if unsure. No forms found requires browser_discover_forms first. "

                "**Risk level:** HIGH RISK - Injects malicious XSS payloads that execute JavaScript. May trigger: "
                "script execution, cookie theft (if httpOnly missing), DOM manipulation, IDS alerts. Highly detectable. "

                "**Returns:** XSS test results with vulnerabilities_found array (field, payload, execution_context), "
                "forms_tested, fields_tested, payloads_tested counts. Auto-creates finding cards for confirmed XSS."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "form_selector": {
                        "type": "string",
                        "description": "CSS selector for the form to test (tests all forms if omitted)",
                    },
                    "field_name": {
                        "type": "string",
                        "description": "Specific field name to test (tests all testable fields if omitted)",
                    },
                    "payloads": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Custom XSS payloads (uses defaults if omitted)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 8. browser_screenshot
        Tool(
            name="browser_screenshot",
            description=(
                "Capture screenshot of current page in PNG or JPEG format. Supports full-page scrolling capture or "
                "visible viewport only. Essential for visual evidence collection, XSS proof, UI behavior documentation, "
                "and client deliverables. Returns base64-encoded image or saves to file. "

                "**When to use:** Phase 3-4 (Assessment/Exploitation) for evidence collection. Capture after: XSS "
                "payload execution (visual proof), authentication bypass (show admin panel), error messages (SQL errors, "
                "debug info), successful exploitation. Use full_page=true for complete documentation, false for specific "
                "element focus. "

                "**Dependencies:** Requires browser_navigate() to load target page. Capture before state changes or "
                "after specific action (browser_click, browser_fill). Follow with evidence_add_artifact(type='screenshot') "
                "to attach to evidence bundle. "

                "**Budget impact:** LOW - no additional network requests, captures current DOM render. PNG generation "
                "<500ms, JPEG faster but lossy. Full-page screenshots larger (1-5MB) than viewport (100-500KB). "

                "**Failure modes:** Empty/black screenshot if page not loaded (wait for browser_navigate completion). "
                "Dynamic content may not render (use browser_wait first). Path write errors if directory doesn't exist. "

                "**Risk level:** SAFE - read-only capture, no target interaction or state modification. Screenshot may "
                "contain sensitive data (PII, credentials) - redact before sharing if include_redacted=false in export. "

                "**Returns:** Screenshot result with: base64 (image data if path omitted), path (file location if saved), "
                "format (png/jpeg), dimensions (width × height), size_bytes. Use base64 for evidence_add_artifact() or "
                "path for file-based reports."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "File path to save screenshot (returns base64 if omitted)",
                    },
                    "full_page": {
                        "type": "boolean",
                        "description": "Capture full scrollable page (default: false)",
                    },
                    "format": {
                        "type": "string",
                        "enum": ["png", "jpeg"],
                        "description": "Image format (default: png)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 9. browser_get_state
        Tool(
            name="browser_get_state",
            description=(
                "Get current page state including URL, title, cookies, localStorage, and sessionStorage. Essential for "
                "capturing authentication state, analyzing storage-based vulnerabilities, and verifying navigation results. "

                "**When to use:** Phase 2-3 after browser_navigate() or browser_click() to capture state changes. Use for: "
                "extracting session tokens (cookies/storage), verifying successful authentication, analyzing client-side "
                "data storage, detecting XSS in storage, documenting navigation behavior. "

                "**Dependencies:** Requires browser_navigate() to load page. Follow with wm_store() to save interesting "
                "state, credentials_add() if auth tokens found, or evidence_add_artifact() for documentation. "

                "**Budget impact:** LOW - no network requests, queries browser context locally. "

                "**Failure modes:** Empty storage if page hasn't set any. httpOnly cookies not accessible via JavaScript. "

                "**Risk level:** SAFE - read-only query of browser state, no modification or target interaction. May "
                "expose sensitive tokens - handle securely. "

                "**Returns:** State object with: url (current), title, cookies array (name/value/domain/path/secure/"
                "httpOnly), localStorage object, sessionStorage object, origin. Use cookies for auth analysis, storage "
                "for client-side vuln detection."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 10. browser_click
        Tool(
            name="browser_click",
            description=(
                "Click an element identified by CSS selector. Waits for element to be visible and clickable before "
                "clicking. Simulates real user click with mouse events and JavaScript-triggered behaviors. Essential "
                "for interacting with buttons, links, form submissions, dropdowns, and dynamic UI elements requiring "
                "click activation. "

                "**When to use:** Phase 2-3 (Mapping/Assessment) for browser interaction workflows. Use to: submit "
                "forms after browser_fill() (click submit button), trigger navigation (click links), activate dropdowns "
                "(click to expand), test JavaScript event handlers, trigger AJAX requests, interact with SPAs. Common "
                "sequences: browser_navigate → browser_fill → browser_click (login), browser_click → browser_wait "
                "(wait for modal), browser_click → browser_screenshot (capture result). "

                "**Dependencies:** Requires browser_navigate() to have loaded page with target element. Element must "
                "match CSS selector and be visible/clickable (waits automatically until timeout). Follow with browser_wait() "
                "if click triggers navigation or dynamic content load, browser_get_state() to capture updated cookies/"
                "storage, browser_screenshot() for visual evidence. Use browser_get_elements() first if unsure about selector. "

                "**Budget impact:** LOW - click action itself no requests. However click may trigger: form submission "
                "(1 request), AJAX calls (1-10 requests), navigation (10-50 requests), downloads. Budget impact depends "
                "on what click triggers. Typical button click: 1-5 requests. Submit form: 1 request + redirect. "

                "**Failure modes:** 'Element not found' if selector doesn't match any element (verify with "
                "browser_get_elements first). 'Element not visible' if hidden/offscreen - use browser_eval to scroll "
                "or browser_wait to wait for visibility. 'Element not clickable' if covered by overlay - use "
                "browser_dismiss_popups() first or click overlay's close button. 'Timeout' if element never becomes "
                "clickable - increase timeout or verify selector. Click succeeded but nothing happened may indicate "
                "JS error - check browser console with browser_eval('console.error'). "

                "**Risk level:** CAUTION to HIGH RISK depending on element clicked. Clicking 'Search' button = low "
                "risk. Clicking 'Delete Account' or 'Approve Payment' = high risk (may perform destructive actions). "
                "Verify element purpose with browser_get_elements() before clicking. All clicks logged with correlation. "
                "Detectable in analytics and server logs as user interactions. "

                "**Returns:** Click result with: success (boolean), selector (what was clicked), timing_ms (how long "
                "to click), correlation_id. Use to verify click succeeded. Follow with browser_wait() if expecting "
                "page changes, browser_get_state() to see updated state. Note: success=true means element was clicked, "
                "not that desired action completed (verify separately with assertions)."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector for the element to click",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Click timeout in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector"],
            },
        ),
        # 11. browser_fill
        Tool(
            name="browser_fill",
            description=(
                "Fill an input field with a value (clears existing content first). Waits for input element to be "
                "visible and editable before filling. Faster than browser_type() - sets value instantly rather than "
                "character-by-character. Use for form filling, authentication, search inputs, and any text input "
                "requiring population. "

                "**When to use:** Phase 2-3 (Mapping/Assessment) for form interaction workflows. Use browser_fill() "
                "for most inputs (fast, efficient). Use browser_type() only when: testing keypress handlers, bypassing "
                "paste detection, simulating real typing. Common sequences: browser_navigate(login_url) → "
                "browser_fill('#username', 'admin') → browser_fill('#password', 'pass') → browser_click('#submit'), "
                "or browser_fill('#search', payload) → browser_click('#search-btn') for injection testing. "

                "**Dependencies:** Requires browser_navigate() to have loaded page with input element. Input must "
                "match CSS selector and be visible/editable. Use browser_discover_forms() first to identify input "
                "selectors (name attributes). Follow with browser_click() to submit form, browser_screenshot() for "
                "evidence if testing injection, or browser_wait() if fill triggers dynamic behavior. "

                "**Budget impact:** LOW - fill action itself no requests. However filling may trigger: input validation "
                "AJAX (1 request), autocomplete lookups (1-5 requests), real-time search (N requests per keystroke if "
                "using browser_type). browser_fill() is instant so no progressive requests. Check what fill triggers "
                "in browser_get_state() or network panel. "

                "**Failure modes:** 'Input not found' if selector doesn't match any element (verify with browser_get_elements). "
                "'Input not editable' if disabled/readonly - check element attributes with browser_get_elements first. "
                "'Value not set' may indicate: JavaScript clearing value immediately (use browser_type instead), "
                "input type incompatible (use browser_eval to set value directly), element not an input (verify selector). "
                "Fill succeeded but form validation fails may indicate: client-side validation rules, required format not met. "

                "**Risk level:** CAUTION - Fills user-controlled values into input fields. Risk depends on value "
                "filled: benign usernames = low risk, XSS payloads = medium risk (no execution until submission), "
                "SQL injection strings = medium risk, command injection = medium risk. Actual risk occurs on browser_click "
                "(form submission). All fills logged with correlation. Use browser_fill for normal inputs, validate "
                "dangerous payloads with browser_test_xss() for systematic testing. "

                "**Returns:** Fill result with: success (boolean), selector (what was filled), value_length (characters "
                "filled), timing_ms, correlation_id. Use to verify fill succeeded. Follow with browser_click() to "
                "submit form, browser_screenshot() if testing visual behavior, or browser_eval() to inspect actual "
                "input value after fill. Note: success=true means value was set, not that form validation passed."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector for the input element",
                    },
                    "value": {
                        "type": "string",
                        "description": "Value to fill into the input",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Timeout in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector", "value"],
            },
        ),
        # 12. browser_eval
        Tool(
            name="browser_eval",
            description=(
                "Execute JavaScript in the page context and return the result. Powerful tool for DOM manipulation, "
                "custom checks, XSS verification, and bypassing client-side controls. Use for: testing XSS execution "
                "(document.cookie access), inspecting DOM state, modifying page behavior, extracting dynamic data. "

                "**When to use:** Phase 3 for advanced testing: verify XSS payload execution, extract dynamically "
                "loaded data, test httpOnly cookie protection, bypass client-side validation, inspect CSP headers, "
                "trigger custom events. More flexible than browser_get_state() for specific queries. "

                "**Dependencies:** Requires browser_navigate() to load page. Use after browser_fill/click for testing "
                "post-interaction state. Follow with evidence_add_artifact() to document results. "

                "**Budget impact:** LOW - executes in browser context, no network requests unless code makes fetch/XHR. "

                "**Failure modes:** JavaScript errors return as result. Sandboxed context may limit access to certain APIs. "
                "CSP may block eval() but not this (runs in page context). "

                "**Risk level:** CAUTION to HIGH - executes arbitrary JavaScript. Can: modify page state, trigger actions, "
                "extract sensitive data, bypass controls. Use responsibly - avoid destructive operations. "

                "**Returns:** Evaluation result with: result (JavaScript return value), success, error (if execution failed). "
                "Supports primitives, objects, arrays (JSON-serializable). Use for dynamic analysis and custom testing logic."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "expression": {
                        "type": "string",
                        "description": "JavaScript expression to evaluate",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["expression"],
            },
        ),
        # 13. browser_get_elements
        Tool(
            name="browser_get_elements",
            description=(
                "Get information about elements matching a CSS selector. Returns tag names, attributes, visibility, "
                "text content, and positions. Use for: verifying element existence before interaction, inspecting "
                "element properties, mapping page structure, validating selectors before browser_click/fill. "

                "**When to use:** Phase 2-3 before browser interactions. Use to: verify selector matches target element, "
                "check element visibility/clickability, extract element attributes (id, class, data-*), understand page "
                "structure, debug interaction failures. "

                "**Dependencies:** Requires browser_navigate() to load page. Use before browser_click/fill to verify "
                "target exists. "

                "**Budget impact:** LOW - queries DOM in browser context, no network requests. "

                "**Failure modes:** Empty array if selector matches nothing (verify selector syntax). "

                "**Risk level:** SAFE - read-only DOM inspection, no modification or interaction. "

                "**Returns:** Elements array with: tag_name, attributes (id, class, etc.), text_content, visible (boolean), "
                "position (x, y), dimensions (width, height). Use to verify targets before interaction or extract data."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector to match elements",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector"],
            },
        ),
        # 14. browser_press_key
        Tool(
            name="browser_press_key",
            description=(
                "Press a keyboard key with optional modifiers (Control, Shift, Alt, Meta). Use for: submitting forms "
                "(Enter), navigating (Tab), triggering keyboard shortcuts (Ctrl+S), dismissing dialogs (Escape), "
                "testing keyboard event handlers. "

                "**When to use:** Phase 2-3 for keyboard-based interactions. Use when: Enter key submits form (alternative "
                "to browser_click), Tab navigates between fields, keyboard shortcuts trigger actions, testing keyboard "
                "event handlers, dismissing modals (Escape). "

                "**Dependencies:** Requires browser_navigate() and optionally browser_fill() to focus input. Works on "
                "currently focused element or document if no focus. "

                "**Budget impact:** LOW - key press no network requests unless triggers form submission or AJAX. "

                "**Failure modes:** Key press ignored if no element focused or page doesn't handle event. "

                "**Risk level:** CAUTION - key press may trigger actions like form submission, navigation, or JavaScript. "

                "**Returns:** Key press result with: key, modifiers, success, timing_ms."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Key to press (e.g. Enter, Tab, Escape, a, F5)",
                    },
                    "modifiers": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Modifier keys (e.g. Control, Shift, Alt, Meta)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["key"],
            },
        ),
        # 15. browser_wait
        Tool(
            name="browser_wait",
            description=(
                "Wait for a CSS selector to appear or wait fixed milliseconds. Essential for handling dynamic content, "
                "AJAX responses, animations, and asynchronous page updates. Use condition as CSS selector (wait for "
                "element) or milliseconds string (fixed delay). "

                "**When to use:** Phase 2-3 after actions triggering dynamic updates. Use after: browser_click() that "
                "loads modal/dropdown, browser_fill() that triggers AJAX autocomplete, browser_navigate() to SPA that "
                "loads async, form submission that shows results dynamically. Wait for element appearance before "
                "interaction or content extraction. "

                "**Dependencies:** Requires browser_navigate() to load page. Use before browser_get_elements/click/fill "
                "on dynamically loaded content. "

                "**Budget impact:** LOW - waits in browser context, no additional requests. Waiting itself free. "

                "**Failure modes:** Timeout if selector never appears (verify selector correct, check if element truly loads). "

                "**Risk level:** SAFE - passive waiting, no interaction or modification. "

                "**Returns:** Wait result with: condition, waited_ms, found (boolean if selector), timeout (boolean)."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "condition": {
                        "type": "string",
                        "description": "CSS selector to wait for, or milliseconds (e.g. '2000')",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Maximum wait time in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["condition"],
            },
        ),
        # 16. browser_dismiss_popups
        Tool(
            name="browser_dismiss_popups",
            description=(
                "Auto-dismiss common popups including JavaScript alert/confirm/prompt dialogs, cookie consent banners, "
                "GDPR notices, newsletter overlays, and age verification screens. Improves automation reliability by "
                "removing blocking overlays before interaction. "

                "**When to use:** Phase 2-3 immediately after browser_navigate() if site has popups, or before browser_click "
                "if element blocked by overlay. Use proactively on: EU sites (GDPR/cookie banners), commercial sites "
                "(newsletter popups), adult content (age verification), sites with alert() dialogs. "

                "**Dependencies:** Requires browser_navigate() to load page with popups. Call before browser_click/fill "
                "if overlays block interaction. "

                "**Budget impact:** LOW - executes JavaScript to find and dismiss popups, no network requests. "

                "**Failure modes:** May not dismiss all popup types (new/unknown patterns). Safe to call even if no popups. "

                "**Risk level:** SAFE to CAUTION - dismisses overlays which may accept default options (cookies accepted, "
                "age confirmed). Review site policies if compliance matters. "

                "**Returns:** Dismissal result with: dismissed_count, popup_types (cookie_banner, alert, overlay), success."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 17. browser_type
        Tool(
            name="browser_type",
            description=(
                "Type text character by character into an element, simulating real user typing with configurable delay "
                "between keystrokes. Slower than browser_fill() but triggers keypress/keydown/keyup events. Use for: "
                "testing real-time validation, bypassing paste detection, triggering autocomplete/suggestions, simulating "
                "human typing behavior. "

                "**When to use:** Phase 3 when browser_fill() insufficient. Use when: testing keypress event handlers, "
                "real-time input validation (character-by-character), autocomplete requires typing (not paste), bypassing "
                "paste detection, simulating human behavior for bot detection. Default to browser_fill() for speed - use "
                "this only when keystroke events matter. "

                "**Dependencies:** Requires browser_navigate() and element exists at selector. Input must be visible/editable. "

                "**Budget impact:** LOW to MEDIUM - typing itself no requests, but may trigger: real-time validation AJAX "
                "(N requests for N characters), autocomplete lookups (multiple requests), search-as-you-type. Delay parameter "
                "controls speed (default 50ms per char = 20 chars/second). "

                "**Failure modes:** Slower than browser_fill() - not suitable for long text. Element not editable if "
                "disabled/readonly. "

                "**Risk level:** CAUTION - types user-controlled characters triggering keystroke events. Similar risk to "
                "browser_fill() but slower and more detectable as sequential keystrokes. "

                "**Returns:** Type result with: selector, characters_typed (count), total_duration_ms, success."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector for the input element",
                    },
                    "text": {
                        "type": "string",
                        "description": "Text to type",
                    },
                    "delay": {
                        "type": "integer",
                        "description": "Delay between keystrokes in milliseconds (default: 50)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector", "text"],
            },
        ),
        # 18. browser_login
        Tool(
            name="browser_login",
            description=(
                "Execute a declarative login flow defined in scope configuration. Reads the login_flow "
                "or authentication section from scope YAML and executes each step (navigate, fill, click, "
                "wait) in order. Supports credential substitution ($username/$password placeholders). "
                "Checks success_condition after completion and returns session cookies on success. "

                "**When to use:** Phase 2 (Mapping) to authenticate browser session before crawling or "
                "testing authenticated endpoints. Call after browser_session_create(). Automates login "
                "without manual fill/click sequences. "

                "**Dependencies:** Requires browser_session_create() first. Requires login_flow configured "
                "in scope YAML (authentication or login_flow section). Uses credential_id to look up "
                "username/password from scope credentials. "

                "**Budget impact:** MEDIUM - executes N steps (navigate, fill, click), each may generate "
                "HTTP requests. Typical form login: 2-5 requests total. "

                "**Failure modes:** 'No login flow configured' if scope YAML missing authentication section. "
                "'Login failed' if success_condition not met after steps. 'Credential not found' if "
                "credential_id invalid. "

                "**Risk level:** CAUTION - submits real credentials to target. Verify login URL is correct "
                "and in scope. Logged in server access logs. "

                "**Returns:** Login result with: success, cookies (array), final_url, success_condition_met."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "credential_id": {
                        "type": "string",
                        "description": "Credential ID from scope config to use for login",
                    },
                    "username": {
                        "type": "string",
                        "description": "Username (overrides credential_id lookup)",
                    },
                    "password": {
                        "type": "string",
                        "description": "Password (overrides credential_id lookup)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 17. browser_ws_connect
        Tool(
            name="browser_ws_connect",
            description=(
                "Establish a WebSocket connection from the browser page via JavaScript injection. "
                "Creates a `new WebSocket(url)` in the page context and stores the reference for "
                "sending/receiving messages. Use for testing WebSocket-based APIs, real-time "
                "features, and WebSocket security (origin checks, auth tokens). "
                "**When to use:** Phase 4 when target uses WebSocket endpoints. "
                "**Dependencies:** Requires browser_session_create + browser_navigate first. "
                "**Returns:** connection_id for use with browser_ws_send/browser_ws_listen."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "WebSocket URL (ws:// or wss://)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Browser session ID (uses active session if omitted)",
                    },
                },
                "required": ["url"],
            },
        ),
        # 18. browser_ws_send
        Tool(
            name="browser_ws_send",
            description=(
                "Send a message over an established WebSocket connection. Calls "
                "window.__ws_{id}.send(message) in the page context. "
                "**When to use:** After browser_ws_connect to send test payloads. "
                "**Returns:** sent_at timestamp."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "connection_id": {
                        "type": "string",
                        "description": "WebSocket connection ID from browser_ws_connect",
                    },
                    "message": {
                        "type": "string",
                        "description": "Message to send (string or JSON)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Browser session ID (uses active session if omitted)",
                    },
                },
                "required": ["connection_id", "message"],
            },
        ),
        # 19. browser_ws_listen
        Tool(
            name="browser_ws_listen",
            description=(
                "Listen for messages received on a WebSocket connection. Polls the "
                "window.__ws_messages_{id} array for messages collected since the last listen. "
                "**When to use:** After browser_ws_send or browser_ws_connect to capture responses. "
                "**Returns:** List of received messages with timestamps."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "connection_id": {
                        "type": "string",
                        "description": "WebSocket connection ID from browser_ws_connect",
                    },
                    "timeout_ms": {
                        "type": "integer",
                        "description": "Max wait time in ms for messages (default: 5000)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Browser session ID (uses active session if omitted)",
                    },
                },
                "required": ["connection_id"],
            },
        ),
        # 20. browser_instrument_dom
        Tool(
            name="browser_instrument_dom",
            description=(
                "Install a MutationObserver to track DOM changes (innerHTML/outerHTML assignments, "
                "attribute modifications, node insertions). Useful for detecting DOM-based XSS, "
                "client-side template injection, and dynamic content manipulation. "
                "**When to use:** Before triggering actions that may cause XSS or DOM manipulation. "
                "**Dependencies:** Requires browser_navigate first. "
                "**Returns:** Confirmation that instrumentation is installed."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Browser session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 21. browser_get_dom_mutations
        Tool(
            name="browser_get_dom_mutations",
            description=(
                "Retrieve the DOM mutation log collected by browser_instrument_dom. Returns all "
                "mutations since instrumentation was installed (or since last retrieval if "
                "clear=true). "
                "**When to use:** After browser_instrument_dom + triggering DOM-changing actions. "
                "**Returns:** List of {type, target_tag, attribute, old_value, new_value, timestamp}."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "clear": {
                        "type": "boolean",
                        "description": "Clear mutation log after retrieval (default: false)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Browser session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 22. browser_new_tab
        Tool(
            name="browser_new_tab",
            description=(
                "Open a new browser tab in the same session context (shares cookies, storage). "
                "Useful for multi-tab testing scenarios: CSRF token reuse across tabs, session "
                "fixation, cross-tab communication attacks. "
                "**When to use:** Phase 4 for testing cross-tab behavior. "
                "**Dependencies:** Requires browser_session_create. "
                "**Returns:** tab_id for use with browser_switch_tab."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "URL to navigate the new tab to (optional, opens blank if omitted)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Browser session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 23. browser_switch_tab
        Tool(
            name="browser_switch_tab",
            description=(
                "Switch the active page context to a different tab. Subsequent browser_* calls "
                "will operate on the switched-to tab. "
                "**When to use:** After browser_new_tab to interact with a specific tab. "
                "**Returns:** Current URL of the switched-to tab."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "tab_id": {
                        "type": "string",
                        "description": "Tab ID from browser_new_tab",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Browser session ID (uses active session if omitted)",
                    },
                },
                "required": ["tab_id"],
            },
        ),
        # 24. browser_postmessage_test
        Tool(
            name="browser_postmessage_test",
            description=(
                "Test postMessage security by sending a message to a target origin and listening "
                "for responses. Detects: missing origin validation, sensitive data in messages, "
                "wildcard (*) origins, DOM manipulation via postMessage. "
                "**When to use:** Phase 4 when target uses iframes or cross-origin communication. "
                "**Returns:** sent_message, responses received, potential vulnerability indicators."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target_origin": {
                        "type": "string",
                        "description": "Target origin for postMessage (e.g. 'https://example.com' or '*')",
                    },
                    "message": {
                        "type": "string",
                        "description": "Message payload to send (string or JSON)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Browser session ID (uses active session if omitted)",
                    },
                },
                "required": ["target_origin", "message"],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_browser_tool(
    name: str,
    arguments: dict,
    mcp_service: Any,
) -> List[TextContent]:
    """Dispatch a browser tool call to the appropriate handler.

    Parameters
    ----------
    name : str
        Tool name (one of the 24 browser_* tools).
    arguments : dict
        Arguments supplied by the caller.
    mcp_service :
        The MCP service instance (kept for interface parity).
    """
    try:
        # Ensure session manager is initialized with assessment ID
        if mcp_service and getattr(mcp_service, 'current_assessment_id', None):
            _get_session_manager(assessment_id=mcp_service.current_assessment_id)
        else:
            _get_session_manager()

        if name == "browser_session_create":
            return await _handle_session_create(arguments)
        elif name == "browser_session_close":
            return await _handle_session_close(arguments)
        elif name == "browser_navigate":
            return await _handle_navigate(arguments, mcp_service)
        elif name == "browser_discover_forms":
            return await _handle_discover_forms(arguments, mcp_service)
        elif name == "browser_test_xss":
            return await _handle_test_xss(arguments, mcp_service)
        elif name == "browser_screenshot":
            return await _handle_screenshot(arguments)
        elif name == "browser_get_state":
            return await _handle_get_state(arguments)
        elif name == "browser_click":
            return await _handle_click(arguments)
        elif name == "browser_fill":
            return await _handle_fill(arguments)
        elif name == "browser_eval":
            return await _handle_eval(arguments)
        elif name == "browser_get_elements":
            return await _handle_get_elements(arguments)
        elif name == "browser_press_key":
            return await _handle_press_key(arguments)
        elif name == "browser_wait":
            return await _handle_wait(arguments)
        elif name == "browser_dismiss_popups":
            return await _handle_dismiss_popups(arguments)
        elif name == "browser_type":
            return await _handle_type(arguments)
        elif name == "browser_login":
            return await _handle_login(arguments, mcp_service)
        elif name == "browser_ws_connect":
            return await _handle_ws_connect(arguments)
        elif name == "browser_ws_send":
            return await _handle_ws_send(arguments)
        elif name == "browser_ws_listen":
            return await _handle_ws_listen(arguments)
        elif name == "browser_instrument_dom":
            return await _handle_instrument_dom(arguments)
        elif name == "browser_get_dom_mutations":
            return await _handle_get_dom_mutations(arguments)
        elif name == "browser_new_tab":
            return await _handle_new_tab(arguments)
        elif name == "browser_switch_tab":
            return await _handle_switch_tab(arguments)
        elif name == "browser_postmessage_test":
            return await _handle_postmessage_test(arguments)
    except Exception as exc:
        logger.error("Browser tool %s failed: %s", name, exc, exc_info=True)
        return _error_content(f"{name} failed: {exc}")

    return _error_content(f"Unknown browser tool: {name}")


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_session_create(arguments: dict) -> List[TextContent]:
    """Create a new browser session."""
    config: Dict[str, Any] = {}

    if "headless" in arguments:
        config["headless"] = arguments["headless"]
    if "proxy_url" in arguments:
        config["proxy_url"] = arguments["proxy_url"]
    if "viewport" in arguments:
        config["viewport"] = arguments["viewport"]
    if "user_agent" in arguments:
        config["user_agent"] = arguments["user_agent"]

    custom_session_id = arguments.get("session_id")
    mgr = _get_session_manager()
    session = await mgr.create_session(config, session_id=custom_session_id)

    return _json_content({
        "success": True,
        "session_id": session.session_id,
        "headless": config.get("headless", True),
        "proxy": config.get("proxy_url"),
        "message": f"Browser session '{session.session_id}' created.",
        "all_sessions": mgr.list_sessions(),
    })


async def _handle_session_close(arguments: dict) -> List[TextContent]:
    """Close a browser session."""
    session_id = arguments.get("session_id")
    mgr = _get_session_manager()

    if session_id:
        session = mgr.get_session(session_id)
        if not session:
            return _error_content(f"Session not found: {session_id}")
        await mgr.close_session(session_id)
    else:
        active = mgr.get_active_session()
        if not active:
            return _error_content("No active session to close.")
        session_id = active.session_id
        await mgr.close_session(session_id)

    return _json_content({
        "success": True,
        "session_id": session_id,
        "message": f"Session '{session_id}' closed.",
        "remaining_sessions": mgr.list_sessions(),
    })


async def _handle_navigate(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Navigate to a URL."""
    url = arguments.get("url", "")
    if not url:
        return _error_content("url is required")

    session = _require_active_session(arguments.get("session_id"))

    result = await session.navigate(
        url=url,
        wait_until=arguments.get("wait_until", "load"),
        timeout=arguments.get("timeout"),
    )

    # Auto-capture page content to knowledge store
    if mcp_service:
        try:
            page = session.get_page()
            page_title = result.get("title", "")
            page_html = await page.content()
            from lib.knowledge_capture import capture_knowledge
            await capture_knowledge(
                mcp_service, source_tool="browser_navigate", category="page_content",
                title=f"Page: {page_title[:150]}",
                content=page_html,
                target=url,
                tags=["browser", "html"],
            )
        except Exception as exc:
            logger.debug("knowledge capture skipped: %s", exc)

    return _json_content({
        "success": True,
        **result,
    })


async def _handle_discover_forms(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Discover all forms on the current page."""
    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()

    analyzer = _get_form_analyzer()
    forms = await analyzer.discover_forms(page)

    # Add testable field count to each form
    for form in forms:
        testable = analyzer.get_testable_fields(form)
        form["testable_field_count"] = len(testable)

    # Auto-save discovered forms as recon
    if mcp_service and forms:
        recon_entries = []
        for form in forms:
            method = (form.get("method") or "GET").upper()
            action = form.get("action") or page.url
            fields = [f.get("name", "") for f in form.get("fields", [])]
            recon_entries.append({
                "data_type": "endpoint",
                "name": f"FORM {method} {action}",
                "details": {
                    "fields": fields,
                    "testable_fields": form.get("testable_field_count", 0),
                    "source_url": page.url,
                },
                "discovered_in_phase": "reconnaissance",
            })
        await mcp_service.safe_add_recon_batch(recon_entries)

    # Auto-capture form data to knowledge store
    if mcp_service and forms:
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="browser_discover_forms", category="form_data",
            title=f"Forms on {page.url[:150]}",
            content=json.dumps(forms, default=str),
            target=page.url,
            tags=["browser", "forms"],
        )

    return _json_content({
        "success": True,
        "forms": forms,
        "total_forms": len(forms),
        "url": page.url,
        "session_id": session.session_id,
    })


async def _handle_test_xss(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Test forms for XSS vulnerabilities."""
    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()

    analyzer = _get_form_analyzer()
    detector = _get_xss_detector()

    # Set up listeners
    await detector.setup_listeners(page)

    form_selector = arguments.get("form_selector")
    target_field = arguments.get("field_name")
    custom_payloads = arguments.get("payloads")

    # Discover forms
    if form_selector:
        form = await analyzer.get_form(page, form_selector)
        if not form:
            return _error_content(f"Form not found: {form_selector}")
        forms = [form]
    else:
        forms = await analyzer.discover_forms(page)

    if not forms:
        return _json_content({
            "success": True,
            "findings": [],
            "message": "No forms found on page.",
            "url": page.url,
            "session_id": session.session_id,
        })

    all_findings: List[Dict[str, Any]] = []

    for form in forms:
        testable_fields = analyzer.get_testable_fields(form)

        if target_field:
            testable_fields = [
                f for f in testable_fields
                if f.get("name") == target_field or f.get("id") == target_field
            ]

        submit_selector = None
        if form.get("submit_button"):
            submit_selector = form["submit_button"].get("selector")

        for field in testable_fields:
            field_name = field.get("name") or field.get("id") or "unknown"
            field_selector = analyzer.get_field_selector(form, field_name)

            findings = await detector.test_field(
                page=page,
                field_name=field_name,
                field_selector=field_selector,
                payloads=custom_payloads,
                submit_selector=submit_selector,
            )

            for finding in findings:
                finding["form_id"] = form.get("form_id")
                finding["form_action"] = form.get("action")
                finding["form_method"] = form.get("method")

            all_findings.extend(findings)

    # Auto-save confirmed XSS findings to backend
    if mcp_service and all_findings:
        for finding in all_findings:
            fname = finding.get("field_name", "unknown")
            faction = finding.get("form_action", "unknown")
            payload = finding.get("payload", "")
            await mcp_service.safe_add_card(
                card_type="finding",
                title=f"XSS: {fname} on {faction}",
                severity="HIGH",
                status="confirmed",
                target_service=page.url,
                technical_analysis=f"Field: {fname}\nPayload: {payload}",
                proof=json.dumps(finding, default=str)[:2000],
                context="Source: browser_test_xss",
            )

    # Auto-capture XSS test results to knowledge store
    if mcp_service:
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="browser_test_xss", category="fuzz_result",
            title=f"XSS test: {page.url[:150]}",
            content=json.dumps(all_findings, default=str),
            target=page.url,
            metadata={"forms_tested": len(forms), "findings_count": len(all_findings)},
            tags=["browser", "xss"],
        )

    return _json_content({
        "success": True,
        "findings": all_findings,
        "total_findings": len(all_findings),
        "forms_tested": len(forms),
        "url": page.url,
        "session_id": session.session_id,
    })


async def _handle_screenshot(arguments: dict) -> List[TextContent]:
    """Capture a screenshot."""
    session = _require_active_session(arguments.get("session_id"))

    result = await session.screenshot(
        path=arguments.get("path"),
        full_page=arguments.get("full_page", False),
        format=arguments.get("format", "png"),
    )

    return _json_content({
        "success": True,
        **result,
    })


async def _handle_get_state(arguments: dict) -> List[TextContent]:
    """Get current page state."""
    session = _require_active_session(arguments.get("session_id"))
    state = await session.get_state()

    return _json_content({
        "success": True,
        **state,
    })


async def _handle_click(arguments: dict) -> List[TextContent]:
    """Click an element."""
    selector = arguments.get("selector", "")
    if not selector:
        return _error_content("selector is required")

    session = _require_active_session(arguments.get("session_id"))
    await session.click(selector, timeout=arguments.get("timeout"))

    return _json_content({
        "success": True,
        "selector": selector,
        "action": "click",
        "session_id": session.session_id,
    })


async def _handle_fill(arguments: dict) -> List[TextContent]:
    """Fill an input field."""
    selector = arguments.get("selector", "")
    value = arguments.get("value", "")
    if not selector:
        return _error_content("selector is required")

    session = _require_active_session(arguments.get("session_id"))
    await session.fill(selector, value, timeout=arguments.get("timeout"))

    return _json_content({
        "success": True,
        "selector": selector,
        "value_length": len(value),
        "action": "fill",
        "session_id": session.session_id,
    })


async def _handle_eval(arguments: dict) -> List[TextContent]:
    """Execute JavaScript."""
    expression = arguments.get("expression", "")
    if not expression:
        return _error_content("expression is required")

    session = _require_active_session(arguments.get("session_id"))
    result = await session.evaluate(expression)

    return _json_content({
        "success": True,
        "expression": expression[:200],
        "result": result,
        "session_id": session.session_id,
    })


async def _handle_get_elements(arguments: dict) -> List[TextContent]:
    """Get element information."""
    selector = arguments.get("selector", "")
    if not selector:
        return _error_content("selector is required")

    session = _require_active_session(arguments.get("session_id"))
    elements = await session.get_elements(selector)

    return _json_content({
        "success": True,
        "selector": selector,
        "elements": elements,
        "count": len(elements),
        "session_id": session.session_id,
    })


async def _handle_press_key(arguments: dict) -> List[TextContent]:
    """Press a keyboard key."""
    key = arguments.get("key", "")
    if not key:
        return _error_content("key is required")

    session = _require_active_session(arguments.get("session_id"))
    modifiers = arguments.get("modifiers")
    await session.press_key(key, modifiers=modifiers)

    return _json_content({
        "success": True,
        "key": key,
        "modifiers": modifiers,
        "action": "press_key",
        "session_id": session.session_id,
    })


async def _handle_wait(arguments: dict) -> List[TextContent]:
    """Wait for a condition."""
    condition = arguments.get("condition", "")
    if not condition:
        return _error_content("condition is required")

    session = _require_active_session(arguments.get("session_id"))
    await session.wait(condition, timeout=arguments.get("timeout"))

    return _json_content({
        "success": True,
        "condition": condition,
        "action": "wait",
        "session_id": session.session_id,
    })


async def _handle_dismiss_popups(arguments: dict) -> List[TextContent]:
    """Dismiss common popups."""
    session = _require_active_session(arguments.get("session_id"))
    result = await session.dismiss_popups()

    return _json_content({
        "success": True,
        **result,
    })


async def _handle_type(arguments: dict) -> List[TextContent]:
    """Type text character by character."""
    selector = arguments.get("selector", "")
    text = arguments.get("text", "")
    if not selector:
        return _error_content("selector is required")
    if not text:
        return _error_content("text is required")

    delay = arguments.get("delay", 50)
    session = _require_active_session(arguments.get("session_id"))
    await session.type_text(selector, text, delay=delay)

    return _json_content({
        "success": True,
        "selector": selector,
        "text_length": len(text),
        "delay_ms": delay,
        "action": "type",
        "session_id": session.session_id,
    })


async def _handle_login(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Execute a declarative login flow from scope configuration."""
    import asyncio as _asyncio
    from lib.login_flow import parse_login_flow, substitute_credentials

    # Get login flow from scope config
    if not mcp_service or not mcp_service.scope_provider:
        return _error_content("Scope provider not available. Load an assessment first.")

    assessment_id = getattr(mcp_service, "current_assessment_id", None)
    if not assessment_id:
        return _error_content("No assessment loaded. Use load_assessment() first.")

    scope = await mcp_service.scope_provider.get_scope(assessment_id)
    if not scope:
        return _error_content(f"No scope configured for assessment {assessment_id}")

    # Parse login flow from scope config
    scope_dict = scope.model_dump()
    login_flow = parse_login_flow(scope_dict)
    if not login_flow:
        return _error_content(
            "No login flow configured in scope. Add an 'authentication' or "
            "'login_flow' section to scope YAML with login_url, steps, and "
            "success_condition."
        )

    if not login_flow.login_url:
        return _error_content("Login flow has no login_url configured.")

    # Resolve credentials
    username = arguments.get("username", "")
    password = arguments.get("password", "")

    if not username and arguments.get("credential_id"):
        cred_id = arguments["credential_id"]
        for cred in scope.credentials or []:
            if cred.id == cred_id:
                if cred.username_env:
                    username = os.environ.get(cred.username_env, "")
                if cred.password_env:
                    password = os.environ.get(cred.password_env, "")
                break
        else:
            return _error_content(f"Credential '{cred_id}' not found in scope config.")

    # Get or create active session
    session = _require_active_session(arguments.get("session_id"))
    steps_executed = []

    # Execute each step
    for i, step in enumerate(login_flow.steps):
        step_result = {"step": i + 1, "action": step.action}
        try:
            if step.action == "navigate":
                url = step.value or login_flow.login_url
                result = await session.navigate(url=url, wait_until="load")
                step_result["url"] = url
                step_result["status"] = "ok"

            elif step.action == "fill":
                value = step.value or ""
                value = substitute_credentials(value, username, password)
                selector = step.selector or ""
                if not selector:
                    step_result["status"] = "skipped"
                    step_result["reason"] = "no selector"
                else:
                    await session.fill(selector, value)
                    step_result["selector"] = selector
                    step_result["status"] = "ok"

            elif step.action == "click":
                selector = step.selector or ""
                if not selector:
                    step_result["status"] = "skipped"
                    step_result["reason"] = "no selector"
                else:
                    await session.click(selector)
                    step_result["selector"] = selector
                    step_result["status"] = "ok"

            elif step.action == "wait":
                wait_ms = step.wait_ms or 1000
                await _asyncio.sleep(wait_ms / 1000.0)
                step_result["waited_ms"] = wait_ms
                step_result["status"] = "ok"

            else:
                step_result["status"] = "unknown_action"

        except Exception as exc:
            step_result["status"] = "error"
            step_result["error"] = str(exc)

        steps_executed.append(step_result)

    # Check success condition
    success_met = False
    condition_detail = ""

    if login_flow.success_condition:
        condition = login_flow.success_condition
        try:
            page = session.get_page()
            if condition.startswith("url_contains:"):
                expected = condition[len("url_contains:"):]
                success_met = expected in page.url
                condition_detail = f"url={page.url}, expected_contains={expected}"

            elif condition.startswith("element_present:"):
                selector = condition[len("element_present:"):]
                elements = await page.query_selector_all(selector)
                success_met = len(elements) > 0
                condition_detail = f"selector={selector}, found={len(elements)}"

            elif condition.startswith("cookie_set:"):
                cookie_name = condition[len("cookie_set:"):]
                cookies = await page.context.cookies()
                success_met = any(c.get("name") == cookie_name for c in cookies)
                condition_detail = f"cookie={cookie_name}"

            else:
                condition_detail = f"unknown condition format: {condition}"
        except Exception as exc:
            condition_detail = f"check failed: {exc}"
    else:
        # No condition means assume success if steps completed
        success_met = all(s.get("status") == "ok" for s in steps_executed)
        condition_detail = "no explicit condition, all steps ok"

    # Collect cookies
    cookies = []
    try:
        page = session.get_page()
        raw_cookies = await page.context.cookies()
        cookies = [
            {"name": c.get("name"), "domain": c.get("domain"), "path": c.get("path")}
            for c in raw_cookies
        ]
    except Exception:
        pass

    return _json_content({
        "success": success_met,
        "login_type": login_flow.login_type,
        "login_url": login_flow.login_url,
        "steps_executed": steps_executed,
        "success_condition": login_flow.success_condition,
        "success_condition_met": success_met,
        "condition_detail": condition_detail,
        "cookies": cookies,
        "final_url": getattr(session.get_page(), "url", ""),
        "session_id": session.session_id,
    })


# ---------------------------------------------------------------------------
# WebSocket handlers
# ---------------------------------------------------------------------------

async def _handle_ws_connect(arguments: dict) -> List[TextContent]:
    """Establish a WebSocket connection via JavaScript injection."""
    import uuid as _uuid

    url = arguments.get("url", "")
    if not url:
        return _error_content("url is required")

    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()

    connection_id = f"ws_{_uuid.uuid4().hex[:8]}"

    js = f"""() => {{
        const ws = new WebSocket({json.dumps(url)});
        window.__ws_{connection_id} = ws;
        window.__ws_messages_{connection_id} = [];
        window.__ws_state_{connection_id} = 'connecting';

        ws.onopen = () => {{
            window.__ws_state_{connection_id} = 'open';
        }};
        ws.onmessage = (event) => {{
            window.__ws_messages_{connection_id}.push({{
                data: typeof event.data === 'string' ? event.data : '[binary]',
                timestamp: Date.now(),
            }});
        }};
        ws.onclose = (event) => {{
            window.__ws_state_{connection_id} = 'closed';
        }};
        ws.onerror = () => {{
            window.__ws_state_{connection_id} = 'error';
        }};

        return '{connection_id}';
    }}"""

    await page.evaluate(js)

    # Wait briefly for connection to establish
    import asyncio as _asyncio
    await _asyncio.sleep(0.5)

    state = await page.evaluate(f"() => window.__ws_state_{connection_id}")

    return _json_content({
        "success": True,
        "connection_id": connection_id,
        "url": url,
        "state": state,
        "session_id": session.session_id,
    })


async def _handle_ws_send(arguments: dict) -> List[TextContent]:
    """Send a message over an established WebSocket connection."""
    connection_id = arguments.get("connection_id", "")
    message = arguments.get("message", "")
    if not connection_id:
        return _error_content("connection_id is required")
    if not message:
        return _error_content("message is required")

    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()

    # Check connection state
    state = await page.evaluate(f"() => window.__ws_state_{connection_id}")
    if state != "open":
        return _error_content(f"WebSocket not open (state: {state})")

    js = f"""() => {{
        window.__ws_{connection_id}.send({json.dumps(message)});
        return Date.now();
    }}"""
    sent_at = await page.evaluate(js)

    return _json_content({
        "success": True,
        "connection_id": connection_id,
        "message_length": len(message),
        "sent_at": sent_at,
        "session_id": session.session_id,
    })


async def _handle_ws_listen(arguments: dict) -> List[TextContent]:
    """Listen for WebSocket messages within a timeout."""
    import asyncio as _asyncio

    connection_id = arguments.get("connection_id", "")
    if not connection_id:
        return _error_content("connection_id is required")

    timeout_ms = arguments.get("timeout_ms", 5000)
    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()

    # Poll for messages over the timeout period
    elapsed = 0
    poll_interval = 200  # ms
    messages = []

    while elapsed < timeout_ms:
        msgs = await page.evaluate(
            f"() => window.__ws_messages_{connection_id} || []"
        )
        if msgs:
            messages = msgs
            # Clear the buffer
            await page.evaluate(
                f"() => {{ window.__ws_messages_{connection_id} = []; }}"
            )
            break
        await _asyncio.sleep(poll_interval / 1000.0)
        elapsed += poll_interval

    state = await page.evaluate(f"() => window.__ws_state_{connection_id}")

    return _json_content({
        "success": True,
        "connection_id": connection_id,
        "messages": messages,
        "message_count": len(messages),
        "state": state,
        "timeout_ms": timeout_ms,
        "session_id": session.session_id,
    })


# ---------------------------------------------------------------------------
# DOM instrumentation handlers
# ---------------------------------------------------------------------------

async def _handle_instrument_dom(arguments: dict) -> List[TextContent]:
    """Install MutationObserver to track DOM changes."""
    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()

    js = """() => {
        if (window.__dom_mutations) return 'already_installed';

        window.__dom_mutations = [];

        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                const entry = {
                    type: mutation.type,
                    target_tag: mutation.target.tagName || '#text',
                    timestamp: Date.now(),
                };

                if (mutation.type === 'attributes') {
                    entry.attribute = mutation.attributeName;
                    entry.old_value = mutation.oldValue;
                    entry.new_value = mutation.target.getAttribute(mutation.attributeName);
                } else if (mutation.type === 'childList') {
                    entry.added_nodes = mutation.addedNodes.length;
                    entry.removed_nodes = mutation.removedNodes.length;
                    if (mutation.addedNodes.length > 0) {
                        const first = mutation.addedNodes[0];
                        entry.first_added = first.tagName || first.textContent?.substring(0, 100);
                    }
                } else if (mutation.type === 'characterData') {
                    entry.old_value = mutation.oldValue?.substring(0, 200);
                    entry.new_value = mutation.target.textContent?.substring(0, 200);
                }

                window.__dom_mutations.push(entry);
            }
        });

        observer.observe(document.body, {
            childList: true,
            attributes: true,
            characterData: true,
            subtree: true,
            attributeOldValue: true,
            characterDataOldValue: true,
        });

        window.__dom_observer = observer;
        return 'installed';
    }"""

    result = await page.evaluate(js)

    return _json_content({
        "success": True,
        "status": result,
        "session_id": session.session_id,
    })


async def _handle_get_dom_mutations(arguments: dict) -> List[TextContent]:
    """Retrieve DOM mutation log."""
    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()
    clear = arguments.get("clear", False)

    mutations = await page.evaluate("() => window.__dom_mutations || []")

    if clear:
        await page.evaluate("() => { window.__dom_mutations = []; }")

    return _json_content({
        "success": True,
        "mutations": mutations,
        "mutation_count": len(mutations),
        "cleared": clear,
        "session_id": session.session_id,
    })


# ---------------------------------------------------------------------------
# Multi-tab handlers
# ---------------------------------------------------------------------------

# Per-session tab tracking: {session_id: {tab_id: page_index}}
_tab_registry: Dict[str, Dict[str, int]] = {}
_tab_counter = 0


async def _handle_new_tab(arguments: dict) -> List[TextContent]:
    """Open a new tab in the same browser context."""
    global _tab_counter

    session = _require_active_session(arguments.get("session_id"))
    url = arguments.get("url")

    # Access the context to create a new page
    context = session._context
    if not context:
        return _error_content("Browser context not available. Session may not be initialized.")

    new_page = await context.new_page()
    _tab_counter += 1
    tab_id = f"tab_{_tab_counter}"

    # Track the tab
    sid = session.session_id
    if sid not in _tab_registry:
        _tab_registry[sid] = {}
    pages = context.pages
    _tab_registry[sid][tab_id] = len(pages) - 1

    # Navigate if URL provided
    tab_url = "about:blank"
    if url:
        response = await new_page.goto(url, wait_until="load")
        tab_url = new_page.url

    return _json_content({
        "success": True,
        "tab_id": tab_id,
        "url": tab_url,
        "total_tabs": len(pages),
        "session_id": session.session_id,
    })


async def _handle_switch_tab(arguments: dict) -> List[TextContent]:
    """Switch active page context to a different tab."""
    tab_id = arguments.get("tab_id", "")
    if not tab_id:
        return _error_content("tab_id is required")

    session = _require_active_session(arguments.get("session_id"))
    sid = session.session_id

    if sid not in _tab_registry or tab_id not in _tab_registry.get(sid, {}):
        return _error_content(f"Tab not found: {tab_id}")

    page_index = _tab_registry[sid][tab_id]
    context = session._context
    if not context:
        return _error_content("Browser context not available.")

    pages = context.pages
    if page_index >= len(pages):
        return _error_content(f"Tab index {page_index} out of range (have {len(pages)} pages)")

    target_page = pages[page_index]

    # Bring tab to front and update session's active page
    await target_page.bring_to_front()
    session._page = target_page

    return _json_content({
        "success": True,
        "tab_id": tab_id,
        "url": target_page.url,
        "session_id": session.session_id,
    })


# ---------------------------------------------------------------------------
# postMessage handler
# ---------------------------------------------------------------------------

async def _handle_postmessage_test(arguments: dict) -> List[TextContent]:
    """Test postMessage security."""
    import asyncio as _asyncio

    target_origin = arguments.get("target_origin", "")
    message = arguments.get("message", "")
    if not target_origin:
        return _error_content("target_origin is required")
    if not message:
        return _error_content("message is required")

    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()

    # Install message listener to capture responses
    js_listen = """() => {
        window.__postmessage_responses = [];
        window.__postmessage_listener = (event) => {
            window.__postmessage_responses.push({
                data: typeof event.data === 'string' ? event.data : JSON.stringify(event.data),
                origin: event.origin,
                timestamp: Date.now(),
            });
        };
        window.addEventListener('message', window.__postmessage_listener);
        return true;
    }"""
    await page.evaluate(js_listen)

    # Send the postMessage
    js_send = f"""() => {{
        try {{
            window.postMessage({json.dumps(message)}, {json.dumps(target_origin)});
            // Also try to send to iframes
            const frames = document.querySelectorAll('iframe');
            for (const frame of frames) {{
                try {{
                    frame.contentWindow.postMessage({json.dumps(message)}, {json.dumps(target_origin)});
                }} catch(e) {{}}
            }}
            return true;
        }} catch(e) {{
            return e.message;
        }}
    }}"""
    send_result = await page.evaluate(js_send)

    # Wait for responses
    await _asyncio.sleep(1.0)

    # Collect responses and clean up
    responses = await page.evaluate("() => window.__postmessage_responses || []")

    js_cleanup = """() => {
        window.removeEventListener('message', window.__postmessage_listener);
        delete window.__postmessage_responses;
        delete window.__postmessage_listener;
    }"""
    await page.evaluate(js_cleanup)

    # Analyze for potential vulnerabilities
    indicators = []
    if target_origin == "*":
        indicators.append("wildcard_origin_used")
    for resp in responses:
        if resp.get("origin") == "null":
            indicators.append("null_origin_response")
        data = resp.get("data", "")
        if any(kw in str(data).lower() for kw in ["token", "session", "password", "secret", "key"]):
            indicators.append("sensitive_data_in_response")

    return _json_content({
        "success": True,
        "target_origin": target_origin,
        "message_sent": message,
        "send_result": send_result,
        "responses": responses,
        "response_count": len(responses),
        "vulnerability_indicators": indicators,
        "session_id": session.session_id,
    })
