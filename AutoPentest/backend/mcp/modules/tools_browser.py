"""
Browser Tools - 15 browser automation tools for security testing.

Ported from browser-mcp TypeScript server to Python.

Tools:
  1.  browser_session_create    - Create a new browser session
  2.  browser_session_close     - Close a browser session
  3.  browser_navigate          - Navigate to a URL
  4.  browser_discover_forms    - Find all forms on page
  5.  browser_test_xss          - Test forms for XSS vulnerabilities
  6.  browser_screenshot        - Capture page screenshot
  7.  browser_get_state         - Get page cookies, URL, title, storage
  8.  browser_click             - Click element by selector
  9.  browser_fill              - Fill input by selector
  10. browser_eval              - Execute JavaScript
  11. browser_get_elements      - Get element info by selector
  12. browser_press_key         - Press keyboard key
  13. browser_wait              - Wait for condition
  14. browser_dismiss_popups    - Auto-dismiss common popups
  15. browser_type              - Type text character by character
"""

from __future__ import annotations

import json
import logging
import os
from typing import Any, Dict, List, Optional

from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")

# ---------------------------------------------------------------------------
# Lazy-initialized singletons
# ---------------------------------------------------------------------------

_session_manager = None
_form_analyzer = None
_xss_detector = None


def _get_session_manager(assessment_id=None):
    """Lazily initialize and return the SessionManager singleton.

    Uses assessment_id if provided, else ENGAGEMENT_ID env var, else 'default'.
    """
    global _session_manager
    if _session_manager is None:
        if assessment_id is not None:
            engagement_id = str(assessment_id)
        else:
            engagement_id = os.environ.get("ENGAGEMENT_ID", "default")

        from lib.browser_session import CorrelationManager, SessionManager

        # Optionally load scope validator
        scope_validator = None
        try:
            from lib.scope_loader import get_scope
            from lib.scope_validator import TargetValidator
            scope = get_scope()
            if scope:
                scope_validator = TargetValidator(scope)
        except Exception:
            logger.info("Scope validator not available for browser sessions")

        correlation = CorrelationManager(engagement_id)
        max_sessions = int(os.environ.get("MAX_BROWSER_SESSIONS", "5"))
        _session_manager = SessionManager(
            correlation_manager=correlation,
            scope_validator=scope_validator,
            max_sessions=max_sessions,
        )
    return _session_manager


def _get_form_analyzer():
    """Lazily initialize and return the FormAnalyzer singleton."""
    global _form_analyzer
    if _form_analyzer is None:
        from lib.browser_forms import FormAnalyzer
        _form_analyzer = FormAnalyzer()
    return _form_analyzer


def _get_xss_detector():
    """Lazily initialize and return the XSSDetector singleton."""
    global _xss_detector
    if _xss_detector is None:
        from lib.browser_xss import XSSDetector
        _xss_detector = XSSDetector()
    return _xss_detector


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _json_content(data: Any) -> List[TextContent]:
    """Return a single-element TextContent list with *data* as JSON."""
    return [TextContent(type="text", text=json.dumps(data, indent=2, default=str))]


def _error_content(message: str) -> List[TextContent]:
    """Return a JSON error object wrapped in TextContent."""
    return [TextContent(type="text", text=json.dumps(
        {"success": False, "error": message}, indent=2
    ))]


def _require_active_session(session_id: Optional[str] = None):
    """Get a session, raising a clear error if none is active.

    Parameters
    ----------
    session_id : str, optional
        Specific session ID. If None, the active session is used.

    Returns
    -------
    BrowserSessionWrapper
    """
    mgr = _get_session_manager()
    if session_id:
        session = mgr.get_session(session_id)
        if not session:
            raise ValueError(f"Session not found: {session_id}")
        return session
    session = mgr.get_active_session()
    if not session:
        raise ValueError(
            "No active browser session. Use browser_session_create first."
        )
    return session


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_browser_tools() -> List[Tool]:
    """Return all 15 browser tool definitions."""
    return [
        # 1. browser_session_create
        Tool(
            name="browser_session_create",
            description=(
                "Create a new Playwright browser session with optional proxy "
                "and headless configuration. Returns a session_id."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "headless": {
                        "type": "boolean",
                        "description": "Run browser in headless mode (default: true)",
                    },
                    "proxy_url": {
                        "type": "string",
                        "description": "HTTP proxy URL (e.g. http://127.0.0.1:8080 for Burp Suite)",
                    },
                    "viewport": {
                        "type": "object",
                        "properties": {
                            "width": {"type": "integer"},
                            "height": {"type": "integer"},
                        },
                        "description": "Browser viewport size",
                    },
                    "user_agent": {
                        "type": "string",
                        "description": "Custom User-Agent string",
                    },
                },
            },
        ),
        # 2. browser_session_close
        Tool(
            name="browser_session_close",
            description="Close a browser session by ID, or close the active session.",
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID to close (closes active session if omitted)",
                    },
                },
            },
        ),
        # 3. browser_navigate
        Tool(
            name="browser_navigate",
            description=(
                "Navigate the browser to a URL. Validates URL against engagement scope."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "The URL to navigate to",
                    },
                    "wait_until": {
                        "type": "string",
                        "enum": ["load", "domcontentloaded", "networkidle", "commit"],
                        "description": "When to consider navigation complete (default: load)",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Navigation timeout in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["url"],
            },
        ),
        # 4. browser_discover_forms
        Tool(
            name="browser_discover_forms",
            description="Find and analyze all HTML forms on the current page.",
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 7. browser_test_xss
        Tool(
            name="browser_test_xss",
            description=(
                "Test forms on the current page for XSS vulnerabilities. "
                "HIGH RISK - injects payloads into form fields."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "form_selector": {
                        "type": "string",
                        "description": "CSS selector for the form to test (tests all forms if omitted)",
                    },
                    "field_name": {
                        "type": "string",
                        "description": "Specific field name to test (tests all testable fields if omitted)",
                    },
                    "payloads": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Custom XSS payloads (uses defaults if omitted)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 8. browser_screenshot
        Tool(
            name="browser_screenshot",
            description="Capture a screenshot of the current page.",
            inputSchema={
                "type": "object",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "File path to save screenshot (returns base64 if omitted)",
                    },
                    "full_page": {
                        "type": "boolean",
                        "description": "Capture full scrollable page (default: false)",
                    },
                    "format": {
                        "type": "string",
                        "enum": ["png", "jpeg"],
                        "description": "Image format (default: png)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 9. browser_get_state
        Tool(
            name="browser_get_state",
            description="Get current page state: URL, title, cookies, localStorage.",
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 10. browser_click
        Tool(
            name="browser_click",
            description="Click an element identified by CSS selector.",
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector for the element to click",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Click timeout in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector"],
            },
        ),
        # 11. browser_fill
        Tool(
            name="browser_fill",
            description="Fill an input field with a value (clears existing content first).",
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector for the input element",
                    },
                    "value": {
                        "type": "string",
                        "description": "Value to fill into the input",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Timeout in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector", "value"],
            },
        ),
        # 12. browser_eval
        Tool(
            name="browser_eval",
            description="Execute JavaScript in the page context and return the result.",
            inputSchema={
                "type": "object",
                "properties": {
                    "expression": {
                        "type": "string",
                        "description": "JavaScript expression to evaluate",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["expression"],
            },
        ),
        # 13. browser_get_elements
        Tool(
            name="browser_get_elements",
            description="Get information about elements matching a CSS selector.",
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector to match elements",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector"],
            },
        ),
        # 14. browser_press_key
        Tool(
            name="browser_press_key",
            description="Press a keyboard key with optional modifiers.",
            inputSchema={
                "type": "object",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Key to press (e.g. Enter, Tab, Escape, a, F5)",
                    },
                    "modifiers": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Modifier keys (e.g. Control, Shift, Alt, Meta)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["key"],
            },
        ),
        # 15. browser_wait
        Tool(
            name="browser_wait",
            description=(
                "Wait for a CSS selector to appear, or wait a fixed number of milliseconds."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "condition": {
                        "type": "string",
                        "description": "CSS selector to wait for, or milliseconds (e.g. '2000')",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Maximum wait time in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["condition"],
            },
        ),
        # 16. browser_dismiss_popups
        Tool(
            name="browser_dismiss_popups",
            description=(
                "Auto-dismiss common popups: alert dialogs, cookie banners, "
                "consent overlays."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 17. browser_type
        Tool(
            name="browser_type",
            description="Type text character by character into an element (simulates real typing).",
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector for the input element",
                    },
                    "text": {
                        "type": "string",
                        "description": "Text to type",
                    },
                    "delay": {
                        "type": "integer",
                        "description": "Delay between keystrokes in milliseconds (default: 50)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector", "text"],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_browser_tool(
    name: str,
    arguments: dict,
    mcp_service: Any,
) -> List[TextContent]:
    """Dispatch a browser tool call to the appropriate handler.

    Parameters
    ----------
    name : str
        Tool name (one of the 15 browser_* tools).
    arguments : dict
        Arguments supplied by the caller.
    mcp_service :
        The MCP service instance (kept for interface parity).
    """
    try:
        # Ensure session manager is initialized with assessment ID
        if mcp_service and getattr(mcp_service, 'current_assessment_id', None):
            _get_session_manager(assessment_id=mcp_service.current_assessment_id)
        else:
            _get_session_manager()

        if name == "browser_session_create":
            return await _handle_session_create(arguments)
        elif name == "browser_session_close":
            return await _handle_session_close(arguments)
        elif name == "browser_navigate":
            return await _handle_navigate(arguments, mcp_service)
        elif name == "browser_discover_forms":
            return await _handle_discover_forms(arguments, mcp_service)
        elif name == "browser_test_xss":
            return await _handle_test_xss(arguments, mcp_service)
        elif name == "browser_screenshot":
            return await _handle_screenshot(arguments)
        elif name == "browser_get_state":
            return await _handle_get_state(arguments)
        elif name == "browser_click":
            return await _handle_click(arguments)
        elif name == "browser_fill":
            return await _handle_fill(arguments)
        elif name == "browser_eval":
            return await _handle_eval(arguments)
        elif name == "browser_get_elements":
            return await _handle_get_elements(arguments)
        elif name == "browser_press_key":
            return await _handle_press_key(arguments)
        elif name == "browser_wait":
            return await _handle_wait(arguments)
        elif name == "browser_dismiss_popups":
            return await _handle_dismiss_popups(arguments)
        elif name == "browser_type":
            return await _handle_type(arguments)
    except Exception as exc:
        logger.error("Browser tool %s failed: %s", name, exc, exc_info=True)
        return _error_content(f"{name} failed: {exc}")

    return _error_content(f"Unknown browser tool: {name}")


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_session_create(arguments: dict) -> List[TextContent]:
    """Create a new browser session."""
    config: Dict[str, Any] = {}

    if "headless" in arguments:
        config["headless"] = arguments["headless"]
    if "proxy_url" in arguments:
        config["proxy_url"] = arguments["proxy_url"]
    if "viewport" in arguments:
        config["viewport"] = arguments["viewport"]
    if "user_agent" in arguments:
        config["user_agent"] = arguments["user_agent"]

    mgr = _get_session_manager()
    session = await mgr.create_session(config)

    return _json_content({
        "success": True,
        "session_id": session.session_id,
        "headless": config.get("headless", True),
        "proxy": config.get("proxy_url"),
        "message": f"Browser session '{session.session_id}' created.",
    })


async def _handle_session_close(arguments: dict) -> List[TextContent]:
    """Close a browser session."""
    session_id = arguments.get("session_id")
    mgr = _get_session_manager()

    if session_id:
        session = mgr.get_session(session_id)
        if not session:
            return _error_content(f"Session not found: {session_id}")
        await mgr.close_session(session_id)
    else:
        active = mgr.get_active_session()
        if not active:
            return _error_content("No active session to close.")
        session_id = active.session_id
        await mgr.close_session(session_id)

    return _json_content({
        "success": True,
        "session_id": session_id,
        "message": f"Session '{session_id}' closed.",
        "remaining_sessions": mgr.list_sessions(),
    })


async def _handle_navigate(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Navigate to a URL."""
    url = arguments.get("url", "")
    if not url:
        return _error_content("url is required")

    session = _require_active_session(arguments.get("session_id"))

    result = await session.navigate(
        url=url,
        wait_until=arguments.get("wait_until", "load"),
        timeout=arguments.get("timeout"),
    )

    # Auto-capture page content to knowledge store
    if mcp_service:
        try:
            page = session.get_page()
            page_title = result.get("title", "")
            page_html = await page.content()
            from lib.knowledge_capture import capture_knowledge
            await capture_knowledge(
                mcp_service, source_tool="browser_navigate", category="page_content",
                title=f"Page: {page_title[:150]}",
                content=page_html,
                target=url,
                tags=["browser", "html"],
            )
        except Exception:
            pass  # Non-critical

    return _json_content({
        "success": True,
        **result,
    })


async def _handle_discover_forms(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Discover all forms on the current page."""
    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()

    analyzer = _get_form_analyzer()
    forms = await analyzer.discover_forms(page)

    # Add testable field count to each form
    for form in forms:
        testable = analyzer.get_testable_fields(form)
        form["testable_field_count"] = len(testable)

    # Auto-save discovered forms as recon
    if mcp_service and forms:
        recon_entries = []
        for form in forms:
            method = (form.get("method") or "GET").upper()
            action = form.get("action") or page.url
            fields = [f.get("name", "") for f in form.get("fields", [])]
            recon_entries.append({
                "data_type": "endpoint",
                "name": f"FORM {method} {action}",
                "details": {
                    "fields": fields,
                    "testable_fields": form.get("testable_field_count", 0),
                    "source_url": page.url,
                },
                "discovered_in_phase": "reconnaissance",
            })
        await mcp_service.safe_add_recon_batch(recon_entries)

    # Auto-capture form data to knowledge store
    if mcp_service and forms:
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="browser_discover_forms", category="form_data",
            title=f"Forms on {page.url[:150]}",
            content=json.dumps(forms, default=str),
            target=page.url,
            tags=["browser", "forms"],
        )

    return _json_content({
        "success": True,
        "forms": forms,
        "total_forms": len(forms),
        "url": page.url,
        "session_id": session.session_id,
    })


async def _handle_test_xss(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Test forms for XSS vulnerabilities."""
    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()

    analyzer = _get_form_analyzer()
    detector = _get_xss_detector()

    # Set up listeners
    await detector.setup_listeners(page)

    form_selector = arguments.get("form_selector")
    target_field = arguments.get("field_name")
    custom_payloads = arguments.get("payloads")

    # Discover forms
    if form_selector:
        form = await analyzer.get_form(page, form_selector)
        if not form:
            return _error_content(f"Form not found: {form_selector}")
        forms = [form]
    else:
        forms = await analyzer.discover_forms(page)

    if not forms:
        return _json_content({
            "success": True,
            "findings": [],
            "message": "No forms found on page.",
            "url": page.url,
            "session_id": session.session_id,
        })

    all_findings: List[Dict[str, Any]] = []

    for form in forms:
        testable_fields = analyzer.get_testable_fields(form)

        if target_field:
            testable_fields = [
                f for f in testable_fields
                if f.get("name") == target_field or f.get("id") == target_field
            ]

        submit_selector = None
        if form.get("submit_button"):
            submit_selector = form["submit_button"].get("selector")

        for field in testable_fields:
            field_name = field.get("name") or field.get("id") or "unknown"
            field_selector = analyzer.get_field_selector(form, field_name)

            findings = await detector.test_field(
                page=page,
                field_name=field_name,
                field_selector=field_selector,
                payloads=custom_payloads,
                submit_selector=submit_selector,
            )

            for finding in findings:
                finding["form_id"] = form.get("form_id")
                finding["form_action"] = form.get("action")
                finding["form_method"] = form.get("method")

            all_findings.extend(findings)

    # Auto-save confirmed XSS findings to backend
    if mcp_service and all_findings:
        for finding in all_findings:
            fname = finding.get("field_name", "unknown")
            faction = finding.get("form_action", "unknown")
            payload = finding.get("payload", "")
            await mcp_service.safe_add_card(
                card_type="finding",
                title=f"XSS: {fname} on {faction}",
                severity="HIGH",
                status="confirmed",
                target_service=page.url,
                technical_analysis=f"Field: {fname}\nPayload: {payload}",
                proof=json.dumps(finding, default=str)[:2000],
                context="Source: browser_test_xss",
            )

    # Auto-capture XSS test results to knowledge store
    if mcp_service:
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="browser_test_xss", category="fuzz_result",
            title=f"XSS test: {page.url[:150]}",
            content=json.dumps(all_findings, default=str),
            target=page.url,
            metadata={"forms_tested": len(forms), "findings_count": len(all_findings)},
            tags=["browser", "xss"],
        )

    return _json_content({
        "success": True,
        "findings": all_findings,
        "total_findings": len(all_findings),
        "forms_tested": len(forms),
        "url": page.url,
        "session_id": session.session_id,
    })


async def _handle_screenshot(arguments: dict) -> List[TextContent]:
    """Capture a screenshot."""
    session = _require_active_session(arguments.get("session_id"))

    result = await session.screenshot(
        path=arguments.get("path"),
        full_page=arguments.get("full_page", False),
        format=arguments.get("format", "png"),
    )

    return _json_content({
        "success": True,
        **result,
    })


async def _handle_get_state(arguments: dict) -> List[TextContent]:
    """Get current page state."""
    session = _require_active_session(arguments.get("session_id"))
    state = await session.get_state()

    return _json_content({
        "success": True,
        **state,
    })


async def _handle_click(arguments: dict) -> List[TextContent]:
    """Click an element."""
    selector = arguments.get("selector", "")
    if not selector:
        return _error_content("selector is required")

    session = _require_active_session(arguments.get("session_id"))
    await session.click(selector, timeout=arguments.get("timeout"))

    return _json_content({
        "success": True,
        "selector": selector,
        "action": "click",
        "session_id": session.session_id,
    })


async def _handle_fill(arguments: dict) -> List[TextContent]:
    """Fill an input field."""
    selector = arguments.get("selector", "")
    value = arguments.get("value", "")
    if not selector:
        return _error_content("selector is required")

    session = _require_active_session(arguments.get("session_id"))
    await session.fill(selector, value, timeout=arguments.get("timeout"))

    return _json_content({
        "success": True,
        "selector": selector,
        "value_length": len(value),
        "action": "fill",
        "session_id": session.session_id,
    })


async def _handle_eval(arguments: dict) -> List[TextContent]:
    """Execute JavaScript."""
    expression = arguments.get("expression", "")
    if not expression:
        return _error_content("expression is required")

    session = _require_active_session(arguments.get("session_id"))
    result = await session.evaluate(expression)

    return _json_content({
        "success": True,
        "expression": expression[:200],
        "result": result,
        "session_id": session.session_id,
    })


async def _handle_get_elements(arguments: dict) -> List[TextContent]:
    """Get element information."""
    selector = arguments.get("selector", "")
    if not selector:
        return _error_content("selector is required")

    session = _require_active_session(arguments.get("session_id"))
    elements = await session.get_elements(selector)

    return _json_content({
        "success": True,
        "selector": selector,
        "elements": elements,
        "count": len(elements),
        "session_id": session.session_id,
    })


async def _handle_press_key(arguments: dict) -> List[TextContent]:
    """Press a keyboard key."""
    key = arguments.get("key", "")
    if not key:
        return _error_content("key is required")

    session = _require_active_session(arguments.get("session_id"))
    modifiers = arguments.get("modifiers")
    await session.press_key(key, modifiers=modifiers)

    return _json_content({
        "success": True,
        "key": key,
        "modifiers": modifiers,
        "action": "press_key",
        "session_id": session.session_id,
    })


async def _handle_wait(arguments: dict) -> List[TextContent]:
    """Wait for a condition."""
    condition = arguments.get("condition", "")
    if not condition:
        return _error_content("condition is required")

    session = _require_active_session(arguments.get("session_id"))
    await session.wait(condition, timeout=arguments.get("timeout"))

    return _json_content({
        "success": True,
        "condition": condition,
        "action": "wait",
        "session_id": session.session_id,
    })


async def _handle_dismiss_popups(arguments: dict) -> List[TextContent]:
    """Dismiss common popups."""
    session = _require_active_session(arguments.get("session_id"))
    result = await session.dismiss_popups()

    return _json_content({
        "success": True,
        **result,
    })


async def _handle_type(arguments: dict) -> List[TextContent]:
    """Type text character by character."""
    selector = arguments.get("selector", "")
    text = arguments.get("text", "")
    if not selector:
        return _error_content("selector is required")
    if not text:
        return _error_content("text is required")

    delay = arguments.get("delay", 50)
    session = _require_active_session(arguments.get("session_id"))
    await session.type_text(selector, text, delay=delay)

    return _json_content({
        "success": True,
        "selector": selector,
        "text_length": len(text),
        "delay_ms": delay,
        "action": "type",
        "session_id": session.session_id,
    })
