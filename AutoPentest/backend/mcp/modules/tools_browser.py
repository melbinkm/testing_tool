"""
Browser Tools - 15 browser automation tools for security testing.

Ported from browser-mcp TypeScript server to Python.

Tools:
  1.  browser_session_create    - Create a new browser session
  2.  browser_session_close     - Close a browser session
  3.  browser_navigate          - Navigate to a URL
  4.  browser_discover_forms    - Find all forms on page
  5.  browser_test_xss          - Test forms for XSS vulnerabilities
  6.  browser_screenshot        - Capture page screenshot
  7.  browser_get_state         - Get page cookies, URL, title, storage
  8.  browser_click             - Click element by selector
  9.  browser_fill              - Fill input by selector
  10. browser_eval              - Execute JavaScript
  11. browser_get_elements      - Get element info by selector
  12. browser_press_key         - Press keyboard key
  13. browser_wait              - Wait for condition
  14. browser_dismiss_popups    - Auto-dismiss common popups
  15. browser_type              - Type text character by character
"""

from __future__ import annotations

import json
import logging
import os
from typing import Any, Dict, List, Optional

from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")

# ---------------------------------------------------------------------------
# Lazy-initialized singletons
# ---------------------------------------------------------------------------

_session_manager = None
_form_analyzer = None
_xss_detector = None


def _get_session_manager(assessment_id=None):
    """Lazily initialize and return the SessionManager singleton.

    Uses assessment_id if provided, else ENGAGEMENT_ID env var, else 'default'.
    """
    global _session_manager
    if _session_manager is None:
        if assessment_id is not None:
            engagement_id = str(assessment_id)
        else:
            engagement_id = os.environ.get("ENGAGEMENT_ID", "default")

        from lib.browser_session import CorrelationManager, SessionManager

        # Optionally load scope validator
        scope_validator = None
        try:
            from lib.scope_loader import get_scope
            from lib.scope_validator import TargetValidator
            scope = get_scope()
            if scope:
                scope_validator = TargetValidator(scope)
        except Exception:
            logger.info("Scope validator not available for browser sessions")

        correlation = CorrelationManager(engagement_id)
        max_sessions = int(os.environ.get("MAX_BROWSER_SESSIONS", "5"))
        _session_manager = SessionManager(
            correlation_manager=correlation,
            scope_validator=scope_validator,
            max_sessions=max_sessions,
        )
    return _session_manager


def _get_form_analyzer():
    """Lazily initialize and return the FormAnalyzer singleton."""
    global _form_analyzer
    if _form_analyzer is None:
        from lib.browser_forms import FormAnalyzer
        _form_analyzer = FormAnalyzer()
    return _form_analyzer


def _get_xss_detector():
    """Lazily initialize and return the XSSDetector singleton."""
    global _xss_detector
    if _xss_detector is None:
        from lib.browser_xss import XSSDetector
        _xss_detector = XSSDetector()
    return _xss_detector


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _json_content(data: Any) -> List[TextContent]:
    """Return a single-element TextContent list with *data* as JSON."""
    return [TextContent(type="text", text=json.dumps(data, indent=2, default=str))]


def _error_content(message: str) -> List[TextContent]:
    """Return a JSON error object wrapped in TextContent."""
    return [TextContent(type="text", text=json.dumps(
        {"success": False, "error": message}, indent=2
    ))]


def _require_active_session(session_id: Optional[str] = None):
    """Get a session, raising a clear error if none is active.

    Parameters
    ----------
    session_id : str, optional
        Specific session ID. If None, the active session is used.

    Returns
    -------
    BrowserSessionWrapper
    """
    mgr = _get_session_manager()
    if session_id:
        session = mgr.get_session(session_id)
        if not session:
            raise ValueError(f"Session not found: {session_id}")
        return session
    session = mgr.get_active_session()
    if not session:
        raise ValueError(
            "No active browser session. Use browser_session_create first."
        )
    return session


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_browser_tools() -> List[Tool]:
    """Return all 15 browser tool definitions."""
    return [
        # 1. browser_session_create
        Tool(
            name="browser_session_create",
            description=(
                "Create a new Playwright browser session with optional proxy routing, headless mode, viewport "
                "configuration, and custom User-Agent. Returns session_id for subsequent browser operations. Supports "
                "up to MAX_BROWSER_SESSIONS concurrent sessions (default 5). Essential for browser-based testing, "
                "JavaScript-heavy applications, and workflows requiring browser state management. "

                "**When to use:** Phase 2 (Mapping) at start of browser-based testing workflows. Create session "
                "BEFORE browser_navigate() or any browser_* operations. Use headless=false for debugging (see browser "
                "window), headless=true for automated testing (default, faster). Set proxy_url to route through "
                "Burp/ZAP for request inspection and modification. Multiple sessions useful for: parallel testing, "
                "session isolation, testing as different users simultaneously. "

                "**Dependencies:** No prerequisites - creates new isolated browser context. Optionally configure "
                "proxy_url (http://127.0.0.1:8080 for Burp Suite) for request interception. Follow with browser_navigate() "
                "to load target page, then browser interactions. Use browser_session_close() when done to free resources. "
                "Sessions auto-closed on server restart but explicit cleanup recommended. "

                "**Budget impact:** LOW - session creation itself no network requests. Creates isolated browser context "
                "with cookies, storage, cache. Browser startup: ~1 second headless, ~2-3 seconds headful. Session persists "
                "until explicitly closed or server restart. Each session consumes ~50-100MB RAM. "

                "**Failure modes:** 'Max sessions exceeded' if MAX_BROWSER_SESSIONS limit reached (close unused sessions "
                "with browser_session_close). 'Playwright not installed' requires Playwright browser binaries (run "
                "'playwright install'). 'Proxy connection failed' if proxy_url unreachable (verify Burp/ZAP running). "
                "Headful mode (headless=false) may fail in Docker/headless environments (use headless=true). "

                "**Risk level:** SAFE - Creates local browser instance, no target interaction yet. Browser capabilities "
                "enable JavaScript execution and full web platform access in subsequent operations. Proxy routing sends "
                "all traffic through specified proxy for inspection (use responsibly). All sessions tracked with correlation. "

                "**Returns:** Session creation result with: session_id (UUID for subsequent operations), is_active (true), "
                "headless (boolean), proxy_configured (boolean), viewport (dimensions), user_agent (string), created_at "
                "(timestamp). Store session_id for use with other browser_* tools or omit to use active session (most recent "
                "created). Use browser_session_close(session_id) when finished."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "headless": {
                        "type": "boolean",
                        "description": "Run browser in headless mode (default: true)",
                    },
                    "proxy_url": {
                        "type": "string",
                        "description": "HTTP proxy URL (e.g. http://127.0.0.1:8080 for Burp Suite)",
                    },
                    "viewport": {
                        "type": "object",
                        "properties": {
                            "width": {"type": "integer"},
                            "height": {"type": "integer"},
                        },
                        "description": "Browser viewport size",
                    },
                    "user_agent": {
                        "type": "string",
                        "description": "Custom User-Agent string",
                    },
                },
            },
        ),
        # 2. browser_session_close
        Tool(
            name="browser_session_close",
            description=(
                "Close a browser session by ID, or close the active session if no ID provided. Terminates browser "
                "process, clears cookies/storage/cache, and frees resources. Essential cleanup after browser-based "
                "testing to prevent resource exhaustion. "

                "**When to use:** Phase 2-3 (Mapping/Assessment) after completing browser workflow. Close session when: "
                "finished with target site, switching to different target, reached session limit (MAX_BROWSER_SESSIONS), "
                "need fresh state (clear cookies/storage). Good practice: close sessions promptly to free RAM (~50-100MB "
                "per session). "

                "**Dependencies:** Requires existing session from browser_session_create(). No follow-up tools - terminal "
                "operation for session lifecycle. Create new session with browser_session_create() if more testing needed. "

                "**Budget impact:** LOW - no network requests, terminates browser process and frees resources instantly. "

                "**Failure modes:** 'Session not found' if session_id doesn't exist (already closed or never created). "
                "Closing active session makes subsequent browser_* calls fail until new session created. "

                "**Risk level:** SAFE - local cleanup operation, no network activity or target interaction. "

                "**Returns:** Close confirmation with: session_id (closed), success (boolean), message. Session no longer "
                "usable after close - create new session for additional testing."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID to close (closes active session if omitted)",
                    },
                },
            },
        ),
        # 3. browser_navigate
        Tool(
            name="browser_navigate",
            description=(
                "Navigate the browser to a URL with automatic scope validation and configurable wait conditions. "
                "Loads target page in Playwright-controlled browser, executing JavaScript and rendering dynamic "
                "content. Essential for testing client-side applications, JavaScript-heavy pages, and workflows "
                "requiring browser context (cookies, storage, DOM manipulation). "

                "**When to use:** Phase 2-3 (Mapping/Assessment) as first step in browser-based testing. Use for: "
                "single-page applications (SPAs) requiring JS execution, pages with client-side routing, login pages "
                "requiring cookie/storage handling, pages with dynamic content loading, XSS testing requiring DOM "
                "verification. Call before browser_discover_forms(), browser_click(), browser_fill(), browser_screenshot(). "
                "Prefer over http_send() when JavaScript execution or browser state needed. "

                "**Dependencies:** Requires browser_session_create() to have created active session. URL automatically "
                "validated against engagement scope (scope_validate_target logic). Follow with browser_discover_forms() "
                "to map inputs, browser_get_state() to capture cookies/storage, browser_screenshot() for evidence, "
                "or browser_wait() if dynamic content loads after initial navigation. "

                "**Budget impact:** MEDIUM - 1 navigation = multiple network requests (page + resources: CSS, JS, images, "
                "API calls). Typical page: 10-50 requests. SPA: 20-100 requests. Each tracked against budget. Use "
                "wait_until='domcontentloaded' instead of 'load' to skip waiting for all resources (faster, less budget). "
                "Check scope_check_budget() before navigating to many pages. "

                "**Failure modes:** 'URL out of scope' if target not in allowlist (check scope_validate_target first). "
                "'Timeout' if page slow to load - increase timeout parameter (default 30s) or use wait_until='commit' "
                "for immediate return. 'Navigation failed' may indicate: URL doesn't exist (404), redirect out of scope "
                "(blocked), SSL/TLS errors, WAF blocking. 'No active session' requires browser_session_create() first. "

                "**Risk level:** CAUTION - Loads target page with JavaScript execution. Executes any client-side code "
                "in page (including malicious JS if present). Logged in target server logs with browser User-Agent. "
                "Detectable by analytics, fingerprinting, bot detection. Proxy support available for inspection (set "
                "proxy_url in browser_session_create). All navigation tracked with correlation IDs for audit trail. "

                "**Returns:** Navigation result with: url (final URL after redirects), title (page title), status "
                "(HTTP status code if available), timing (load duration ms), correlation_id (for tracking). Use to: "
                "verify navigation success, detect redirects (compare final URL to requested), capture page state for "
                "analysis. Follow with browser_get_state() for cookies/localStorage if authentication workflow."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "The URL to navigate to",
                    },
                    "wait_until": {
                        "type": "string",
                        "enum": ["load", "domcontentloaded", "networkidle", "commit"],
                        "description": "When to consider navigation complete (default: load)",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Navigation timeout in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["url"],
            },
        ),
        # 4. browser_discover_forms
        Tool(
            name="browser_discover_forms",
            description=(
                "Find and analyze all HTML forms on the current page. Extracts form attributes, "
                "input fields, validation rules, CSRF tokens, and submission endpoints. Identifies "
                "all input vectors for injection testing. "

                "**When to use:** Phase 2 (Mapping) after loading a page with browser_navigate(). "
                "Run on login pages, search forms, user profile pages, admin panels, and any page "
                "with user input. Essential for identifying all input vectors before vulnerability "
                "assessment. Prefer this over manual HTML parsing for complete form discovery. "

                "**Dependencies:** Requires active browser session with page already loaded via "
                "browser_navigate(). Target URL must be in scope (validated automatically on navigate). "
                "Follow with browser_test_xss() for automated testing, or browser_fill() + browser_click() "
                "for manual injection tests. "

                "**Budget impact:** LOW - no additional page loads, analysis happens in browser context. "
                "JavaScript execution to find forms completes in <1 second. "

                "**Failure modes:** JavaScript-generated forms may not be detected if they load after "
                "initial page render - use browser_wait(selector) before discovery. Shadow DOM forms "
                "and iframe forms are not detected (limitation of current implementation). Returns empty "
                "array if page has no forms (expected for API endpoints or single-page-apps without forms). "

                "**Risk level:** SAFE - read-only page introspection, no form submission or data "
                "modification. No additional network requests. "

                "**Returns:** Array of forms with: action URL, HTTP method, input fields (name, type, "
                "required, pattern, maxlength, autocomplete, placeholder), detected CSRF tokens, hidden "
                "fields, submit button text, validation rules. Use to map all input vectors and identify "
                "missing CSRF protection or weak client-side validation."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 7. browser_test_xss
        Tool(
            name="browser_test_xss",
            description=(
                "Test forms on the current page for XSS vulnerabilities by injecting payloads and detecting execution. "
                "Automatically fills forms with XSS payloads, submits, and checks for JavaScript execution using DOM "
                "alerts, script tags, and event handlers. Comprehensive automated XSS detection for reflected, stored, "
                "and DOM-based XSS. HIGH RISK - actively injects attack payloads. "

                "**When to use:** Phase 3 (Assessment) after browser_discover_forms() identifies input vectors. Automated "
                "XSS testing across all forms on page. Faster than manual browser_fill + browser_click per field. Use "
                "for: login forms, search boxes, comment fields, profile updates, any user input. "

                "**Dependencies:** Requires browser_navigate() to load page with forms, browser_discover_forms() identifies "
                "testable inputs. Follow with validate_repro() if XSS found, browser_screenshot() for visual proof, "
                "evidence_bundle() to document. Custom payloads optional (uses comprehensive default set). "

                "**Budget impact:** MEDIUM to HIGH - N form submissions where N = forms × testable fields × payloads. "
                "Default payloads: ~10 per field. Page with 2 forms, 5 inputs each, 10 payloads = 100 requests. "

                "**Failure modes:** WAF may block payloads (403/429) - indicates detection. False positives rare but "
                "check with browser_eval if unsure. No forms found requires browser_discover_forms first. "

                "**Risk level:** HIGH RISK - Injects malicious XSS payloads that execute JavaScript. May trigger: "
                "script execution, cookie theft (if httpOnly missing), DOM manipulation, IDS alerts. Highly detectable. "

                "**Returns:** XSS test results with vulnerabilities_found array (field, payload, execution_context), "
                "forms_tested, fields_tested, payloads_tested counts. Auto-creates finding cards for confirmed XSS."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "form_selector": {
                        "type": "string",
                        "description": "CSS selector for the form to test (tests all forms if omitted)",
                    },
                    "field_name": {
                        "type": "string",
                        "description": "Specific field name to test (tests all testable fields if omitted)",
                    },
                    "payloads": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Custom XSS payloads (uses defaults if omitted)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 8. browser_screenshot
        Tool(
            name="browser_screenshot",
            description=(
                "Capture screenshot of current page in PNG or JPEG format. Supports full-page scrolling capture or "
                "visible viewport only. Essential for visual evidence collection, XSS proof, UI behavior documentation, "
                "and client deliverables. Returns base64-encoded image or saves to file. "

                "**When to use:** Phase 3-4 (Assessment/Exploitation) for evidence collection. Capture after: XSS "
                "payload execution (visual proof), authentication bypass (show admin panel), error messages (SQL errors, "
                "debug info), successful exploitation. Use full_page=true for complete documentation, false for specific "
                "element focus. "

                "**Dependencies:** Requires browser_navigate() to load target page. Capture before state changes or "
                "after specific action (browser_click, browser_fill). Follow with evidence_add_artifact(type='screenshot') "
                "to attach to evidence bundle. "

                "**Budget impact:** LOW - no additional network requests, captures current DOM render. PNG generation "
                "<500ms, JPEG faster but lossy. Full-page screenshots larger (1-5MB) than viewport (100-500KB). "

                "**Failure modes:** Empty/black screenshot if page not loaded (wait for browser_navigate completion). "
                "Dynamic content may not render (use browser_wait first). Path write errors if directory doesn't exist. "

                "**Risk level:** SAFE - read-only capture, no target interaction or state modification. Screenshot may "
                "contain sensitive data (PII, credentials) - redact before sharing if include_redacted=false in export. "

                "**Returns:** Screenshot result with: base64 (image data if path omitted), path (file location if saved), "
                "format (png/jpeg), dimensions (width × height), size_bytes. Use base64 for evidence_add_artifact() or "
                "path for file-based reports."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "File path to save screenshot (returns base64 if omitted)",
                    },
                    "full_page": {
                        "type": "boolean",
                        "description": "Capture full scrollable page (default: false)",
                    },
                    "format": {
                        "type": "string",
                        "enum": ["png", "jpeg"],
                        "description": "Image format (default: png)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 9. browser_get_state
        Tool(
            name="browser_get_state",
            description=(
                "Get current page state including URL, title, cookies, localStorage, and sessionStorage. Essential for "
                "capturing authentication state, analyzing storage-based vulnerabilities, and verifying navigation results. "

                "**When to use:** Phase 2-3 after browser_navigate() or browser_click() to capture state changes. Use for: "
                "extracting session tokens (cookies/storage), verifying successful authentication, analyzing client-side "
                "data storage, detecting XSS in storage, documenting navigation behavior. "

                "**Dependencies:** Requires browser_navigate() to load page. Follow with wm_store() to save interesting "
                "state, credentials_add() if auth tokens found, or evidence_add_artifact() for documentation. "

                "**Budget impact:** LOW - no network requests, queries browser context locally. "

                "**Failure modes:** Empty storage if page hasn't set any. httpOnly cookies not accessible via JavaScript. "

                "**Risk level:** SAFE - read-only query of browser state, no modification or target interaction. May "
                "expose sensitive tokens - handle securely. "

                "**Returns:** State object with: url (current), title, cookies array (name/value/domain/path/secure/"
                "httpOnly), localStorage object, sessionStorage object, origin. Use cookies for auth analysis, storage "
                "for client-side vuln detection."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 10. browser_click
        Tool(
            name="browser_click",
            description=(
                "Click an element identified by CSS selector. Waits for element to be visible and clickable before "
                "clicking. Simulates real user click with mouse events and JavaScript-triggered behaviors. Essential "
                "for interacting with buttons, links, form submissions, dropdowns, and dynamic UI elements requiring "
                "click activation. "

                "**When to use:** Phase 2-3 (Mapping/Assessment) for browser interaction workflows. Use to: submit "
                "forms after browser_fill() (click submit button), trigger navigation (click links), activate dropdowns "
                "(click to expand), test JavaScript event handlers, trigger AJAX requests, interact with SPAs. Common "
                "sequences: browser_navigate → browser_fill → browser_click (login), browser_click → browser_wait "
                "(wait for modal), browser_click → browser_screenshot (capture result). "

                "**Dependencies:** Requires browser_navigate() to have loaded page with target element. Element must "
                "match CSS selector and be visible/clickable (waits automatically until timeout). Follow with browser_wait() "
                "if click triggers navigation or dynamic content load, browser_get_state() to capture updated cookies/"
                "storage, browser_screenshot() for visual evidence. Use browser_get_elements() first if unsure about selector. "

                "**Budget impact:** LOW - click action itself no requests. However click may trigger: form submission "
                "(1 request), AJAX calls (1-10 requests), navigation (10-50 requests), downloads. Budget impact depends "
                "on what click triggers. Typical button click: 1-5 requests. Submit form: 1 request + redirect. "

                "**Failure modes:** 'Element not found' if selector doesn't match any element (verify with "
                "browser_get_elements first). 'Element not visible' if hidden/offscreen - use browser_eval to scroll "
                "or browser_wait to wait for visibility. 'Element not clickable' if covered by overlay - use "
                "browser_dismiss_popups() first or click overlay's close button. 'Timeout' if element never becomes "
                "clickable - increase timeout or verify selector. Click succeeded but nothing happened may indicate "
                "JS error - check browser console with browser_eval('console.error'). "

                "**Risk level:** CAUTION to HIGH RISK depending on element clicked. Clicking 'Search' button = low "
                "risk. Clicking 'Delete Account' or 'Approve Payment' = high risk (may perform destructive actions). "
                "Verify element purpose with browser_get_elements() before clicking. All clicks logged with correlation. "
                "Detectable in analytics and server logs as user interactions. "

                "**Returns:** Click result with: success (boolean), selector (what was clicked), timing_ms (how long "
                "to click), correlation_id. Use to verify click succeeded. Follow with browser_wait() if expecting "
                "page changes, browser_get_state() to see updated state. Note: success=true means element was clicked, "
                "not that desired action completed (verify separately with assertions)."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector for the element to click",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Click timeout in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector"],
            },
        ),
        # 11. browser_fill
        Tool(
            name="browser_fill",
            description=(
                "Fill an input field with a value (clears existing content first). Waits for input element to be "
                "visible and editable before filling. Faster than browser_type() - sets value instantly rather than "
                "character-by-character. Use for form filling, authentication, search inputs, and any text input "
                "requiring population. "

                "**When to use:** Phase 2-3 (Mapping/Assessment) for form interaction workflows. Use browser_fill() "
                "for most inputs (fast, efficient). Use browser_type() only when: testing keypress handlers, bypassing "
                "paste detection, simulating real typing. Common sequences: browser_navigate(login_url) → "
                "browser_fill('#username', 'admin') → browser_fill('#password', 'pass') → browser_click('#submit'), "
                "or browser_fill('#search', payload) → browser_click('#search-btn') for injection testing. "

                "**Dependencies:** Requires browser_navigate() to have loaded page with input element. Input must "
                "match CSS selector and be visible/editable. Use browser_discover_forms() first to identify input "
                "selectors (name attributes). Follow with browser_click() to submit form, browser_screenshot() for "
                "evidence if testing injection, or browser_wait() if fill triggers dynamic behavior. "

                "**Budget impact:** LOW - fill action itself no requests. However filling may trigger: input validation "
                "AJAX (1 request), autocomplete lookups (1-5 requests), real-time search (N requests per keystroke if "
                "using browser_type). browser_fill() is instant so no progressive requests. Check what fill triggers "
                "in browser_get_state() or network panel. "

                "**Failure modes:** 'Input not found' if selector doesn't match any element (verify with browser_get_elements). "
                "'Input not editable' if disabled/readonly - check element attributes with browser_get_elements first. "
                "'Value not set' may indicate: JavaScript clearing value immediately (use browser_type instead), "
                "input type incompatible (use browser_eval to set value directly), element not an input (verify selector). "
                "Fill succeeded but form validation fails may indicate: client-side validation rules, required format not met. "

                "**Risk level:** CAUTION - Fills user-controlled values into input fields. Risk depends on value "
                "filled: benign usernames = low risk, XSS payloads = medium risk (no execution until submission), "
                "SQL injection strings = medium risk, command injection = medium risk. Actual risk occurs on browser_click "
                "(form submission). All fills logged with correlation. Use browser_fill for normal inputs, validate "
                "dangerous payloads with browser_test_xss() for systematic testing. "

                "**Returns:** Fill result with: success (boolean), selector (what was filled), value_length (characters "
                "filled), timing_ms, correlation_id. Use to verify fill succeeded. Follow with browser_click() to "
                "submit form, browser_screenshot() if testing visual behavior, or browser_eval() to inspect actual "
                "input value after fill. Note: success=true means value was set, not that form validation passed."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector for the input element",
                    },
                    "value": {
                        "type": "string",
                        "description": "Value to fill into the input",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Timeout in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector", "value"],
            },
        ),
        # 12. browser_eval
        Tool(
            name="browser_eval",
            description=(
                "Execute JavaScript in the page context and return the result. Powerful tool for DOM manipulation, "
                "custom checks, XSS verification, and bypassing client-side controls. Use for: testing XSS execution "
                "(document.cookie access), inspecting DOM state, modifying page behavior, extracting dynamic data. "

                "**When to use:** Phase 3 for advanced testing: verify XSS payload execution, extract dynamically "
                "loaded data, test httpOnly cookie protection, bypass client-side validation, inspect CSP headers, "
                "trigger custom events. More flexible than browser_get_state() for specific queries. "

                "**Dependencies:** Requires browser_navigate() to load page. Use after browser_fill/click for testing "
                "post-interaction state. Follow with evidence_add_artifact() to document results. "

                "**Budget impact:** LOW - executes in browser context, no network requests unless code makes fetch/XHR. "

                "**Failure modes:** JavaScript errors return as result. Sandboxed context may limit access to certain APIs. "
                "CSP may block eval() but not this (runs in page context). "

                "**Risk level:** CAUTION to HIGH - executes arbitrary JavaScript. Can: modify page state, trigger actions, "
                "extract sensitive data, bypass controls. Use responsibly - avoid destructive operations. "

                "**Returns:** Evaluation result with: result (JavaScript return value), success, error (if execution failed). "
                "Supports primitives, objects, arrays (JSON-serializable). Use for dynamic analysis and custom testing logic."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "expression": {
                        "type": "string",
                        "description": "JavaScript expression to evaluate",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["expression"],
            },
        ),
        # 13. browser_get_elements
        Tool(
            name="browser_get_elements",
            description=(
                "Get information about elements matching a CSS selector. Returns tag names, attributes, visibility, "
                "text content, and positions. Use for: verifying element existence before interaction, inspecting "
                "element properties, mapping page structure, validating selectors before browser_click/fill. "

                "**When to use:** Phase 2-3 before browser interactions. Use to: verify selector matches target element, "
                "check element visibility/clickability, extract element attributes (id, class, data-*), understand page "
                "structure, debug interaction failures. "

                "**Dependencies:** Requires browser_navigate() to load page. Use before browser_click/fill to verify "
                "target exists. "

                "**Budget impact:** LOW - queries DOM in browser context, no network requests. "

                "**Failure modes:** Empty array if selector matches nothing (verify selector syntax). "

                "**Risk level:** SAFE - read-only DOM inspection, no modification or interaction. "

                "**Returns:** Elements array with: tag_name, attributes (id, class, etc.), text_content, visible (boolean), "
                "position (x, y), dimensions (width, height). Use to verify targets before interaction or extract data."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector to match elements",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector"],
            },
        ),
        # 14. browser_press_key
        Tool(
            name="browser_press_key",
            description=(
                "Press a keyboard key with optional modifiers (Control, Shift, Alt, Meta). Use for: submitting forms "
                "(Enter), navigating (Tab), triggering keyboard shortcuts (Ctrl+S), dismissing dialogs (Escape), "
                "testing keyboard event handlers. "

                "**When to use:** Phase 2-3 for keyboard-based interactions. Use when: Enter key submits form (alternative "
                "to browser_click), Tab navigates between fields, keyboard shortcuts trigger actions, testing keyboard "
                "event handlers, dismissing modals (Escape). "

                "**Dependencies:** Requires browser_navigate() and optionally browser_fill() to focus input. Works on "
                "currently focused element or document if no focus. "

                "**Budget impact:** LOW - key press no network requests unless triggers form submission or AJAX. "

                "**Failure modes:** Key press ignored if no element focused or page doesn't handle event. "

                "**Risk level:** CAUTION - key press may trigger actions like form submission, navigation, or JavaScript. "

                "**Returns:** Key press result with: key, modifiers, success, timing_ms."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "key": {
                        "type": "string",
                        "description": "Key to press (e.g. Enter, Tab, Escape, a, F5)",
                    },
                    "modifiers": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Modifier keys (e.g. Control, Shift, Alt, Meta)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["key"],
            },
        ),
        # 15. browser_wait
        Tool(
            name="browser_wait",
            description=(
                "Wait for a CSS selector to appear or wait fixed milliseconds. Essential for handling dynamic content, "
                "AJAX responses, animations, and asynchronous page updates. Use condition as CSS selector (wait for "
                "element) or milliseconds string (fixed delay). "

                "**When to use:** Phase 2-3 after actions triggering dynamic updates. Use after: browser_click() that "
                "loads modal/dropdown, browser_fill() that triggers AJAX autocomplete, browser_navigate() to SPA that "
                "loads async, form submission that shows results dynamically. Wait for element appearance before "
                "interaction or content extraction. "

                "**Dependencies:** Requires browser_navigate() to load page. Use before browser_get_elements/click/fill "
                "on dynamically loaded content. "

                "**Budget impact:** LOW - waits in browser context, no additional requests. Waiting itself free. "

                "**Failure modes:** Timeout if selector never appears (verify selector correct, check if element truly loads). "

                "**Risk level:** SAFE - passive waiting, no interaction or modification. "

                "**Returns:** Wait result with: condition, waited_ms, found (boolean if selector), timeout (boolean)."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "condition": {
                        "type": "string",
                        "description": "CSS selector to wait for, or milliseconds (e.g. '2000')",
                    },
                    "timeout": {
                        "type": "integer",
                        "description": "Maximum wait time in milliseconds",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["condition"],
            },
        ),
        # 16. browser_dismiss_popups
        Tool(
            name="browser_dismiss_popups",
            description=(
                "Auto-dismiss common popups including JavaScript alert/confirm/prompt dialogs, cookie consent banners, "
                "GDPR notices, newsletter overlays, and age verification screens. Improves automation reliability by "
                "removing blocking overlays before interaction. "

                "**When to use:** Phase 2-3 immediately after browser_navigate() if site has popups, or before browser_click "
                "if element blocked by overlay. Use proactively on: EU sites (GDPR/cookie banners), commercial sites "
                "(newsletter popups), adult content (age verification), sites with alert() dialogs. "

                "**Dependencies:** Requires browser_navigate() to load page with popups. Call before browser_click/fill "
                "if overlays block interaction. "

                "**Budget impact:** LOW - executes JavaScript to find and dismiss popups, no network requests. "

                "**Failure modes:** May not dismiss all popup types (new/unknown patterns). Safe to call even if no popups. "

                "**Risk level:** SAFE to CAUTION - dismisses overlays which may accept default options (cookies accepted, "
                "age confirmed). Review site policies if compliance matters. "

                "**Returns:** Dismissal result with: dismissed_count, popup_types (cookie_banner, alert, overlay), success."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
            },
        ),
        # 17. browser_type
        Tool(
            name="browser_type",
            description=(
                "Type text character by character into an element, simulating real user typing with configurable delay "
                "between keystrokes. Slower than browser_fill() but triggers keypress/keydown/keyup events. Use for: "
                "testing real-time validation, bypassing paste detection, triggering autocomplete/suggestions, simulating "
                "human typing behavior. "

                "**When to use:** Phase 3 when browser_fill() insufficient. Use when: testing keypress event handlers, "
                "real-time input validation (character-by-character), autocomplete requires typing (not paste), bypassing "
                "paste detection, simulating human behavior for bot detection. Default to browser_fill() for speed - use "
                "this only when keystroke events matter. "

                "**Dependencies:** Requires browser_navigate() and element exists at selector. Input must be visible/editable. "

                "**Budget impact:** LOW to MEDIUM - typing itself no requests, but may trigger: real-time validation AJAX "
                "(N requests for N characters), autocomplete lookups (multiple requests), search-as-you-type. Delay parameter "
                "controls speed (default 50ms per char = 20 chars/second). "

                "**Failure modes:** Slower than browser_fill() - not suitable for long text. Element not editable if "
                "disabled/readonly. "

                "**Risk level:** CAUTION - types user-controlled characters triggering keystroke events. Similar risk to "
                "browser_fill() but slower and more detectable as sequential keystrokes. "

                "**Returns:** Type result with: selector, characters_typed (count), total_duration_ms, success."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "selector": {
                        "type": "string",
                        "description": "CSS selector for the input element",
                    },
                    "text": {
                        "type": "string",
                        "description": "Text to type",
                    },
                    "delay": {
                        "type": "integer",
                        "description": "Delay between keystrokes in milliseconds (default: 50)",
                    },
                    "session_id": {
                        "type": "string",
                        "description": "Session ID (uses active session if omitted)",
                    },
                },
                "required": ["selector", "text"],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_browser_tool(
    name: str,
    arguments: dict,
    mcp_service: Any,
) -> List[TextContent]:
    """Dispatch a browser tool call to the appropriate handler.

    Parameters
    ----------
    name : str
        Tool name (one of the 15 browser_* tools).
    arguments : dict
        Arguments supplied by the caller.
    mcp_service :
        The MCP service instance (kept for interface parity).
    """
    try:
        # Ensure session manager is initialized with assessment ID
        if mcp_service and getattr(mcp_service, 'current_assessment_id', None):
            _get_session_manager(assessment_id=mcp_service.current_assessment_id)
        else:
            _get_session_manager()

        if name == "browser_session_create":
            return await _handle_session_create(arguments)
        elif name == "browser_session_close":
            return await _handle_session_close(arguments)
        elif name == "browser_navigate":
            return await _handle_navigate(arguments, mcp_service)
        elif name == "browser_discover_forms":
            return await _handle_discover_forms(arguments, mcp_service)
        elif name == "browser_test_xss":
            return await _handle_test_xss(arguments, mcp_service)
        elif name == "browser_screenshot":
            return await _handle_screenshot(arguments)
        elif name == "browser_get_state":
            return await _handle_get_state(arguments)
        elif name == "browser_click":
            return await _handle_click(arguments)
        elif name == "browser_fill":
            return await _handle_fill(arguments)
        elif name == "browser_eval":
            return await _handle_eval(arguments)
        elif name == "browser_get_elements":
            return await _handle_get_elements(arguments)
        elif name == "browser_press_key":
            return await _handle_press_key(arguments)
        elif name == "browser_wait":
            return await _handle_wait(arguments)
        elif name == "browser_dismiss_popups":
            return await _handle_dismiss_popups(arguments)
        elif name == "browser_type":
            return await _handle_type(arguments)
    except Exception as exc:
        logger.error("Browser tool %s failed: %s", name, exc, exc_info=True)
        return _error_content(f"{name} failed: {exc}")

    return _error_content(f"Unknown browser tool: {name}")


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_session_create(arguments: dict) -> List[TextContent]:
    """Create a new browser session."""
    config: Dict[str, Any] = {}

    if "headless" in arguments:
        config["headless"] = arguments["headless"]
    if "proxy_url" in arguments:
        config["proxy_url"] = arguments["proxy_url"]
    if "viewport" in arguments:
        config["viewport"] = arguments["viewport"]
    if "user_agent" in arguments:
        config["user_agent"] = arguments["user_agent"]

    mgr = _get_session_manager()
    session = await mgr.create_session(config)

    return _json_content({
        "success": True,
        "session_id": session.session_id,
        "headless": config.get("headless", True),
        "proxy": config.get("proxy_url"),
        "message": f"Browser session '{session.session_id}' created.",
    })


async def _handle_session_close(arguments: dict) -> List[TextContent]:
    """Close a browser session."""
    session_id = arguments.get("session_id")
    mgr = _get_session_manager()

    if session_id:
        session = mgr.get_session(session_id)
        if not session:
            return _error_content(f"Session not found: {session_id}")
        await mgr.close_session(session_id)
    else:
        active = mgr.get_active_session()
        if not active:
            return _error_content("No active session to close.")
        session_id = active.session_id
        await mgr.close_session(session_id)

    return _json_content({
        "success": True,
        "session_id": session_id,
        "message": f"Session '{session_id}' closed.",
        "remaining_sessions": mgr.list_sessions(),
    })


async def _handle_navigate(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Navigate to a URL."""
    url = arguments.get("url", "")
    if not url:
        return _error_content("url is required")

    session = _require_active_session(arguments.get("session_id"))

    result = await session.navigate(
        url=url,
        wait_until=arguments.get("wait_until", "load"),
        timeout=arguments.get("timeout"),
    )

    # Auto-capture page content to knowledge store
    if mcp_service:
        try:
            page = session.get_page()
            page_title = result.get("title", "")
            page_html = await page.content()
            from lib.knowledge_capture import capture_knowledge
            await capture_knowledge(
                mcp_service, source_tool="browser_navigate", category="page_content",
                title=f"Page: {page_title[:150]}",
                content=page_html,
                target=url,
                tags=["browser", "html"],
            )
        except Exception as exc:
            logger.debug("knowledge capture skipped: %s", exc)

    return _json_content({
        "success": True,
        **result,
    })


async def _handle_discover_forms(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Discover all forms on the current page."""
    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()

    analyzer = _get_form_analyzer()
    forms = await analyzer.discover_forms(page)

    # Add testable field count to each form
    for form in forms:
        testable = analyzer.get_testable_fields(form)
        form["testable_field_count"] = len(testable)

    # Auto-save discovered forms as recon
    if mcp_service and forms:
        recon_entries = []
        for form in forms:
            method = (form.get("method") or "GET").upper()
            action = form.get("action") or page.url
            fields = [f.get("name", "") for f in form.get("fields", [])]
            recon_entries.append({
                "data_type": "endpoint",
                "name": f"FORM {method} {action}",
                "details": {
                    "fields": fields,
                    "testable_fields": form.get("testable_field_count", 0),
                    "source_url": page.url,
                },
                "discovered_in_phase": "reconnaissance",
            })
        await mcp_service.safe_add_recon_batch(recon_entries)

    # Auto-capture form data to knowledge store
    if mcp_service and forms:
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="browser_discover_forms", category="form_data",
            title=f"Forms on {page.url[:150]}",
            content=json.dumps(forms, default=str),
            target=page.url,
            tags=["browser", "forms"],
        )

    return _json_content({
        "success": True,
        "forms": forms,
        "total_forms": len(forms),
        "url": page.url,
        "session_id": session.session_id,
    })


async def _handle_test_xss(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Test forms for XSS vulnerabilities."""
    session = _require_active_session(arguments.get("session_id"))
    page = session.get_page()

    analyzer = _get_form_analyzer()
    detector = _get_xss_detector()

    # Set up listeners
    await detector.setup_listeners(page)

    form_selector = arguments.get("form_selector")
    target_field = arguments.get("field_name")
    custom_payloads = arguments.get("payloads")

    # Discover forms
    if form_selector:
        form = await analyzer.get_form(page, form_selector)
        if not form:
            return _error_content(f"Form not found: {form_selector}")
        forms = [form]
    else:
        forms = await analyzer.discover_forms(page)

    if not forms:
        return _json_content({
            "success": True,
            "findings": [],
            "message": "No forms found on page.",
            "url": page.url,
            "session_id": session.session_id,
        })

    all_findings: List[Dict[str, Any]] = []

    for form in forms:
        testable_fields = analyzer.get_testable_fields(form)

        if target_field:
            testable_fields = [
                f for f in testable_fields
                if f.get("name") == target_field or f.get("id") == target_field
            ]

        submit_selector = None
        if form.get("submit_button"):
            submit_selector = form["submit_button"].get("selector")

        for field in testable_fields:
            field_name = field.get("name") or field.get("id") or "unknown"
            field_selector = analyzer.get_field_selector(form, field_name)

            findings = await detector.test_field(
                page=page,
                field_name=field_name,
                field_selector=field_selector,
                payloads=custom_payloads,
                submit_selector=submit_selector,
            )

            for finding in findings:
                finding["form_id"] = form.get("form_id")
                finding["form_action"] = form.get("action")
                finding["form_method"] = form.get("method")

            all_findings.extend(findings)

    # Auto-save confirmed XSS findings to backend
    if mcp_service and all_findings:
        for finding in all_findings:
            fname = finding.get("field_name", "unknown")
            faction = finding.get("form_action", "unknown")
            payload = finding.get("payload", "")
            await mcp_service.safe_add_card(
                card_type="finding",
                title=f"XSS: {fname} on {faction}",
                severity="HIGH",
                status="confirmed",
                target_service=page.url,
                technical_analysis=f"Field: {fname}\nPayload: {payload}",
                proof=json.dumps(finding, default=str)[:2000],
                context="Source: browser_test_xss",
            )

    # Auto-capture XSS test results to knowledge store
    if mcp_service:
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="browser_test_xss", category="fuzz_result",
            title=f"XSS test: {page.url[:150]}",
            content=json.dumps(all_findings, default=str),
            target=page.url,
            metadata={"forms_tested": len(forms), "findings_count": len(all_findings)},
            tags=["browser", "xss"],
        )

    return _json_content({
        "success": True,
        "findings": all_findings,
        "total_findings": len(all_findings),
        "forms_tested": len(forms),
        "url": page.url,
        "session_id": session.session_id,
    })


async def _handle_screenshot(arguments: dict) -> List[TextContent]:
    """Capture a screenshot."""
    session = _require_active_session(arguments.get("session_id"))

    result = await session.screenshot(
        path=arguments.get("path"),
        full_page=arguments.get("full_page", False),
        format=arguments.get("format", "png"),
    )

    return _json_content({
        "success": True,
        **result,
    })


async def _handle_get_state(arguments: dict) -> List[TextContent]:
    """Get current page state."""
    session = _require_active_session(arguments.get("session_id"))
    state = await session.get_state()

    return _json_content({
        "success": True,
        **state,
    })


async def _handle_click(arguments: dict) -> List[TextContent]:
    """Click an element."""
    selector = arguments.get("selector", "")
    if not selector:
        return _error_content("selector is required")

    session = _require_active_session(arguments.get("session_id"))
    await session.click(selector, timeout=arguments.get("timeout"))

    return _json_content({
        "success": True,
        "selector": selector,
        "action": "click",
        "session_id": session.session_id,
    })


async def _handle_fill(arguments: dict) -> List[TextContent]:
    """Fill an input field."""
    selector = arguments.get("selector", "")
    value = arguments.get("value", "")
    if not selector:
        return _error_content("selector is required")

    session = _require_active_session(arguments.get("session_id"))
    await session.fill(selector, value, timeout=arguments.get("timeout"))

    return _json_content({
        "success": True,
        "selector": selector,
        "value_length": len(value),
        "action": "fill",
        "session_id": session.session_id,
    })


async def _handle_eval(arguments: dict) -> List[TextContent]:
    """Execute JavaScript."""
    expression = arguments.get("expression", "")
    if not expression:
        return _error_content("expression is required")

    session = _require_active_session(arguments.get("session_id"))
    result = await session.evaluate(expression)

    return _json_content({
        "success": True,
        "expression": expression[:200],
        "result": result,
        "session_id": session.session_id,
    })


async def _handle_get_elements(arguments: dict) -> List[TextContent]:
    """Get element information."""
    selector = arguments.get("selector", "")
    if not selector:
        return _error_content("selector is required")

    session = _require_active_session(arguments.get("session_id"))
    elements = await session.get_elements(selector)

    return _json_content({
        "success": True,
        "selector": selector,
        "elements": elements,
        "count": len(elements),
        "session_id": session.session_id,
    })


async def _handle_press_key(arguments: dict) -> List[TextContent]:
    """Press a keyboard key."""
    key = arguments.get("key", "")
    if not key:
        return _error_content("key is required")

    session = _require_active_session(arguments.get("session_id"))
    modifiers = arguments.get("modifiers")
    await session.press_key(key, modifiers=modifiers)

    return _json_content({
        "success": True,
        "key": key,
        "modifiers": modifiers,
        "action": "press_key",
        "session_id": session.session_id,
    })


async def _handle_wait(arguments: dict) -> List[TextContent]:
    """Wait for a condition."""
    condition = arguments.get("condition", "")
    if not condition:
        return _error_content("condition is required")

    session = _require_active_session(arguments.get("session_id"))
    await session.wait(condition, timeout=arguments.get("timeout"))

    return _json_content({
        "success": True,
        "condition": condition,
        "action": "wait",
        "session_id": session.session_id,
    })


async def _handle_dismiss_popups(arguments: dict) -> List[TextContent]:
    """Dismiss common popups."""
    session = _require_active_session(arguments.get("session_id"))
    result = await session.dismiss_popups()

    return _json_content({
        "success": True,
        **result,
    })


async def _handle_type(arguments: dict) -> List[TextContent]:
    """Type text character by character."""
    selector = arguments.get("selector", "")
    text = arguments.get("text", "")
    if not selector:
        return _error_content("selector is required")
    if not text:
        return _error_content("text is required")

    delay = arguments.get("delay", 50)
    session = _require_active_session(arguments.get("session_id"))
    await session.type_text(selector, text, delay=delay)

    return _json_content({
        "success": True,
        "selector": selector,
        "text_length": len(text),
        "delay_ms": delay,
        "action": "type",
        "session_id": session.session_id,
    })
