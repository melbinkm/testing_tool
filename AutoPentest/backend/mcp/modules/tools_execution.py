"""
Command Execution Tools - execute
"""
import asyncio
from typing import List
from mcp.types import Tool, TextContent
from modules.scan_parsers import parse_scan_output


def get_execution_tools() -> List[Tool]:
    return [
        Tool(
            name="execute",
            description=(
                "Execute arbitrary commands in the Kali Linux container. Provides access to 300+ "
                "penetration testing tools including sqlmap, metasploit, hydra, john, hashcat, and "
                "specialized tools not wrapped by dedicated MCP tools. "

                "**When to use:** When dedicated MCP tools don't cover your needs. Use for: "
                "(1) Specialized tools (sqlmap, wpscan, joomscan, cms scanners), "
                "(2) Custom command combinations (piped commands, complex flags), "
                "(3) Tools discovered via tool_help() that need custom syntax, "
                "(4) Advanced exploitation requiring tool-specific features. "
                "ALWAYS prefer dedicated tools (scan, fuzz_parameter, etc.) over execute() when available. "

                "**Dependencies:** Check tool availability first with tool_help(). Validate target scope "
                "with scope_validate_target() before execution. For commands needing credentials, use "
                "placeholders: credentials_add() creates {{CRED_NAME}} that auto-substitute on execution. "

                "**Budget impact:** VARIES - depends entirely on command. Scope_record_request() is NOT "
                "called automatically for execute() - tool is responsible for budget management. Use "
                "http_send() or http_send_batch() for budget-tracked HTTP requests. "

                "**Failure modes:** Command approval required in 'closed' or 'filter' execution modes - "
                "polls for user approval up to 5min timeout. Safety classifier blocks dangerous commands "
                "(rm -rf /, dd, fork bombs, mkfs). Commands timeout after 120s default (300s for sqlmap). "
                "If command requires stdin/TTY interaction, it will hang - use non-interactive flags. "
                "Credential placeholders must exist (credentials_list to verify). Output truncated at "
                "50000 chars - full output auto-saved to knowledge store via wm_store. "

                "**Risk level:** VARIES - inherits risk level of executed command. Safety classifier "
                "categorizes as SAFE/DANGEROUS/BLOCKED. Dangerous commands show warning but execute. "
                "Blocked commands (destructive operations) rejected automatically. Active exploitation "
                "tools (sqlmap, metasploit) are HIGH RISK and detectable. Passive tools (whois, dig) "
                "are SAFE. "

                "**Returns:** Command stdout/stderr with intelligent parsing. Nmap/gobuster/ffuf output "
                "auto-parsed and formatted. Full untruncated output auto-saved to knowledge store "
                "(wm_recall to retrieve). On timeout, prompts user to run manually and paste results. "
                "Exit codes and execution time included in response metadata."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "command": {
                        "type": "string",
                        "description": "Command to execute"
                    },
                    "phase": {
                        "type": "string",
                        "description": "Current phase for logging"
                    }
                },
                "required": ["command"]
            }
        ),
    ]


async def handle_execution_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    if name == "execute":
        return await _handle_execute(arguments, mcp_service)
    return [TextContent(type="text", text=f"Unknown execution tool: {name}")]


async def _handle_execute(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle execute with command approval modes, timeout, credential substitution, and intelligent parsing"""
    command = arguments["command"]
    phase = arguments.get("phase")

    # ========== SAFETY CLASSIFICATION ==========
    try:
        from lib.safety_classifier import get_safety_classifier
        classifier = get_safety_classifier()
        safety = classifier.classify_command(command)

        if safety["level"] == "blocked":
            return [TextContent(
                type="text",
                text=f"**BLOCKED:** {safety['reason']}\n\n"
                     f"**Command:** `{command}`\n\n"
                     f"This command has been blocked by the safety classifier."
            )]
    except ImportError:
        safety = {"level": "safe", "reason": "Safety classifier not available"}

    # Check if assessment loaded
    if not mcp_service.current_assessment_id:
        return [TextContent(
            type="text",
            text="No assessment loaded. Use 'load_assessment' first."
        )]

    # ========== STEP 1: CHECK COMMAND EXECUTION MODE ==========
    try:
        mode_response = await mcp_service.http_client.get(
            f"{mcp_service.backend_url}/command-settings"
        )
        mode_response.raise_for_status()
        settings = mode_response.json()

        execution_mode = settings.get("execution_mode", "open")
        filter_keywords = settings.get("filter_keywords", [])
    except Exception:
        # Default to open mode if settings unavailable
        execution_mode = "open"
        filter_keywords = []

    # ========== STEP 2: DETERMINE IF APPROVAL REQUIRED ==========
    requires_approval = False
    matched_keywords = []

    if execution_mode == "closed":
        # All commands require approval
        requires_approval = True
    elif execution_mode == "filter":
        # Check if command contains any filter keywords
        command_lower = command.lower()
        matched_keywords = [kw for kw in filter_keywords if kw.lower() in command_lower]
        if matched_keywords:
            requires_approval = True

    # ========== STEP 3: APPROVAL FLOW WITH BLOCKING WAIT ==========
    if requires_approval:
        # Get timeout from settings (default 5 minutes)
        timeout_seconds = 300
        try:
            timeout_response = await mcp_service.http_client.get(
                f"{mcp_service.backend_url}/command-settings"
            )
            if timeout_response.status_code == 200:
                timeout_seconds = timeout_response.json().get("timeout_seconds", 300)
        except Exception:
            pass

        poll_interval = 2  # Poll every 2 seconds
        pending_id = None

        # Create pending command
        try:
            pending_response = await mcp_service.http_client.post(
                f"{mcp_service.backend_url}/pending-commands/create",
                json={
                    "assessment_id": mcp_service.current_assessment_id,
                    "command": command,
                    "phase": phase,
                    "matched_keywords": matched_keywords
                }
            )
            pending_response.raise_for_status()
            pending_cmd = pending_response.json()
            pending_id = pending_cmd.get("id")

        except Exception as e:
            # If we can't create pending command, reject by default for safety
            return [TextContent(
                type="text",
                text=f"**Command blocked - failed to create approval request**\n\n"
                     f"**Command:** `{command}`\n"
                     f"**Error:** {str(e)}\n\n"
                     f"The command was NOT executed for safety reasons."
            )]

        if not pending_id:
            return [TextContent(
                type="text",
                text=f"**Command blocked - invalid approval request**\n\n"
                     f"**Command:** `{command}`\n\n"
                     f"The command was NOT executed for safety reasons."
            )]

        # ========== POLL AND WAIT FOR APPROVAL ==========
        elapsed = 0
        final_status = "timeout"
        execution_result = None

        while elapsed < timeout_seconds:
            await asyncio.sleep(poll_interval)
            elapsed += poll_interval

            try:
                # Check status of pending command
                status_response = await mcp_service.http_client.get(
                    f"{mcp_service.backend_url}/pending-commands/{pending_id}"
                )

                if status_response.status_code == 200:
                    pending_data = status_response.json()
                    current_status = pending_data.get("status", "pending")

                    if current_status == "executed":
                        # User approved and command was executed
                        final_status = "approved"
                        execution_result = pending_data.get("execution_result", {})
                        break

                    elif current_status == "rejected":
                        # User rejected
                        final_status = "rejected"
                        break

                    elif current_status == "timeout":
                        # Already timed out by backend
                        final_status = "timeout"
                        break

                    # Still pending - continue polling

            except Exception:
                # Continue polling on error
                pass

        # ========== RETURN RESULT BASED ON FINAL STATUS ==========
        if final_status == "approved" and execution_result:
            # Command was approved and executed - return output like normal execution
            stdout = execution_result.get("stdout", "")
            stderr = execution_result.get("stderr", "")
            success = execution_result.get("success", False)

            max_length = await mcp_service.get_output_max_length()

            if success:
                if stdout:
                    response_text = f"```\n{stdout[:max_length]}\n```\n"
                else:
                    response_text = "*(Command completed with no output)*\n"
            else:
                response_text = f"Command failed (exit code {execution_result.get('returncode', 'unknown')})\n"
                if stderr:
                    response_text += f"```\n{stderr[:500]}\n```\n"

            return [TextContent(type="text", text=response_text)]

        elif final_status == "rejected":
            return [TextContent(
                type="text",
                text="Command rejected by user"
            )]

        else:  # timeout
            return [TextContent(
                type="text",
                text=f"Command approval timed out after {timeout_seconds}s. The command was NOT executed."
            )]

    # ========== SAFETY WARNING FOR DANGEROUS COMMANDS ==========
    safety_warning = ""
    if safety.get("level") == "dangerous":
        safety_warning = (
            f"**WARNING (Safety: DANGEROUS):** {safety['reason']}\n\n"
        )

    # ========== STEP 4: EXECUTE IMMEDIATELY (OPEN MODE OR NO KEYWORD MATCH) ==========
    try:
        response = await mcp_service.http_client.post(
            f"{mcp_service.backend_url}/assessments/{mcp_service.current_assessment_id}/commands/execute-with-credentials",
            json={"command": command, "phase": phase}
        )
        response.raise_for_status()
        result = response.json()

    except Exception as e:
        error_msg = str(e)
        if "404" in error_msg and "Placeholder" in error_msg:
            return [TextContent(
                type="text",
                text=f"ERROR: {error_msg}\n\nUse `credentials_list` to see available placeholders, or `credentials_add` to add it."
            )]
        else:
            return [TextContent(
                type="text",
                text=f"ERROR executing command: {error_msg}"
            )]

    # Format response (do NOT echo command back - it causes confusion)
    response_text = ""

    # Check if timeout occurred
    if result.get("status") == "timeout":
        timeout_seconds = result.get("execution_time", 300)
        response_text += f"**Timeout ({timeout_seconds}s exceeded)**\n\n"
        response_text += f"**Command:**\n```bash\n{command}\n```\n\n"
        response_text += "Please run this command manually and paste the results here.\n"
        response_text += "I'm pausing until you provide the output.\n"

        return [TextContent(type="text", text=response_text)]

    # Get output_max_length setting
    max_length = await mcp_service.get_output_max_length()

    # Success - parse output intelligently
    if result.get("success"):
        parsed_output = parse_scan_output(command, result, max_length)
        response_text += parsed_output

        # Auto-capture full untruncated stdout to knowledge store
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="execute", category="command_output",
            title=f"exec: {command[:100]}",
            content=result.get("stdout", ""),
            metadata={"command": command, "exit_code": result.get("returncode")},
            tags=["execute"],
        )
    else:
        # Error - show both stdout and stderr
        stdout = result.get("stdout") or ""
        stderr = result.get("stderr") or ""

        if stdout:
            response_text += f"**Command output (exit code {result.get('returncode', 'unknown')}):**\n\n"
            response_text += f"```\n{stdout[:max_length]}\n```\n"
            if stderr:
                response_text += f"\n**Stderr:**\n{stderr[:500]}\n"
        elif stderr:
            response_text += f"ERROR: {stderr[:500]}\n"
        else:
            response_text += f"ERROR: Command failed with exit code {result.get('returncode', 'unknown')}\n"
            response_text += f"DEBUG: success={result.get('success')}, stdout={repr(result.get('stdout'))}, stderr={repr(result.get('stderr'))}, status={result.get('status')}\n"

    return [TextContent(type="text", text=safety_warning + response_text)]
