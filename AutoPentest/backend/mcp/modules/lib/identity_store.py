"""
IdentityStore - Loads and manages test identities from YAML files

Identities represent different authentication contexts (users, roles, API keys)
used for differential authorization testing and BOLA/IDOR detection.

Ported from auth-tester-mcp/src/identity-store.ts
"""
from __future__ import annotations

from typing import Any, Dict, List, Optional


class Identity:
    """Represents a single test identity with authentication credentials."""

    def __init__(
        self,
        id: str,
        type: str,
        scope: str = "",
        auth_header: str = "",
        cookies: Optional[Dict[str, str]] = None,
        should_have_access: bool = True,
        description: str = "",
    ) -> None:
        self.id = id
        self.type = type  # bearer, basic, api_key, cookie
        self.scope = scope
        self.auth_header = auth_header
        self.cookies = cookies or {}
        self.should_have_access = should_have_access
        self.description = description

    def to_dict(self) -> Dict[str, Any]:
        """Serialize identity to a JSON-safe dict."""
        result: Dict[str, Any] = {
            "id": self.id,
            "type": self.type,
            "scope": self.scope,
            "should_have_access": self.should_have_access,
        }
        if self.description:
            result["description"] = self.description
        if self.auth_header:
            result["auth_header"] = self.auth_header
        if self.cookies:
            result["cookies"] = self.cookies
        return result


VALID_AUTH_TYPES = ("bearer", "basic", "api_key", "cookie")


class IdentityStore:
    """Load, validate, and query test identities from YAML configuration."""

    def __init__(self) -> None:
        self._identities: Dict[str, Identity] = {}
        self._loaded_path: Optional[str] = None

    # ------------------------------------------------------------------
    # Loading
    # ------------------------------------------------------------------

    def load_from_yaml(self, path: str) -> None:
        """Load identities from a YAML file.

        Expected YAML format::

            identities:
              - id: admin
                type: bearer
                scope: admin
                auth_header: "Bearer eyJ..."
                should_have_access: true
              - id: readonly
                type: api_key
                scope: read
                auth_header: "sk-read-..."
                should_have_access: false

        Args:
            path: Filesystem path to the YAML file.

        Raises:
            FileNotFoundError: If the YAML file does not exist.
            ValueError: If the YAML structure is invalid.
        """
        try:
            import yaml
        except ImportError as exc:
            raise ImportError(
                "PyYAML is required for identity loading. "
                "Install it with: pip install pyyaml"
            ) from exc

        with open(path, "r", encoding="utf-8") as fh:
            data = yaml.safe_load(fh)

        if not data:
            raise ValueError(f"Empty YAML file: {path}")

        # Support top-level list or dict with 'identities' key
        raw_identities: List[Dict[str, Any]]
        if isinstance(data, list):
            raw_identities = data
        elif isinstance(data, dict) and "identities" in data:
            raw_identities = data["identities"]
        else:
            raise ValueError(
                "YAML must be a list of identities or a dict with an 'identities' key"
            )

        if not isinstance(raw_identities, list) or len(raw_identities) == 0:
            raise ValueError("No identities found in YAML file")

        self._identities.clear()

        for idx, raw in enumerate(raw_identities):
            identity = self._parse_identity(raw, idx)
            if identity.id in self._identities:
                raise ValueError(f"Duplicate identity id: {identity.id}")
            self._identities[identity.id] = identity

        self._loaded_path = path

    def _parse_identity(self, raw: Dict[str, Any], index: int) -> Identity:
        """Parse and validate a single identity dict.

        Args:
            raw: Raw identity dict from YAML.
            index: Position in the list (for error messages).

        Returns:
            A validated Identity instance.

        Raises:
            ValueError: If required fields are missing or invalid.
        """
        identity_id = raw.get("id")
        if not identity_id:
            raise ValueError(f"Identity at index {index} is missing 'id'")

        auth_type = raw.get("type", "")
        if auth_type not in VALID_AUTH_TYPES:
            raise ValueError(
                f"Identity '{identity_id}' has invalid type '{auth_type}'. "
                f"Must be one of: {', '.join(VALID_AUTH_TYPES)}"
            )

        # Cookie type requires cookies dict; others require auth_header
        if auth_type == "cookie":
            cookies = raw.get("cookies")
            if not cookies or not isinstance(cookies, dict):
                raise ValueError(
                    f"Identity '{identity_id}' with type 'cookie' must have a 'cookies' dict"
                )
        else:
            auth_header = raw.get("auth_header", "")
            if not auth_header:
                raise ValueError(
                    f"Identity '{identity_id}' with type '{auth_type}' must have 'auth_header'"
                )

        return Identity(
            id=str(identity_id),
            type=auth_type,
            scope=raw.get("scope", ""),
            auth_header=raw.get("auth_header", ""),
            cookies=raw.get("cookies") if isinstance(raw.get("cookies"), dict) else {},
            should_have_access=bool(raw.get("should_have_access", True)),
            description=raw.get("description", ""),
        )

    # ------------------------------------------------------------------
    # Querying
    # ------------------------------------------------------------------

    def get_identity(self, identity_id: str) -> Optional[Identity]:
        """Get a single identity by ID."""
        return self._identities.get(identity_id)

    def get_identities(self) -> List[Identity]:
        """Get all loaded identities."""
        return list(self._identities.values())

    def get_identities_for_scope(self, scope: str) -> List[Identity]:
        """Get identities whose scope matches the given value."""
        return [i for i in self._identities.values() if i.scope == scope]

    def get_identity_ids(self) -> List[str]:
        """Get all identity IDs."""
        return list(self._identities.keys())

    @property
    def count(self) -> int:
        """Number of loaded identities."""
        return len(self._identities)

    @property
    def loaded_path(self) -> Optional[str]:
        """Path of the loaded YAML file, or None if not yet loaded."""
        return self._loaded_path

    # ------------------------------------------------------------------
    # Auth header building
    # ------------------------------------------------------------------

    @staticmethod
    def build_auth_headers(identity: Identity) -> Dict[str, str]:
        """Build HTTP headers for the given identity.

        - bearer / basic  -> Authorization header
        - api_key          -> X-API-Key header
        - cookie           -> Cookie header from cookies dict

        Args:
            identity: An Identity instance.

        Returns:
            Dict of HTTP header name -> value.
        """
        headers: Dict[str, str] = {}

        if identity.type == "cookie" and identity.cookies:
            cookie_str = "; ".join(
                f"{key}={value}" for key, value in identity.cookies.items()
            )
            headers["Cookie"] = cookie_str
            return headers

        if identity.auth_header:
            if identity.type in ("bearer", "basic"):
                headers["Authorization"] = identity.auth_header
            elif identity.type == "api_key":
                headers["X-API-Key"] = identity.auth_header

        return headers
