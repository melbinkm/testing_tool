"""
SAST Runner

Wrapper for SAST tools (Semgrep, Bandit, Gitleaks) with Docker exec support.
NO MOCK MODE - returns error when tools unavailable.

Follows nuclei_runner.py Docker exec pattern.
"""
from __future__ import annotations

import asyncio
import json
import os
import re
import time
from typing import Any, Dict, List, Optional, Tuple
from urllib.parse import urlparse


class SASTRunner:
    """Async SAST tool wrapper with Docker exec. No mock mode."""

    def __init__(
        self,
        container_name: str = "kali-autopentest",
        repo_base_dir: str = "/workspace/repos",
        scan_timeout: int = 300,
    ) -> None:
        """Initialize SAST runner.

        Parameters
        ----------
        container_name : str
            Docker container name for Kali (where tools are installed)
        repo_base_dir : str
            Base directory for cloned repositories (inside container)
        scan_timeout : int
            Default scan timeout in seconds
        """
        self.container_name = container_name
        self.repo_base_dir = repo_base_dir
        self.scan_timeout = scan_timeout
        self._tool_cache: Dict[str, Tuple[bool, bool]] = {}  # tool -> (available, use_docker)

    # -- Tool Detection --

    async def check_tool(self, tool: str) -> Tuple[bool, bool]:
        """Check if SAST tool is available (locally or via Docker).

        Parameters
        ----------
        tool : str
            Tool name (semgrep, bandit, gitleaks)

        Returns
        -------
        tuple of (bool, bool)
            (available, use_docker). If neither works: (False, False)
        """
        if tool in self._tool_cache:
            return self._tool_cache[tool]

        # Try local PATH first
        try:
            result = await self._exec_local("which", [tool])
            if result["exit_code"] == 0:
                self._tool_cache[tool] = (True, False)
                return (True, False)
        except Exception:
            pass

        # Try Docker exec
        try:
            result = await self._exec_docker("which", [tool])
            if result["exit_code"] == 0:
                self._tool_cache[tool] = (True, True)
                return (True, True)
        except Exception:
            pass

        # Not available
        self._tool_cache[tool] = (False, False)
        return (False, False)

    # -- Command Execution --

    async def _exec_local(self, cmd: str, args: List[str], timeout: Optional[int] = None, cwd: Optional[str] = None) -> Dict[str, Any]:
        """Execute command locally via subprocess."""
        try:
            timeout_sec = timeout or self.scan_timeout
            proc = await asyncio.create_subprocess_exec(
                cmd,
                *args,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd,
            )
            stdout_bytes, stderr_bytes = await asyncio.wait_for(
                proc.communicate(), timeout=timeout_sec
            )
            return {
                "exit_code": proc.returncode or 0,
                "stdout": stdout_bytes.decode("utf-8", errors="replace"),
                "stderr": stderr_bytes.decode("utf-8", errors="replace"),
            }
        except asyncio.TimeoutError:
            return {"exit_code": 1, "stdout": "", "stderr": "Command timed out"}
        except Exception as exc:
            return {"exit_code": 1, "stdout": "", "stderr": str(exc)}

    async def _exec_docker(self, cmd: str, args: List[str], timeout: Optional[int] = None, cwd: Optional[str] = None) -> Dict[str, Any]:
        """Execute command in Kali container via docker exec."""
        try:
            timeout_sec = timeout or self.scan_timeout
            # Build bash command
            quoted_args = [f"'{arg}'" if " " in arg or '"' in arg else arg for arg in args]
            bash_cmd = f"{cmd} {' '.join(quoted_args)}"

            docker_args = ["docker", "exec"]
            if cwd:
                docker_args.extend(["-w", cwd])
            docker_args.extend([self.container_name, "bash", "-c", bash_cmd])

            proc = await asyncio.create_subprocess_exec(
                *docker_args,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout_bytes, stderr_bytes = await asyncio.wait_for(
                proc.communicate(), timeout=timeout_sec
            )
            return {
                "exit_code": proc.returncode or 0,
                "stdout": stdout_bytes.decode("utf-8", errors="replace"),
                "stderr": stderr_bytes.decode("utf-8", errors="replace"),
            }
        except asyncio.TimeoutError:
            return {"exit_code": 1, "stdout": "", "stderr": "Command timed out (Docker exec)"}
        except Exception as exc:
            return {"exit_code": 1, "stdout": "", "stderr": f"Docker exec failed: {str(exc)}"}

    async def _exec(self, cmd: str, args: List[str], timeout: Optional[int] = None, cwd: Optional[str] = None, tool: Optional[str] = None) -> Dict[str, Any]:
        """Execute command via local or Docker based on tool availability."""
        if tool:
            available, use_docker = await self.check_tool(tool)
            if not available:
                return {"exit_code": 1, "stdout": "", "stderr": f"{tool} not found"}
        else:
            use_docker = False  # Assume local for non-tool commands

        if use_docker:
            return await self._exec_docker(cmd, args, timeout, cwd)
        else:
            return await self._exec_local(cmd, args, timeout, cwd)

    # -- Git Operations --

    async def clone_repo(
        self,
        url: str,
        assessment_id: int,
        branch: str = "main",
        depth: int = 0,
        auth_token_env: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Clone git repository into assessment-scoped directory.

        Parameters
        ----------
        url : str
            Git repository URL
        assessment_id : int
            Assessment ID for isolation
        branch : str
            Branch to clone (default: main)
        depth : int
            Clone depth (0 = full history)
        auth_token_env : str, optional
            Environment variable containing auth token

        Returns
        -------
        dict
            {success, repo_path, commit_sha, branch, file_count, languages_detected, total_size_kb, error}
        """
        start_time = time.monotonic()

        # Check git availability
        available, use_docker = await self.check_tool("git")
        if not available:
            return {
                "success": False,
                "error": "git not found. Rebuild Kali container: docker compose build kali",
                "repo_path": None,
                "scan_time_ms": int((time.monotonic() - start_time) * 1000),
            }

        # Build repo path: /workspace/repos/{assessment_id}/
        repo_dir = f"{self.repo_base_dir}/{assessment_id}"

        # Parse repo name from URL
        repo_name = urlparse(url).path.rstrip("/").split("/")[-1].replace(".git", "")
        repo_path = f"{repo_dir}/{repo_name}"

        # Auth token substitution
        clone_url = url
        if auth_token_env:
            token = os.environ.get(auth_token_env, "")
            if token:
                # Insert token into HTTPS URL: https://TOKEN@github.com/org/repo.git
                if url.startswith("https://"):
                    clone_url = url.replace("https://", f"https://{token}@")

        # Build clone command
        clone_args = ["clone"]
        if branch:
            clone_args.extend(["-b", branch])
        if depth > 0:
            clone_args.extend(["--depth", str(depth)])
        clone_args.extend([clone_url, repo_path])

        # Execute clone
        result = await self._exec("git", clone_args, timeout=300, tool="git")

        if result["exit_code"] != 0:
            return {
                "success": False,
                "error": result["stderr"] or "Git clone failed",
                "repo_path": None,
                "scan_time_ms": int((time.monotonic() - start_time) * 1000),
            }

        # Get commit SHA
        sha_result = await self._exec("git", ["rev-parse", "HEAD"], cwd=repo_path, tool="git")
        commit_sha = sha_result["stdout"].strip() if sha_result["exit_code"] == 0 else "unknown"

        # Count files
        find_result = await self._exec("find", [repo_path, "-type", "f"], timeout=60)
        file_count = len(find_result["stdout"].splitlines()) if find_result["exit_code"] == 0 else 0

        # Detect languages
        languages = await self.detect_languages(repo_path)

        # Calculate size
        du_result = await self._exec("du", ["-sk", repo_path], timeout=30)
        total_size_kb = 0
        if du_result["exit_code"] == 0:
            match = re.search(r"^(\d+)", du_result["stdout"])
            if match:
                total_size_kb = int(match.group(1))

        return {
            "success": True,
            "repo_path": repo_path,
            "commit_sha": commit_sha,
            "branch": branch,
            "file_count": file_count,
            "languages_detected": languages,
            "total_size_kb": total_size_kb,
            "scan_time_ms": int((time.monotonic() - start_time) * 1000),
        }

    async def detect_languages(self, repo_path: str) -> Dict[str, int]:
        """Detect languages in repository by file extension.

        Returns: {language: file_count}
        """
        lang_map = {
            ".py": "python",
            ".js": "javascript",
            ".ts": "typescript",
            ".jsx": "javascript",
            ".tsx": "typescript",
            ".java": "java",
            ".go": "go",
            ".rb": "ruby",
            ".php": "php",
            ".c": "c",
            ".cpp": "cpp",
            ".cs": "csharp",
            ".rs": "rust",
            ".swift": "swift",
            ".kt": "kotlin",
        }

        find_result = await self._exec("find", [repo_path, "-type", "f"], timeout=60)
        if find_result["exit_code"] != 0:
            return {}

        lang_counts: Dict[str, int] = {}
        for line in find_result["stdout"].splitlines():
            for ext, lang in lang_map.items():
                if line.endswith(ext):
                    lang_counts[lang] = lang_counts.get(lang, 0) + 1
                    break

        return lang_counts

    # -- Scanner Wrappers --

    async def run_semgrep(
        self,
        repo_path: str,
        rulesets: Optional[List[str]] = None,
        paths: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        severity: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Run Semgrep scanner.

        Parameters
        ----------
        repo_path : str
            Path to repository
        rulesets : list of str
            Semgrep rulesets (default: ["auto"])
        paths : list of str, optional
            Specific paths to scan
        exclude : list of str, optional
            Paths to exclude
        severity : str, optional
            Minimum severity filter (INFO, WARNING, ERROR)

        Returns
        -------
        dict
            {success, findings, scan_time_ms, languages_scanned, error}
        """
        start_time = time.monotonic()

        available, use_docker = await self.check_tool("semgrep")
        if not available:
            return {
                "success": False,
                "error": "semgrep not found. Rebuild Kali container with: pip3 install semgrep",
                "findings": [],
                "scan_time_ms": int((time.monotonic() - start_time) * 1000),
            }

        rulesets = rulesets or ["auto"]
        config_str = ",".join(rulesets)

        args = ["--json", "--config", config_str, "--no-git-ignore"]
        if severity:
            args.extend(["--severity", severity])
        if exclude:
            for exc in exclude:
                args.extend(["--exclude", exc])

        if paths:
            args.extend(paths)
        else:
            args.append(".")

        result = await self._exec("semgrep", args, timeout=300, cwd=repo_path, tool="semgrep")

        if result["exit_code"] not in [0, 1]:  # 1 = findings found
            # Semgrep puts errors in JSON stdout, not stderr
            error_msg = result["stderr"] or ""
            try:
                parsed = json.loads(result["stdout"])
                json_errors = parsed.get("errors", [])
                if json_errors:
                    error_msg = "; ".join(e.get("message", "") for e in json_errors)
            except (json.JSONDecodeError, TypeError):
                pass
            return {
                "success": False,
                "error": error_msg or "Semgrep scan failed",
                "findings": [],
                "scan_time_ms": int((time.monotonic() - start_time) * 1000),
            }

        findings = self.parse_semgrep_json(result["stdout"])

        return {
            "success": True,
            "findings": findings,
            "scan_time_ms": int((time.monotonic() - start_time) * 1000),
            "languages_scanned": list(set(f.get("language", "unknown") for f in findings)),
        }

    async def run_bandit(
        self,
        repo_path: str,
        confidence: str = "medium",
        severity: str = "low",
        exclude_dirs: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        """Run Bandit (Python-only) scanner.

        Returns: {success, findings, scan_time_ms, error}
        """
        start_time = time.monotonic()

        available, use_docker = await self.check_tool("bandit")
        if not available:
            return {
                "success": False,
                "error": "bandit not found. Rebuild Kali container with: pip3 install bandit",
                "findings": [],
                "scan_time_ms": int((time.monotonic() - start_time) * 1000),
            }

        args = ["-r", ".", "-f", "json"]
        if confidence:
            args.extend(["--confidence-level", confidence.lower()])
        if severity:
            args.extend(["--severity-level", severity.lower()])
        if exclude_dirs:
            args.extend(["-x", ",".join(exclude_dirs)])

        result = await self._exec("bandit", args, timeout=180, cwd=repo_path, tool="bandit")

        # Bandit exit code 1 = findings found, 0 = no findings
        if result["exit_code"] not in [0, 1]:
            return {
                "success": False,
                "error": result["stderr"] or "Bandit scan failed",
                "findings": [],
                "scan_time_ms": int((time.monotonic() - start_time) * 1000),
            }

        findings = self.parse_bandit_json(result["stdout"])

        return {
            "success": True,
            "findings": findings,
            "scan_time_ms": int((time.monotonic() - start_time) * 1000),
        }

    async def run_gitleaks(
        self,
        repo_path: str,
        scan_history: bool = False,
    ) -> Dict[str, Any]:
        """Run Gitleaks secret scanner.

        Parameters
        ----------
        repo_path : str
            Path to repository
        scan_history : bool
            Scan full git history (default: False = staged/unstaged files only)

        Returns
        -------
        dict
            {success, findings, scan_time_ms, error}
        """
        start_time = time.monotonic()

        available, use_docker = await self.check_tool("gitleaks")
        if not available:
            return {
                "success": False,
                "error": "gitleaks not found. See Dockerfile.kali for installation",
                "findings": [],
                "scan_time_ms": int((time.monotonic() - start_time) * 1000),
            }

        args = ["detect", "--source", repo_path, "--report-format", "json", "--no-color"]
        if not scan_history:
            args.append("--no-git")

        result = await self._exec("gitleaks", args, timeout=180, cwd=repo_path, tool="gitleaks")

        # Gitleaks exit code 1 = leaks found
        if result["exit_code"] not in [0, 1]:
            return {
                "success": False,
                "error": result["stderr"] or "Gitleaks scan failed",
                "findings": [],
                "scan_time_ms": int((time.monotonic() - start_time) * 1000),
            }

        findings = self.parse_gitleaks_json(result["stdout"])

        return {
            "success": True,
            "findings": findings,
            "scan_time_ms": int((time.monotonic() - start_time) * 1000),
        }

    # -- Output Parsers --

    @staticmethod
    def parse_semgrep_json(raw: str) -> List[Dict[str, Any]]:
        """Parse Semgrep JSON output into normalized finding format."""
        try:
            data = json.loads(raw)
            results = data.get("results", [])
        except (json.JSONDecodeError, KeyError):
            return []

        findings = []
        for result in results:
            finding = {
                "source": "sast_semgrep",
                "rule_id": result.get("check_id", ""),
                "title": result.get("extra", {}).get("message", result.get("check_id", "")),
                "severity": result.get("extra", {}).get("severity", "info").lower(),
                "confidence": 0.8,
                "file": result.get("path", ""),
                "line": result.get("start", {}).get("line", 0),
                "end_line": result.get("end", {}).get("line", 0),
                "code_snippet": result.get("extra", {}).get("lines", ""),
                "message": result.get("extra", {}).get("message", ""),
                "vuln_class": SASTRunner._map_vuln_class("semgrep", result.get("check_id", "")),
                "cwe": result.get("extra", {}).get("metadata", {}).get("cwe", ""),
                "remediation": result.get("extra", {}).get("metadata", {}).get("fix", ""),
                "language": result.get("extra", {}).get("metadata", {}).get("technology", ["unknown"])[0] if isinstance(result.get("extra", {}).get("metadata", {}).get("technology"), list) else "unknown",
            }
            findings.append(finding)

        return findings

    @staticmethod
    def parse_bandit_json(raw: str) -> List[Dict[str, Any]]:
        """Parse Bandit JSON output into normalized finding format."""
        try:
            data = json.loads(raw)
            results = data.get("results", [])
        except (json.JSONDecodeError, KeyError):
            return []

        findings = []
        for result in results:
            finding = {
                "source": "sast_bandit",
                "rule_id": result.get("test_id", ""),
                "title": result.get("test_name", ""),
                "severity": result.get("issue_severity", "low").lower(),
                "confidence": SASTRunner._confidence_to_float(result.get("issue_confidence", "MEDIUM")),
                "file": result.get("filename", ""),
                "line": result.get("line_number", 0),
                "end_line": result.get("line_number", 0),
                "code_snippet": result.get("code", ""),
                "message": result.get("issue_text", ""),
                "vuln_class": SASTRunner._map_vuln_class("bandit", result.get("test_id", "")),
                "cwe": result.get("cwe", {}).get("id", "") if isinstance(result.get("cwe"), dict) else "",
                "remediation": "",
                "language": "python",
            }
            findings.append(finding)

        return findings

    @staticmethod
    def parse_gitleaks_json(raw: str) -> List[Dict[str, Any]]:
        """Parse Gitleaks JSON output into normalized finding format."""
        try:
            results = json.loads(raw)
            if not isinstance(results, list):
                results = []
        except json.JSONDecodeError:
            return []

        findings = []
        for result in results:
            # Redact secret values (show only first/last 4 chars)
            secret = result.get("Secret", "")
            if len(secret) > 8:
                redacted = f"{secret[:4]}...{secret[-4:]}"
            else:
                redacted = "***"

            finding = {
                "source": "sast_gitleaks",
                "rule_id": result.get("RuleID", ""),
                "title": f"Secret detected: {result.get('Description', 'Hardcoded secret')}",
                "severity": "high",  # All secrets are high severity
                "confidence": 0.9,
                "file": result.get("File", ""),
                "line": result.get("StartLine", 0),
                "end_line": result.get("EndLine", 0),
                "code_snippet": result.get("Match", ""),
                "message": f"Secret: {redacted}",
                "vuln_class": "info_leak_headers",  # Map to existing vuln class
                "cwe": "CWE-798",
                "remediation": "Remove hardcoded secrets and use environment variables or secret management systems",
                "language": "unknown",
            }
            findings.append(finding)

        return findings

    @staticmethod
    def deduplicate(findings: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Deduplicate findings by (file, line, rule_id)."""
        seen = set()
        unique = []
        for finding in findings:
            key = (finding.get("file", ""), finding.get("line", 0), finding.get("rule_id", ""))
            if key not in seen:
                seen.add(key)
                unique.append(finding)
        return unique

    # -- Helpers --

    @staticmethod
    def _map_vuln_class(scanner: str, rule_id: str) -> str:
        """Map scanner rule ID to AutoPentest vuln_class."""
        rule_lower = rule_id.lower()

        # SQL Injection
        if ("sql" in rule_lower and "injection" in rule_lower) or "sqli" in rule_lower:
            return "sqli_error"

        # XSS
        if "xss" in rule_lower or "cross-site-scripting" in rule_lower:
            if "stored" in rule_lower:
                return "xss_stored"
            elif "dom" in rule_lower:
                return "xss_dom"
            else:
                return "xss_reflected"

        # SSTI
        if "ssti" in rule_lower or "template" in rule_lower and "injection" in rule_lower:
            return "ssti"

        # SSRF
        if "ssrf" in rule_lower or "server-side-request" in rule_lower:
            return "ssrf"

        # Path Traversal
        if "path-traversal" in rule_lower or "directory-traversal" in rule_lower:
            return "path_traversal"

        # Command Injection
        if "command" in rule_lower and "injection" in rule_lower:
            return "command_injection"

        # Weak Crypto
        if "crypto" in rule_lower or "hash" in rule_lower or "random" in rule_lower:
            return "tls_config"

        # Hardcoded Secrets
        if "secret" in rule_lower or "password" in rule_lower or "key" in rule_lower:
            return "info_leak_headers"

        # Default
        return "misconfig"

    @staticmethod
    def _confidence_to_float(confidence: str) -> float:
        """Convert Bandit confidence string to float."""
        mapping = {"HIGH": 0.9, "MEDIUM": 0.7, "LOW": 0.5}
        return mapping.get(confidence.upper(), 0.7)


# -- Module-level singleton --

_sast_runner: Optional[SASTRunner] = None


def get_sast_runner() -> SASTRunner:
    """Return the lazily-initialized module-level SASTRunner singleton."""
    global _sast_runner
    if _sast_runner is None:
        _sast_runner = SASTRunner()
    return _sast_runner
