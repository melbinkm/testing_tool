"""
Safety Classifier - 4-tier safety classification for commands and payloads.

Adapted from Zen-Ai-Pentest exploit safety levels.
Classifies commands and payloads into SAFE, CAUTION, DANGEROUS, or BLOCKED
based on pattern matching against known-dangerous operations.
"""

from __future__ import annotations

import re
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple


class SafetyLevel(Enum):
    """Four-tier safety classification."""
    SAFE = "safe"           # Read-only, no side effects
    CAUTION = "caution"     # May modify state, needs awareness
    DANGEROUS = "dangerous" # Can cause damage, needs confirmation
    BLOCKED = "blocked"     # Out-of-scope or destructive, refuse


# ---------------------------------------------------------------------------
# Pattern definitions: (regex_pattern, reason)
# Patterns are checked in order: BLOCKED first, then DANGEROUS, then CAUTION.
# Anything that doesn't match is SAFE.
# ---------------------------------------------------------------------------

_BLOCKED_COMMAND_PATTERNS: List[Tuple[str, str]] = [
    (r"\brm\s+(-[rfRF]+\s+)?/\s*$", "Recursive deletion of root filesystem"),
    (r"\brm\s+-[rfRF]*\s+/\b", "Recursive deletion of root or system path"),
    (r"\bshutdown\b", "System shutdown"),
    (r"\breboot\b", "System reboot"),
    (r"\binit\s+[06]\b", "System init level change"),
    (r"\bsystemctl\s+(poweroff|halt|reboot)\b", "System power control"),
    (r"\b(dd\s+.*of=/dev/[sh]d[a-z])\b", "Direct disk write"),
    (r"\bmkfs\b", "Filesystem format"),
    (r"\bfdisk\b", "Disk partition modification"),
    (r"\b:(){ :\|:& };:", "Fork bomb"),
    (r"\b>\s*/dev/[sh]d[a-z]\b", "Direct device overwrite"),
    (r"\biptables\s+(-F|--flush)\b", "Firewall flush"),
]

_BLOCKED_PAYLOAD_PATTERNS: List[Tuple[str, str]] = [
    (r"\bDROP\s+DATABASE\b", "Database destruction"),
    (r"\bDROP\s+ALL\b", "Mass drop operation"),
    (r"\bTRUNCATE\s+TABLE\b", "Table truncation"),
    (r"\bFORMAT\s+C:", "Drive format"),
    (r"\bxp_cmdshell\b.*\b(del|rm|format)\b", "OS command via xp_cmdshell with destructive action"),
]

_DANGEROUS_COMMAND_PATTERNS: List[Tuple[str, str]] = [
    (r"\brm\s+-[rfRF]", "Recursive file deletion"),
    (r"\bDROP\s+TABLE\b", "SQL table drop"),
    (r"\bDELETE\s+FROM\b", "SQL row deletion"),
    (r"\btruncate\b", "Data truncation"),
    (r"\bchmod\s+777\b", "Overly permissive file permissions"),
    (r"\bchown\s+.*root\b", "Ownership change to root"),
    (r"\bsqlmap\b.*--os-shell\b", "sqlmap OS shell access"),
    (r"\bmetasploit\b|\bmsfconsole\b|\bmsfvenom\b", "Metasploit framework"),
    (r"\bhydra\b.*-l\b.*-P\b", "Brute-force credential attack"),
    (r"\bjohn\b.*--wordlist\b", "Password cracking"),
    (r"\bhashcat\b", "Password hash cracking"),
    (r"\bwget\b.*\|\s*(sh|bash)\b", "Remote code execution via pipe"),
    (r"\bcurl\b.*\|\s*(sh|bash)\b", "Remote code execution via pipe"),
]

_DANGEROUS_PAYLOAD_PATTERNS: List[Tuple[str, str]] = [
    (r"\bDROP\s+TABLE\b", "SQL table drop"),
    (r"\bDELETE\s+FROM\b", "SQL data deletion"),
    (r"\bALTER\s+TABLE\b", "SQL schema modification"),
    (r"\bxp_cmdshell\b", "SQL Server command execution"),
    (r"\bUTL_HTTP\b", "Oracle HTTP callout"),
    (r"\bDBMS_PIPE\b", "Oracle pipe command"),
    (r"\bLOAD_FILE\b", "MySQL file read"),
    (r"\bINTO\s+OUTFILE\b", "MySQL file write"),
    (r"\bINTO\s+DUMPFILE\b", "MySQL binary file write"),
]

_CAUTION_COMMAND_PATTERNS: List[Tuple[str, str]] = [
    (r"\bsqlmap\b", "SQL injection testing tool"),
    (r"\bnikto\b", "Web vulnerability scanner"),
    (r"\bwfuzz\b", "Web fuzzer"),
    (r"\bffuf\b", "Fast web fuzzer"),
    (r"\bdirb\b", "Directory brute-forcer"),
    (r"\bgobuster\b", "Directory/DNS brute-forcer"),
    (r"\bnuclei\b", "Vulnerability scanner"),
    (r"\bwpscan\b", "WordPress scanner"),
    (r"\bsearchsploit\b", "Exploit database search"),
    (r"\bcurl\b.*-X\s*(POST|PUT|DELETE|PATCH)\b", "HTTP state-changing request"),
    (r"\bINSERT\s+INTO\b", "SQL data insertion"),
    (r"\bUPDATE\s+.*\bSET\b", "SQL data update"),
    (r"\bCREATE\s+(TABLE|DATABASE)\b", "SQL schema creation"),
]

_CAUTION_PAYLOAD_PATTERNS: List[Tuple[str, str]] = [
    (r"\bINSERT\s+INTO\b", "SQL data insertion"),
    (r"\bUPDATE\s+.*\bSET\b", "SQL data update"),
    (r"\bCREATE\s+(TABLE|INDEX)\b", "SQL schema modification"),
    (r"\bUNION\s+SELECT\b", "SQL union injection"),
    (r"<script\b", "XSS script injection"),
    (r"javascript:", "JavaScript URI injection"),
    (r"\bonerror\s*=", "Event handler injection"),
]


def _check_patterns(
    text: str,
    patterns: List[Tuple[str, str]],
) -> Optional[Tuple[str, str]]:
    """Check text against a list of (pattern, reason) tuples.
    Returns (matched_pattern, reason) or None.
    """
    for pattern, reason in patterns:
        if re.search(pattern, text, re.IGNORECASE):
            return (pattern, reason)
    return None


class SafetyClassifier:
    """Classify commands and payloads by safety level."""

    def classify_command(self, command: str) -> Dict[str, Any]:
        """Classify a shell command.

        Returns
        -------
        dict
            level (SafetyLevel value str), reason, matched_pattern
        """
        if not command or not command.strip():
            return {"level": SafetyLevel.SAFE.value, "reason": "Empty command", "matched_pattern": ""}

        # Check BLOCKED
        match = _check_patterns(command, _BLOCKED_COMMAND_PATTERNS)
        if match:
            return {"level": SafetyLevel.BLOCKED.value, "reason": match[1], "matched_pattern": match[0]}

        # Check DANGEROUS
        match = _check_patterns(command, _DANGEROUS_COMMAND_PATTERNS)
        if match:
            return {"level": SafetyLevel.DANGEROUS.value, "reason": match[1], "matched_pattern": match[0]}

        # Check CAUTION
        match = _check_patterns(command, _CAUTION_COMMAND_PATTERNS)
        if match:
            return {"level": SafetyLevel.CAUTION.value, "reason": match[1], "matched_pattern": match[0]}

        return {"level": SafetyLevel.SAFE.value, "reason": "No dangerous patterns detected", "matched_pattern": ""}

    def classify_payload(self, payload: str, payload_type: str = "generic") -> Dict[str, Any]:
        """Classify a fuzz payload.

        Parameters
        ----------
        payload : str
            The payload string.
        payload_type : str
            Hint about the payload type (sqli, xss, cmdi, etc.).
        """
        if not payload:
            return {"level": SafetyLevel.SAFE.value, "reason": "Empty payload", "matched_pattern": ""}

        # Check BLOCKED
        match = _check_patterns(payload, _BLOCKED_PAYLOAD_PATTERNS)
        if match:
            return {"level": SafetyLevel.BLOCKED.value, "reason": match[1], "matched_pattern": match[0]}

        # Check DANGEROUS
        match = _check_patterns(payload, _DANGEROUS_PAYLOAD_PATTERNS)
        if match:
            return {"level": SafetyLevel.DANGEROUS.value, "reason": match[1], "matched_pattern": match[0]}

        # Check CAUTION
        match = _check_patterns(payload, _CAUTION_PAYLOAD_PATTERNS)
        if match:
            return {"level": SafetyLevel.CAUTION.value, "reason": match[1], "matched_pattern": match[0]}

        return {"level": SafetyLevel.SAFE.value, "reason": "No dangerous patterns detected", "matched_pattern": ""}

    def classify_url(self, url: str, scope_validator=None) -> Dict[str, Any]:
        """Classify a URL for safety.

        Parameters
        ----------
        url : str
            The URL to classify.
        scope_validator :
            Optional callable(url) -> bool to check if the URL is in scope.
        """
        if not url:
            return {"level": SafetyLevel.SAFE.value, "reason": "Empty URL", "matched_pattern": ""}

        # Check if out of scope
        if scope_validator is not None:
            try:
                if not scope_validator(url):
                    return {
                        "level": SafetyLevel.BLOCKED.value,
                        "reason": "URL is out of scope",
                        "matched_pattern": url,
                    }
            except Exception:
                pass

        # Internal/metadata endpoints
        metadata_patterns = [
            (r"169\.254\.169\.254", "AWS metadata endpoint"),
            (r"metadata\.google\.internal", "GCP metadata endpoint"),
            (r"100\.100\.100\.200", "Alibaba metadata endpoint"),
        ]
        match = _check_patterns(url, metadata_patterns)
        if match:
            return {"level": SafetyLevel.CAUTION.value, "reason": f"Cloud metadata: {match[1]}", "matched_pattern": match[0]}

        return {"level": SafetyLevel.SAFE.value, "reason": "URL appears safe", "matched_pattern": ""}


# ---------------------------------------------------------------------------
# Module-level singleton
# ---------------------------------------------------------------------------

_classifier_instance: Optional[SafetyClassifier] = None


def get_safety_classifier() -> SafetyClassifier:
    """Return (or create) the module-level SafetyClassifier singleton."""
    global _classifier_instance
    if _classifier_instance is None:
        _classifier_instance = SafetyClassifier()
    return _classifier_instance
