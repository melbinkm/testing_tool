"""
Scope Loader (Database) - Loads and saves engagement scope from PostgreSQL.

Provides per-assessment scope configuration with versioning support.
Complements file-based scope_loader.py with database persistence.
"""

import logging
from typing import Optional, List, Dict, Any
from datetime import datetime

import asyncpg
from pydantic import ValidationError as PydanticValidationError

from lib.scope_types import EngagementScope, ScopeValidationError

logger = logging.getLogger("autopentest-mcp")


async def load_scope_from_db(
    assessment_id: int,
    pool: asyncpg.Pool,
) -> Optional[EngagementScope]:
    """Load the active scope configuration for an assessment from the database.

    Parameters
    ----------
    assessment_id : int
        Assessment ID to load scope for.
    pool : asyncpg.Pool
        Database connection pool.

    Returns
    -------
    EngagementScope or None
        Validated scope configuration, or None if no scope exists for this assessment.

    Raises
    ------
    ScopeValidationError
        If the scope data in the database is invalid or fails Pydantic validation.
    """
    async with pool.acquire() as conn:
        row = await conn.fetchrow(
            """
            SELECT scope_data
            FROM wm_scope_config
            WHERE assessment_id = $1 AND is_active = TRUE
            ORDER BY version DESC
            LIMIT 1
            """,
            assessment_id,
        )

    if not row:
        logger.debug(f"No scope configuration found for assessment {assessment_id}")
        return None

    scope_data = row["scope_data"]

    # Validate against Pydantic schema
    try:
        scope = EngagementScope(**scope_data)
        logger.info(
            f"Loaded scope configuration for assessment {assessment_id} "
            f"(engagement: {scope.engagement.id})"
        )
        return scope
    except PydanticValidationError as exc:
        errors = []
        for err in exc.errors():
            loc = " -> ".join(str(part) for part in err["loc"])
            errors.append(f"{loc}: {err['msg']}")
        raise ScopeValidationError(
            f"Invalid scope data for assessment {assessment_id}",
            errors,
        )


async def save_scope_to_db(
    assessment_id: int,
    scope: EngagementScope,
    pool: asyncpg.Pool,
    created_by: Optional[str] = None,
    notes: Optional[str] = None,
) -> int:
    """Save a new scope configuration version for an assessment.

    Creates a new scope version and deactivates all previous versions.
    This provides an audit trail of scope changes during an assessment.

    Parameters
    ----------
    assessment_id : int
        Assessment ID to save scope for.
    scope : EngagementScope
        Validated scope configuration to save.
    pool : asyncpg.Pool
        Database connection pool.
    created_by : str, optional
        User/system that created this scope version (for audit trail).
    notes : str, optional
        Notes about this scope change (e.g., "Added staging environment to allowlist").

    Returns
    -------
    int
        Version number of the newly created scope configuration.

    Raises
    ------
    asyncpg.PostgresError
        If database operation fails.
    """
    # Serialize scope to dict (Pydantic model_dump)
    scope_data = scope.model_dump(mode="json", exclude_none=True)

    async with pool.acquire() as conn:
        async with conn.transaction():
            # Get the next version number
            current_version = await conn.fetchval(
                """
                SELECT COALESCE(MAX(version), 0)
                FROM wm_scope_config
                WHERE assessment_id = $1
                """,
                assessment_id,
            )
            next_version = current_version + 1

            # Deactivate all existing scope configurations
            await conn.execute(
                """
                UPDATE wm_scope_config
                SET is_active = FALSE
                WHERE assessment_id = $1 AND is_active = TRUE
                """,
                assessment_id,
            )

            # Insert new scope configuration
            await conn.execute(
                """
                INSERT INTO wm_scope_config
                    (assessment_id, version, scope_data, is_active, created_by, notes)
                VALUES ($1, $2, $3, TRUE, $4, $5)
                """,
                assessment_id,
                next_version,
                scope_data,
                created_by,
                notes,
            )

    logger.info(
        f"Saved scope configuration v{next_version} for assessment {assessment_id} "
        f"(engagement: {scope.engagement.id})"
    )
    return next_version


async def get_scope_history(
    assessment_id: int,
    pool: asyncpg.Pool,
    limit: int = 50,
) -> List[Dict[str, Any]]:
    """Get the version history of scope configurations for an assessment.

    Returns metadata about each scope version (without full scope data)
    for audit trail and investigation of scope changes.

    Parameters
    ----------
    assessment_id : int
        Assessment ID to get history for.
    pool : asyncpg.Pool
        Database connection pool.
    limit : int
        Maximum number of versions to return (default 50).

    Returns
    -------
    List[Dict[str, Any]]
        List of scope versions, newest first. Each dict contains:
        - id: Database record ID
        - version: Version number
        - is_active: Whether this version is currently active
        - created_at: Timestamp when version was created
        - created_by: User/system that created this version
        - notes: Notes about this scope change
        - engagement_id: Engagement ID from the scope data
    """
    async with pool.acquire() as conn:
        rows = await conn.fetch(
            """
            SELECT
                id,
                version,
                is_active,
                created_at,
                created_by,
                notes,
                scope_data->'engagement'->>'id' as engagement_id
            FROM wm_scope_config
            WHERE assessment_id = $1
            ORDER BY version DESC
            LIMIT $2
            """,
            assessment_id,
            limit,
        )

    history = []
    for row in rows:
        history.append({
            "id": row["id"],
            "version": row["version"],
            "is_active": row["is_active"],
            "created_at": row["created_at"].isoformat() if row["created_at"] else None,
            "created_by": row["created_by"],
            "notes": row["notes"],
            "engagement_id": row.get("engagement_id"),
        })

    logger.debug(f"Retrieved {len(history)} scope versions for assessment {assessment_id}")
    return history


async def delete_scope_version(
    assessment_id: int,
    version: int,
    pool: asyncpg.Pool,
) -> bool:
    """Delete a specific scope version (only if not active).

    Parameters
    ----------
    assessment_id : int
        Assessment ID.
    version : int
        Version number to delete.
    pool : asyncpg.Pool
        Database connection pool.

    Returns
    -------
    bool
        True if version was deleted, False if it was active or didn't exist.
    """
    async with pool.acquire() as conn:
        result = await conn.execute(
            """
            DELETE FROM wm_scope_config
            WHERE assessment_id = $1 AND version = $2 AND is_active = FALSE
            """,
            assessment_id,
            version,
        )

    deleted = result.split()[1] == "1"  # "DELETE 1" means one row deleted
    if deleted:
        logger.info(f"Deleted scope version {version} for assessment {assessment_id}")
    else:
        logger.debug(
            f"Could not delete scope version {version} for assessment {assessment_id} "
            "(may be active or not exist)"
        )
    return deleted
