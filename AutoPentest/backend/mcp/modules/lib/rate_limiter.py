"""
Token Bucket Rate Limiter

Implements the token bucket algorithm for rate limiting HTTP requests.
Tokens refill at a constant rate up to a maximum bucket size.

Ported from http-client-mcp/src/rate-limiter.ts
"""

import asyncio
import math
import time


class RateLimiter:
    """Token bucket rate limiter for controlling request throughput."""

    def __init__(self, max_rps: float) -> None:
        """
        Create a new rate limiter.

        Args:
            max_rps: Maximum requests per second (also the bucket size).
                     Must be positive.

        Raises:
            ValueError: If max_rps is not positive.
        """
        if max_rps <= 0:
            raise ValueError("max_rps must be positive")

        self._max_tokens: float = max_rps
        self._tokens: float = max_rps  # Start with full bucket
        self._refill_rate_per_second: float = max_rps
        self._last_refill_time: float = time.time()

    def _refill(self) -> None:
        """Refill tokens based on elapsed time since last refill."""
        now = time.time()
        elapsed_seconds = now - self._last_refill_time

        tokens_to_add = elapsed_seconds * self._refill_rate_per_second
        self._tokens = min(self._max_tokens, self._tokens + tokens_to_add)
        self._last_refill_time = now

    def try_acquire(self) -> dict:
        """
        Try to acquire a token without waiting.

        Returns:
            dict with keys:
                - "allowed" (bool): Whether acquisition was successful.
                - "wait_ms" (float): Milliseconds to wait if not allowed (0 if allowed).
        """
        self._refill()

        if self._tokens >= 1:
            self._tokens -= 1
            return {"allowed": True, "wait_ms": 0.0}

        # Calculate how long until a token is available
        tokens_needed = 1 - self._tokens
        wait_ms = math.ceil((tokens_needed / self._refill_rate_per_second) * 1000)

        return {"allowed": False, "wait_ms": float(wait_ms)}

    async def wait_for_token(self) -> None:
        """
        Wait for a token to become available.

        Uses asyncio.sleep to yield control while waiting for rate limit
        tokens to refill.

        Raises:
            RuntimeError: If a token cannot be acquired after waiting.
        """
        result = self.try_acquire()

        if result["allowed"]:
            return

        # Wait and try again
        await asyncio.sleep(result["wait_ms"] / 1000.0)

        # After waiting, try to acquire again
        retry_result = self.try_acquire()
        if not retry_result["allowed"]:
            # Edge case: if still not allowed, wait the remaining time
            await asyncio.sleep(retry_result["wait_ms"] / 1000.0)
            final_result = self.try_acquire()
            if not final_result["allowed"]:
                raise RuntimeError("Failed to acquire token after waiting")

    def get_status(self) -> dict:
        """
        Get current rate limiter status.

        Returns:
            dict with keys:
                - "tokens" (float): Currently available tokens.
                - "max_tokens" (float): Maximum bucket capacity.
                - "refill_rate_per_second" (float): Token refill rate.
                - "last_refill_time" (float): Timestamp of last refill.
        """
        self._refill()
        return {
            "tokens": self._tokens,
            "max_tokens": self._max_tokens,
            "refill_rate_per_second": self._refill_rate_per_second,
            "last_refill_time": self._last_refill_time,
        }

    def reset(self) -> None:
        """Reset the rate limiter to initial state (full bucket)."""
        self._tokens = self._max_tokens
        self._last_refill_time = time.time()

    def get_available_tokens(self) -> float:
        """
        Get the number of available tokens.

        Returns:
            The current token count after refilling.
        """
        self._refill()
        return self._tokens
