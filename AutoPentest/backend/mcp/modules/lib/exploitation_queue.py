"""Exploitation Queue - Code-Analysis-Derived Attack Plan.

Builds a prioritized queue of potential exploitation targets from
SAST findings and data flow traces.
"""

import uuid
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Any, Optional


class QueueSlotType(Enum):
    INJECTION = "injection"
    AUTH = "auth"
    PRIVILEGE = "privilege"
    DATA_EXPOSURE = "data_exposure"
    BUSINESS_LOGIC = "business_logic"


@dataclass
class ExploitationQueueEntry:
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    vuln_type: str = ""
    source: str = ""
    sink: str = ""
    slot_type: QueueSlotType = QueueSlotType.INJECTION
    sanitization: str = ""
    verdict: str = "needs_review"
    witness_payload: str = ""
    confidence: float = 0.5

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "vuln_type": self.vuln_type,
            "source": self.source,
            "sink": self.sink,
            "slot_type": self.slot_type.value,
            "sanitization": self.sanitization,
            "verdict": self.verdict,
            "witness_payload": self.witness_payload,
            "confidence": self.confidence,
        }


class ExploitationQueue:
    """Prioritized queue of exploitation targets."""

    def __init__(self):
        self.entries: List[ExploitationQueueEntry] = []

    def add_entry(self, entry: ExploitationQueueEntry) -> None:
        self.entries.append(entry)

    def filter_by_vuln_type(self, vuln_type: str) -> List[ExploitationQueueEntry]:
        return [e for e in self.entries if e.vuln_type == vuln_type]

    def filter_by_confidence(self, min_confidence: float) -> List[ExploitationQueueEntry]:
        return [e for e in self.entries if e.confidence >= min_confidence]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "total_entries": len(self.entries),
            "entries": [e.to_dict() for e in self.entries],
            "by_slot_type": self._count_by_slot_type(),
            "avg_confidence": self._avg_confidence(),
        }

    def _count_by_slot_type(self) -> Dict[str, int]:
        counts: Dict[str, int] = {}
        for e in self.entries:
            key = e.slot_type.value
            counts[key] = counts.get(key, 0) + 1
        return counts

    def _avg_confidence(self) -> float:
        if not self.entries:
            return 0.0
        return round(sum(e.confidence for e in self.entries) / len(self.entries), 2)


# Mapping of vulnerability classes to slot types
_VULN_TO_SLOT: Dict[str, QueueSlotType] = {
    "sqli": QueueSlotType.INJECTION,
    "sql_injection": QueueSlotType.INJECTION,
    "xss": QueueSlotType.INJECTION,
    "command_injection": QueueSlotType.INJECTION,
    "ssti": QueueSlotType.INJECTION,
    "nosql_injection": QueueSlotType.INJECTION,
    "ldap_injection": QueueSlotType.INJECTION,
    "insecure_deserialization": QueueSlotType.INJECTION,
    "path_traversal": QueueSlotType.INJECTION,
    "auth_bypass": QueueSlotType.AUTH,
    "broken_auth": QueueSlotType.AUTH,
    "session_fixation": QueueSlotType.AUTH,
    "jwt_manipulation": QueueSlotType.AUTH,
    "privilege_escalation": QueueSlotType.PRIVILEGE,
    "idor": QueueSlotType.PRIVILEGE,
    "mass_assignment": QueueSlotType.PRIVILEGE,
    "info_leak": QueueSlotType.DATA_EXPOSURE,
    "ssrf": QueueSlotType.DATA_EXPOSURE,
    "race_condition": QueueSlotType.BUSINESS_LOGIC,
    "csrf": QueueSlotType.BUSINESS_LOGIC,
}

# Suggested witness payloads by vuln type
_WITNESS_PAYLOADS: Dict[str, str] = {
    "sqli": "' OR 1=1 --",
    "sql_injection": "' OR 1=1 --",
    "xss": "<script>alert(1)</script>",
    "command_injection": "; id",
    "ssti": "{{7*7}}",
    "path_traversal": "../../etc/passwd",
    "ssrf": "http://169.254.169.254/",
    "nosql_injection": '{"$gt": ""}',
    "insecure_deserialization": "rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcA==",
}


def build_queue_from_sast(
    sast_findings: List[Dict[str, Any]],
    dataflow_traces: Optional[List[Dict[str, Any]]] = None,
) -> ExploitationQueue:
    """Build an exploitation queue from SAST findings and data flow traces.

    Parameters
    ----------
    sast_findings : list[dict]
        SAST findings from wm_knowledge.
    dataflow_traces : list[dict], optional
        Data flow traces from wm_knowledge.

    Returns
    -------
    ExploitationQueue
        Populated exploitation queue.
    """
    queue = ExploitationQueue()
    trace_map: Dict[str, Dict] = {}

    # Index traces by file+line for matching
    for trace in (dataflow_traces or []):
        metadata = trace.get("metadata", {})
        if isinstance(metadata, str):
            import json
            try:
                metadata = json.loads(metadata)
            except (json.JSONDecodeError, TypeError):
                metadata = {}
        source = metadata.get("source", {})
        key = f"{source.get('file', '')}:{source.get('line', 0)}"
        trace_map[key] = metadata

    for finding in sast_findings:
        metadata = finding.get("metadata", {})
        if isinstance(metadata, str):
            import json
            try:
                metadata = json.loads(metadata)
            except (json.JSONDecodeError, TypeError):
                metadata = {}

        file_path = metadata.get("file", "")
        line = metadata.get("line", 0)
        vuln_class = metadata.get("vuln_class", "")
        severity = metadata.get("severity", "medium")

        # Check for matching trace
        trace_key = f"{file_path}:{line}"
        trace = trace_map.get(trace_key, {})

        # Determine slot type
        slot_type = _VULN_TO_SLOT.get(vuln_class, QueueSlotType.INJECTION)

        # Build source/sink strings
        source_str = f"{file_path}:{line}"
        sink_str = trace.get("sink", {}).get("function", vuln_class)
        sanitization = ", ".join(
            s.get("transform_name", "") for s in trace.get("sanitization_chain", [])
        )
        verdict = trace.get("verdict", "needs_review")
        confidence = trace.get("confidence", _severity_confidence(severity))

        entry = ExploitationQueueEntry(
            vuln_type=vuln_class,
            source=source_str,
            sink=sink_str,
            slot_type=slot_type,
            sanitization=sanitization,
            verdict=verdict,
            witness_payload=_WITNESS_PAYLOADS.get(vuln_class, ""),
            confidence=confidence,
        )
        queue.add_entry(entry)

    return queue


def _severity_confidence(severity: str) -> float:
    """Map severity string to default confidence."""
    return {
        "critical": 0.9,
        "high": 0.7,
        "medium": 0.5,
        "low": 0.3,
        "info": 0.1,
    }.get(severity.lower(), 0.5)
