"""
Activity Logger - Detailed debug logging for assessment activities

Logs all tool executions, phase transitions, findings created, and system events
to both database and log files for debugging and audit trails.
"""
import logging
from datetime import datetime
from typing import Optional, Dict, Any
import json

logger = logging.getLogger(__name__)


class ActivityLogger:
    """Logs all assessment activities to database and files"""

    def __init__(self, assessment_id: int, db_pool):
        self.assessment_id = assessment_id
        self.db_pool = db_pool

    async def log_tool_execution(
        self,
        tool_name: str,
        parameters: Dict[str, Any],
        status: str,  # "started", "completed", "failed"
        result: Optional[str] = None,
        error: Optional[str] = None,
        execution_time_ms: Optional[int] = None
    ):
        """Log tool execution with full details"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "assessment_id": self.assessment_id,
            "activity_type": f"tool_execution/{status}",  # Compound format for WebSocket routing
            "tool_name": tool_name,
            "parameters": parameters,
            "status": status,
            "result": result,
            "error": error,
            "execution_time_ms": execution_time_ms
        }

        # Write to database
        await self._write_to_db(log_entry)

        # Write to file
        logger.info(f"TOOL_EXEC: {json.dumps(log_entry)}")

    async def log_phase_transition(
        self,
        from_phase: int,
        to_phase: int,
        reason: str,
        forced: bool = False,
        metrics: Optional[Dict[str, Any]] = None
    ):
        """Log phase transitions"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "assessment_id": self.assessment_id,
            "activity_type": "phase_transition",
            "from_phase": from_phase,
            "to_phase": to_phase,
            "reason": reason,
            "forced": forced,
            "metrics": metrics or {}
        }

        await self._write_to_db(log_entry)
        logger.info(f"PHASE_TRANSITION: {json.dumps(log_entry)}")

    async def log_finding_created(
        self,
        finding_id: int,
        title: str,
        severity: str,
        source: str,  # "tool", "manual", "world_model"
        tool_name: Optional[str] = None
    ):
        """Log when findings are created"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "assessment_id": self.assessment_id,
            "activity_type": "finding_created",
            "finding_id": finding_id,
            "title": title,
            "severity": severity,
            "source": source,
            "tool_name": tool_name
        }

        await self._write_to_db(log_entry)
        logger.info(f"FINDING_CREATED: {json.dumps(log_entry)}")

    async def log_scan_started(
        self,
        scan_type: str,
        target: str,
        options: Dict[str, Any]
    ):
        """Log when scans start"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "assessment_id": self.assessment_id,
            "activity_type": "scan_started",
            "scan_type": scan_type,
            "target": target,
            "options": options
        }

        await self._write_to_db(log_entry)
        logger.info(f"SCAN_STARTED: {json.dumps(log_entry)}")

    async def log_scan_completed(
        self,
        scan_type: str,
        target: str,
        results_count: int,
        execution_time_ms: int,
        findings_created: int = 0
    ):
        """Log when scans complete"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "assessment_id": self.assessment_id,
            "activity_type": "scan_completed",
            "scan_type": scan_type,
            "target": target,
            "results_count": results_count,
            "execution_time_ms": execution_time_ms,
            "findings_created": findings_created
        }

        await self._write_to_db(log_entry)
        logger.info(f"SCAN_COMPLETED: {json.dumps(log_entry)}")

    async def log_recon_data(
        self,
        data_type: str,
        count: int,
        details: Optional[Dict] = None
    ):
        """Log reconnaissance data collection"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "assessment_id": self.assessment_id,
            "activity_type": "recon_data",
            "data_type": data_type,
            "count": count,
            "details": details or {}
        }

        await self._write_to_db(log_entry)
        logger.info(f"RECON_DATA: {json.dumps(log_entry)}")

    async def log_world_model_update(
        self,
        operation: str,  # "create", "update", "delete"
        entity_type: str,  # "asset", "endpoint", "finding", "observation", "hypothesis"
        entity_id: str,
        details: Optional[Dict] = None
    ):
        """Log world model database operations"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "assessment_id": self.assessment_id,
            "activity_type": "world_model_update",
            "operation": operation,
            "entity_type": entity_type,
            "entity_id": entity_id,
            "details": details or {}
        }

        await self._write_to_db(log_entry)
        logger.info(f"WORLD_MODEL_UPDATE: {json.dumps(log_entry)}")

    async def log_http_exchange(
        self,
        url: str,
        method: str,
        status_code: int,
        request_headers: Dict[str, Any],
        response_headers: Dict[str, Any],
        response_body_preview: str,
        correlation_id: str,
        timing_ms: float
    ):
        """Log an HTTP exchange for audit trail"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "assessment_id": self.assessment_id,
            "activity_type": "http_exchange",
            "url": url,
            "method": method,
            "status_code": status_code,
            "request_headers": request_headers,
            "response_headers": response_headers,
            "body_preview": response_body_preview[:2048],
            "correlation_id": correlation_id,
            "timing_ms": timing_ms,
        }

        await self._write_to_db(log_entry)
        logger.debug(f"HTTP_EXCHANGE: {method} {url} -> {status_code} ({timing_ms:.0f}ms)")

    async def log_error(
        self,
        error_type: str,
        error_message: str,
        context: Optional[Dict] = None,
        stack_trace: Optional[str] = None
    ):
        """Log errors and exceptions"""
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "assessment_id": self.assessment_id,
            "activity_type": "error",
            "error_type": error_type,
            "error_message": error_message,
            "context": context or {},
            "stack_trace": stack_trace
        }

        await self._write_to_db(log_entry)
        logger.error(f"ERROR: {json.dumps(log_entry)}")

    async def _write_to_db(self, log_entry: Dict):
        """Write log entry to activity_log table"""
        try:
            query = """
                INSERT INTO activity_log (
                    assessment_id, activity_type, timestamp,
                    data, created_at
                ) VALUES ($1, $2, $3, $4, NOW())
            """

            # Convert ISO string to datetime for asyncpg (Fix 4)
            ts = log_entry["timestamp"]
            if isinstance(ts, str):
                ts = datetime.fromisoformat(ts.replace('Z', '+00:00'))

            async with self.db_pool.acquire() as conn:
                await conn.execute(
                    query,
                    self.assessment_id,
                    log_entry["activity_type"],
                    ts,
                    json.dumps(log_entry)
                )
        except Exception as e:
            # Don't fail the operation if logging fails, just log to file
            logger.error(f"Failed to write activity log to database: {e}")
