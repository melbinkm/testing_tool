"""Shared utility helpers used by all tool modules.

Centralises the four micro-helpers that were duplicated across every tool
module.  Import what you need and delete the local copy:

    from lib.tool_helpers import _get_db, _json_content, _error_content
    from lib.tool_helpers import _get_http_client  # if needed
"""
from __future__ import annotations

import json
import os
from typing import Any, List

from mcp.types import TextContent

from lib.error_codes import ErrorCode, ErrorType, PentestError
from lib.http_client import HttpClient
from lib.world_model_db import get_world_model_db


# ---------------------------------------------------------------------------
# Database helper
# ---------------------------------------------------------------------------

async def _get_db(mcp_service: Any):
    """Get WorldModelDatabase for current assessment.

    Raises ValueError if no assessment is loaded.
    """
    if not mcp_service or not mcp_service.current_assessment_id:
        raise ValueError("No assessment loaded. Call load_assessment first.")
    return await get_world_model_db(mcp_service.current_assessment_id)


# ---------------------------------------------------------------------------
# MCP response helpers
# ---------------------------------------------------------------------------

def _json_content(data: Any) -> List[TextContent]:
    """Return *data* serialised as JSON inside a single TextContent list."""
    return [TextContent(type="text", text=json.dumps(data, indent=2, default=str))]


def _error_content(message: str) -> List[TextContent]:
    """Return a JSON error object inside a single TextContent list."""
    return [TextContent(type="text", text=json.dumps(
        {"success": False, "error": message}, indent=2
    ))]


# ---------------------------------------------------------------------------
# HTTP client helper
# ---------------------------------------------------------------------------

def _get_http_client(mcp_service) -> HttpClient:
    """Get or create a rate-limited, scope-validated HttpClient.

    Caches the client per assessment on *mcp_service* so that budget and
    rate-limit counters are preserved across tool calls.
    """
    cache_key = mcp_service.current_assessment_id
    if (
        hasattr(mcp_service, "_http_client_cache")
        and hasattr(mcp_service, "_http_client_cache_key")
        and mcp_service._http_client_cache_key == cache_key
        and mcp_service._http_client_cache is not None
    ):
        return mcp_service._http_client_cache

    # Build an exchange-logger callback for the audit trail
    async def _log_exchange(request, response, correlation_ids, timing):
        if hasattr(mcp_service, "activity_logger") and mcp_service.activity_logger:
            await mcp_service.activity_logger.log_http_exchange(
                url=request.get("url", ""),
                method=request.get("method", ""),
                status_code=response.get("status", 0),
                request_headers=request.get("headers", {}),
                response_headers=response.get("headers", {}),
                response_body_preview=(response.get("body") or "")[:2048],
                correlation_id=correlation_ids.get("request_id", ""),
                timing_ms=timing.get("duration_ms", 0),
            )

    client = HttpClient(
        config={
            "engagement_id": os.environ.get("ENGAGEMENT_ID", "default"),
            "proxy_url": os.environ.get("HTTP_PROXY_URL"),
            "max_rps": float(os.environ.get("MAX_RPS", "10")),
            "max_concurrent": int(os.environ.get("MAX_CONCURRENT", "5")),
            "default_timeout": float(os.environ.get("DEFAULT_TIMEOUT", "30000")),
            "max_total_requests": int(os.environ.get("MAX_TOTAL_REQUESTS", "999999999")),
        },
        assessment_id=mcp_service.current_assessment_id,
        scope_provider=mcp_service.scope_provider,
        exchange_logger=_log_exchange,
    )

    mcp_service._http_client_cache = client
    mcp_service._http_client_cache_key = cache_key
    return client
