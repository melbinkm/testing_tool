"""
Risk Engine - CVSS v3.1 scoring, EPSS estimation, business impact, unified risk scoring.

Adapted from Zen-Ai-Pentest risk assessment concepts.
Provides CVSS v3.1 base score calculation, business impact assessment,
and a unified risk scorer that combines multiple factors.
"""

from __future__ import annotations

import math
import re
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple


# ---------------------------------------------------------------------------
# CVSS v3.1 constants
# ---------------------------------------------------------------------------

# Metric value maps (metric_name -> {value_code: numeric_value})
_CVSS_METRICS = {
    "AV": {"N": 0.85, "A": 0.62, "L": 0.55, "P": 0.20},
    "AC": {"L": 0.77, "H": 0.44},
    "PR": {
        # scope_changed=False
        "N": {"U": 0.85, "C": 0.85},
        "L": {"U": 0.62, "C": 0.68},
        "H": {"U": 0.27, "C": 0.50},
    },
    "UI": {"N": 0.85, "R": 0.62},
    "S": {"U": "unchanged", "C": "changed"},
    "C": {"N": 0.0, "L": 0.22, "H": 0.56},
    "I": {"N": 0.0, "L": 0.22, "H": 0.56},
    "A": {"N": 0.0, "L": 0.22, "H": 0.56},
}

_SEVERITY_RANGES = [
    (0.0, 0.0, "none"),
    (0.1, 3.9, "low"),
    (4.0, 6.9, "medium"),
    (7.0, 8.9, "high"),
    (9.0, 10.0, "critical"),
]


def _roundup(x: float) -> float:
    """CVSS v3.1 'roundup' function: round to one decimal place, always up."""
    return math.ceil(x * 10) / 10


class CVSSv31:
    """Parse and calculate CVSS v3.1 base scores.

    Example
    -------
    >>> c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
    >>> c.base_score()
    9.8
    """

    def __init__(self, vector: str) -> None:
        self._vector = vector.strip()
        self._metrics: Dict[str, str] = {}
        self._parse()

    def _parse(self) -> None:
        """Parse the vector string into metric values."""
        # Accept both "CVSS:3.1/..." and raw "AV:N/AC:L/..."
        cleaned = re.sub(r"^CVSS:\d+\.\d+/", "", self._vector)
        parts = cleaned.split("/")
        for part in parts:
            if ":" not in part:
                continue
            key, val = part.split(":", 1)
            key = key.strip().upper()
            val = val.strip().upper()
            if key in _CVSS_METRICS:
                self._metrics[key] = val

        # Validate required metrics
        required = {"AV", "AC", "PR", "UI", "S", "C", "I", "A"}
        missing = required - set(self._metrics.keys())
        if missing:
            raise ValueError(f"Missing CVSS v3.1 metrics: {', '.join(sorted(missing))}")

    def base_score(self) -> float:
        """Calculate the CVSS v3.1 base score (0.0 - 10.0)."""
        scope_changed = self._metrics["S"] == "C"

        # Impact sub-score components
        isc_c = _CVSS_METRICS["C"][self._metrics["C"]]
        isc_i = _CVSS_METRICS["I"][self._metrics["I"]]
        isc_a = _CVSS_METRICS["A"][self._metrics["A"]]
        isc_base = 1 - ((1 - isc_c) * (1 - isc_i) * (1 - isc_a))

        if scope_changed:
            impact = 7.52 * (isc_base - 0.029) - 3.25 * (isc_base - 0.02) ** 15
        else:
            impact = 6.42 * isc_base

        if impact <= 0:
            return 0.0

        # Exploitability sub-score
        av = _CVSS_METRICS["AV"][self._metrics["AV"]]
        ac = _CVSS_METRICS["AC"][self._metrics["AC"]]

        # PR depends on scope
        pr_map = _CVSS_METRICS["PR"][self._metrics["PR"]]
        scope_key = "C" if scope_changed else "U"
        pr = pr_map[scope_key]

        ui = _CVSS_METRICS["UI"][self._metrics["UI"]]
        exploitability = 8.22 * av * ac * pr * ui

        if scope_changed:
            score = _roundup(min(1.08 * (impact + exploitability), 10.0))
        else:
            score = _roundup(min(impact + exploitability, 10.0))

        return score

    def severity(self) -> str:
        """Return the qualitative severity rating."""
        score = self.base_score()
        for low, high, label in _SEVERITY_RANGES:
            if low <= score <= high:
                return label
        return "none"

    def to_dict(self) -> Dict[str, Any]:
        """Return all metrics, scores, and severity as a dict."""
        return {
            "vector": self._vector,
            "metrics": dict(self._metrics),
            "base_score": self.base_score(),
            "severity": self.severity(),
        }


# ---------------------------------------------------------------------------
# Business Impact
# ---------------------------------------------------------------------------

# Weight maps for business impact calculation
_ASSET_TYPE_WEIGHTS = {
    "web_app": 0.7,
    "api": 0.8,
    "database": 0.9,
    "infrastructure": 0.85,
    "iot": 0.6,
}

_DATA_CLASSIFICATION_WEIGHTS = {
    "public": 0.1,
    "internal": 0.4,
    "confidential": 0.7,
    "restricted": 1.0,
}

_COMPLIANCE_WEIGHTS = {
    "pci-dss": 0.9,
    "hipaa": 0.95,
    "gdpr": 0.85,
    "sox": 0.8,
    "iso27001": 0.7,
    "nist": 0.75,
    "fedramp": 0.85,
}

_USER_BASE_WEIGHTS = {
    "internal": 0.3,
    "small": 0.5,
    "medium": 0.7,
    "large": 0.9,
    "public": 1.0,
}


class BusinessImpact:
    """Calculate business impact from asset context."""

    def calculate(
        self,
        asset_type: str = "web_app",
        data_classification: str = "internal",
        compliance_frameworks: Optional[List[str]] = None,
        user_base: str = "medium",
    ) -> Dict[str, Any]:
        """Calculate business impact scores.

        Returns a dict with financial, reputation, compliance, operational,
        overall scores (0.0-1.0), and contributing factors.
        """
        compliance_frameworks = compliance_frameworks or []

        asset_w = _ASSET_TYPE_WEIGHTS.get(asset_type, 0.5)
        data_w = _DATA_CLASSIFICATION_WEIGHTS.get(data_classification, 0.4)
        user_w = _USER_BASE_WEIGHTS.get(user_base, 0.5)

        # Compliance: max of all frameworks, default 0.3 if none
        if compliance_frameworks:
            comp_w = max(
                _COMPLIANCE_WEIGHTS.get(f.lower(), 0.5)
                for f in compliance_frameworks
            )
        else:
            comp_w = 0.3

        # Sub-scores
        financial = round(0.4 * data_w + 0.3 * asset_w + 0.3 * user_w, 4)
        reputation = round(0.5 * user_w + 0.3 * data_w + 0.2 * asset_w, 4)
        compliance_score = round(comp_w, 4)
        operational = round(0.5 * asset_w + 0.3 * data_w + 0.2 * user_w, 4)

        overall = round(
            0.30 * financial
            + 0.25 * reputation
            + 0.25 * compliance_score
            + 0.20 * operational,
            4,
        )

        factors = []
        if data_w >= 0.7:
            factors.append(f"High-sensitivity data ({data_classification})")
        if comp_w >= 0.8:
            factors.append(f"Compliance-critical ({', '.join(compliance_frameworks)})")
        if user_w >= 0.7:
            factors.append(f"Large user base ({user_base})")
        if asset_w >= 0.8:
            factors.append(f"Critical asset type ({asset_type})")

        return {
            "financial": financial,
            "reputation": reputation,
            "compliance": compliance_score,
            "operational": operational,
            "overall": overall,
            "factors": factors,
        }


# ---------------------------------------------------------------------------
# EPSS estimation
# ---------------------------------------------------------------------------

def calculate_epss(cve_id: Optional[str] = None, cvss_score: float = 0.0) -> float:
    """Estimate EPSS score.

    If a CVE ID is provided, a heuristic based on CVSS score is used.
    In a production deployment, this would call the FIRST EPSS API.
    Returns a float 0.0-1.0.
    """
    if not cve_id and cvss_score <= 0:
        return 0.0

    # Heuristic: map CVSS to an approximate EPSS range
    if cvss_score >= 9.0:
        return 0.7
    elif cvss_score >= 7.0:
        return 0.4
    elif cvss_score >= 4.0:
        return 0.15
    elif cvss_score > 0:
        return 0.05
    return 0.02


# ---------------------------------------------------------------------------
# Unified Risk Scorer
# ---------------------------------------------------------------------------

_RISK_LEVELS = [
    (0.0, 0.2, "low", 4),
    (0.2, 0.4, "medium", 3),
    (0.4, 0.7, "high", 2),
    (0.7, 1.0, "critical", 1),
]

_RISK_RECOMMENDATIONS = {
    "critical": "Immediate remediation required. Escalate to security lead.",
    "high": "Prioritize for next sprint. Assign dedicated resources.",
    "medium": "Schedule remediation within the next release cycle.",
    "low": "Track and address during routine maintenance.",
}


class RiskScorer:
    """Combine CVSS, confidence, business impact, and EPSS into a unified risk score.

    Formula: risk = 0.35*cvss_norm + 0.25*confidence + 0.25*business_impact + 0.15*epss
    """

    def score(
        self,
        cvss_score: float,
        confidence: float,
        business_impact: float = 0.5,
        epss_score: float = 0.0,
    ) -> Dict[str, Any]:
        """Calculate the unified risk score.

        Parameters
        ----------
        cvss_score : float
            CVSS v3.1 base score (0.0-10.0).
        confidence : float
            Finding confidence (0.0-1.0).
        business_impact : float
            Business impact score (0.0-1.0).
        epss_score : float
            EPSS score (0.0-1.0).

        Returns
        -------
        dict
            risk_score, risk_level, priority, factors, recommendation
        """
        cvss_norm = min(cvss_score / 10.0, 1.0)
        confidence = max(0.0, min(confidence, 1.0))
        business_impact = max(0.0, min(business_impact, 1.0))
        epss_score = max(0.0, min(epss_score, 1.0))

        risk = (
            0.35 * cvss_norm
            + 0.25 * confidence
            + 0.25 * business_impact
            + 0.15 * epss_score
        )
        risk = round(risk, 4)

        # Determine level and priority
        risk_level = "low"
        priority = 4
        for low, high, level, prio in _RISK_LEVELS:
            if low <= risk <= high:
                risk_level = level
                priority = prio
                break

        factors = []
        if cvss_norm >= 0.7:
            factors.append(f"High CVSS ({cvss_score})")
        if confidence >= 0.8:
            factors.append(f"High confidence ({confidence})")
        if business_impact >= 0.7:
            factors.append("Significant business impact")
        if epss_score >= 0.5:
            factors.append(f"High exploit probability (EPSS={epss_score})")

        return {
            "risk_score": risk,
            "risk_level": risk_level,
            "priority": priority,
            "factors": factors,
            "recommendation": _RISK_RECOMMENDATIONS.get(risk_level, ""),
            "components": {
                "cvss_normalized": round(cvss_norm, 4),
                "confidence": round(confidence, 4),
                "business_impact": round(business_impact, 4),
                "epss": round(epss_score, 4),
            },
        }
