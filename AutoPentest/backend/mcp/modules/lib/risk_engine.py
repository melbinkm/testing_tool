"""
Risk Engine - CVSS v3.1 scoring, EPSS estimation, business impact, unified risk scoring.

Adapted from Zen-Ai-Pentest risk assessment concepts.
Provides CVSS v3.1 base score calculation, business impact assessment,
and a unified risk scorer that combines multiple factors.
"""

from __future__ import annotations

import math
import re
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple


# ---------------------------------------------------------------------------
# CVSS v3.1 constants
# ---------------------------------------------------------------------------

# Metric value maps (metric_name -> {value_code: numeric_value})
_CVSS_METRICS = {
    "AV": {"N": 0.85, "A": 0.62, "L": 0.55, "P": 0.20},
    "AC": {"L": 0.77, "H": 0.44},
    "PR": {
        # scope_changed=False
        "N": {"U": 0.85, "C": 0.85},
        "L": {"U": 0.62, "C": 0.68},
        "H": {"U": 0.27, "C": 0.50},
    },
    "UI": {"N": 0.85, "R": 0.62},
    "S": {"U": "unchanged", "C": "changed"},
    "C": {"N": 0.0, "L": 0.22, "H": 0.56},
    "I": {"N": 0.0, "L": 0.22, "H": 0.56},
    "A": {"N": 0.0, "L": 0.22, "H": 0.56},
}

_SEVERITY_RANGES = [
    (0.0, 0.0, "none"),
    (0.1, 3.9, "low"),
    (4.0, 6.9, "medium"),
    (7.0, 8.9, "high"),
    (9.0, 10.0, "critical"),
]


def _roundup(x: float) -> float:
    """CVSS v3.1 'roundup' function: round to one decimal place, always up."""
    return math.ceil(x * 10) / 10


class CVSSv31:
    """Parse and calculate CVSS v3.1 base scores.

    Example
    -------
    >>> c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
    >>> c.base_score()
    9.8
    """

    def __init__(self, vector: str) -> None:
        self._vector = vector.strip()
        self._metrics: Dict[str, str] = {}
        self._parse()

    def _parse(self) -> None:
        """Parse the vector string into metric values."""
        # Accept both "CVSS:3.1/..." and raw "AV:N/AC:L/..."
        cleaned = re.sub(r"^CVSS:\d+\.\d+/", "", self._vector)
        parts = cleaned.split("/")
        for part in parts:
            if ":" not in part:
                continue
            key, val = part.split(":", 1)
            key = key.strip().upper()
            val = val.strip().upper()
            if key in _CVSS_METRICS:
                self._metrics[key] = val

        # Validate required metrics
        required = {"AV", "AC", "PR", "UI", "S", "C", "I", "A"}
        missing = required - set(self._metrics.keys())
        if missing:
            raise ValueError(f"Missing CVSS v3.1 metrics: {', '.join(sorted(missing))}")

    def base_score(self) -> float:
        """Calculate the CVSS v3.1 base score (0.0 - 10.0)."""
        scope_changed = self._metrics["S"] == "C"

        # Impact sub-score components
        isc_c = _CVSS_METRICS["C"][self._metrics["C"]]
        isc_i = _CVSS_METRICS["I"][self._metrics["I"]]
        isc_a = _CVSS_METRICS["A"][self._metrics["A"]]
        isc_base = 1 - ((1 - isc_c) * (1 - isc_i) * (1 - isc_a))

        if scope_changed:
            impact = 7.52 * (isc_base - 0.029) - 3.25 * (isc_base - 0.02) ** 15
        else:
            impact = 6.42 * isc_base

        if impact <= 0:
            return 0.0

        # Exploitability sub-score
        av = _CVSS_METRICS["AV"][self._metrics["AV"]]
        ac = _CVSS_METRICS["AC"][self._metrics["AC"]]

        # PR depends on scope
        pr_map = _CVSS_METRICS["PR"][self._metrics["PR"]]
        scope_key = "C" if scope_changed else "U"
        pr = pr_map[scope_key]

        ui = _CVSS_METRICS["UI"][self._metrics["UI"]]
        exploitability = 8.22 * av * ac * pr * ui

        if scope_changed:
            score = _roundup(min(1.08 * (impact + exploitability), 10.0))
        else:
            score = _roundup(min(impact + exploitability, 10.0))

        return score

    def severity(self) -> str:
        """Return the qualitative severity rating."""
        score = self.base_score()
        for low, high, label in _SEVERITY_RANGES:
            if low <= score <= high:
                return label
        return "none"

    def to_dict(self) -> Dict[str, Any]:
        """Return all metrics, scores, and severity as a dict."""
        return {
            "vector": self._vector,
            "metrics": dict(self._metrics),
            "base_score": self.base_score(),
            "severity": self.severity(),
        }


# ---------------------------------------------------------------------------
# Temporal Metrics
# ---------------------------------------------------------------------------

_EXPLOIT_MATURITY = {
    "not_defined": 1.0,
    "unproven": 0.91,
    "poc": 0.94,
    "functional": 0.97,
    "high": 1.0,
}

_REMEDIATION_LEVEL = {
    "not_defined": 1.0,
    "official_fix": 0.87,
    "temporary_fix": 0.90,
    "workaround": 0.95,
    "unavailable": 1.0,
}

_REPORT_CONFIDENCE = {
    "not_defined": 1.0,
    "unknown": 0.92,
    "reasonable": 0.96,
    "confirmed": 1.0,
}


def temporal_score(
    base_score: float,
    exploit_maturity: str = "not_defined",
    remediation_level: str = "not_defined",
    report_confidence: str = "not_defined",
) -> float:
    """Calculate CVSS v3.1 temporal score from base score and temporal metrics.

    Parameters
    ----------
    base_score : float
        CVSS base score (0.0-10.0).
    exploit_maturity : str
        Exploit code maturity: not_defined, unproven, poc, functional, high.
    remediation_level : str
        Remediation level: not_defined, official_fix, temporary_fix, workaround, unavailable.
    report_confidence : str
        Report confidence: not_defined, unknown, reasonable, confirmed.

    Returns
    -------
    float
        Temporal score (0.0-10.0).
    """
    e = _EXPLOIT_MATURITY.get(exploit_maturity, 1.0)
    rl = _REMEDIATION_LEVEL.get(remediation_level, 1.0)
    rc = _REPORT_CONFIDENCE.get(report_confidence, 1.0)
    return _roundup(base_score * e * rl * rc)


# ---------------------------------------------------------------------------
# Environmental Metrics
# ---------------------------------------------------------------------------

_BUSINESS_CRITICALITY = {
    "low": 0.25,
    "medium": 0.5,
    "high": 0.75,
    "critical": 1.0,
}


def environmental_adjustment(
    base_score: float,
    business_criticality: str = "medium",
    target_distribution: float = 1.0,
) -> float:
    """Adjust risk score based on environmental context.

    Parameters
    ----------
    base_score : float
        CVSS base or temporal score (0.0-10.0).
    business_criticality : str
        Business criticality: low, medium, high, critical.
    target_distribution : float
        Percentage of affected systems (0.0-1.0).

    Returns
    -------
    float
        Environmentally adjusted score (0.0-10.0).
    """
    bc = _BUSINESS_CRITICALITY.get(business_criticality, 0.5)
    td = max(0.0, min(target_distribution, 1.0))
    # Environmental modifier: blend of criticality and distribution
    modifier = 0.6 * bc + 0.4 * td
    adjusted = base_score * modifier
    return _roundup(min(adjusted, 10.0))


# ---------------------------------------------------------------------------
# CWE-to-Minimum-Severity Mapping
# ---------------------------------------------------------------------------

CWE_SEVERITY_MAP: Dict[int, str] = {
    89: "high",       # SQL Injection
    79: "medium",     # Cross-site Scripting (XSS)
    22: "high",       # Path Traversal
    78: "critical",   # OS Command Injection
    502: "critical",  # Deserialization of Untrusted Data
    94: "critical",   # Code Injection
    798: "high",      # Use of Hard-coded Credentials
    862: "high",      # Missing Authorization
    863: "high",      # Incorrect Authorization
    918: "high",      # Server-Side Request Forgery (SSRF)
    611: "high",      # XML External Entity (XXE)
    352: "medium",    # Cross-Site Request Forgery (CSRF)
    287: "high",      # Improper Authentication
    306: "high",      # Missing Authentication for Critical Function
    434: "high",      # Unrestricted Upload of File with Dangerous Type
    284: "medium",    # Improper Access Control
    200: "low",       # Exposure of Sensitive Information
    319: "medium",    # Cleartext Transmission of Sensitive Information
    522: "medium",    # Insufficiently Protected Credentials
    269: "high",      # Improper Privilege Management
    601: "medium",    # Open Redirect
    942: "medium",    # Overly Permissive CORS Policy
    1021: "low",      # Clickjacking
    16: "low",        # Configuration
    209: "low",       # Information Exposure Through Error Messages
}


def cwe_minimum_severity(cwe_id: int) -> Optional[str]:
    """Return the minimum severity for a CWE ID, or None if unmapped."""
    return CWE_SEVERITY_MAP.get(cwe_id)


def enforce_cwe_severity(
    severity: str,
    cwe_id: Optional[int] = None,
) -> str:
    """Enforce CWE minimum severity floor.

    If the CWE maps to a higher minimum severity, escalate.
    """
    if cwe_id is None:
        return severity

    min_sev = CWE_SEVERITY_MAP.get(cwe_id)
    if min_sev is None:
        return severity

    severity_order = {"info": 0, "low": 1, "medium": 2, "high": 3, "critical": 4}
    current = severity_order.get(severity.lower(), 0)
    minimum = severity_order.get(min_sev, 0)

    if minimum > current:
        return min_sev
    return severity


# ---------------------------------------------------------------------------
# Business Impact Override
# ---------------------------------------------------------------------------

_PII_FINANCIAL_KEYWORDS = {
    "pii", "personal data", "ssn", "social security", "credit card",
    "financial", "payment", "bank account", "health record", "hipaa",
    "gdpr", "medical", "passport", "driver license",
}


def business_impact_override(
    severity: str,
    data_tags: Optional[List[str]] = None,
) -> str:
    """Escalate severity by one level if finding involves PII or financial data.

    Parameters
    ----------
    severity : str
        Current severity level.
    data_tags : list[str], optional
        Tags describing the data involved.

    Returns
    -------
    str
        Potentially escalated severity.
    """
    if not data_tags:
        return severity

    tags_lower = {t.lower() for t in data_tags}
    if tags_lower & _PII_FINANCIAL_KEYWORDS:
        escalation = {
            "info": "low",
            "low": "medium",
            "medium": "high",
            "high": "critical",
            "critical": "critical",
        }
        return escalation.get(severity.lower(), severity)
    return severity


# ---------------------------------------------------------------------------
# Business Impact
# ---------------------------------------------------------------------------

# Weight maps for business impact calculation
_ASSET_TYPE_WEIGHTS = {
    "web_app": 0.7,
    "api": 0.8,
    "database": 0.9,
    "infrastructure": 0.85,
    "iot": 0.6,
}

_DATA_CLASSIFICATION_WEIGHTS = {
    "public": 0.1,
    "internal": 0.4,
    "confidential": 0.7,
    "restricted": 1.0,
}

_COMPLIANCE_WEIGHTS = {
    "pci-dss": 0.9,
    "hipaa": 0.95,
    "gdpr": 0.85,
    "sox": 0.8,
    "iso27001": 0.7,
    "nist": 0.75,
    "fedramp": 0.85,
}

_USER_BASE_WEIGHTS = {
    "internal": 0.3,
    "small": 0.5,
    "medium": 0.7,
    "large": 0.9,
    "public": 1.0,
}


class BusinessImpact:
    """Calculate business impact from asset context."""

    def calculate(
        self,
        asset_type: str = "web_app",
        data_classification: str = "internal",
        compliance_frameworks: Optional[List[str]] = None,
        user_base: str = "medium",
    ) -> Dict[str, Any]:
        """Calculate business impact scores.

        Returns a dict with financial, reputation, compliance, operational,
        overall scores (0.0-1.0), and contributing factors.
        """
        compliance_frameworks = compliance_frameworks or []

        asset_w = _ASSET_TYPE_WEIGHTS.get(asset_type, 0.5)
        data_w = _DATA_CLASSIFICATION_WEIGHTS.get(data_classification, 0.4)
        user_w = _USER_BASE_WEIGHTS.get(user_base, 0.5)

        # Compliance: max of all frameworks, default 0.3 if none
        if compliance_frameworks:
            comp_w = max(
                _COMPLIANCE_WEIGHTS.get(f.lower(), 0.5)
                for f in compliance_frameworks
            )
        else:
            comp_w = 0.3

        # Sub-scores
        financial = round(0.4 * data_w + 0.3 * asset_w + 0.3 * user_w, 4)
        reputation = round(0.5 * user_w + 0.3 * data_w + 0.2 * asset_w, 4)
        compliance_score = round(comp_w, 4)
        operational = round(0.5 * asset_w + 0.3 * data_w + 0.2 * user_w, 4)

        overall = round(
            0.30 * financial
            + 0.25 * reputation
            + 0.25 * compliance_score
            + 0.20 * operational,
            4,
        )

        factors = []
        if data_w >= 0.7:
            factors.append(f"High-sensitivity data ({data_classification})")
        if comp_w >= 0.8:
            factors.append(f"Compliance-critical ({', '.join(compliance_frameworks)})")
        if user_w >= 0.7:
            factors.append(f"Large user base ({user_base})")
        if asset_w >= 0.8:
            factors.append(f"Critical asset type ({asset_type})")

        return {
            "financial": financial,
            "reputation": reputation,
            "compliance": compliance_score,
            "operational": operational,
            "overall": overall,
            "factors": factors,
        }


# ---------------------------------------------------------------------------
# EPSS estimation
# ---------------------------------------------------------------------------

def calculate_epss(cve_id: Optional[str] = None, cvss_score: float = 0.0) -> float:
    """Estimate EPSS score.

    If a CVE ID is provided, a heuristic based on CVSS score is used.
    In a production deployment, this would call the FIRST EPSS API.
    Returns a float 0.0-1.0.
    """
    if not cve_id and cvss_score <= 0:
        return 0.0

    # Heuristic: map CVSS to an approximate EPSS range
    if cvss_score >= 9.0:
        return 0.7
    elif cvss_score >= 7.0:
        return 0.4
    elif cvss_score >= 4.0:
        return 0.15
    elif cvss_score > 0:
        return 0.05
    return 0.02


# ---------------------------------------------------------------------------
# Unified Risk Scorer
# ---------------------------------------------------------------------------

_RISK_LEVELS = [
    (0.0, 0.2, "low", 4),
    (0.2, 0.4, "medium", 3),
    (0.4, 0.7, "high", 2),
    (0.7, 1.0, "critical", 1),
]

_RISK_RECOMMENDATIONS = {
    "critical": "Immediate remediation required. Escalate to security lead.",
    "high": "Prioritize for next sprint. Assign dedicated resources.",
    "medium": "Schedule remediation within the next release cycle.",
    "low": "Track and address during routine maintenance.",
}


class RiskScorer:
    """Combine CVSS, confidence, business impact, and EPSS into a unified risk score.

    Formula: risk = 0.35*cvss_norm + 0.25*confidence + 0.25*business_impact + 0.15*epss
    """

    def score(
        self,
        cvss_score: float,
        confidence: float,
        business_impact: float = 0.5,
        epss_score: float = 0.0,
    ) -> Dict[str, Any]:
        """Calculate the unified risk score.

        Parameters
        ----------
        cvss_score : float
            CVSS v3.1 base score (0.0-10.0).
        confidence : float
            Finding confidence (0.0-1.0).
        business_impact : float
            Business impact score (0.0-1.0).
        epss_score : float
            EPSS score (0.0-1.0).

        Returns
        -------
        dict
            risk_score, risk_level, priority, factors, recommendation
        """
        cvss_norm = min(cvss_score / 10.0, 1.0)
        confidence = max(0.0, min(confidence, 1.0))
        business_impact = max(0.0, min(business_impact, 1.0))
        epss_score = max(0.0, min(epss_score, 1.0))

        risk = (
            0.35 * cvss_norm
            + 0.25 * confidence
            + 0.25 * business_impact
            + 0.15 * epss_score
        )
        risk = round(risk, 4)

        # Determine level and priority
        risk_level = "low"
        priority = 4
        for low, high, level, prio in _RISK_LEVELS:
            if low <= risk <= high:
                risk_level = level
                priority = prio
                break

        factors = []
        if cvss_norm >= 0.7:
            factors.append(f"High CVSS ({cvss_score})")
        if confidence >= 0.8:
            factors.append(f"High confidence ({confidence})")
        if business_impact >= 0.7:
            factors.append("Significant business impact")
        if epss_score >= 0.5:
            factors.append(f"High exploit probability (EPSS={epss_score})")

        return {
            "risk_score": risk,
            "risk_level": risk_level,
            "priority": priority,
            "factors": factors,
            "recommendation": _RISK_RECOMMENDATIONS.get(risk_level, ""),
            "components": {
                "cvss_normalized": round(cvss_norm, 4),
                "confidence": round(confidence, 4),
                "business_impact": round(business_impact, 4),
                "epss": round(epss_score, 4),
            },
        }
