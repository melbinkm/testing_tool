"""
Exploitation Decision Queue - Tracks exploit attempts and decides retry/skip.

Maintains a per-finding decision queue that tracks exploitation attempts,
results, and automatically determines whether to retry, skip, or escalate.
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional

logger = logging.getLogger("autopentest-mcp")


class ExploitResult(Enum):
    """Result of an exploitation attempt."""
    SUCCESS = "success"
    PARTIAL = "partial"
    BLOCKED_BY_SECURITY = "blocked_by_security"
    FAILED = "failed"
    NOT_ATTEMPTED = "not_attempted"


@dataclass
class ExploitationDecision:
    """Decision state for a single finding."""
    finding_id: str
    vuln_type: str = ""
    should_exploit: bool = True
    should_retry: bool = False
    attempt_count: int = 0
    last_result: ExploitResult = ExploitResult.NOT_ATTEMPTED
    notes: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "finding_id": self.finding_id,
            "vuln_type": self.vuln_type,
            "should_exploit": self.should_exploit,
            "should_retry": self.should_retry,
            "attempt_count": self.attempt_count,
            "last_result": self.last_result.value,
            "notes": self.notes,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> ExploitationDecision:
        result_str = data.get("last_result", "not_attempted")
        try:
            last_result = ExploitResult(result_str)
        except ValueError:
            last_result = ExploitResult.NOT_ATTEMPTED
        return cls(
            finding_id=data["finding_id"],
            vuln_type=data.get("vuln_type", ""),
            should_exploit=data.get("should_exploit", True),
            should_retry=data.get("should_retry", False),
            attempt_count=data.get("attempt_count", 0),
            last_result=last_result,
            notes=data.get("notes", ""),
        )


MAX_ATTEMPTS = 3


class DecisionQueue:
    """Manages exploitation decisions for all findings in an assessment."""

    def __init__(self):
        self.decisions: Dict[str, ExploitationDecision] = {}

    def get_decision(self, finding_id: str) -> ExploitationDecision:
        """Get the decision for a finding, creating a default if not present."""
        if finding_id not in self.decisions:
            self.decisions[finding_id] = ExploitationDecision(finding_id=finding_id)
        return self.decisions[finding_id]

    def update_decision(self, finding_id: str, result: ExploitResult, vuln_type: str = "", notes: str = "") -> ExploitationDecision:
        """Update the decision after an exploitation attempt.

        Decision logic:
        - Skip if attempt_count > MAX_ATTEMPTS
        - Skip if last_result == blocked_by_security
        - Retry if last_result == partial
        - Mark complete if last_result == success
        """
        decision = self.get_decision(finding_id)
        decision.attempt_count += 1
        decision.last_result = result
        if vuln_type:
            decision.vuln_type = vuln_type
        if notes:
            decision.notes = notes

        # Apply decision logic
        if result == ExploitResult.SUCCESS:
            decision.should_exploit = False
            decision.should_retry = False
            decision.notes = decision.notes or "Exploitation successful"
        elif result == ExploitResult.BLOCKED_BY_SECURITY:
            decision.should_exploit = False
            decision.should_retry = False
            decision.notes = decision.notes or "Blocked by WAF/security control"
        elif result == ExploitResult.PARTIAL:
            decision.should_retry = decision.attempt_count < MAX_ATTEMPTS
            decision.should_exploit = decision.should_retry
        elif result == ExploitResult.FAILED:
            decision.should_retry = decision.attempt_count < MAX_ATTEMPTS
            decision.should_exploit = decision.should_retry

        # Hard cap on attempts
        if decision.attempt_count >= MAX_ATTEMPTS:
            decision.should_retry = False
            if result not in (ExploitResult.SUCCESS, ExploitResult.BLOCKED_BY_SECURITY):
                decision.should_exploit = False
                decision.notes = decision.notes or f"Max attempts ({MAX_ATTEMPTS}) reached"

        return decision

    def get_pending(self) -> List[ExploitationDecision]:
        """Get all findings that should still be exploited."""
        return [d for d in self.decisions.values() if d.should_exploit]

    def get_completed(self) -> List[ExploitationDecision]:
        """Get all findings where exploitation is done (success or skipped)."""
        return [d for d in self.decisions.values() if not d.should_exploit]

    def to_dict(self) -> Dict[str, Any]:
        return {fid: d.to_dict() for fid, d in self.decisions.items()}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> DecisionQueue:
        queue = cls()
        for fid, d in data.items():
            d["finding_id"] = fid
            queue.decisions[fid] = ExploitationDecision.from_dict(d)
        return queue


async def load_decision_queue(db, assessment_id: int) -> DecisionQueue:
    """Load the decision queue from wm_knowledge.

    Parameters
    ----------
    db : WorldModelDatabase
        Active world model database.
    assessment_id : int
        Assessment ID.

    Returns
    -------
    DecisionQueue
        The loaded queue (empty if none saved).
    """
    rows = await db.recall_knowledge(
        category="exploitation_decision",
        limit=1,
    )
    if not rows:
        return DecisionQueue()

    content = rows[0].get("content") or "{}"
    try:
        data = json.loads(content)
    except (json.JSONDecodeError, TypeError):
        return DecisionQueue()

    return DecisionQueue.from_dict(data)


async def save_decision_queue(db, assessment_id: int, queue: DecisionQueue) -> None:
    """Save the decision queue to wm_knowledge.

    Parameters
    ----------
    db : WorldModelDatabase
        Active world model database.
    assessment_id : int
        Assessment ID.
    queue : DecisionQueue
        The queue to persist.
    """
    await db.store_knowledge(
        category="exploitation_decision",
        key=f"exploitation_decision_{assessment_id}",
        content=json.dumps(queue.to_dict()),
        metadata={"pending": len(queue.get_pending()), "completed": len(queue.get_completed())},
    )
