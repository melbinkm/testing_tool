"""
DifferentialTester - Compare responses across identities for BOLA/IDOR detection

Sends the same request with different authentication contexts and analyses
the responses for authorization enforcement issues such as:
- Unauthorized identities receiving 200 OK
- Response body similarity between authorized and unauthorized requests
- Response length variance indicating data leakage

Ported from auth-tester-mcp/src/diff-tester.ts
"""
from __future__ import annotations

import hashlib
import time
from typing import Any, Dict, List, Optional

import httpx

from lib.identity_store import Identity, IdentityStore


# Threshold: if response lengths differ by more than this ratio,
# the variance is considered suspicious (potential BOLA indicator).
LENGTH_VARIANCE_THRESHOLD = 0.20  # 20%


class DifferentialTester:
    """Compare HTTP responses across multiple identities to detect auth issues."""

    def __init__(self, identity_store: Optional[IdentityStore] = None, http_client=None) -> None:
        self._identity_store = identity_store
        self._http_client = http_client

    @property
    def identity_store(self) -> Optional[IdentityStore]:
        return self._identity_store

    @identity_store.setter
    def identity_store(self, store: IdentityStore) -> None:
        self._identity_store = store

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    @staticmethod
    def hash_response(body: str) -> str:
        """Generate SHA-256 hash of a response body."""
        return hashlib.sha256(body.encode("utf-8")).hexdigest()

    # ------------------------------------------------------------------
    # Core testing
    # ------------------------------------------------------------------

    async def test_endpoint(
        self,
        url: str,
        method: str,
        identities: List[Identity],
        headers: Optional[Dict[str, str]] = None,
        body: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Test an endpoint with each identity and collect results.

        Args:
            url: Target endpoint URL.
            method: HTTP method (GET, POST, etc.).
            identities: List of Identity objects to test.
            headers: Additional headers to merge with auth headers.
            body: Optional request body (for POST/PUT/PATCH).

        Returns:
            Dict with ``identity_results`` list and ``url``/``method`` metadata.
        """
        identity_results: List[Dict[str, Any]] = []

        for identity in identities:
            result = await self._test_single_identity(
                url=url,
                method=method,
                identity=identity,
                extra_headers=headers,
                body=body,
            )
            identity_results.append(result)

        return {
            "url": url,
            "method": method,
            "identity_results": identity_results,
        }

    async def _test_single_identity(
        self,
        url: str,
        method: str,
        identity: Identity,
        extra_headers: Optional[Dict[str, str]] = None,
        body: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Send a request with a single identity's credentials.

        Returns a result dict with status_code, response_hash, response_length,
        timing_ms, has_access, and expected_access fields.
        """
        start_time = time.monotonic()

        try:
            # Build headers: extra headers first, then auth headers override
            auth_headers = IdentityStore.build_auth_headers(identity)
            merged_headers: Dict[str, str] = {}
            if extra_headers:
                merged_headers.update(extra_headers)
            merged_headers.update(auth_headers)

            # Use audited HttpClient if available
            if self._http_client:
                result = await self._http_client.send({
                    "method": method,
                    "url": url,
                    "headers": merged_headers,
                    "body": body,
                })
                end_time = time.monotonic()

                if result["success"]:
                    response_body = result["response"]["body"]
                    status_code = result["response"]["status"]
                else:
                    # HTTP client error
                    return {
                        "identity_id": identity.id,
                        "identity_type": identity.type,
                        "scope": identity.scope,
                        "should_have_access": identity.should_have_access,
                        "status_code": 0,
                        "response_hash": "",
                        "response_length": 0,
                        "has_access": False,
                        "timing_ms": round((end_time - start_time) * 1000),
                        "error": result.get("error", {}).get("message", "HTTP client error"),
                    }
            else:
                # Fallback to raw httpx
                content: Optional[str] = None
                if body and method.upper() in ("POST", "PUT", "PATCH"):
                    content = body

                async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
                    response = await client.request(
                        method=method,
                        url=url,
                        headers=merged_headers,
                        content=content,
                    )
                    response_body = response.text
                    status_code = response.status_code

                end_time = time.monotonic()

            has_access = 200 <= status_code < 400

            return {
                "identity_id": identity.id,
                "identity_type": identity.type,
                "scope": identity.scope,
                "should_have_access": identity.should_have_access,
                "status_code": status_code,
                "response_hash": self.hash_response(response_body),
                "response_length": len(response_body),
                "has_access": has_access,
                "timing_ms": round((end_time - start_time) * 1000),
            }

        except Exception as exc:
            end_time = time.monotonic()
            return {
                "identity_id": identity.id,
                "identity_type": identity.type,
                "scope": identity.scope,
                "should_have_access": identity.should_have_access,
                "status_code": 0,
                "response_hash": "",
                "response_length": 0,
                "has_access": False,
                "timing_ms": round((end_time - start_time) * 1000),
                "error": str(exc),
            }

    # ------------------------------------------------------------------
    # Analysis
    # ------------------------------------------------------------------

    def analyze_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze test_endpoint results for authorization issues.

        Checks:
        - Status code patterns (unauthorized getting 200 = suspicious)
        - Response length variance (>20% difference = suspicious)
        - Response hash comparison between identities

        Args:
            results: Output of test_endpoint().

        Returns:
            Analysis dict with issues list, bola_indicators, and risk_level.
        """
        identity_results: List[Dict[str, Any]] = results.get("identity_results", [])
        if not identity_results:
            return {
                "issues": [],
                "bola_indicators": [],
                "risk_level": "none",
                "summary": "No results to analyze",
            }

        issues: List[str] = []
        bola_indicators = self.detect_bola_indicators(results)

        # --- Status code pattern analysis ---
        authorized_results = [
            r for r in identity_results if r.get("should_have_access")
        ]
        unauthorized_results = [
            r for r in identity_results if not r.get("should_have_access")
        ]

        for res in unauthorized_results:
            if res.get("has_access"):
                issues.append(
                    f"Identity '{res['identity_id']}' (should NOT have access) "
                    f"received status {res['status_code']} indicating access was granted"
                )

        for res in authorized_results:
            if not res.get("has_access") and not res.get("error"):
                issues.append(
                    f"Identity '{res['identity_id']}' (should have access) "
                    f"was denied with status {res['status_code']}"
                )

        # --- Response length variance analysis ---
        if authorized_results and unauthorized_results:
            auth_lengths = [
                r["response_length"]
                for r in authorized_results
                if r.get("response_length", 0) > 0
            ]
            unauth_lengths = [
                r["response_length"]
                for r in unauthorized_results
                if r.get("response_length", 0) > 0
            ]

            if auth_lengths and unauth_lengths:
                avg_auth_len = sum(auth_lengths) / len(auth_lengths)
                avg_unauth_len = sum(unauth_lengths) / len(unauth_lengths)

                if avg_auth_len > 0:
                    variance = abs(avg_auth_len - avg_unauth_len) / avg_auth_len
                    if variance < LENGTH_VARIANCE_THRESHOLD and avg_unauth_len > 0:
                        issues.append(
                            f"Response lengths are suspiciously similar "
                            f"(auth avg: {avg_auth_len:.0f}, unauth avg: {avg_unauth_len:.0f}, "
                            f"variance: {variance:.1%}). "
                            f"Unauthorized users may be receiving the same data."
                        )

        # --- Response hash comparison ---
        hashes = [r.get("response_hash") for r in identity_results if r.get("response_hash")]
        if len(set(hashes)) == 1 and len(hashes) > 1:
            # All responses are identical
            has_mixed_access = (
                any(r.get("should_have_access") for r in identity_results)
                and any(not r.get("should_have_access") for r in identity_results)
            )
            if has_mixed_access:
                issues.append(
                    "All identities received identical responses (same hash). "
                    "Authorization may not be enforced."
                )

        # Determine risk level
        if bola_indicators:
            risk_level = "high"
        elif issues:
            risk_level = "medium"
        else:
            risk_level = "low"

        summary_parts: List[str] = []
        summary_parts.append(f"{len(identity_results)} identities tested")
        if issues:
            summary_parts.append(f"{len(issues)} issue(s) found")
        if bola_indicators:
            summary_parts.append(f"{len(bola_indicators)} BOLA indicator(s)")

        return {
            "issues": issues,
            "bola_indicators": bola_indicators,
            "risk_level": risk_level,
            "summary": "; ".join(summary_parts),
            "identities_tested": len(identity_results),
        }

    def detect_bola_indicators(self, results: Dict[str, Any]) -> List[Dict[str, str]]:
        """Detect specific BOLA (Broken Object Level Authorization) indicators.

        BOLA indicators:
        1. Unauthorized identity gets 200 with response body
        2. Unauthorized identity gets same response hash as authorized identity
        3. Unauthorized identity gets similar response length as authorized identity

        Args:
            results: Output of test_endpoint().

        Returns:
            List of indicator dicts with type, identity_id, and detail.
        """
        identity_results: List[Dict[str, Any]] = results.get("identity_results", [])
        indicators: List[Dict[str, str]] = []

        authorized_results = [
            r for r in identity_results if r.get("should_have_access")
        ]
        unauthorized_results = [
            r for r in identity_results if not r.get("should_have_access")
        ]

        if not authorized_results or not unauthorized_results:
            return indicators

        # Collect authorized response hashes and lengths for comparison
        auth_hashes = set(
            r["response_hash"] for r in authorized_results if r.get("response_hash")
        )
        auth_lengths = [
            r["response_length"]
            for r in authorized_results
            if r.get("response_length", 0) > 0
        ]
        avg_auth_len = (sum(auth_lengths) / len(auth_lengths)) if auth_lengths else 0

        for res in unauthorized_results:
            # Indicator 1: Unauthorized gets 200 with non-empty response
            if res.get("status_code") == 200 and res.get("response_length", 0) > 0:
                indicators.append({
                    "type": "unauthorized_access",
                    "identity_id": res["identity_id"],
                    "detail": (
                        f"Unauthorized identity received 200 OK with "
                        f"{res['response_length']} byte response body"
                    ),
                })

            # Indicator 2: Same response hash as authorized
            if res.get("response_hash") and res["response_hash"] in auth_hashes:
                indicators.append({
                    "type": "identical_response",
                    "identity_id": res["identity_id"],
                    "detail": (
                        "Unauthorized identity received identical response "
                        "to authorized identity (same hash)"
                    ),
                })

            # Indicator 3: Similar response length
            if avg_auth_len > 0 and res.get("response_length", 0) > 0:
                length_diff = abs(res["response_length"] - avg_auth_len) / avg_auth_len
                if length_diff < LENGTH_VARIANCE_THRESHOLD:
                    indicators.append({
                        "type": "similar_response_length",
                        "identity_id": res["identity_id"],
                        "detail": (
                            f"Unauthorized response length ({res['response_length']}) "
                            f"is within {LENGTH_VARIANCE_THRESHOLD:.0%} of authorized "
                            f"average ({avg_auth_len:.0f})"
                        ),
                    })

        return indicators
