"""
Coverage Tracker - Maps vuln classes to existing tools and computes test priority.

Core intelligence layer for the deterministic coverage engine.
Classifies endpoints by applicable vulnerability classes, resolves exact
MCP tool calls, and builds the coverage matrix.
"""

from __future__ import annotations

import re
from typing import Any, Dict, List, Optional


# ---------------------------------------------------------------------------
# Vuln class → tool mapping
# ---------------------------------------------------------------------------

_VULN_TOOL_MAP: Dict[str, Dict[str, Any]] = {
    "sqli": {
        "tool_name": "fuzz_parameter",
        "base_args": {"payload_types": ["injection", "sqli_db"], "db_type": "generic"},
    },
    "xss": {
        "tool_name": "fuzz_parameter",
        "base_args": {"payload_types": ["injection"]},
    },
    "idor": {
        "tool_name": "auth_diff_test",
        "base_args": {},
    },
    "injection": {
        "tool_name": "fuzz_parameter",
        "base_args": {"payload_types": ["injection"]},
    },
    "auth_bypass": {
        "tool_name": "auth_diff_test",
        "base_args": {},
    },
    "ssrf": {
        "tool_name": "fuzz_parameter",
        "base_args": {"payload_types": ["format"]},
    },
    "path_traversal": {
        "tool_name": "fuzz_parameter",
        "base_args": {"payload_types": ["format"]},
    },
    "overflow": {
        "tool_name": "fuzz_parameter",
        "base_args": {"payload_types": ["overflow", "boundary"]},
    },
    "type_confusion": {
        "tool_name": "fuzz_parameter",
        "base_args": {"payload_types": ["type_confusion"]},
    },
    "info_disclosure": {
        "tool_name": "http_send",
        "base_args": {"method": "GET"},
    },
    "misconfig": {
        "tool_name": "http_send",
        "base_args": {"method": "OPTIONS"},
    },
    "nuclei": {
        "tool_name": "nuclei_scan_template",
        "base_args": {"severity": ["medium", "high", "critical"]},
    },
}

# Severity tiers for priority scoring
_HIGH_SEVERITY_CLASSES = {"sqli", "auth_bypass", "ssrf", "injection"}
_LOW_SEVERITY_CLASSES = {"info_disclosure", "misconfig"}

# Path parameter pattern (e.g. /{id}, /{user_id})
_PATH_PARAM_RE = re.compile(r"/\{[^}]+\}")


# ---------------------------------------------------------------------------
# CoverageTracker
# ---------------------------------------------------------------------------

class CoverageTracker:
    """Maps endpoints to vuln classes, resolves tool calls, and builds the coverage matrix."""

    @staticmethod
    def classify_endpoint(endpoint: Dict[str, Any]) -> List[str]:
        """Determine applicable vuln classes for an endpoint.

        Classification rules:
        - Has parameters → sqli, xss, injection, type_confusion, overflow, path_traversal
        - auth_required=True → idor, auth_bypass
        - Path params /{id} → idor, ssrf
        - POST/PUT/PATCH → sqli, xss, injection
        - Always: info_disclosure, misconfig, nuclei
        """
        classes: set = set()
        method = (endpoint.get("method") or "GET").upper()
        path = endpoint.get("path") or ""
        parameters = endpoint.get("parameters") or {}
        auth_required = endpoint.get("auth_required", False)

        # Count parameters
        param_count = 0
        if isinstance(parameters, dict):
            # Could be {"query": {...}, "body": {...}} or flat {"param1": "type"}
            for v in parameters.values():
                if isinstance(v, dict):
                    param_count += len(v)
                else:
                    param_count += 1

        has_params = param_count > 0
        has_path_params = bool(_PATH_PARAM_RE.search(path))
        is_state_changing = method in ("POST", "PUT", "PATCH", "DELETE")

        # Parameter-based classes
        if has_params:
            classes.update({"sqli", "xss", "injection", "type_confusion", "overflow", "path_traversal"})

        # Auth-based classes
        if auth_required:
            classes.update({"idor", "auth_bypass"})

        # Path param classes
        if has_path_params:
            classes.update({"idor", "ssrf"})

        # State-changing method classes
        if is_state_changing:
            classes.update({"sqli", "xss", "injection"})

        # Always applicable
        classes.update({"info_disclosure", "misconfig", "nuclei"})

        return sorted(classes)

    @staticmethod
    def resolve_tool_call(
        endpoint: Dict[str, Any],
        vuln_class: str,
        base_url: str,
    ) -> Dict[str, Any]:
        """Resolve a vuln class to an exact MCP tool call.

        Returns ``{"tool_name": str, "arguments": dict}``.
        """
        mapping = _VULN_TOOL_MAP.get(vuln_class)
        if not mapping:
            return {"tool_name": "", "arguments": {}}

        tool_name = mapping["tool_name"]
        base_args = dict(mapping["base_args"])
        method = (endpoint.get("method") or "GET").upper()
        path = endpoint.get("path") or ""
        url = f"{base_url.rstrip('/')}{path}"
        parameters = endpoint.get("parameters") or {}

        if tool_name == "fuzz_parameter":
            # Resolve target parameter names
            param_names = []
            if isinstance(parameters, dict):
                for k, v in parameters.items():
                    if isinstance(v, dict):
                        param_names.extend(v.keys())
                    else:
                        param_names.append(k)

            base_args["url"] = url
            base_args["method"] = method
            if param_names:
                base_args["parameter"] = param_names[0]

        elif tool_name == "auth_diff_test":
            base_args["url"] = url
            base_args["method"] = method

        elif tool_name == "http_send":
            base_args["url"] = url

        elif tool_name == "nuclei_scan_template":
            base_args["targets"] = [url]

        return {"tool_name": tool_name, "arguments": base_args}

    @staticmethod
    def compute_priority(
        endpoint: Dict[str, Any],
        vuln_class: str,
    ) -> int:
        """Compute priority score 0-100 for a coverage cell.

        - base = 50
        - +20 auth_required
        - +10 state-changing method (POST/PUT/PATCH/DELETE)
        - +10 high-severity vuln class
        - +5 per parameter (max +15)
        - -10 low-severity class
        """
        priority = 50
        method = (endpoint.get("method") or "GET").upper()
        parameters = endpoint.get("parameters") or {}
        auth_required = endpoint.get("auth_required", False)

        if auth_required:
            priority += 20

        if method in ("POST", "PUT", "PATCH", "DELETE"):
            priority += 10

        if vuln_class in _HIGH_SEVERITY_CLASSES:
            priority += 10

        if vuln_class in _LOW_SEVERITY_CLASSES:
            priority -= 10

        # Count parameters
        param_count = 0
        if isinstance(parameters, dict):
            for v in parameters.values():
                if isinstance(v, dict):
                    param_count += len(v)
                else:
                    param_count += 1
        priority += min(param_count * 5, 15)

        return max(0, min(priority, 100))

    @classmethod
    def build_matrix(
        cls,
        endpoints: List[Dict[str, Any]],
        base_url: str,
        vuln_classes: Optional[List[str]] = None,
    ) -> List[Dict[str, Any]]:
        """Build the full coverage matrix from a list of endpoints.

        Returns rows ready for ``WorldModelDatabase.coverage_init_rows()``.
        """
        rows: List[Dict[str, Any]] = []

        for ep in endpoints:
            ep_id = ep.get("id")
            if not ep_id:
                continue

            applicable = cls.classify_endpoint(ep)

            # Filter to requested vuln classes if specified
            if vuln_classes:
                applicable = [vc for vc in applicable if vc in vuln_classes]

            for vc in applicable:
                tool_call = cls.resolve_tool_call(ep, vc, base_url)
                priority = cls.compute_priority(ep, vc)

                rows.append({
                    "endpoint_id": ep_id,
                    "vuln_class": vc,
                    "tool_name": tool_call["tool_name"],
                    "tool_args": tool_call["arguments"],
                    "priority": priority,
                })

        return rows
