"""
Coverage Tracker - Maps vuln classes to existing tools and computes test priority.

Core intelligence layer for the deterministic coverage engine.
Classifies endpoints by applicable vulnerability classes, resolves exact
MCP tool calls, and builds the coverage matrix.
"""

from __future__ import annotations

import re
from typing import Any, Dict, List, Optional

# Import vuln checklist for 42-class coverage
try:
    from .vuln_checklist import get_vuln_checklist
    _CHECKLIST_AVAILABLE = True
except ImportError:
    _CHECKLIST_AVAILABLE = False


# ---------------------------------------------------------------------------
# Vuln class â†’ tool mapping (42+ classes)
# ---------------------------------------------------------------------------

def _build_vuln_tool_map() -> Dict[str, Dict[str, Any]]:
    """Build vuln class to tool mapping from checklist."""
    if _CHECKLIST_AVAILABLE:
        checklist = get_vuln_checklist()
        return checklist.build_tool_map()
    else:
        # Fallback to legacy 12-class mapping
        return {
            "sqli": {
                "tool_name": "fuzz_parameter",
                "base_args": {"payload_types": ["injection", "sqli_db"], "db_type": "generic"},
                "parameter_bound": True
            },
            "xss": {
                "tool_name": "fuzz_parameter",
                "base_args": {"payload_types": ["injection"]},
                "parameter_bound": True
            },
            "idor": {
                "tool_name": "auth_diff_test",
                "base_args": {},
                "parameter_bound": False
            },
            "injection": {
                "tool_name": "fuzz_parameter",
                "base_args": {"payload_types": ["injection"]},
                "parameter_bound": True
            },
            "auth_bypass": {
                "tool_name": "auth_diff_test",
                "base_args": {},
                "parameter_bound": False
            },
            "ssrf": {
                "tool_name": "fuzz_parameter",
                "base_args": {"payload_types": ["format"]},
                "parameter_bound": True
            },
            "path_traversal": {
                "tool_name": "fuzz_parameter",
                "base_args": {"payload_types": ["format"]},
                "parameter_bound": True
            },
            "overflow": {
                "tool_name": "fuzz_parameter",
                "base_args": {"payload_types": ["overflow", "boundary"]},
                "parameter_bound": True
            },
            "type_confusion": {
                "tool_name": "fuzz_parameter",
                "base_args": {"payload_types": ["type_confusion"]},
                "parameter_bound": True
            },
            "ssti": {
                "tool_name": "fuzz_parameter",
                "base_args": {"payload_types": ["injection"]},
                "parameter_bound": True
            },
            "info_disclosure": {
                "tool_name": "http_send",
                "base_args": {"method": "GET"},
                "parameter_bound": False
            },
            "misconfig": {
                "tool_name": "http_send",
                "base_args": {"method": "OPTIONS"},
                "parameter_bound": False
            },
        }


_VULN_TOOL_MAP = _build_vuln_tool_map()

# Vuln classes that should have one coverage row per parameter
_PARAMETER_BOUND_CLASSES = {
    vuln_class
    for vuln_class, config in _VULN_TOOL_MAP.items()
    if config.get('parameter_bound', False)
}

# Severity tiers for priority scoring (legacy compatibility)
_HIGH_SEVERITY_CLASSES = {"sqli", "auth_bypass", "ssrf", "injection", "command_injection", "xml_injection", "jwt_manipulation"}
_LOW_SEVERITY_CLASSES = {"info_disclosure", "misconfig", "info_leak_errors", "info_leak_comments", "info_leak_headers"}

# Path parameter pattern (e.g. /{id}, /{user_id})
_PATH_PARAM_RE = re.compile(r"/\{[^}]+\}")


# ---------------------------------------------------------------------------
# CoverageTracker
# ---------------------------------------------------------------------------

class CoverageTracker:
    """Maps endpoints to vuln classes, resolves tool calls, and builds the coverage matrix."""

    @staticmethod
    def classify_endpoint(endpoint: Dict[str, Any]) -> List[str]:
        """Determine applicable vuln classes for an endpoint.

        Uses the 42-class vulnerability checklist with applicability predicates.
        Falls back to legacy rules if checklist not available.
        """
        if _CHECKLIST_AVAILABLE:
            # Use checklist predicates
            checklist = get_vuln_checklist()
            # Normalize endpoint data for predicates
            normalized = checklist._normalize_endpoint_for_predicates(endpoint)
            applicable_specs = checklist.get_applicable_specs(normalized)
            return sorted([spec.id for spec in applicable_specs])
        else:
            # Legacy classification rules (12 classes)
            classes: set = set()
            method = (endpoint.get("method") or "GET").upper()
            path = endpoint.get("path") or ""
            parameters = endpoint.get("parameters") or {}
            auth_required = endpoint.get("auth_required", False)

            # Count parameters
            param_count = 0
            if isinstance(parameters, dict):
                # Could be {"query": {...}, "body": {...}} or flat {"param1": "type"}
                for v in parameters.values():
                    if isinstance(v, dict):
                        param_count += len(v)
                    else:
                        param_count += 1

            has_params = param_count > 0
            has_path_params = bool(_PATH_PARAM_RE.search(path))
            is_state_changing = method in ("POST", "PUT", "PATCH", "DELETE")

            # Parameter-based classes
            if has_params:
                classes.update({"sqli", "xss", "injection", "type_confusion", "overflow", "path_traversal", "ssti"})

            # Auth-based classes
            if auth_required:
                classes.update({"idor", "auth_bypass"})

            # Path param classes
            if has_path_params:
                classes.update({"idor", "ssrf"})

            # State-changing method classes
            if is_state_changing:
                classes.update({"sqli", "xss", "injection", "ssti"})

            # Always applicable
            classes.update({"info_disclosure", "misconfig"})

            return sorted(classes)

    @staticmethod
    def _extract_param_names(endpoint: Dict[str, Any]) -> List[str]:
        """Extract all parameter names from the endpoint's parameters dict."""
        parameters = endpoint.get("parameters") or {}
        param_names: List[str] = []
        if isinstance(parameters, dict):
            for k, v in parameters.items():
                if isinstance(v, dict):
                    param_names.extend(v.keys())
                else:
                    param_names.append(k)
        return param_names

    @staticmethod
    def resolve_tool_call(
        endpoint: Dict[str, Any],
        vuln_class: str,
        base_url: str,
        parameter: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Resolve a vuln class to an exact MCP tool call.

        Parameters
        ----------
        parameter : str, optional
            If given, override the target parameter in fuzz_parameter calls.

        Returns ``{"tool_name": str, "arguments": dict}``.
        """
        mapping = _VULN_TOOL_MAP.get(vuln_class)
        if not mapping:
            return {"tool_name": "", "arguments": {}}

        tool_name = mapping["tool_name"]
        base_args = dict(mapping["base_args"])
        method = (endpoint.get("method") or "GET").upper()
        path = endpoint.get("path") or ""
        url = f"{base_url.rstrip('/')}{path}"
        parameters = endpoint.get("parameters") or {}

        if tool_name == "fuzz_parameter":
            base_args["url"] = url
            base_args["method"] = method
            if parameter:
                base_args["parameter"] = parameter
            else:
                # Resolve target parameter names
                param_names = CoverageTracker._extract_param_names(endpoint)
                if param_names:
                    base_args["parameter"] = param_names[0]

        elif tool_name == "auth_diff_test":
            base_args["url"] = url
            base_args["method"] = method

        elif tool_name == "http_send":
            base_args["url"] = url

        elif tool_name == "nuclei_scan_template":
            base_args["targets"] = [url]

        return {"tool_name": tool_name, "arguments": base_args}

    @staticmethod
    def compute_priority(
        endpoint: Dict[str, Any],
        vuln_class: str,
    ) -> int:
        """Compute priority score 0-100 for a coverage cell.

        - base = 50
        - +20 auth_required
        - +10 state-changing method (POST/PUT/PATCH/DELETE)
        - +10 high-severity vuln class
        - +5 per parameter (max +15)
        - -10 low-severity class
        """
        priority = 50
        method = (endpoint.get("method") or "GET").upper()
        parameters = endpoint.get("parameters") or {}
        auth_required = endpoint.get("auth_required", False)

        if auth_required:
            priority += 20

        if method in ("POST", "PUT", "PATCH", "DELETE"):
            priority += 10

        if vuln_class in _HIGH_SEVERITY_CLASSES:
            priority += 10

        if vuln_class in _LOW_SEVERITY_CLASSES:
            priority -= 10

        # Count parameters
        param_count = 0
        if isinstance(parameters, dict):
            for v in parameters.values():
                if isinstance(v, dict):
                    param_count += len(v)
                else:
                    param_count += 1
        priority += min(param_count * 5, 15)

        return max(0, min(priority, 100))

    @classmethod
    def build_matrix(
        cls,
        endpoints: List[Dict[str, Any]],
        base_url: str,
        vuln_classes: Optional[List[str]] = None,
    ) -> List[Dict[str, Any]]:
        """Build the full coverage matrix from a list of endpoints.

        For parameter-bound vuln classes, emits one row per parameter.
        For non-parameter classes, emits one row with parameter="".

        Returns rows ready for ``WorldModelDatabase.coverage_init_rows()``.
        """
        rows: List[Dict[str, Any]] = []

        for ep in endpoints:
            ep_id = ep.get("id")
            if not ep_id:
                continue

            applicable = cls.classify_endpoint(ep)

            # Filter to requested vuln classes if specified
            if vuln_classes:
                applicable = [vc for vc in applicable if vc in vuln_classes]

            param_names = cls._extract_param_names(ep)

            for vc in applicable:
                if vc in _PARAMETER_BOUND_CLASSES and param_names:
                    # One row per parameter
                    for param in param_names:
                        tool_call = cls.resolve_tool_call(ep, vc, base_url, parameter=param)
                        priority = cls.compute_priority(ep, vc)
                        rows.append({
                            "endpoint_id": ep_id,
                            "vuln_class": vc,
                            "parameter": param,
                            "tool_name": tool_call["tool_name"],
                            "tool_args": tool_call["arguments"],
                            "priority": priority,
                        })
                else:
                    # Single row, no specific parameter
                    tool_call = cls.resolve_tool_call(ep, vc, base_url)
                    priority = cls.compute_priority(ep, vc)
                    rows.append({
                        "endpoint_id": ep_id,
                        "vuln_class": vc,
                        "parameter": "",
                        "tool_name": tool_call["tool_name"],
                        "tool_args": tool_call["arguments"],
                        "priority": priority,
                    })

        return rows
