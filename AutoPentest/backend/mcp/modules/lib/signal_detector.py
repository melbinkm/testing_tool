"""
Signal Detector
Detects anomalies and potential vulnerabilities in HTTP responses.
Ported from fuzzer-mcp/src/signal-detector.ts
"""

from __future__ import annotations

import hashlib
from typing import Any, Dict, List, Optional


# ---------------------------------------------------------------------------
# Error indicators in response bodies
# ---------------------------------------------------------------------------
ERROR_INDICATORS: dict[str, list[str]] = {
    "sql": [
        "sql syntax",
        "mysql_fetch",
        "ora-01756",
        "postgresql",
        "sqlite3",
        "jdbc",
        "odbc",
        "syntax error",
        "unclosed quotation",
        "unterminated string",
        "sql server",
        "sqlstate",
    ],
    "stackTrace": [
        "stacktrace",
        "stack trace",
        "traceback",
        "at line",
        "exception in",
        "error in",
        "fatal error",
        "caused by",
        "java.lang.",
        "at java.",
        "at org.",
        "at com.",
        'file "',
        '.py", line',
        ".php on line",
        ".rb:",
    ],
    "debug": [
        "debug=true",
        "debug mode",
        "development mode",
        "dev server",
        "[debug]",
        "debug info",
        "error_reporting",
    ],
    "path": [
        "/var/www",
        "/home/",
        "c:\\",
        "d:\\",
        "/usr/",
        "/etc/",
        "document root",
        "web root",
    ],
    "internal": [
        "internal server error",
        "server error",
        "application error",
        "runtime error",
        "unhandled exception",
    ],
}

# ---------------------------------------------------------------------------
# Reflection patterns for XSS detection
# ---------------------------------------------------------------------------
REFLECTION_PATTERNS: list[str] = [
    "<script",
    "javascript:",
    "onerror=",
    "onload=",
    "onclick=",
    "onmouseover=",
    "alert(",
    "prompt(",
    "confirm(",
    "{{",
    "${",
    "#{",
]


class SignalDetector:
    """Detects anomalies and potential vulnerabilities in HTTP responses."""

    def __init__(self, config: Optional[dict[str, Any]] = None) -> None:
        defaults = {
            "timing_threshold_multiplier": 3,
            "min_timing_threshold": 1000,
            "error_status_codes": [500, 501, 502, 503, 504],
            "reflection_min_length": 3,
        }
        if config:
            defaults.update(config)
        self.config = defaults

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    @staticmethod
    def hash_response(body: str) -> str:
        """SHA-256 hash of *body*, truncated to the first 16 hex chars."""
        return hashlib.sha256(body.encode("utf-8")).hexdigest()[:16]

    def detect_signals(
        self,
        response: dict[str, Any],
        payload: str,
        payload_type: str,
        baseline: Optional[dict[str, Any]] = None,
    ) -> list[dict[str, Any]]:
        """Detect all signals from a response compared to an optional baseline."""
        signals: list[dict[str, Any]] = []

        error_signal = self.detect_error_signal(response, payload, payload_type)
        if error_signal is not None:
            signals.append(error_signal)

        if baseline is not None:
            timing_signal = self.detect_timing_signal(response, payload, payload_type, baseline)
            if timing_signal is not None:
                signals.append(timing_signal)

        reflection_signal = self.detect_reflection_signal(response, payload, payload_type)
        if reflection_signal is not None:
            signals.append(reflection_signal)

        if baseline is not None:
            differential_signal = self.detect_differential_signal(response, payload, payload_type, baseline)
            if differential_signal is not None:
                signals.append(differential_signal)

        return signals

    def detect_error_signal(
        self,
        response: dict[str, Any],
        payload: str,
        payload_type: str,
    ) -> Optional[dict[str, Any]]:
        """Detect error-based signals (5xx status, stack traces, SQL errors)."""
        body_lower: str = response.get("body", "").lower()
        evidence: Optional[str] = None
        severity: str = "low"
        details: Optional[str] = None

        # Check for error status codes
        if response.get("status") in self.config["error_status_codes"]:
            evidence = f"HTTP {response['status']}"
            severity = "medium"
            details = "Server returned error status code"

        # Check for SQL error indicators
        for indicator in ERROR_INDICATORS["sql"]:
            if indicator in body_lower:
                evidence = indicator
                severity = "high"
                details = "Potential SQL error disclosure"
                break

        # Check for stack traces
        for indicator in ERROR_INDICATORS["stackTrace"]:
            if indicator in body_lower:
                evidence = evidence or indicator
                severity = severity if severity == "high" else "medium"
                details = details or "Stack trace detected in response"
                break

        # Check for path disclosure
        for indicator in ERROR_INDICATORS["path"]:
            if indicator in body_lower:
                evidence = evidence or indicator
                severity = severity if severity == "high" else "low"
                details = details or "Path disclosure detected"
                break

        # Check for debug info
        for indicator in ERROR_INDICATORS["debug"]:
            if indicator in body_lower:
                evidence = evidence or indicator
                severity = "info"
                details = details or "Debug information detected"
                break

        if evidence is None:
            return None

        # Calculate confidence based on evidence strength
        confidence = 0.5
        if response.get("status") in self.config["error_status_codes"]:
            confidence += 0.2
        if severity == "high":
            confidence += 0.2
        if payload_type == "injection":
            confidence += 0.1

        return {
            "payload": self._truncate_payload(payload),
            "payload_type": payload_type,
            "response_status": response.get("status"),
            "response_time_ms": response.get("timing_ms"),
            "signal_type": "error",
            "severity": severity,
            "confidence": min(confidence, 1.0),
            "evidence": evidence,
            "details": details,
        }

    def detect_timing_signal(
        self,
        response: dict[str, Any],
        payload: str,
        payload_type: str,
        baseline: dict[str, Any],
    ) -> Optional[dict[str, Any]]:
        """Detect timing-based signals (slow responses indicating injection)."""
        baseline_time: float = baseline.get("timing_ms", 0)
        response_time: float = response.get("timing_ms", 0)

        threshold = max(
            baseline_time * self.config["timing_threshold_multiplier"],
            self.config["min_timing_threshold"],
        )

        if response_time <= threshold:
            return None

        multiplier = response_time / baseline_time if baseline_time else float("inf")

        if multiplier > 10:
            severity = "high"
        elif multiplier > 5:
            severity = "medium"
        else:
            severity = "low"

        confidence = 0.4
        if payload_type == "injection":
            confidence += 0.3
        if multiplier > 5:
            confidence += 0.2

        return {
            "payload": self._truncate_payload(payload),
            "payload_type": payload_type,
            "response_status": response.get("status"),
            "response_time_ms": response_time,
            "signal_type": "timing",
            "severity": severity,
            "confidence": min(confidence, 1.0),
            "evidence": f"{response_time}ms (baseline: {baseline_time}ms, {multiplier:.1f}x)",
            "details": f"Response time {multiplier:.1f}x slower than baseline",
        }

    def detect_reflection_signal(
        self,
        response: dict[str, Any],
        payload: str,
        payload_type: str,
    ) -> Optional[dict[str, Any]]:
        """Detect reflection-based signals (XSS potential)."""
        if len(payload) < self.config["reflection_min_length"]:
            return None

        body: str = response.get("body", "")
        payload_str = payload if isinstance(payload, str) else str(payload)

        # Check if payload is reflected in response
        if payload_str not in body:
            return None

        severity = "low"
        evidence = "Payload reflected in response"
        details = "Input is echoed back in response"

        # Check for dangerous reflection patterns
        payload_lower = payload_str.lower()
        body_lower = body.lower()

        for pattern in REFLECTION_PATTERNS:
            if pattern in payload_lower and pattern in body_lower:
                severity = "high"
                evidence = f'Dangerous pattern "{pattern}" reflected'
                details = "Potential XSS - dangerous pattern reflected without encoding"
                break

        # Higher confidence for injection payloads reflecting
        confidence = 0.5
        if payload_type == "injection":
            confidence += 0.3
        if severity == "high":
            confidence += 0.2

        return {
            "payload": self._truncate_payload(payload_str),
            "payload_type": payload_type,
            "response_status": response.get("status"),
            "response_time_ms": response.get("timing_ms"),
            "signal_type": "reflection",
            "severity": severity,
            "confidence": min(confidence, 1.0),
            "evidence": evidence,
            "details": details,
        }

    def detect_differential_signal(
        self,
        response: dict[str, Any],
        payload: str,
        payload_type: str,
        baseline: dict[str, Any],
    ) -> Optional[dict[str, Any]]:
        """Detect differential signals (different response vs baseline)."""
        # Compare status codes
        status_diff = response.get("status") != baseline.get("status")

        # Compare response body hashes
        response_hash = self.hash_response(response.get("body", ""))
        baseline_hash = self.hash_response(baseline.get("body", ""))
        body_diff = response_hash != baseline_hash

        # Compare response lengths (significant difference)
        response_len = len(response.get("body", ""))
        baseline_len = len(baseline.get("body", "")) or 1
        length_ratio = response_len / baseline_len
        length_diff = length_ratio < 0.5 or length_ratio > 2

        if not status_diff and not body_diff and not length_diff:
            return None

        differences: list[str] = []
        if status_diff:
            differences.append(f"status: {baseline.get('status')} -> {response.get('status')}")
        if body_diff:
            differences.append("body hash changed")
        if length_diff:
            differences.append(f"length: {len(baseline.get('body', ''))} -> {response_len}")

        severity = "info"
        if status_diff and response.get("status") in self.config["error_status_codes"]:
            severity = "medium"
        resp_status = response.get("status", 0)
        base_status = baseline.get("status", 0)
        if status_diff and 200 <= resp_status < 300 and base_status >= 400:
            severity = "high"  # Bypassed protection

        confidence = 0.3
        if status_diff:
            confidence += 0.2
        if payload_type in ("injection", "boundary"):
            confidence += 0.2
        if severity == "high":
            confidence += 0.2

        return {
            "payload": self._truncate_payload(payload),
            "payload_type": payload_type,
            "response_status": response.get("status"),
            "response_time_ms": response.get("timing_ms"),
            "signal_type": "differential",
            "severity": severity,
            "confidence": min(confidence, 1.0),
            "evidence": ", ".join(differences),
            "details": "Response differs significantly from baseline",
        }

    # ------------------------------------------------------------------
    # Configuration helpers
    # ------------------------------------------------------------------

    def get_config(self) -> dict[str, Any]:
        """Return a copy of the current configuration."""
        return dict(self.config)

    def set_config(self, config: dict[str, Any]) -> None:
        """Merge *config* into the current configuration."""
        self.config.update(config)

    # ------------------------------------------------------------------
    # Private helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _truncate_payload(payload: str, max_length: int = 100) -> str:
        """Truncate long payloads for display."""
        if len(payload) <= max_length:
            return payload
        return payload[: max_length - 3] + "..."


# Default instance for convenience
signal_detector = SignalDetector()
