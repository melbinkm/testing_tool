"""
ControlRunner - Handles negative control and cross-identity validation

Negative controls verify the vulnerability doesn't exist in control scenarios.
Cross-identity validation confirms authorization is properly enforced.

Uses httpx (async) for HTTP requests and hashlib for response hashing.

Ported from validator-mcp/src/control-runner.ts
"""
from __future__ import annotations

import hashlib
import time
from typing import Any, Dict, List, Optional

import httpx


class ControlRunner:
    """Handles negative control and cross-identity testing."""

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    def hash_response(self, body: str) -> str:
        """Generate SHA-256 hash of response body."""
        return hashlib.sha256(body.encode("utf-8")).hexdigest()

    def build_auth_headers(self, identity: Dict[str, Any]) -> Dict[str, str]:
        """Build authentication headers for an identity.

        Args:
            identity: An IdentityConfig dict with keys:
                - identity_id (str)
                - auth_header (str, optional)
                - auth_type ('bearer' | 'basic' | 'api_key' | 'cookie', optional)
                - cookies (dict, optional)
                - should_have_access (bool)

        Returns:
            A dict of HTTP headers representing the identity's auth.
        """
        headers: Dict[str, str] = {}

        # Handle cookie auth type separately since it uses cookies object, not auth_header
        if identity.get("auth_type") == "cookie" and identity.get("cookies"):
            cookie_str = "; ".join(
                f"{key}={value}"
                for key, value in identity["cookies"].items()
            )
            headers["Cookie"] = cookie_str
            return headers

        auth_header = identity.get("auth_header")
        if auth_header:
            auth_type = identity.get("auth_type")
            if auth_type in ("bearer", "basic"):
                headers["Authorization"] = auth_header
            elif auth_type == "api_key":
                headers["X-API-Key"] = auth_header

        return headers

    def _build_control_headers(
        self,
        original_headers: Optional[Dict[str, str]],
        config: Dict[str, Any],
    ) -> Dict[str, str]:
        """Modify request headers based on control configuration.

        Args:
            original_headers: The finding's original request headers.
            config: NegativeControlConfig dict.

        Returns:
            A new headers dict with modifications applied.
        """
        headers = dict(original_headers) if original_headers else {}

        # Remove authentication if specified
        if config.get("remove_auth"):
            headers.pop("Authorization", None)
            headers.pop("X-API-Key", None)
            headers.pop("Cookie", None)

        # Apply modified headers
        modified_headers = config.get("modified_headers")
        if modified_headers:
            headers.update(modified_headers)

        return headers

    def _get_expected_behavior(self, config: Dict[str, Any]) -> str:
        """Get expected behavior description for a control type."""
        control_type = config.get("control_type", "")

        if control_type == "unauthenticated":
            return "Request without authentication should be rejected (401/403)"
        elif control_type == "invalid_token":
            return "Request with invalid token should be rejected (401/403)"
        elif control_type == "different_user":
            return "Request from unauthorized user should be rejected (403)"
        elif control_type == "modified_request":
            expected_status = config.get("expected_status")
            if expected_status:
                return f"Modified request should return status {expected_status}"
            return "Modified request should be rejected"
        else:
            return "Request should be rejected"

    def _evaluate_control_result(
        self,
        status_code: int,
        config: Dict[str, Any],
    ) -> bool:
        """Determine if the control test passed.

        Args:
            status_code: The HTTP response status code.
            config: NegativeControlConfig dict.

        Returns:
            True if the control test passed (request was properly rejected).
        """
        # If specific expected status is provided, check for it
        expected_status = config.get("expected_status")
        if expected_status is not None:
            return status_code == expected_status

        # Default: control passes if request is rejected (4xx status)
        control_type = config.get("control_type", "")

        if control_type == "unauthenticated":
            return status_code in (401, 403)
        elif control_type == "invalid_token":
            return status_code in (401, 403)
        elif control_type == "different_user":
            return status_code in (403, 404)
        elif control_type == "modified_request":
            return status_code >= 400
        else:
            return status_code >= 400

    # ------------------------------------------------------------------
    # Negative control testing
    # ------------------------------------------------------------------

    async def run_negative_control(
        self,
        finding: Dict[str, Any],
        config: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Run negative control test for a finding.

        Args:
            finding: The finding to test (must have finding_id and request).
            config: NegativeControlConfig dict with control_type, optional
                modified_headers, modified_body, remove_auth, expected_status.

        Returns:
            A NegativeControlResult dict with pass/fail status.
        """
        try:
            request = finding["request"]
            headers = self._build_control_headers(request.get("headers"), config)
            body = config.get("modified_body") or request.get("body")

            method = request["method"]
            url = request["url"]

            # Only attach body for methods that support it
            content: Optional[str] = None
            if body and method.upper() in ("POST", "PUT", "PATCH"):
                content = body

            async with httpx.AsyncClient(verify=False) as client:
                response = await client.request(
                    method=method,
                    url=url,
                    headers=headers,
                    content=content,
                )

            passed = self._evaluate_control_result(response.status_code, config)
            control_type = config.get("control_type", "unknown")

            return {
                "finding_id": finding["finding_id"],
                "control_type": control_type,
                "passed": passed,
                "expected_behavior": self._get_expected_behavior(config),
                "actual_status": response.status_code,
                "actual_behavior": (
                    "Request was properly rejected"
                    if passed
                    else f"Request unexpectedly returned status {response.status_code}"
                ),
                "message": (
                    f"Negative control passed: {control_type} test confirmed authorization is enforced"
                    if passed
                    else f"Negative control FAILED: {control_type} test shows potential authorization bypass"
                ),
            }

        except Exception as exc:
            control_type = config.get("control_type", "unknown")
            return {
                "finding_id": finding["finding_id"],
                "control_type": control_type,
                "passed": False,
                "expected_behavior": self._get_expected_behavior(config),
                "actual_status": 0,
                "actual_behavior": f"Request failed: {exc}",
                "message": f"Negative control error: {exc}",
            }

    # ------------------------------------------------------------------
    # Cross-identity testing
    # ------------------------------------------------------------------

    async def _test_identity(
        self,
        finding: Dict[str, Any],
        identity: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Test a single identity for cross-identity validation.

        Args:
            finding: The finding to test.
            identity: An IdentityConfig dict.

        Returns:
            A CrossIdentityTestResult dict.
        """
        start_time = time.monotonic()

        try:
            request = finding["request"]
            auth_headers = self.build_auth_headers(identity)
            headers = {**(request.get("headers") or {}), **auth_headers}

            method = request["method"]
            url = request["url"]
            body = request.get("body")

            content: Optional[str] = None
            if body and method.upper() in ("POST", "PUT", "PATCH"):
                content = body

            async with httpx.AsyncClient(verify=False) as client:
                response = await client.request(
                    method=method,
                    url=url,
                    headers=headers,
                    content=content,
                )
                response_body = response.text

            end_time = time.monotonic()

            # Determine if the identity has access based on status code
            has_access = 200 <= response.status_code < 400

            return {
                "identity_id": identity["identity_id"],
                "status_code": response.status_code,
                "response_hash": self.hash_response(response_body),
                "has_access": has_access,
                "expected_access": identity["should_have_access"],
                "timing_ms": round((end_time - start_time) * 1000),
            }

        except Exception as exc:
            end_time = time.monotonic()
            return {
                "identity_id": identity["identity_id"],
                "status_code": 0,
                "response_hash": "",
                "has_access": False,
                "expected_access": identity["should_have_access"],
                "timing_ms": round((end_time - start_time) * 1000),
                "error": str(exc),
            }

    async def run_cross_identity(
        self,
        finding: Dict[str, Any],
        identities: List[Dict[str, Any]],
    ) -> Dict[str, Any]:
        """Run cross-identity validation for a finding.

        Args:
            finding: The finding to test.
            identities: Array of IdentityConfig dicts to test.

        Returns:
            A CrossIdentityResult dict with authorization enforcement status.
        """
        results: List[Dict[str, Any]] = []

        for identity in identities:
            result = await self._test_identity(finding, identity)
            results.append(result)

        # Check for authorization violations
        violations: List[str] = []
        for result in results:
            if result["has_access"] != result["expected_access"]:
                if result["has_access"] and not result["expected_access"]:
                    violations.append(
                        f"{result['identity_id']}: Gained unauthorized access "
                        f"(status {result['status_code']})"
                    )
                elif not result["has_access"] and result["expected_access"]:
                    violations.append(
                        f"{result['identity_id']}: Denied expected access "
                        f"(status {result['status_code']})"
                    )

        authorization_enforced = len(violations) == 0

        return {
            "finding_id": finding["finding_id"],
            "identities_tested": [i["identity_id"] for i in identities],
            "results": results,
            "authorization_enforced": authorization_enforced,
            "violations": violations,
            "message": (
                "Authorization is properly enforced across all tested identities"
                if authorization_enforced
                else f"Authorization violations detected: {'; '.join(violations)}"
            ),
        }
