"""
ReproRunner - Handles reproduction validation of findings

Runs the same test N times to confirm the finding is consistent
and reproducible. Uses httpx (async) for HTTP requests and hashlib
for response hashing.

Ported from validator-mcp/src/repro-runner.ts
"""
from __future__ import annotations

import hashlib
import os
import re
import time
from typing import Any, Dict, List, Optional

import httpx


# Default number of reproduction attempts
DEFAULT_REPRO_COUNT = int(os.environ.get("REPRO_COUNT", "3"))


class ReproRunner:
    """Handles reproduction testing for finding validation."""

    def __init__(self, default_count: int = DEFAULT_REPRO_COUNT) -> None:
        self._default_count = default_count

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    def hash_response(self, body: str) -> str:
        """Generate SHA-256 hash of response body."""
        return hashlib.sha256(body.encode("utf-8")).hexdigest()

    def matches_expectations(
        self,
        status_code: int,
        response_body: str,
        expected: Optional[Dict[str, Any]] = None,
    ) -> bool:
        """Check if response matches expected characteristics.

        Args:
            status_code: HTTP response status code.
            response_body: HTTP response body text.
            expected: Optional dict with keys:
                - status_code (int)
                - body_contains (List[str])
                - body_not_contains (List[str])
                - body_regex (str)

        Returns:
            True if the response matches all specified expectations.
        """
        if expected is None:
            # If no expectations specified, consider 2xx responses as matching
            return 200 <= status_code < 300

        # Check status code if specified
        if expected.get("status_code") is not None and status_code != expected["status_code"]:
            return False

        # Check body contains patterns
        body_contains: Optional[List[str]] = expected.get("body_contains")
        if body_contains:
            for pattern in body_contains:
                if pattern not in response_body:
                    return False

        # Check body does not contain patterns
        body_not_contains: Optional[List[str]] = expected.get("body_not_contains")
        if body_not_contains:
            for pattern in body_not_contains:
                if pattern in response_body:
                    return False

        # Check body regex pattern
        body_regex: Optional[str] = expected.get("body_regex")
        if body_regex:
            if not re.search(body_regex, response_body):
                return False

        return True

    # ------------------------------------------------------------------
    # Execute a single reproduction attempt
    # ------------------------------------------------------------------

    async def execute_attempt(
        self,
        finding: Dict[str, Any],
        attempt_number: int,
    ) -> Dict[str, Any]:
        """Execute a single reproduction attempt.

        Args:
            finding: The finding dict with ``finding_id``, ``title``,
                ``request`` (method, url, headers, body), and optional
                ``expected``.
            attempt_number: 1-based attempt index.

        Returns:
            A ReproAttempt dict.
        """
        start_time = time.monotonic()

        try:
            request = finding["request"]
            method = request["method"]
            url = request["url"]
            headers = request.get("headers") or {}
            body = request.get("body")

            # Only attach body for methods that support it
            content: Optional[str] = None
            if body and method.upper() in ("POST", "PUT", "PATCH"):
                content = body

            async with httpx.AsyncClient(verify=False) as client:
                response = await client.request(
                    method=method,
                    url=url,
                    headers=headers,
                    content=content,
                )
                response_body = response.text

            end_time = time.monotonic()

            matched_expectations = self.matches_expectations(
                response.status_code,
                response_body,
                finding.get("expected"),
            )

            return {
                "attempt": attempt_number,
                "success": True,
                "status_code": response.status_code,
                "response_length": len(response_body),
                "response_hash": self.hash_response(response_body),
                "matched_expectations": matched_expectations,
                "timing_ms": round((end_time - start_time) * 1000),
            }

        except Exception as exc:
            end_time = time.monotonic()
            return {
                "attempt": attempt_number,
                "success": False,
                "status_code": 0,
                "response_length": 0,
                "response_hash": "",
                "matched_expectations": False,
                "timing_ms": round((end_time - start_time) * 1000),
                "error": str(exc),
            }

    # ------------------------------------------------------------------
    # Run full reproduction validation
    # ------------------------------------------------------------------

    async def run_repro(
        self,
        finding: Dict[str, Any],
        count: Optional[int] = None,
    ) -> Dict[str, Any]:
        """Run reproduction validation for a finding.

        Args:
            finding: The finding to reproduce.
            count: Number of reproduction attempts (defaults to
                ``self._default_count``).

        Returns:
            A ReproResult dict with success rate and consistency info.
        """
        attempt_count = count if count is not None else self._default_count
        attempts: List[Dict[str, Any]] = []

        for i in range(1, attempt_count + 1):
            attempt = await self.execute_attempt(finding, i)
            attempts.append(attempt)

        # Calculate statistics
        successful_attempts = [
            a for a in attempts if a["success"] and a["matched_expectations"]
        ]
        failed_attempts = [
            a for a in attempts if not a["success"] or not a["matched_expectations"]
        ]

        # Check consistency - all successful attempts should have similar responses
        successful_hashes = [a["response_hash"] for a in successful_attempts]
        unique_hashes = set(successful_hashes)
        consistent = len(unique_hashes) <= 1 and len(successful_attempts) > 0

        return {
            "finding_id": finding["finding_id"],
            "total_attempts": attempt_count,
            "successful_attempts": len(successful_attempts),
            "failed_attempts": len(failed_attempts),
            "success_rate": len(successful_attempts) / attempt_count if attempt_count > 0 else 0,
            "consistent": consistent,
            "attempts": attempts,
        }

    # ------------------------------------------------------------------
    # Accessors
    # ------------------------------------------------------------------

    def get_default_count(self) -> int:
        """Get the default reproduction count."""
        return self._default_count
