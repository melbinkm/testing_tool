"""
Scope Loader - Loads and validates engagement scope files.
Ported from TypeScript scope-loader.ts to Python.

Supports YAML and JSON scope files, with Pydantic-based validation
and normalization (lowercase domains / keywords).
"""

import json
import os
from pathlib import Path

import yaml
from pydantic import ValidationError as PydanticValidationError

from lib.scope_types import EngagementScope, ScopeValidationError


def load_scope(file_path: str) -> EngagementScope:
    """Load and validate an engagement scope file.

    Parameters
    ----------
    file_path : str
        Path to the YAML or JSON scope file.

    Returns
    -------
    EngagementScope
        Validated and normalized engagement scope.

    Raises
    ------
    ScopeValidationError
        If the file cannot be found, read, parsed, or does not pass
        validation.
    """
    path = Path(file_path)

    # Check file exists
    if not path.exists():
        raise ScopeValidationError(
            f"Scope file not found: {file_path}",
            [f"File does not exist: {file_path}"],
        )

    # Read file content
    try:
        content = path.read_text(encoding="utf-8")
    except OSError as exc:
        raise ScopeValidationError(
            f"Failed to read scope file: {file_path}",
            [str(exc)],
        )

    # Parse based on file extension
    ext = path.suffix.lower()
    data = None

    try:
        if ext in (".yaml", ".yml"):
            data = yaml.safe_load(content)
        elif ext == ".json":
            data = json.loads(content)
        else:
            # Try YAML first, then JSON
            try:
                data = yaml.safe_load(content)
            except yaml.YAMLError:
                data = json.loads(content)
    except (yaml.YAMLError, json.JSONDecodeError) as exc:
        raise ScopeValidationError(
            f"Failed to parse scope file: {file_path}",
            [str(exc)],
        )

    # Validate against Pydantic schema
    scope = validate_scope(data)

    # Normalize the scope
    return normalize_scope(scope)


def validate_scope(data: dict) -> EngagementScope:
    """Validate scope data using Pydantic models.

    Parameters
    ----------
    data : dict
        Parsed scope data (from YAML or JSON).

    Returns
    -------
    EngagementScope
        Validated engagement scope.

    Raises
    ------
    ScopeValidationError
        If Pydantic validation fails.
    """
    if not isinstance(data, dict):
        raise ScopeValidationError(
            "Scope validation failed",
            ["Scope data must be a dictionary/object"],
        )

    try:
        return EngagementScope(**data)
    except PydanticValidationError as exc:
        errors = []
        for err in exc.errors():
            loc = " -> ".join(str(part) for part in err["loc"])
            errors.append(f"{loc}: {err['msg']}")
        raise ScopeValidationError("Scope validation failed", errors)


def normalize_scope(scope: EngagementScope) -> EngagementScope:
    """Normalize scope data (lowercase domains, keywords, etc.).

    Parameters
    ----------
    scope : EngagementScope
        Raw validated scope.

    Returns
    -------
    EngagementScope
        Normalized copy of the scope.
    """
    # Work on a shallow copy so the original is untouched
    data = scope.model_copy(deep=True)

    # Normalize allowlist domains to lowercase
    if data.allowlist and data.allowlist.domains:
        data.allowlist.domains = [d.lower() for d in data.allowlist.domains]

    # Normalize denylist domains to lowercase
    if data.denylist and data.denylist.domains:
        data.denylist.domains = [d.lower() for d in data.denylist.domains]

    # Normalize denylist keywords to lowercase for case-insensitive matching
    if data.denylist and data.denylist.keywords:
        data.denylist.keywords = [k.lower() for k in data.denylist.keywords]

    return data


def load_scope_from_env(
    env_var: str = "SCOPE_FILE",
    default_path: str = "./scope/engagement.yaml",
) -> EngagementScope:
    """Load scope from an environment variable or a default path.

    Parameters
    ----------
    env_var : str
        Environment variable that holds the scope file path.
        Defaults to ``SCOPE_FILE``.
    default_path : str
        Fallback path when the environment variable is not set.

    Returns
    -------
    EngagementScope
        Validated and normalized engagement scope.
    """
    file_path = os.environ.get(env_var) or default_path
    return load_scope(file_path)


async def load_scope_hybrid(
    assessment_id: int,
    pool,
    fallback_file: str = "./scope/engagement.yaml",
) -> EngagementScope:
    """Load scope from database first, fall back to file if not found.

    This hybrid approach allows per-assessment scope configuration stored
    in the database, while maintaining backward compatibility with file-based
    scope configuration for development and legacy assessments.

    Parameters
    ----------
    assessment_id : int
        Assessment ID to load scope for.
    pool : asyncpg.Pool
        Database connection pool.
    fallback_file : str
        Path to fallback YAML/JSON scope file if no database scope exists.

    Returns
    -------
    EngagementScope
        Validated and normalized engagement scope from DB or file.

    Raises
    ------
    ScopeValidationError
        If scope cannot be loaded from either DB or file, or fails validation.
    """
    import logging
    logger = logging.getLogger("autopentest-mcp")

    # Try loading from database first
    try:
        from lib.scope_loader_db import load_scope_from_db
        scope = await load_scope_from_db(assessment_id, pool)
        if scope:
            logger.info(
                f"Loaded scope for assessment {assessment_id} from database "
                f"(engagement: {scope.engagement.id})"
            )
            return normalize_scope(scope)
    except Exception as exc:
        logger.warning(
            f"Failed to load scope from database for assessment {assessment_id}: {exc}"
        )

    # Fall back to file-based scope
    logger.info(
        f"No database scope for assessment {assessment_id}, falling back to file: {fallback_file}"
    )
    try:
        scope = load_scope(fallback_file)
        logger.info(
            f"Loaded scope for assessment {assessment_id} from file "
            f"(engagement: {scope.engagement.id})"
        )
        return scope
    except Exception as exc:
        raise ScopeValidationError(
            f"Failed to load scope for assessment {assessment_id} from both DB and file",
            [f"DB error: {exc.__class__.__name__}", f"File error: {exc}"],
        )
