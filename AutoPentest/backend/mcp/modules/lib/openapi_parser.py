"""
OpenAPI Specification Parser

Parses OpenAPI 3.x specifications (YAML or JSON) and extracts
endpoint information for security testing.

Ported from the openapi-mcp TypeScript server's parser.ts.
"""
from __future__ import annotations

import json
import uuid
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

import yaml


class OpenAPIParser:
    """Parse and store OpenAPI 3.x specifications for querying."""

    def __init__(self) -> None:
        self._specs: Dict[str, Dict[str, Any]] = {}

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def parse(self, content: str, spec_id: Optional[str] = None) -> Dict[str, Any]:
        """Parse an OpenAPI specification from string content.

        Parameters
        ----------
        content : str
            Raw YAML or JSON string of the OpenAPI document.
        spec_id : str, optional
            Custom identifier.  A UUID is generated when omitted.

        Returns
        -------
        dict
            The ``ParsedSpec`` dictionary stored internally.

        Raises
        ------
        ValueError
            If the content is not valid YAML/JSON, is not OpenAPI 3.x,
            or is missing required fields.
        """
        sid = spec_id or str(uuid.uuid4())

        # Try YAML first (also handles plain JSON), then fall back to json.loads
        doc: Optional[Dict[str, Any]] = None
        try:
            doc = yaml.safe_load(content)
        except Exception:
            pass

        if not isinstance(doc, dict):
            try:
                doc = json.loads(content)
            except Exception:
                raise ValueError("Failed to parse OpenAPI spec: invalid YAML or JSON")

        if not isinstance(doc, dict):
            raise ValueError("Failed to parse OpenAPI spec: invalid YAML or JSON")

        # Validate basic structure
        openapi_version = doc.get("openapi", "")
        if not isinstance(openapi_version, str) or not openapi_version.startswith("3."):
            raise ValueError("Only OpenAPI 3.x specifications are supported")

        info = doc.get("info") or {}
        if not info.get("title") or not info.get("version"):
            raise ValueError("OpenAPI spec must have info.title and info.version")

        paths = doc.get("paths") or {}
        if not paths:
            raise ValueError("OpenAPI spec must have at least one path")

        # Parse the specification
        endpoints = self._parse_endpoints(doc)
        servers = [s.get("url", "") for s in (doc.get("servers") or [])]

        components = doc.get("components") or {}

        parsed: Dict[str, Any] = {
            "specId": sid,
            "title": info["title"],
            "version": info["version"],
            "description": info.get("description"),
            "servers": servers,
            "endpoints": endpoints,
            "schemas": components.get("schemas") or {},
            "securitySchemes": components.get("securitySchemes") or {},
            "tags": doc.get("tags") or [],
            "parsedAt": datetime.now(timezone.utc).isoformat(),
        }

        self._specs[sid] = parsed
        return parsed

    def get_spec(self, spec_id: str) -> Optional[Dict[str, Any]]:
        """Get a parsed specification by ID."""
        return self._specs.get(spec_id)

    def list_specs(self) -> List[Dict[str, Any]]:
        """List all loaded specifications (summary only)."""
        return [
            {
                "specId": spec["specId"],
                "title": spec["title"],
                "version": spec["version"],
                "endpointCount": len(spec["endpoints"]),
            }
            for spec in self._specs.values()
        ]

    def get_endpoints(
        self,
        spec_id: str,
        filter: Optional[Dict[str, Any]] = None,
    ) -> List[Dict[str, Any]]:
        """Get endpoints from a specification with optional filtering.

        ``filter`` may contain any of the keys: ``method``, ``tag``,
        ``pathPattern``, ``hasParameter``, ``deprecated``.
        """
        spec = self._specs.get(spec_id)
        if not spec:
            return []

        endpoints: List[Dict[str, Any]] = list(spec["endpoints"])

        if filter:
            method = filter.get("method")
            tag = filter.get("tag")
            path_pattern = filter.get("pathPattern")
            has_parameter = filter.get("hasParameter")
            deprecated = filter.get("deprecated")

            filtered: List[Dict[str, Any]] = []
            for ep in endpoints:
                if method and ep["method"].lower() != method.lower():
                    continue
                if tag and tag not in ep["tags"]:
                    continue
                if path_pattern and path_pattern not in ep["path"]:
                    continue
                if has_parameter and not any(
                    p["name"] == has_parameter for p in ep["parameters"]
                ):
                    continue
                if deprecated is not None and ep["deprecated"] != deprecated:
                    continue
                filtered.append(ep)
            endpoints = filtered

        return endpoints

    def get_endpoint(
        self,
        spec_id: str,
        path: str,
        method: str,
    ) -> Optional[Dict[str, Any]]:
        """Get a specific endpoint by path and method."""
        spec = self._specs.get(spec_id)
        if not spec:
            return None

        for ep in spec["endpoints"]:
            if ep["path"] == path and ep["method"].lower() == method.lower():
                return ep
        return None

    def get_schemas(self, spec_id: str) -> Dict[str, Any]:
        """Get component schemas from a specification."""
        spec = self._specs.get(spec_id)
        if not spec:
            return {}
        return spec.get("schemas") or {}

    def get_schema(self, spec_id: str, schema_name: str) -> Optional[Dict[str, Any]]:
        """Get a specific schema by name."""
        spec = self._specs.get(spec_id)
        if not spec:
            return None
        schemas = spec.get("schemas") or {}
        return schemas.get(schema_name)

    def remove_spec(self, spec_id: str) -> bool:
        """Remove a loaded specification.  Returns True if it existed."""
        if spec_id in self._specs:
            del self._specs[spec_id]
            return True
        return False

    def clear(self) -> None:
        """Clear all loaded specifications."""
        self._specs.clear()

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    _HTTP_METHODS = ("get", "put", "post", "delete", "options", "head", "patch", "trace")

    def _parse_endpoints(self, doc: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Parse endpoints from an OpenAPI document."""
        endpoints: List[Dict[str, Any]] = []
        paths: Dict[str, Any] = doc.get("paths") or {}

        for path, path_item in paths.items():
            if not isinstance(path_item, dict):
                continue
            path_params: List[Dict[str, Any]] = path_item.get("parameters") or []

            for method in self._HTTP_METHODS:
                operation = path_item.get(method)
                if not operation or not isinstance(operation, dict):
                    continue
                endpoint = self._parse_operation(
                    path, method.upper(), operation, path_params, doc
                )
                endpoints.append(endpoint)

        return endpoints

    def _parse_operation(
        self,
        path: str,
        method: str,
        operation: Dict[str, Any],
        path_params: List[Dict[str, Any]],
        doc: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Parse a single operation into a ParsedEndpoint dict."""

        # Merge path-level and operation-level parameters
        all_params = list(path_params) + list(operation.get("parameters") or [])

        # Parse parameters
        parameters: List[Dict[str, Any]] = []
        for param in all_params:
            if not isinstance(param, dict):
                continue
            parameters.append({
                "name": param.get("name", ""),
                "in": param.get("in", "query"),
                "required": param.get("required", False) or param.get("in") == "path",
                "type": self._get_schema_type(param.get("schema")),
                "description": param.get("description"),
                "example": param.get("example"),
            })

        # Parse request body
        request_body: Optional[Dict[str, Any]] = None
        op_request_body = operation.get("requestBody")
        if isinstance(op_request_body, dict):
            rb_content = op_request_body.get("content") or {}
            request_body = {
                "required": op_request_body.get("required", False),
                "contentTypes": list(rb_content.keys()),
                "description": op_request_body.get("description"),
            }
            # Get schema from first content type
            first_media = next(iter(rb_content.values()), None) if rb_content else None
            if isinstance(first_media, dict) and first_media.get("schema"):
                request_body["schema"] = first_media["schema"]

        # Parse responses
        responses: List[Dict[str, Any]] = []
        op_responses = operation.get("responses") or {}
        for status_code, response in op_responses.items():
            if not isinstance(response, dict):
                continue
            responses.append({
                "statusCode": str(status_code),
                "description": response.get("description", ""),
                "contentTypes": list((response.get("content") or {}).keys()),
            })

        # Get security requirements (deduplicated)
        security_reqs = operation.get("security") or doc.get("security") or []
        security_names: List[str] = []
        seen: set = set()
        for req in security_reqs:
            if isinstance(req, dict):
                for key in req:
                    if key not in seen:
                        seen.add(key)
                        security_names.append(key)

        return {
            "path": path,
            "method": method,
            "operationId": operation.get("operationId"),
            "summary": operation.get("summary"),
            "description": operation.get("description"),
            "tags": operation.get("tags") or [],
            "parameters": parameters,
            "requestBody": request_body,
            "responses": responses,
            "security": security_names,
            "deprecated": operation.get("deprecated", False),
        }

    def _get_schema_type(self, schema: Optional[Dict[str, Any]]) -> str:
        """Get a human-readable type string from a schema dict."""
        if not schema or not isinstance(schema, dict):
            return "any"

        ref = schema.get("$ref")
        if ref and isinstance(ref, str):
            parts = ref.split("/")
            return parts[-1]

        schema_type = schema.get("type", "")

        if schema_type == "array" and schema.get("items"):
            return f"array<{self._get_schema_type(schema['items'])}>"

        if schema.get("oneOf"):
            return " | ".join(self._get_schema_type(s) for s in schema["oneOf"])

        if schema.get("anyOf"):
            return " | ".join(self._get_schema_type(s) for s in schema["anyOf"])

        if schema.get("allOf"):
            return " & ".join(self._get_schema_type(s) for s in schema["allOf"])

        return schema_type or "any"
