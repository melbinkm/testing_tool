"""
SARIF Formatter - SARIF 2.1.0 compliant output for evidence export.

Formats security findings into SARIF 2.1.0 JSON for CI/CD integration.
Spec: https://docs.oasis-open.org/sarif/sarif/v2.1.0/sarif-v2.1.0.html
"""

from __future__ import annotations

import hashlib
import json
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional


# SARIF 2.1.0 schema URL
SARIF_SCHEMA = "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/main/sarif-2.1/schema/sarif-schema-2.1.0.json"
SARIF_VERSION = "2.1.0"

# Severity mapping: finding severity -> SARIF level
_SEVERITY_TO_SARIF: Dict[str, str] = {
    "critical": "error",
    "high": "error",
    "medium": "warning",
    "low": "note",
    "info": "note",
    "none": "none",
}

# Severity to SARIF security-severity (for GitHub Code Scanning)
_SEVERITY_TO_SCORE: Dict[str, float] = {
    "critical": 9.5,
    "high": 8.0,
    "medium": 5.5,
    "low": 3.0,
    "info": 1.0,
}


def _make_rule_id(finding: Dict[str, Any]) -> str:
    """Generate a deterministic rule ID from finding type/title."""
    vuln_type = finding.get("vuln_type") or finding.get("type") or finding.get("title", "unknown")
    # Normalize to a short ID
    normalized = vuln_type.lower().replace(" ", "-").replace("_", "-")
    # Prefix with autopentest
    return f"autopentest/{normalized}"


def _make_fingerprint(finding: Dict[str, Any]) -> str:
    """Generate a fingerprint for deduplication."""
    parts = [
        finding.get("title", ""),
        finding.get("url", finding.get("target", "")),
        finding.get("vuln_type", finding.get("type", "")),
    ]
    raw = "|".join(str(p) for p in parts)
    return hashlib.sha256(raw.encode()).hexdigest()[:32]


class SARIFFormatter:
    """Format findings as SARIF 2.1.0 JSON."""

    def __init__(
        self,
        tool_name: str = "AutoPentest",
        tool_version: str = "1.0.0",
    ) -> None:
        self._tool_name = tool_name
        self._tool_version = tool_version

    def format_findings(
        self,
        findings: List[Dict[str, Any]],
        tool_name: Optional[str] = None,
        tool_version: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Format a list of findings into a complete SARIF document.

        Parameters
        ----------
        findings : list of dict
            Each finding should have: title, severity, description/content,
            and optionally: url, vuln_type, confidence, remediation, cwe_id,
            cvss_vector, evidence_ids, request, response.

        Returns
        -------
        dict
            A SARIF 2.1.0 compliant JSON document.
        """
        name = tool_name or self._tool_name
        version = tool_version or self._tool_version

        # Collect unique rules
        rules: Dict[str, Dict[str, Any]] = {}
        results: List[Dict[str, Any]] = []

        for finding in findings:
            if not finding or not isinstance(finding, dict):
                continue

            rule = self._finding_to_rule(finding)
            rule_id = rule["id"]
            if rule_id not in rules:
                rules[rule_id] = rule

            result = self._finding_to_result(finding, rule_id)
            results.append(result)

        sarif_doc = {
            "$schema": SARIF_SCHEMA,
            "version": SARIF_VERSION,
            "runs": [
                {
                    "tool": {
                        "driver": {
                            "name": name,
                            "version": version,
                            "informationUri": "https://github.com/AutoPentest",
                            "rules": list(rules.values()),
                        }
                    },
                    "results": results,
                    "invocations": [
                        {
                            "executionSuccessful": True,
                            "endTimeUtc": datetime.now(timezone.utc).isoformat(),
                        }
                    ],
                }
            ],
        }

        return sarif_doc

    def format_single(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Format a single finding into a SARIF result object."""
        return self.format_findings([finding])

    def _severity_to_sarif_level(self, severity: str) -> str:
        """Convert finding severity to SARIF level."""
        return _SEVERITY_TO_SARIF.get(severity.lower(), "warning")

    def _finding_to_rule(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Convert a finding into a SARIF rule definition."""
        rule_id = _make_rule_id(finding)
        severity = finding.get("severity", "medium").lower()
        security_severity = _SEVERITY_TO_SCORE.get(severity, 5.0)

        rule: Dict[str, Any] = {
            "id": rule_id,
            "name": finding.get("title", "Unknown Finding"),
            "shortDescription": {
                "text": finding.get("title", "Security finding"),
            },
            "properties": {
                "security-severity": str(security_severity),
                "tags": ["security"],
            },
        }

        # Full description
        desc = finding.get("description") or finding.get("content") or ""
        if desc:
            rule["fullDescription"] = {"text": desc[:4000]}

        # Help text with remediation
        remediation = finding.get("remediation", "")
        if remediation:
            rule["help"] = {
                "text": remediation,
                "markdown": f"**Remediation:**\n\n{remediation}",
            }

        # CWE
        cwe_id = finding.get("cwe_id") or finding.get("cwe")
        if cwe_id:
            cwe_num = str(cwe_id).replace("CWE-", "").strip()
            rule.setdefault("properties", {})["tags"].append(f"external/cwe/cwe-{cwe_num}")

        return rule

    def _finding_to_result(self, finding: Dict[str, Any], rule_id: str) -> Dict[str, Any]:
        """Convert a finding into a SARIF result object."""
        severity = finding.get("severity", "medium").lower()
        level = self._severity_to_sarif_level(severity)

        # Build message
        title = finding.get("title", "Security finding")
        desc = finding.get("description") or finding.get("content") or ""
        message_text = f"{title}"
        if desc:
            message_text += f": {desc[:2000]}"

        result: Dict[str, Any] = {
            "ruleId": rule_id,
            "level": level,
            "message": {"text": message_text},
            "fingerprints": {
                "autopentest/v1": _make_fingerprint(finding),
            },
        }

        # Location - prioritize SAST file+line, fallback to DAST URL
        evidence = finding.get("evidence", {})
        if isinstance(evidence, str):
            try:
                import json as _json
                evidence = _json.loads(evidence)
            except (Exception,):
                evidence = {}

        metadata = finding.get("metadata", {})
        file_path = evidence.get("file") or metadata.get("file")
        line_num = evidence.get("line") or metadata.get("line")

        # Physical location (for SAST findings with file + line)
        if file_path and line_num:
            location: Dict[str, Any] = {
                "physicalLocation": {
                    "artifactLocation": {
                        "uri": str(file_path),
                        "uriBaseId": "%SRCROOT%"
                    },
                    "region": {
                        "startLine": int(line_num)
                    }
                }
            }

            # Add code snippet if available
            code_snippet = evidence.get("code_snippet") or metadata.get("code_snippet")
            if code_snippet:
                location["physicalLocation"]["region"]["snippet"] = {
                    "text": str(code_snippet)[:500]
                }

            # Add end line if available
            end_line = evidence.get("end_line") or metadata.get("end_line")
            if end_line:
                location["physicalLocation"]["region"]["endLine"] = int(end_line)

            result["locations"] = [location]

        # URL location (for DAST findings)
        else:
            url = finding.get("url") or finding.get("target") or ""
            if url:
                result["locations"] = [
                    {
                        "physicalLocation": {
                            "artifactLocation": {
                                "uri": url,
                            }
                        }
                    }
                ]

        # Confidence as rank
        confidence = finding.get("confidence")
        if confidence is not None:
            result["rank"] = round(float(confidence) * 100, 1)

        # CVSS in properties
        cvss = finding.get("cvss_vector") or finding.get("cvss")
        if cvss:
            result.setdefault("properties", {})["cvss_vector"] = cvss

        # Finding ID
        finding_id = finding.get("id") or finding.get("finding_id")
        if finding_id:
            result.setdefault("properties", {})["finding_id"] = finding_id

        # Request/response as code flows
        request = finding.get("request")
        response = finding.get("response")
        if request or response:
            related = []
            if request:
                related.append({
                    "target": {
                        "id": "request",
                        "properties": {"content": str(request)[:4000]},
                    },
                    "kinds": ["request"],
                })
            if response:
                related.append({
                    "target": {
                        "id": "response",
                        "properties": {"content": str(response)[:4000]},
                    },
                    "kinds": ["response"],
                })
            result["relatedLocations"] = [
                {
                    "id": i,
                    "message": {"text": r["target"]["id"]},
                    "physicalLocation": {
                        "artifactLocation": {"uri": url or "unknown"},
                    },
                }
                for i, r in enumerate(related)
            ]

        return result
