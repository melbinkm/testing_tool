"""
Target Validator - Validates domains, IPs, and URLs against scope.
Ported from TypeScript validators.ts to Python.

Uses the ``ipaddress`` stdlib module instead of ipaddr.js.
"""

import ipaddress
import re
from typing import Dict, Optional
from urllib.parse import urlparse

from lib.scope_types import (
    EngagementScope,
    OutOfScopeError,
    ValidationResult,
)


# Default ports for well-known protocols
_DEFAULT_PORTS: Dict[str, int] = {
    "http": 80,
    "https": 443,
    "ssh": 22,
    "ftp": 21,
}

# Regex patterns for target parsing
_IPV4_PORT_RE = re.compile(
    r"^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(?::(\d+))?$"
)
_IPV6_BRACKET_RE = re.compile(r"^\[([^\]]+)\](?::(\d+))?$")
_DOMAIN_PORT_RE = re.compile(
    r"^([a-z0-9]([a-z0-9\-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9\-]*[a-z0-9])?)*)(?::(\d+))?$",
    re.IGNORECASE,
)


class TargetValidator:
    """Validates targets against an engagement scope."""

    def __init__(self, scope: EngagementScope) -> None:
        self.scope = scope

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def validate_target(self, target: str) -> ValidationResult:
        """Validate a target (URL, domain, or IP) against the scope.

        Parameters
        ----------
        target : str
            Target string to validate.

        Returns
        -------
        ValidationResult
        """
        normalized_target = target.lower().strip()

        # Parse the target to extract host / port / path
        parsed = self._parse_target(normalized_target)
        if parsed is None:
            return ValidationResult(
                valid=False,
                target=target,
                reason="Invalid target format",
            )

        host = parsed["host"]
        port = parsed.get("port")
        path = parsed.get("path")

        # Check denylist first (takes precedence)
        deny_result = self._check_denylist(host, port, path)
        if deny_result is not None:
            return ValidationResult(
                valid=False,
                target=target,
                reason=deny_result["reason"],
                matched_rule=deny_result["matched_rule"],
            )

        # Check allowlist
        allow_result = self._check_allowlist(host, port)
        if not allow_result["allowed"]:
            return ValidationResult(
                valid=False,
                target=target,
                reason=allow_result["reason"],
            )

        return ValidationResult(
            valid=True,
            target=target,
            matched_rule=allow_result.get("matched_rule"),
        )

    def assert_in_scope(self, target: str) -> None:
        """Validate and raise if the target is out of scope.

        Raises
        ------
        OutOfScopeError
            When the target is not permitted by the current scope.
        """
        result = self.validate_target(target)
        if not result.valid:
            raise OutOfScopeError(target, result.reason or "Unknown reason")

    # ------------------------------------------------------------------
    # Target parsing
    # ------------------------------------------------------------------

    def _parse_target(self, target: str) -> Optional[Dict]:
        """Extract host, port, and path from a URL, IP, or domain string.

        Returns
        -------
        dict or None
            Dictionary with keys ``host``, and optionally ``port`` and
            ``path``.  Returns ``None`` when the target cannot be parsed.
        """
        try:
            # Try parsing as URL first
            if "://" in target:
                parsed = urlparse(target)
                host = (parsed.hostname or "").lower()
                if not host:
                    return None
                port: Optional[int] = parsed.port
                if port is None:
                    port = _DEFAULT_PORTS.get(parsed.scheme)
                path = parsed.path
                if parsed.query:
                    path = f"{path}?{parsed.query}"
                return {"host": host, "port": port, "path": path}

            # Check for IPv4 (with optional port)
            m = _IPV4_PORT_RE.match(target)
            if m:
                result: Dict = {"host": m.group(1)}
                if m.group(2):
                    result["port"] = int(m.group(2))
                return result

            # Check for bracketed IPv6 (with optional port)
            m = _IPV6_BRACKET_RE.match(target)
            if m:
                result = {"host": m.group(1)}
                if m.group(2):
                    result["port"] = int(m.group(2))
                return result

            # Treat as domain (with optional port)
            m = _DOMAIN_PORT_RE.match(target)
            if m:
                result = {"host": m.group(1).lower()}
                if m.group(5):
                    result["port"] = int(m.group(5))
                return result

            # Try as plain IP without strict regex
            if self.is_valid_ip(target):
                return {"host": target}

            return None
        except Exception:
            return None

    # ------------------------------------------------------------------
    # Denylist / allowlist checks
    # ------------------------------------------------------------------

    def _check_denylist(
        self,
        host: str,
        port: Optional[int],
        path: Optional[str],
    ) -> Optional[Dict]:
        """Return a dict with ``reason`` and ``matched_rule`` if the
        target is denied, otherwise ``None``."""
        denylist = self.scope.denylist
        if denylist is None:
            return None

        # Check denied domains
        if denylist.domains:
            for pattern in denylist.domains:
                if self.matches_domain_pattern(host, pattern.lower()):
                    return {
                        "reason": "Domain is in denylist",
                        "matched_rule": f"denylist.domains: {pattern}",
                    }

        # Check denied IP ranges
        if denylist.ip_ranges and self.is_valid_ip(host):
            for range_str in denylist.ip_ranges:
                if self.ip_in_range(host, range_str):
                    return {
                        "reason": "IP is in denylist",
                        "matched_rule": f"denylist.ip_ranges: {range_str}",
                    }

        # Check denied ports
        if denylist.ports and port is not None:
            if port in denylist.ports:
                return {
                    "reason": "Port is in denylist",
                    "matched_rule": f"denylist.ports: {port}",
                }

        # Check denied keywords in path
        if denylist.keywords and path:
            lower_path = path.lower()
            for keyword in denylist.keywords:
                if keyword.lower() in lower_path:
                    return {
                        "reason": "Path contains denied keyword",
                        "matched_rule": f"denylist.keywords: {keyword}",
                    }

        return None

    def _check_allowlist(self, host: str, port: Optional[int]) -> Dict:
        """Return a dict with ``allowed`` (bool), ``reason``, and
        optionally ``matched_rule``."""
        allowlist = self.scope.allowlist

        # ---------- IP addresses ----------
        if self.is_valid_ip(host):
            if allowlist.ip_ranges:
                for range_str in allowlist.ip_ranges:
                    if self.ip_in_range(host, range_str):
                        # Also check port if specified
                        if (
                            port is not None
                            and allowlist.ports
                            and port not in allowlist.ports
                        ):
                            return {
                                "allowed": False,
                                "reason": f"Port {port} is not in allowlist",
                            }
                        return {
                            "allowed": True,
                            "reason": "IP in allowed range",
                            "matched_rule": f"allowlist.ip_ranges: {range_str}",
                        }
            return {
                "allowed": False,
                "reason": "IP not in any allowed range",
            }

        # ---------- Domain names ----------
        if allowlist.domains:
            for pattern in allowlist.domains:
                if self.matches_domain_pattern(host, pattern.lower()):
                    # Also check port if specified
                    if (
                        port is not None
                        and allowlist.ports
                        and port not in allowlist.ports
                    ):
                        return {
                            "allowed": False,
                            "reason": f"Port {port} is not in allowlist",
                        }
                    return {
                        "allowed": True,
                        "reason": "Domain matches allowed pattern",
                        "matched_rule": f"allowlist.domains: {pattern}",
                    }

        return {
            "allowed": False,
            "reason": "Domain not in allowlist",
        }

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------

    def matches_domain_pattern(self, domain: str, pattern: str) -> bool:
        """Check if *domain* matches *pattern* (supports ``*.`` wildcards).

        Parameters
        ----------
        domain : str
            Fully qualified domain name to check.
        pattern : str
            Domain pattern, e.g. ``*.example.com`` or ``api.example.com``.
        """
        normalized_domain = domain.lower()
        normalized_pattern = pattern.lower()

        # Exact match
        if normalized_domain == normalized_pattern:
            return True

        # Wildcard match (*.example.com)
        if normalized_pattern.startswith("*."):
            suffix = normalized_pattern[2:]  # Remove "*."

            # Must be a subdomain, not just the base domain
            if normalized_domain == suffix:
                return False

            return normalized_domain.endswith("." + suffix)

        return False

    @staticmethod
    def is_valid_ip(host: str) -> bool:
        """Return ``True`` if *host* is a valid IPv4 or IPv6 address."""
        try:
            ipaddress.ip_address(host)
            return True
        except ValueError:
            return False

    @staticmethod
    def ip_in_range(ip: str, range_str: str) -> bool:
        """Check if *ip* falls within the CIDR *range_str*.

        Handles both single IP comparisons and CIDR notation
        (e.g. ``192.168.1.0/24``).
        """
        try:
            addr = ipaddress.ip_address(ip)

            # Handle single IP (no CIDR notation)
            if "/" not in range_str:
                return ip == range_str

            network = ipaddress.ip_network(range_str, strict=False)

            # Ensure both are the same IP version
            if addr.version != network.version:
                # Try to handle IPv4-mapped IPv6
                if addr.version == 6 and network.version == 4:
                    mapped = getattr(addr, "ipv4_mapped", None)
                    if mapped is not None:
                        return mapped in network
                return False

            return addr in network
        except (ValueError, TypeError):
            return False
