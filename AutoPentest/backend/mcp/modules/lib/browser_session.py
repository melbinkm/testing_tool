"""
Browser Session Management - Playwright-based browser automation with
correlation tracking, scope validation, and proxy support.

Ported from browser-mcp TypeScript:
  - stagehand-wrapper.ts (BrowserSessionWrapper)
  - proxy-config.ts (proxy configuration)
  - correlation.ts (CorrelationManager)

Uses ``playwright.async_api`` for async browser automation.
"""

from __future__ import annotations

import asyncio
import base64
import logging
import os
import uuid
from typing import Any, Dict, List, Optional

logger = logging.getLogger("autopentest-mcp")


# ---------------------------------------------------------------------------
# CorrelationManager
# ---------------------------------------------------------------------------

class CorrelationManager:
    """Generate and manage correlation IDs for browser requests.

    Each browser action gets a unique action ID scoped under an engagement.
    """

    def __init__(self, engagement_id: str) -> None:
        self.engagement_id = engagement_id
        self._action_counter = 0

    def generate_ids(self, session_id: Optional[str] = None) -> Dict[str, str]:
        """Generate a new set of correlation IDs.

        Returns
        -------
        dict
            Keys: engagement_id, action_id, request_id, session_id
        """
        self._action_counter += 1
        return {
            "engagement_id": self.engagement_id,
            "action_id": f"act-{self._action_counter}-{uuid.uuid4().hex[:8]}",
            "request_id": str(uuid.uuid4()),
            "session_id": session_id or "",
        }

    def get_correlation_headers(self, ids: Dict[str, str]) -> Dict[str, str]:
        """Convert correlation IDs to HTTP headers for request interception.

        Returns
        -------
        dict
            HTTP headers: X-Engagement-ID, X-Action-ID, X-Request-ID
        """
        headers: Dict[str, str] = {
            "X-Engagement-ID": ids.get("engagement_id", self.engagement_id),
            "X-Action-ID": ids.get("action_id", ""),
            "X-Request-ID": ids.get("request_id", str(uuid.uuid4())),
        }
        if ids.get("session_id"):
            headers["X-Session-ID"] = ids["session_id"]
        return headers


# ---------------------------------------------------------------------------
# BrowserSessionWrapper
# ---------------------------------------------------------------------------

class BrowserSessionWrapper:
    """Wraps a Playwright browser context with scope validation,
    correlation header injection, and proxy support.
    """

    def __init__(
        self,
        session_id: str,
        config: Dict[str, Any],
        correlation_manager: CorrelationManager,
        scope_validator: Any = None,
    ) -> None:
        self.session_id = session_id
        self._config = config
        self._correlation = correlation_manager
        self._scope_validator = scope_validator

        self._browser: Any = None
        self._context: Any = None
        self._page: Any = None
        self._playwright: Any = None
        self._active = False

    # ------------------------------------------------------------------
    # Lifecycle
    # ------------------------------------------------------------------

    async def initialize(self) -> None:
        """Launch Playwright Chromium, set up proxy, and intercept
        requests to inject correlation headers."""
        try:
            from playwright.async_api import async_playwright
        except ImportError:
            raise RuntimeError(
                "playwright is required for browser tools. "
                "Install with: pip install playwright && python -m playwright install chromium"
            )

        self._playwright = await async_playwright().start()

        # Build launch options
        launch_opts: Dict[str, Any] = {
            "headless": self._config.get("headless", True),
        }

        # Proxy configuration
        proxy_url = self._config.get("proxy_url") or os.environ.get("BROWSER_PROXY_URL")
        if proxy_url:
            launch_opts["proxy"] = {"server": proxy_url}

        chromium_args = self._config.get("chromium_args", [])
        if chromium_args:
            launch_opts["args"] = chromium_args

        self._browser = await self._playwright.chromium.launch(**launch_opts)

        # Create browser context
        context_opts: Dict[str, Any] = {
            "ignore_https_errors": True,
        }
        viewport = self._config.get("viewport")
        if viewport:
            context_opts["viewport"] = viewport

        user_agent = self._config.get("user_agent")
        if user_agent:
            context_opts["user_agent"] = user_agent

        self._context = await self._browser.new_context(**context_opts)

        # Intercept requests to add correlation headers
        await self._context.route("**/*", self._inject_correlation_headers)

        self._page = await self._context.new_page()
        self._active = True
        logger.info("Browser session %s initialized", self.session_id)

    async def _inject_correlation_headers(self, route: Any) -> None:
        """Route handler that injects correlation headers into every request."""
        ids = self._correlation.generate_ids(self.session_id)
        headers = {**route.request.headers, **self._correlation.get_correlation_headers(ids)}
        await route.continue_(headers=headers)

    async def close(self) -> None:
        """Close browser and clean up resources."""
        self._active = False
        try:
            if self._page and not self._page.is_closed():
                await self._page.close()
        except Exception:
            pass
        try:
            if self._context:
                await self._context.close()
        except Exception:
            pass
        try:
            if self._browser:
                await self._browser.close()
        except Exception:
            pass
        try:
            if self._playwright:
                await self._playwright.stop()
        except Exception:
            pass
        logger.info("Browser session %s closed", self.session_id)

    def is_active(self) -> bool:
        """Return True if the browser session is active."""
        return self._active and self._page is not None and not self._page.is_closed()

    def get_page(self) -> Any:
        """Return the Playwright Page object."""
        return self._page

    # ------------------------------------------------------------------
    # Navigation
    # ------------------------------------------------------------------

    async def navigate(
        self,
        url: str,
        wait_until: str = "load",
        timeout: Optional[int] = None,
    ) -> Dict[str, Any]:
        """Navigate to a URL with scope validation.

        Parameters
        ----------
        url : str
            Target URL.
        wait_until : str
            Playwright wait condition: 'load', 'domcontentloaded', 'networkidle', 'commit'.
        timeout : int, optional
            Navigation timeout in milliseconds.

        Returns
        -------
        dict
            Navigation result with url, title, status.
        """
        self._ensure_active()

        # Scope validation
        if self._scope_validator:
            result = self._scope_validator.validate_target(url)
            if not result.valid:
                raise ValueError(
                    f"URL out of scope: {url} - {result.reason}"
                )

        nav_opts: Dict[str, Any] = {"wait_until": wait_until}
        if timeout:
            nav_opts["timeout"] = timeout

        response = await self._page.goto(url, **nav_opts)

        return {
            "url": self._page.url,
            "title": await self._page.title(),
            "status": response.status if response else None,
            "session_id": self.session_id,
        }

    # ------------------------------------------------------------------
    # Screenshot
    # ------------------------------------------------------------------

    async def screenshot(
        self,
        path: Optional[str] = None,
        full_page: bool = False,
        format: str = "png",
    ) -> Dict[str, Any]:
        """Capture a screenshot of the current page.

        Returns
        -------
        dict
            Screenshot result with base64 data or file path.
        """
        self._ensure_active()

        opts: Dict[str, Any] = {
            "full_page": full_page,
            "type": format,
        }
        if path:
            opts["path"] = path

        screenshot_bytes = await self._page.screenshot(**opts)

        result: Dict[str, Any] = {
            "url": self._page.url,
            "full_page": full_page,
            "format": format,
            "session_id": self.session_id,
        }

        if path:
            result["path"] = path
            result["size_bytes"] = len(screenshot_bytes)
        else:
            result["data_base64"] = base64.b64encode(screenshot_bytes).decode("ascii")
            result["size_bytes"] = len(screenshot_bytes)

        return result

    # ------------------------------------------------------------------
    # State
    # ------------------------------------------------------------------

    async def get_state(self) -> Dict[str, Any]:
        """Return current page state: cookies, URL, title, local storage.

        Returns
        -------
        dict
            Page state information.
        """
        self._ensure_active()

        cookies = await self._context.cookies()
        title = await self._page.title()
        url = self._page.url

        # Try to get localStorage
        local_storage: Dict[str, str] = {}
        try:
            local_storage = await self._page.evaluate("""() => {
                const items = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key) items[key] = localStorage.getItem(key);
                }
                return items;
            }""")
        except Exception:
            pass

        return {
            "url": url,
            "title": title,
            "cookies": cookies,
            "local_storage": local_storage,
            "session_id": self.session_id,
        }

    # ------------------------------------------------------------------
    # Interaction
    # ------------------------------------------------------------------

    async def click(self, selector: str, timeout: Optional[int] = None) -> None:
        """Click an element identified by CSS selector."""
        self._ensure_active()
        opts: Dict[str, Any] = {}
        if timeout:
            opts["timeout"] = timeout
        await self._page.click(selector, **opts)

    async def fill(self, selector: str, value: str, timeout: Optional[int] = None) -> None:
        """Fill an input field with a value."""
        self._ensure_active()
        opts: Dict[str, Any] = {}
        if timeout:
            opts["timeout"] = timeout
        await self._page.fill(selector, value, **opts)

    async def evaluate(self, expression: str) -> Any:
        """Execute JavaScript in the page context.

        Parameters
        ----------
        expression : str
            JavaScript expression to evaluate.

        Returns
        -------
        Any
            The evaluation result.
        """
        self._ensure_active()
        return await self._page.evaluate(expression)

    async def get_elements(self, selector: str) -> List[Dict[str, Any]]:
        """Get information about elements matching a CSS selector.

        Returns
        -------
        list
            List of dicts with tag, text, attributes, visible, bounding_box.
        """
        self._ensure_active()

        elements = await self._page.evaluate("""(selector) => {
            const els = document.querySelectorAll(selector);
            return Array.from(els).map(el => {
                const rect = el.getBoundingClientRect();
                const attrs = {};
                for (const attr of el.attributes) {
                    attrs[attr.name] = attr.value;
                }
                return {
                    tag: el.tagName.toLowerCase(),
                    text: (el.textContent || '').trim().substring(0, 200),
                    attributes: attrs,
                    visible: rect.width > 0 && rect.height > 0,
                    bounding_box: {
                        x: rect.x,
                        y: rect.y,
                        width: rect.width,
                        height: rect.height
                    }
                };
            });
        }""", selector)

        return elements

    async def press_key(self, key: str, modifiers: Optional[List[str]] = None) -> None:
        """Press a keyboard key with optional modifiers.

        Parameters
        ----------
        key : str
            Key to press (e.g. 'Enter', 'Tab', 'a').
        modifiers : list of str, optional
            Modifier keys (e.g. ['Control', 'Shift']).
        """
        self._ensure_active()

        if modifiers:
            combo = "+".join(modifiers + [key])
            await self._page.keyboard.press(combo)
        else:
            await self._page.keyboard.press(key)

    async def wait(self, condition: str, timeout: Optional[int] = None) -> None:
        """Wait for a condition.

        Parameters
        ----------
        condition : str
            CSS selector to wait for, or a numeric string for ms delay.
        timeout : int, optional
            Maximum wait time in milliseconds.
        """
        self._ensure_active()

        # If the condition is a number, wait that many ms
        try:
            delay_ms = int(condition)
            await asyncio.sleep(delay_ms / 1000.0)
            return
        except ValueError:
            pass

        # Otherwise treat as CSS selector
        opts: Dict[str, Any] = {}
        if timeout:
            opts["timeout"] = timeout
        await self._page.wait_for_selector(condition, **opts)

    async def type_text(self, selector: str, text: str, delay: int = 50) -> None:
        """Type text character by character into an element.

        Parameters
        ----------
        selector : str
            CSS selector for the target element.
        text : str
            Text to type.
        delay : int
            Delay in milliseconds between keystrokes.
        """
        self._ensure_active()
        await self._page.type(selector, text, delay=delay)

    async def dismiss_popups(self) -> Dict[str, Any]:
        """Dismiss common popups: alert dialogs, cookie banners, overlays.

        Returns
        -------
        dict
            Summary of dismissed popups.
        """
        self._ensure_active()

        dismissed: List[str] = []

        # Set up a dialog handler for alert/confirm/prompt
        async def handle_dialog(dialog: Any) -> None:
            dismissed.append(f"dialog:{dialog.type}")
            await dialog.dismiss()

        self._page.on("dialog", handle_dialog)

        # Try to dismiss common cookie/consent banners
        cookie_selectors = [
            "[id*='cookie'] button",
            "[class*='cookie'] button",
            "[id*='consent'] button",
            "[class*='consent'] button",
            "[id*='gdpr'] button",
            "[class*='gdpr'] button",
            "button[class*='accept']",
            "button[class*='close']",
            "[aria-label*='close']",
            "[aria-label*='dismiss']",
        ]

        for sel in cookie_selectors:
            try:
                element = await self._page.query_selector(sel)
                if element:
                    visible = await element.is_visible()
                    if visible:
                        await element.click()
                        dismissed.append(f"banner:{sel}")
                        # Small delay to allow UI to update
                        await asyncio.sleep(0.3)
            except Exception:
                continue

        # Remove the dialog handler after scanning
        self._page.remove_listener("dialog", handle_dialog)

        return {
            "dismissed": dismissed,
            "count": len(dismissed),
            "session_id": self.session_id,
        }

    # ------------------------------------------------------------------
    # Internals
    # ------------------------------------------------------------------

    def _ensure_active(self) -> None:
        """Raise if the session is not active."""
        if not self.is_active():
            raise RuntimeError(
                f"Browser session {self.session_id} is not active. "
                "Create or re-initialize the session first."
            )


# ---------------------------------------------------------------------------
# SessionManager
# ---------------------------------------------------------------------------

class SessionManager:
    """Manage multiple browser sessions with limits."""

    def __init__(
        self,
        correlation_manager: CorrelationManager,
        scope_validator: Any = None,
        max_sessions: int = 5,
    ) -> None:
        self._correlation = correlation_manager
        self._scope_validator = scope_validator
        self._max_sessions = max_sessions
        self._sessions: Dict[str, BrowserSessionWrapper] = {}
        self._active_session_id: Optional[str] = None

    async def create_session(
        self,
        config: Optional[Dict[str, Any]] = None,
    ) -> BrowserSessionWrapper:
        """Create and initialize a new browser session.

        Parameters
        ----------
        config : dict, optional
            Browser configuration (headless, proxy_url, viewport, etc.).

        Returns
        -------
        BrowserSessionWrapper
            The initialized session.

        Raises
        ------
        RuntimeError
            If the maximum number of sessions has been reached.
        """
        if len(self._sessions) >= self._max_sessions:
            raise RuntimeError(
                f"Maximum sessions ({self._max_sessions}) reached. "
                "Close an existing session first."
            )

        session_id = f"session-{uuid.uuid4().hex[:8]}"
        session_config = config or {}

        session = BrowserSessionWrapper(
            session_id=session_id,
            config=session_config,
            correlation_manager=self._correlation,
            scope_validator=self._scope_validator,
        )

        await session.initialize()
        self._sessions[session_id] = session

        # Set as active if it's the first or only session
        if self._active_session_id is None:
            self._active_session_id = session_id

        return session

    def get_session(self, session_id: str) -> Optional[BrowserSessionWrapper]:
        """Get a session by ID, or None if not found."""
        return self._sessions.get(session_id)

    def get_active_session(self) -> Optional[BrowserSessionWrapper]:
        """Get the currently active session, or None."""
        if self._active_session_id is None:
            return None
        session = self._sessions.get(self._active_session_id)
        if session and session.is_active():
            return session
        return None

    def set_active_session(self, session_id: str) -> None:
        """Set a session as the active session.

        Raises
        ------
        ValueError
            If the session ID is not found.
        """
        if session_id not in self._sessions:
            raise ValueError(f"Session not found: {session_id}")
        self._active_session_id = session_id

    async def close_session(self, session_id: str) -> None:
        """Close and remove a session by ID."""
        session = self._sessions.pop(session_id, None)
        if session:
            await session.close()
            if self._active_session_id == session_id:
                # Set active to the first remaining session, if any
                remaining = list(self._sessions.keys())
                self._active_session_id = remaining[0] if remaining else None

    async def close_all_sessions(self) -> None:
        """Close all browser sessions."""
        session_ids = list(self._sessions.keys())
        for sid in session_ids:
            session = self._sessions.pop(sid, None)
            if session:
                await session.close()
        self._active_session_id = None

    def list_sessions(self) -> List[Dict[str, Any]]:
        """Return a summary of all sessions."""
        result = []
        for sid, session in self._sessions.items():
            result.append({
                "session_id": sid,
                "active": sid == self._active_session_id,
                "is_active": session.is_active(),
            })
        return result
