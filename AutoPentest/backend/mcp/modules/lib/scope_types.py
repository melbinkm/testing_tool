"""
Scope Types - Pydantic models and custom exceptions for Scope Guard.
Ported from TypeScript types.ts to Python.
These types match the structure defined in scope/engagement.yaml.
"""

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Literal

from pydantic import BaseModel, Field


# ---------------------------------------------------------------------------
# Pydantic models (mirror the TypeScript interfaces)
# ---------------------------------------------------------------------------

class EngagementInfo(BaseModel):
    id: str
    name: str
    client: str = ""
    start_date: str = ""
    end_date: str = ""
    timezone: str = "UTC"


class ScopeRule(BaseModel):
    """A scope rule that can match paths, methods, headers, or parameters."""
    pattern: str
    rule_type: str = "path"  # path / subdomain / domain / method / header / parameter
    description: Optional[str] = None


class ScopeAllowlist(BaseModel):
    domains: Optional[List[str]] = None
    ip_ranges: Optional[List[str]] = None
    ports: Optional[List[int]] = None
    services: Optional[List[str]] = None
    urls: Optional[List[str]] = None  # Allow direct URL specification


class ScopeDenylist(BaseModel):
    domains: Optional[List[str]] = None
    ip_ranges: Optional[List[str]] = None
    ports: Optional[List[int]] = None
    keywords: Optional[List[str]] = None


class RateLimits(BaseModel):
    requests_per_second: int = 10
    max_concurrent: int = 5
    burst_limit: int = 20


class Budget(BaseModel):
    max_total_requests: int = 999999999
    max_requests_per_target: int = 999999999
    max_scan_duration_hours: float = 999.0


class Timeouts(BaseModel):
    connect_timeout_ms: int = 10000
    read_timeout_ms: int = 30000
    total_timeout_ms: int = 60000


class ScopeConstraints(BaseModel):
    rate_limits: RateLimits = RateLimits()
    budget: Budget = Budget()
    timeouts: Timeouts = Timeouts()


class Credential(BaseModel):
    id: str
    type: Literal["basic", "bearer", "api_key", "oauth2", "custom"]
    username_env: Optional[str] = None
    password_env: Optional[str] = None
    token_env: Optional[str] = None
    api_key_env: Optional[str] = None
    scope: List[str]


class Actions(BaseModel):
    forbidden: List[str]
    requires_approval: List[str]


class Escalation(BaseModel):
    on_timeout: Literal["DENY", "ALLOW"] = "DENY"
    on_error: Literal["DENY", "ALLOW"] = "DENY"
    notify: bool = False


class ApprovalPolicy(BaseModel):
    mode: Literal["INTERACTIVE", "AUTO_APPROVE", "DENY_ALL"] = "AUTO_APPROVE"
    timeout_seconds: int = 30
    default_action: Literal["DENY", "ALLOW"] = "ALLOW"
    escalation: Escalation = Escalation()


class EvidencePolicy(BaseModel):
    enabled: bool
    storage_path: str
    retention_days: int
    auto_capture: List[str]
    redact_patterns: List[str]
    formats: List[str]


class LoggingOutput(BaseModel):
    console: bool
    file: str


class LoggingConfig(BaseModel):
    level: Literal["debug", "info", "warn", "error"]
    audit_trail: bool
    correlation_ids: bool
    output: LoggingOutput


class EngagementScope(BaseModel):
    schema_version: str = "1.0"
    engagement: EngagementInfo
    allowlist: ScopeAllowlist = ScopeAllowlist()
    denylist: Optional[ScopeDenylist] = None
    credentials: Optional[List[Credential]] = None
    constraints: ScopeConstraints = ScopeConstraints()
    actions: Optional[Actions] = None
    approval_policy: ApprovalPolicy = ApprovalPolicy()
    evidence_policy: Optional[EvidencePolicy] = None
    logging: Optional[LoggingConfig] = None
    avoid_rules: Optional[List[ScopeRule]] = None
    focus_rules: Optional[List[ScopeRule]] = None


# ---------------------------------------------------------------------------
# Dataclasses for lightweight result / status objects
# ---------------------------------------------------------------------------

@dataclass
class ValidationResult:
    """Result of target validation."""
    valid: bool
    target: str
    reason: Optional[str] = None
    matched_rule: Optional[str] = None


@dataclass
class RateLimitStatus:
    """Nested rate-limit portion of BudgetStatus."""
    current_rate: int
    max_rate: int
    within_limit: bool


@dataclass
class BudgetStatus:
    """Budget status information."""
    total_requests: int
    max_total_requests: int
    remaining_requests: int
    requests_by_target: Dict[str, int] = field(default_factory=dict)
    rate_limit_status: RateLimitStatus = field(
        default_factory=lambda: RateLimitStatus(
            current_rate=0, max_rate=0, within_limit=True
        )
    )
    budget_exhausted: bool = False


# ---------------------------------------------------------------------------
# Custom exceptions
# ---------------------------------------------------------------------------

class ScopeValidationError(Exception):
    """Error thrown when scope validation fails."""

    def __init__(self, message: str, errors: Optional[List[str]] = None):
        super().__init__(message)
        self.errors: List[str] = errors or []


class OutOfScopeError(Exception):
    """Error thrown when a target is out of scope."""

    def __init__(self, target: str, reason: str):
        super().__init__(f"Target '{target}' is out of scope: {reason}")
        self.target = target
        self.reason = reason


class BudgetExceededError(Exception):
    """Error thrown when a budget limit is exceeded."""

    def __init__(
        self,
        budget_type: Literal["total", "per_target", "rate"],
        current: int,
        limit: int,
    ):
        super().__init__(f"Budget exceeded: {budget_type} ({current}/{limit})")
        self.budget_type = budget_type
        self.current = current
        self.limit = limit
