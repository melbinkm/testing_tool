"""
Payload Registry

Unified registry that consolidates existing and new payload sources
for all 42+ vulnerability classes in the testing engine.
"""

from typing import List, Dict, Any, Optional
import logging

# Import existing payload libraries
from .sql_payloads import get_sql_payloads, get_all_payloads_flat as get_all_sql_payloads
from .xss_payloads import get_xss_payloads
from .ssrf_payloads import get_ssrf_payloads
from .path_traversal_payloads import get_path_traversal_payloads
from .ssti_payloads import get_ssti_payloads

# Import new payload libraries
from .cmdi_payloads import get_cmdi_payloads
from .nosql_payloads import get_nosql_payloads
from .xxe_payloads import get_xxe_payloads
from .header_injection_payloads import get_header_injection_payloads
from .jwt_payloads import get_jwt_payloads, build_jwt_token
from .cors_payloads import get_cors_payloads
from .redirect_payloads import get_redirect_payloads

logger = logging.getLogger(__name__)


class PayloadRegistry:
    """
    Unified payload registry for all vulnerability classes.

    Provides a consistent interface to retrieve payloads regardless of
    the underlying payload library structure.
    """

    # Mapping of vuln spec IDs to payload getter functions
    PAYLOAD_GETTERS = {
        # SQL Injection (split into techniques)
        'sqli_error': lambda ctx: [p for p in get_all_sql_payloads() if p.technique == 'error_based'],
        'sqli_blind_boolean': lambda ctx: [p for p in get_all_sql_payloads() if p.technique == 'blind_boolean'],
        'sqli_blind_time': lambda ctx: [p for p in get_all_sql_payloads() if p.technique == 'blind_time'],
        'sqli_union': lambda ctx: [p for p in get_all_sql_payloads() if p.technique == 'union'],

        # XSS (split into types)
        'xss_reflected': lambda ctx: [p for p in get_xss_payloads() if p.technique == 'reflected'],
        'xss_stored': lambda ctx: [p for p in get_xss_payloads() if p.technique == 'stored'],
        'xss_dom': lambda ctx: [p for p in get_xss_payloads() if p.technique == 'dom_based'],

        # Other injection types
        'ssti': lambda ctx: get_ssti_payloads(),
        'ssrf': lambda ctx: get_ssrf_payloads(),
        'path_traversal': lambda ctx: get_path_traversal_payloads(),
        'command_injection': lambda ctx: get_cmdi_payloads(),
        'ldap_injection': lambda ctx: _get_ldap_injection_payloads(),
        'xml_injection': lambda ctx: get_xxe_payloads(),
        'header_injection': lambda ctx: get_header_injection_payloads(),
        'nosql_injection': lambda ctx: get_nosql_payloads(),

        # Auth/Session
        'idor': lambda ctx: _get_idor_payloads(ctx),
        'auth_bypass': lambda ctx: _get_auth_bypass_payloads(),
        'broken_auth': lambda ctx: _get_broken_auth_payloads(),
        'session_fixation': lambda ctx: _get_session_fixation_payloads(),
        'session_expiry': lambda ctx: _get_session_expiry_payloads(),
        'jwt_manipulation': lambda ctx: get_jwt_payloads(),
        'privilege_escalation': lambda ctx: _get_privilege_escalation_payloads(),
        'username_enumeration': lambda ctx: _get_username_enum_payloads(ctx),

        # Configuration
        'cors_misconfig': lambda ctx: get_cors_payloads(),
        'csrf': lambda ctx: _get_csrf_payloads(),
        'clickjacking': lambda ctx: _get_clickjacking_payloads(),
        'security_headers': lambda ctx: _get_security_headers_payloads(),
        'cookie_security': lambda ctx: _get_cookie_security_payloads(),
        'http_method_tampering': lambda ctx: _get_method_tampering_payloads(),
        'tls_config': lambda ctx: _get_tls_config_payloads(),

        # Client-side
        'open_redirect': lambda ctx: get_redirect_payloads(),

        # Info leaks
        'info_leak_errors': lambda ctx: [],  # Detection via existing errors
        'info_leak_comments': lambda ctx: [],  # Regex-based detection
        'info_leak_source_maps': lambda ctx: [],  # Path-based detection
        'info_leak_headers': lambda ctx: [],  # Header analysis
        'directory_listing': lambda ctx: [],  # Path-based detection

        # API
        'mass_assignment': lambda ctx: _generate_mass_assignment_payloads(ctx),
        'param_pollution': lambda ctx: _generate_param_pollution_payloads(ctx),
        'graphql_introspection': lambda ctx: _get_graphql_payloads(),
        'rate_limit_bypass': lambda ctx: _get_rate_limit_bypass_payloads(),

        # Business logic
        'race_condition': lambda ctx: _get_race_condition_payloads(),
        'price_manipulation': lambda ctx: _generate_price_payloads(ctx),

        # Round 11 Fix 4A/4B: New vuln classes
        'weak_password_policy': lambda ctx: _get_weak_password_payloads(),
        'input_validation': lambda ctx: _get_input_validation_payloads(ctx),

        # Insecure deserialization
        'insecure_deserialization': lambda ctx: _get_deserialization_payloads(ctx),

        # Legacy aliases (backward compatibility)
        'sqli': lambda ctx: [p for p in get_all_sql_payloads() if p.technique == 'error_based'],
        'xss': lambda ctx: [p for p in get_xss_payloads() if p.technique == 'reflected'],
    }

    def __init__(self):
        """Initialize the payload registry."""
        pass

    def get_payloads(self, vuln_spec_id: str, context: Optional[Dict[str, Any]] = None) -> List[Any]:
        """
        Get payloads for a specific vulnerability specification.

        Args:
            vuln_spec_id: Vulnerability specification ID (e.g., 'sqli_error', 'xss_reflected')
            context: Optional context dict with keys like:
                    - endpoint: Endpoint metadata
                    - parameter: Parameter being tested
                    - detected_tech: Detected technologies

        Returns:
            List of payload objects. The type varies by vuln class:
            - SQLPayload, XSSPayload, etc. for injection classes
            - String payloads for simpler tests
            - Empty list if no hardcoded payloads exist
        """
        if vuln_spec_id not in self.PAYLOAD_GETTERS:
            logger.warning(f"No payload getter for vuln spec: {vuln_spec_id}")
            return []

        try:
            getter = self.PAYLOAD_GETTERS[vuln_spec_id]
            payloads = getter(context or {})
            return payloads
        except Exception as e:
            logger.error(f"Error getting payloads for {vuln_spec_id}: {e}", exc_info=True)
            return []

    def get_payload_count(self, vuln_spec_id: str) -> int:
        """
        Get count of available payloads for a vuln spec.

        Args:
            vuln_spec_id: Vulnerability specification ID

        Returns:
            Number of payloads available
        """
        payloads = self.get_payloads(vuln_spec_id)
        return len(payloads)

    def get_all_payload_counts(self) -> Dict[str, int]:
        """
        Get payload counts for all vulnerability specifications.

        Returns:
            Dict mapping vuln_spec_id -> payload count
        """
        counts = {}
        for spec_id in self.PAYLOAD_GETTERS.keys():
            counts[spec_id] = self.get_payload_count(spec_id)
        return counts

    def has_payloads(self, vuln_spec_id: str) -> bool:
        """Check if a vuln spec has any payloads."""
        return self.get_payload_count(vuln_spec_id) > 0

    def to_string_payloads(self, payloads: List[Any]) -> List[str]:
        """
        Convert payload objects to string representations.

        Handles different payload types (SQLPayload, XSSPayload, JWT, etc.)
        and extracts the actual payload string.

        Args:
            payloads: List of payload objects

        Returns:
            List of payload strings
        """
        string_payloads = []
        for p in payloads:
            if isinstance(p, str):
                string_payloads.append(p)
            elif hasattr(p, 'payload'):
                string_payloads.append(p.payload)
            elif hasattr(p, 'origin_header'):
                # CORS payload - use origin header value
                string_payloads.append(p.origin_header)
            elif hasattr(p, 'header') and hasattr(p, 'payload_claims'):
                # JWT payload - build token
                from .jwt_payloads import build_jwt_token
                string_payloads.append(build_jwt_token(p))
            else:
                # Unknown type, convert to string
                string_payloads.append(str(p))
        return string_payloads


# ==== DYNAMIC PAYLOAD GENERATORS ====

def _get_ldap_injection_payloads() -> List[str]:
    """Get LDAP injection payloads."""
    return [
        '*',
        '*)*',
        '*)(uid=*',
        '*)(objectClass=*',
        '*)(&',
        '*)(|(uid=*',
        'admin*',
        '*)(cn=*',
        '*)(mail=*',
        '*)(!(&(uid=*',
        '*))%00',
    ]


def _get_username_enum_payloads(context: Dict[str, Any]) -> List[str]:
    """Get username enumeration test payloads."""
    return [
        'admin',
        'administrator',
        'root',
        'test',
        'user',
        'guest',
        'admin@example.com',
        'user@example.com',
        'nonexistent_user_12345',
        '',
        ' ',
        'a' * 100,
        '../admin',
    ]


def _get_method_tampering_payloads() -> List[str]:
    """Get HTTP method tampering payloads."""
    return [
        'GET',
        'POST',
        'PUT',
        'DELETE',
        'PATCH',
        'HEAD',
        'OPTIONS',
        'TRACE',
        'CONNECT',
        'PROPFIND',
        'PROPPATCH',
        'MKCOL',
        'COPY',
        'MOVE',
    ]


def _get_rate_limit_bypass_payloads() -> List[str]:
    """Get rate limit bypass header payloads (header values for X-Forwarded-For etc)."""
    return [
        '127.0.0.1',
        '10.0.0.1',
        '192.168.1.1',
        '8.8.8.8',
        '1.2.3.4',
        '::1',
        'localhost',
        '0.0.0.0',
        '255.255.255.255',
        '127.0.0.1, 8.8.8.8',
    ]


def _generate_mass_assignment_payloads(context: Dict[str, Any]) -> List[str]:
    """Generate mass assignment payloads based on endpoint context."""
    base_payloads = [
        '{"role": "admin"}',
        '{"isAdmin": true}',
        '{"admin": true}',
        '{"is_admin": true}',
        '{"privilege": "administrator"}',
        '{"permissions": ["admin", "write", "delete"]}',
        '{"account_type": "premium"}',
        '{"credits": 999999}',
    ]

    # Add context-specific payloads if endpoint info available
    endpoint = context.get('endpoint', {})
    if 'user' in endpoint.get('path', '').lower():
        base_payloads.extend([
            '{"verified": true}',
            '{"email_verified": true}',
            '{"active": true}',
        ])

    return base_payloads


def _generate_param_pollution_payloads(context: Dict[str, Any]) -> List[str]:
    """Generate HTTP parameter pollution payloads."""
    param = context.get('parameter', {})
    param_name = param.get('name', 'id')

    return [
        f"{param_name}=1&{param_name}=2",
        f"{param_name}[]=1&{param_name}[]=2",
        f"{param_name}=1%26{param_name}=2",  # Encoded &
    ]


def _get_graphql_payloads() -> List[str]:
    """Get GraphQL introspection payloads."""
    return [
        '{"query": "{ __schema { types { name } } }"}',
        '{"query": "{ __type(name: \\"User\\") { name fields { name } } }"}',
        '{"query": "query IntrospectionQuery { __schema { queryType { name } mutationType { name } subscriptionType { name } types { ...FullType } directives { name description locations args { ...InputValue } } } } fragment FullType on __Type { kind name description fields(includeDeprecated: true) { name description args { ...InputValue } type { ...TypeRef } isDeprecated deprecationReason } inputFields { ...InputValue } interfaces { ...TypeRef } enumValues(includeDeprecated: true) { name description isDeprecated deprecationReason } possibleTypes { ...TypeRef } } fragment InputValue on __InputValue { name description type { ...TypeRef } defaultValue } fragment TypeRef on __Type { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name } } } } } } } }"}',
    ]


def _generate_price_payloads(context: Dict[str, Any]) -> List[str]:
    """Generate price manipulation payloads."""
    param = context.get('parameter', {})
    param_name = param.get('name', 'price')

    # Detect current value type
    base_payloads = [
        '0',
        '-1',
        '0.01',
        '-100',
        '999999999',
        '1e10',
    ]

    # JSON format variations
    json_payloads = [
        f'{{"{param_name}": 0}}',
        f'{{"{param_name}": -1}}',
        f'{{"{param_name}": 0.01}}',
    ]

    return base_payloads + json_payloads


def _get_idor_payloads(context: Dict[str, Any]) -> List[str]:
    """Get IDOR (Insecure Direct Object Reference) payloads."""
    return [
        '../1', '../2', '../0', '../-1', '../999999',
        '1', '2', '100', '0', '-1',
        '00000000-0000-0000-0000-000000000001',
        '00000000-0000-0000-0000-000000000000',
        'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',
        '$TARGET/../admin',
        '$TARGET?id=1&id=2',
    ]


def _get_auth_bypass_payloads() -> List[str]:
    """Get authentication bypass payloads."""
    return [
        'admin:admin', 'admin:password', 'admin:123456',
        'root:root', 'test:test', 'guest:guest',
        'Authorization: ', 'Authorization: null',
        'Authorization: Bearer null',
        'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIn0.',  # JWT none alg
        'X-Original-URL: /admin', 'X-Rewrite-URL: /admin',
    ]


def _get_broken_auth_payloads() -> List[str]:
    """Get broken authentication test payloads."""
    return [
        'session=AAAAAAAAAAAAAAAA',  # fixated session
        'session=00000000',
        'token=expired_token_placeholder',
        'PHPSESSID=predictable123',
        'JSESSIONID=0000000000000000',
        'cookie: session=; path=/',
        'concurrent_login_marker_1',
        'concurrent_login_marker_2',
        'credential_stuff_admin',
        'credential_stuff_user',
    ]


def _get_session_fixation_payloads() -> List[str]:
    """Get session fixation test payloads."""
    return [
        'PHPSESSID=attacker_fixed_session',
        'JSESSIONID=attacker_fixed_session',
        'session_id=attacker_fixed_session',
        'sid=attacker_fixed_session',
        'ASP.NET_SessionId=attacker_fixed_session',
        'connect.sid=attacker_fixed_session',
        'Set-Cookie: session=malicious; path=/',
        'Set-Cookie: token=malicious; domain=$TARGET',
    ]


def _get_session_expiry_payloads() -> List[str]:
    """Get session expiry test payloads."""
    return [
        'token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjF9.expired',
        'session=expired_session_token_2020',
        'Bearer old_token_should_be_rejected',
        'remember_me=1; max-age=99999999',
        'session_timeout=999999',
        'token_replay_after_logout',
    ]


def _get_privilege_escalation_payloads() -> List[str]:
    """Get privilege escalation test payloads."""
    return [
        'role=admin', 'role=administrator', 'role=superuser',
        'isAdmin=true', 'is_admin=1', 'admin=1',
        'privilege=admin', 'access_level=9',
        '/admin/', '/admin/dashboard', '/admin/users',
        '/api/admin/', '/management/', '/internal/',
        'X-Admin: true', 'X-Role: admin',
        'user_type=admin',
    ]


def _get_csrf_payloads() -> List[str]:
    """Get CSRF test payloads (forms without tokens)."""
    return [
        '<form action="$TARGET" method="POST"><input type="submit"></form>',
        '<form action="$TARGET" method="POST"><input name="csrf_token" value=""><input type="submit"></form>',
        '<form action="$TARGET" method="POST"><input name="csrf_token" value="invalid_token"><input type="submit"></form>',
        'csrf_token=', 'csrf_token=null',
        'csrf_token=reused_old_token',
        '_token=', 'X-CSRF-Token: ',
        'Referer: https://evil.com',
        'Origin: https://evil.com',
    ]


def _get_clickjacking_payloads() -> List[str]:
    """Get clickjacking test payloads (iframe embedding checks)."""
    return [
        '<iframe src="$TARGET" width="500" height="500"></iframe>',
        '<iframe src="$TARGET" sandbox></iframe>',
        '<object data="$TARGET" width="500" height="500"></object>',
        '<embed src="$TARGET" width="500" height="500">',
        'X-Frame-Options: missing',
        'X-Frame-Options: ALLOWALL',
        'Content-Security-Policy: frame-ancestors missing',
        'frame-ancestors *',
    ]


def _get_security_headers_payloads() -> List[str]:
    """Get security header check payloads (expected header patterns)."""
    return [
        'Content-Security-Policy: missing',
        'Strict-Transport-Security: missing',
        'X-Content-Type-Options: missing',
        'X-Frame-Options: missing',
        'X-XSS-Protection: missing',
        'Referrer-Policy: missing',
        'Permissions-Policy: missing',
        'Cache-Control: no-store missing',
        'Server: version_disclosed',
        'X-Powered-By: technology_disclosed',
    ]


def _get_cookie_security_payloads() -> List[str]:
    """Get cookie security check payloads."""
    return [
        'Secure flag missing',
        'HttpOnly flag missing',
        'SameSite=None without Secure',
        'SameSite attribute missing',
        'Path=/ (overly broad)',
        'Domain=.example.com (overly broad)',
        'Expires=far-future (persistent session)',
        '__Host- prefix missing for sensitive cookies',
    ]


def _get_tls_config_payloads() -> List[str]:
    """Get TLS configuration check payloads."""
    return [
        'TLSv1.0 supported',
        'TLSv1.1 supported',
        'SSLv3 supported',
        'RC4 cipher enabled',
        'DES cipher enabled',
        '3DES cipher enabled',
    ]


def _get_race_condition_payloads() -> List[str]:
    """Get race condition timing marker payloads."""
    return [
        'concurrent_transfer_1', 'concurrent_transfer_2',
        'double_spend_attempt',
        'toctou_check_then_use',
        'parallel_coupon_apply',
        'simultaneous_withdrawal',
        'race_signup_bonus',
        'concurrent_vote',
        'parallel_reservation',
        'simultaneous_password_change',
    ]


def _get_deserialization_payloads(context: Dict[str, Any]) -> List[str]:
    """Get insecure deserialization payloads from the deserialization library."""
    try:
        from .deserialization_payloads import get_deserialization_payloads
        platform = context.get('platform', 'java')
        return get_deserialization_payloads(platform)
    except ImportError:
        return []


def _get_weak_password_payloads() -> List[str]:
    """Generate weak password payloads for testing password policy enforcement.

    Round 11 Fix 4A: Payloads that should be rejected by strong password policies.
    """
    return [
        'pass',          # Too short
        'password',      # Dictionary word
        'abc123',        # Too short + common
        'aaaaaaa',       # No complexity (only lowercase)
        '12345678',      # Only digits
        'Password',      # No special chars or digits
        'password1',     # Common pattern
        'qwerty123',     # Common keyboard pattern
    ]


def _get_input_validation_payloads(context: Dict[str, Any]) -> List[str]:
    """Generate input validation payloads for testing input sanitization.

    Round 11 Fix 4B: Payloads that test for insufficient input validation.
    """
    param = context.get('parameter', {})
    param_type = param.get('type', 'string')

    payloads = [
        'A' * 10000,                # Extremely long string
        '-1',                        # Negative number
        '999999999999999',          # Very large number
        '../../etc/passwd',         # Path traversal attempt
        '<script>alert(1)</script>',# XSS attempt (should be validated)
        '${7*7}',                   # Template injection
        '\x00',                     # Null byte
        'true',                     # Boolean string (type confusion)
        '[]',                       # Empty array (type confusion)
        '{}',                       # Empty object (type confusion)
    ]

    # Add type-specific payloads
    if param_type in ('integer', 'number'):
        payloads.extend([
            'NaN',
            'Infinity',
            '1e308',
            '9007199254740992',  # Max safe integer + 1
        ])
    elif param_type == 'email':
        payloads.extend([
            'not-an-email',
            '@example.com',
            'user@',
            'user..name@example.com',
        ])

    return payloads


# Global singleton instance
_registry_instance = None

def get_payload_registry() -> PayloadRegistry:
    """Get the global payload registry instance."""
    global _registry_instance
    if _registry_instance is None:
        _registry_instance = PayloadRegistry()
    return _registry_instance
