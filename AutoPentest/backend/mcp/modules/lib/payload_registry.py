"""
Payload Registry

Unified registry that consolidates existing and new payload sources
for all 42+ vulnerability classes in the testing engine.
"""

from typing import List, Dict, Any, Optional
import logging

# Import existing payload libraries
from .sql_payloads import get_sql_payloads, get_all_payloads_flat as get_all_sql_payloads
from .xss_payloads import get_xss_payloads
from .ssrf_payloads import get_ssrf_payloads
from .path_traversal_payloads import get_path_traversal_payloads
from .ssti_payloads import get_ssti_payloads

# Import new payload libraries
from .cmdi_payloads import get_cmdi_payloads
from .nosql_payloads import get_nosql_payloads
from .xxe_payloads import get_xxe_payloads
from .header_injection_payloads import get_header_injection_payloads
from .jwt_payloads import get_jwt_payloads, build_jwt_token
from .cors_payloads import get_cors_payloads
from .redirect_payloads import get_redirect_payloads

logger = logging.getLogger(__name__)


class PayloadRegistry:
    """
    Unified payload registry for all vulnerability classes.

    Provides a consistent interface to retrieve payloads regardless of
    the underlying payload library structure.
    """

    # Mapping of vuln spec IDs to payload getter functions
    PAYLOAD_GETTERS = {
        # SQL Injection (split into techniques)
        'sqli_error': lambda ctx: [p for p in get_all_sql_payloads() if p.technique == 'error_based'],
        'sqli_blind_boolean': lambda ctx: [p for p in get_all_sql_payloads() if p.technique == 'blind_boolean'],
        'sqli_blind_time': lambda ctx: [p for p in get_all_sql_payloads() if p.technique == 'blind_time'],
        'sqli_union': lambda ctx: [p for p in get_all_sql_payloads() if p.technique == 'union'],

        # XSS (split into types)
        'xss_reflected': lambda ctx: [p for p in get_xss_payloads() if p.technique == 'reflected'],
        'xss_stored': lambda ctx: [p for p in get_xss_payloads() if p.technique == 'stored'],
        'xss_dom': lambda ctx: [p for p in get_xss_payloads() if p.technique == 'dom_based'],

        # Other injection types
        'ssti': lambda ctx: get_ssti_payloads(),
        'ssrf': lambda ctx: get_ssrf_payloads(),
        'path_traversal': lambda ctx: get_path_traversal_payloads(),
        'command_injection': lambda ctx: get_cmdi_payloads(),
        'ldap_injection': lambda ctx: _get_ldap_injection_payloads(),
        'xml_injection': lambda ctx: get_xxe_payloads(),
        'header_injection': lambda ctx: get_header_injection_payloads(),
        'nosql_injection': lambda ctx: get_nosql_payloads(),

        # Auth/Session
        'idor': lambda ctx: [],  # IDOR is tool-based, not payload-based
        'auth_bypass': lambda ctx: [],  # Tool-based
        'broken_auth': lambda ctx: [],  # Credential-based, not payload-based
        'session_fixation': lambda ctx: [],  # Tool-based
        'session_expiry': lambda ctx: [],  # Tool-based
        'jwt_manipulation': lambda ctx: get_jwt_payloads(),
        'privilege_escalation': lambda ctx: [],  # Tool-based
        'username_enumeration': lambda ctx: _get_username_enum_payloads(ctx),

        # Configuration
        'cors_misconfig': lambda ctx: get_cors_payloads(),
        'csrf': lambda ctx: [],  # Token-based detection, not payload-based
        'clickjacking': lambda ctx: [],  # Header-based detection
        'security_headers': lambda ctx: [],  # Header analysis
        'cookie_security': lambda ctx: [],  # Header analysis
        'http_method_tampering': lambda ctx: _get_method_tampering_payloads(),
        'tls_config': lambda ctx: [],  # Tool-based (ssl_analysis)

        # Client-side
        'open_redirect': lambda ctx: get_redirect_payloads(),

        # Info leaks
        'info_leak_errors': lambda ctx: [],  # Detection via existing errors
        'info_leak_comments': lambda ctx: [],  # Regex-based detection
        'info_leak_source_maps': lambda ctx: [],  # Path-based detection
        'info_leak_headers': lambda ctx: [],  # Header analysis
        'directory_listing': lambda ctx: [],  # Path-based detection

        # API
        'mass_assignment': lambda ctx: _generate_mass_assignment_payloads(ctx),
        'param_pollution': lambda ctx: _generate_param_pollution_payloads(ctx),
        'graphql_introspection': lambda ctx: _get_graphql_payloads(),
        'rate_limit_bypass': lambda ctx: _get_rate_limit_bypass_payloads(),

        # Business logic
        'race_condition': lambda ctx: [],  # Timing/concurrency based
        'price_manipulation': lambda ctx: _generate_price_payloads(ctx),

        # Round 11 Fix 4A/4B: New vuln classes
        'weak_password_policy': lambda ctx: _get_weak_password_payloads(),
        'input_validation': lambda ctx: _get_input_validation_payloads(ctx),

        # Legacy aliases (backward compatibility)
        'sqli': lambda ctx: [p for p in get_all_sql_payloads() if p.technique == 'error_based'],
        'xss': lambda ctx: [p for p in get_xss_payloads() if p.technique == 'reflected'],
    }

    def __init__(self):
        """Initialize the payload registry."""
        pass

    def get_payloads(self, vuln_spec_id: str, context: Optional[Dict[str, Any]] = None) -> List[Any]:
        """
        Get payloads for a specific vulnerability specification.

        Args:
            vuln_spec_id: Vulnerability specification ID (e.g., 'sqli_error', 'xss_reflected')
            context: Optional context dict with keys like:
                    - endpoint: Endpoint metadata
                    - parameter: Parameter being tested
                    - detected_tech: Detected technologies

        Returns:
            List of payload objects. The type varies by vuln class:
            - SQLPayload, XSSPayload, etc. for injection classes
            - String payloads for simpler tests
            - Empty list if no hardcoded payloads exist
        """
        if vuln_spec_id not in self.PAYLOAD_GETTERS:
            logger.warning(f"No payload getter for vuln spec: {vuln_spec_id}")
            return []

        try:
            getter = self.PAYLOAD_GETTERS[vuln_spec_id]
            payloads = getter(context or {})
            return payloads
        except Exception as e:
            logger.error(f"Error getting payloads for {vuln_spec_id}: {e}", exc_info=True)
            return []

    def get_payload_count(self, vuln_spec_id: str) -> int:
        """
        Get count of available payloads for a vuln spec.

        Args:
            vuln_spec_id: Vulnerability specification ID

        Returns:
            Number of payloads available
        """
        payloads = self.get_payloads(vuln_spec_id)
        return len(payloads)

    def get_all_payload_counts(self) -> Dict[str, int]:
        """
        Get payload counts for all vulnerability specifications.

        Returns:
            Dict mapping vuln_spec_id -> payload count
        """
        counts = {}
        for spec_id in self.PAYLOAD_GETTERS.keys():
            counts[spec_id] = self.get_payload_count(spec_id)
        return counts

    def has_payloads(self, vuln_spec_id: str) -> bool:
        """Check if a vuln spec has any payloads."""
        return self.get_payload_count(vuln_spec_id) > 0

    def to_string_payloads(self, payloads: List[Any]) -> List[str]:
        """
        Convert payload objects to string representations.

        Handles different payload types (SQLPayload, XSSPayload, JWT, etc.)
        and extracts the actual payload string.

        Args:
            payloads: List of payload objects

        Returns:
            List of payload strings
        """
        string_payloads = []
        for p in payloads:
            if isinstance(p, str):
                string_payloads.append(p)
            elif hasattr(p, 'payload'):
                string_payloads.append(p.payload)
            elif hasattr(p, 'origin_header'):
                # CORS payload - use origin header value
                string_payloads.append(p.origin_header)
            elif hasattr(p, 'header') and hasattr(p, 'payload_claims'):
                # JWT payload - build token
                from .jwt_payloads import build_jwt_token
                string_payloads.append(build_jwt_token(p))
            else:
                # Unknown type, convert to string
                string_payloads.append(str(p))
        return string_payloads


# ==== DYNAMIC PAYLOAD GENERATORS ====

def _get_ldap_injection_payloads() -> List[str]:
    """Get LDAP injection payloads."""
    return [
        '*',
        '*)*',
        '*)(uid=*',
        '*)(objectClass=*',
        '*)(&',
        '*)(|(uid=*',
        'admin*',
        '*)(cn=*',
        '*)(mail=*',
        '*)(!(&(uid=*',
        '*))%00',
    ]


def _get_username_enum_payloads(context: Dict[str, Any]) -> List[str]:
    """Get username enumeration test payloads."""
    return [
        'admin',
        'administrator',
        'root',
        'test',
        'user',
        'guest',
        'admin@example.com',
        'user@example.com',
        'nonexistent_user_12345',
        '',
        ' ',
        'a' * 100,
        '../admin',
    ]


def _get_method_tampering_payloads() -> List[str]:
    """Get HTTP method tampering payloads."""
    return [
        'GET',
        'POST',
        'PUT',
        'DELETE',
        'PATCH',
        'HEAD',
        'OPTIONS',
        'TRACE',
        'CONNECT',
        'PROPFIND',
        'PROPPATCH',
        'MKCOL',
        'COPY',
        'MOVE',
    ]


def _get_rate_limit_bypass_payloads() -> List[str]:
    """Get rate limit bypass header payloads (header values for X-Forwarded-For etc)."""
    return [
        '127.0.0.1',
        '10.0.0.1',
        '192.168.1.1',
        '8.8.8.8',
        '1.2.3.4',
        '::1',
        'localhost',
        '0.0.0.0',
        '255.255.255.255',
        '127.0.0.1, 8.8.8.8',
    ]


def _generate_mass_assignment_payloads(context: Dict[str, Any]) -> List[str]:
    """Generate mass assignment payloads based on endpoint context."""
    base_payloads = [
        '{"role": "admin"}',
        '{"isAdmin": true}',
        '{"admin": true}',
        '{"is_admin": true}',
        '{"privilege": "administrator"}',
        '{"permissions": ["admin", "write", "delete"]}',
        '{"account_type": "premium"}',
        '{"credits": 999999}',
    ]

    # Add context-specific payloads if endpoint info available
    endpoint = context.get('endpoint', {})
    if 'user' in endpoint.get('path', '').lower():
        base_payloads.extend([
            '{"verified": true}',
            '{"email_verified": true}',
            '{"active": true}',
        ])

    return base_payloads


def _generate_param_pollution_payloads(context: Dict[str, Any]) -> List[str]:
    """Generate HTTP parameter pollution payloads."""
    param = context.get('parameter', {})
    param_name = param.get('name', 'id')

    return [
        f"{param_name}=1&{param_name}=2",
        f"{param_name}[]=1&{param_name}[]=2",
        f"{param_name}=1%26{param_name}=2",  # Encoded &
    ]


def _get_graphql_payloads() -> List[str]:
    """Get GraphQL introspection payloads."""
    return [
        '{"query": "{ __schema { types { name } } }"}',
        '{"query": "{ __type(name: \\"User\\") { name fields { name } } }"}',
        '{"query": "query IntrospectionQuery { __schema { queryType { name } mutationType { name } subscriptionType { name } types { ...FullType } directives { name description locations args { ...InputValue } } } } fragment FullType on __Type { kind name description fields(includeDeprecated: true) { name description args { ...InputValue } type { ...TypeRef } isDeprecated deprecationReason } inputFields { ...InputValue } interfaces { ...TypeRef } enumValues(includeDeprecated: true) { name description isDeprecated deprecationReason } possibleTypes { ...TypeRef } } fragment InputValue on __InputValue { name description type { ...TypeRef } defaultValue } fragment TypeRef on __Type { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name } } } } } } } }"}',
    ]


def _generate_price_payloads(context: Dict[str, Any]) -> List[str]:
    """Generate price manipulation payloads."""
    param = context.get('parameter', {})
    param_name = param.get('name', 'price')

    # Detect current value type
    base_payloads = [
        '0',
        '-1',
        '0.01',
        '-100',
        '999999999',
        '1e10',
    ]

    # JSON format variations
    json_payloads = [
        f'{{"{param_name}": 0}}',
        f'{{"{param_name}": -1}}',
        f'{{"{param_name}": 0.01}}',
    ]

    return base_payloads + json_payloads


def _get_weak_password_payloads() -> List[str]:
    """Generate weak password payloads for testing password policy enforcement.

    Round 11 Fix 4A: Payloads that should be rejected by strong password policies.
    """
    return [
        'pass',          # Too short
        'password',      # Dictionary word
        'abc123',        # Too short + common
        'aaaaaaa',       # No complexity (only lowercase)
        '12345678',      # Only digits
        'Password',      # No special chars or digits
        'password1',     # Common pattern
        'qwerty123',     # Common keyboard pattern
    ]


def _get_input_validation_payloads(context: Dict[str, Any]) -> List[str]:
    """Generate input validation payloads for testing input sanitization.

    Round 11 Fix 4B: Payloads that test for insufficient input validation.
    """
    param = context.get('parameter', {})
    param_type = param.get('type', 'string')

    payloads = [
        'A' * 10000,                # Extremely long string
        '-1',                        # Negative number
        '999999999999999',          # Very large number
        '../../etc/passwd',         # Path traversal attempt
        '<script>alert(1)</script>',# XSS attempt (should be validated)
        '${7*7}',                   # Template injection
        '\x00',                     # Null byte
        'true',                     # Boolean string (type confusion)
        '[]',                       # Empty array (type confusion)
        '{}',                       # Empty object (type confusion)
    ]

    # Add type-specific payloads
    if param_type in ('integer', 'number'):
        payloads.extend([
            'NaN',
            'Infinity',
            '1e308',
            '9007199254740992',  # Max safe integer + 1
        ])
    elif param_type == 'email':
        payloads.extend([
            'not-an-email',
            '@example.com',
            'user@',
            'user..name@example.com',
        ])

    return payloads


# Global singleton instance
_registry_instance = None

def get_payload_registry() -> PayloadRegistry:
    """Get the global payload registry instance."""
    global _registry_instance
    if _registry_instance is None:
        _registry_instance = PayloadRegistry()
    return _registry_instance
