"""
Template Manager

Handles Nuclei template discovery, listing, and filtering.
Supports recursive directory scanning of YAML template files
with automatic fallback to mock templates when the templates
directory is not available.

Ported from nuclei-mcp/src/template-manager.ts
"""
from __future__ import annotations

import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

try:
    import yaml  # PyYAML
except ImportError:  # pragma: no cover â€“ allow import even without PyYAML
    yaml = None  # type: ignore[assignment]


# ---------------------------------------------------------------------------
# Types
# ---------------------------------------------------------------------------

Severity = str  # "info" | "low" | "medium" | "high" | "critical"

VALID_SEVERITIES = ("info", "low", "medium", "high", "critical")

# ---------------------------------------------------------------------------
# Mock templates for testing
# ---------------------------------------------------------------------------

MOCK_TEMPLATES: List[Dict[str, Any]] = [
    {
        "id": "CVE-2021-44228",
        "name": "Apache Log4j RCE (Log4Shell)",
        "severity": "critical",
        "author": "pdteam",
        "tags": ["cve", "cve2021", "rce", "log4j", "apache", "jndi"],
        "description": (
            "Apache Log4j2 <=2.14.1 JNDI features used in configuration, "
            "log messages, and parameters do not protect against attacker "
            "controlled LDAP and other JNDI related endpoints."
        ),
        "reference": ["https://nvd.nist.gov/vuln/detail/CVE-2021-44228"],
        "file_path": "cves/2021/CVE-2021-44228.yaml",
    },
    {
        "id": "CVE-2023-44487",
        "name": "HTTP/2 Rapid Reset Attack",
        "severity": "high",
        "author": "pdteam",
        "tags": ["cve", "cve2023", "dos", "http2"],
        "description": (
            "HTTP/2 protocol allows for rapid stream reset, enabling "
            "denial of service attacks."
        ),
        "reference": ["https://nvd.nist.gov/vuln/detail/CVE-2023-44487"],
        "file_path": "cves/2023/CVE-2023-44487.yaml",
    },
    {
        "id": "xss-detection",
        "name": "Cross-Site Scripting Detection",
        "severity": "medium",
        "author": "pdteam",
        "tags": ["xss", "injection", "web"],
        "description": "Detects reflected and stored XSS vulnerabilities.",
        "file_path": "vulnerabilities/generic/xss-detection.yaml",
    },
    {
        "id": "sql-injection-detection",
        "name": "SQL Injection Detection",
        "severity": "high",
        "author": "pdteam",
        "tags": ["sqli", "injection", "database", "web"],
        "description": (
            "Detects SQL injection vulnerabilities using error-based "
            "and time-based detection."
        ),
        "file_path": "vulnerabilities/generic/sql-injection-detection.yaml",
    },
    {
        "id": "http-missing-security-headers",
        "name": "Missing Security Headers",
        "severity": "info",
        "author": "pdteam",
        "tags": ["misconfiguration", "headers", "security"],
        "description": (
            "Detects missing security headers like CSP, X-Frame-Options, etc."
        ),
        "file_path": "misconfiguration/http-missing-security-headers.yaml",
    },
    {
        "id": "exposed-panels-detect",
        "name": "Exposed Admin Panels",
        "severity": "low",
        "author": "pdteam",
        "tags": ["exposure", "panel", "admin"],
        "description": "Detects exposed administrative panels and login pages.",
        "file_path": "exposures/panels/exposed-panels-detect.yaml",
    },
    {
        "id": "default-credentials",
        "name": "Default Credentials Check",
        "severity": "high",
        "author": "pdteam",
        "tags": ["default-login", "credentials", "authentication"],
        "description": "Checks for default credentials on common services.",
        "file_path": "default-logins/default-credentials.yaml",
    },
    {
        "id": "open-redirect",
        "name": "Open Redirect Detection",
        "severity": "medium",
        "author": "pdteam",
        "tags": ["redirect", "web", "owasp"],
        "description": "Detects open redirect vulnerabilities.",
        "file_path": "vulnerabilities/generic/open-redirect.yaml",
    },
    {
        "id": "ssrf-detection",
        "name": "Server-Side Request Forgery",
        "severity": "high",
        "author": "pdteam",
        "tags": ["ssrf", "owasp", "web"],
        "description": "Detects SSRF vulnerabilities.",
        "file_path": "vulnerabilities/generic/ssrf-detection.yaml",
    },
    {
        "id": "lfi-detection",
        "name": "Local File Inclusion",
        "severity": "high",
        "author": "pdteam",
        "tags": ["lfi", "inclusion", "file"],
        "description": "Detects local file inclusion vulnerabilities.",
        "file_path": "vulnerabilities/generic/lfi-detection.yaml",
    },
]


# ---------------------------------------------------------------------------
# TemplateManager
# ---------------------------------------------------------------------------

class TemplateManager:
    """Discover, cache, and filter Nuclei YAML templates."""

    def __init__(self, templates_dir: Optional[str] = None) -> None:
        self._templates_dir: str = (
            templates_dir
            or os.environ.get("TEMPLATES_DIR", "./nuclei-templates")
        )
        self._mock_mode: bool = False
        self._cached_templates: Optional[List[Dict[str, Any]]] = None

    # -- Directory checking -------------------------------------------------

    def check_templates_dir(self) -> bool:
        """Return True if the templates directory exists and is a directory."""
        try:
            return Path(self._templates_dir).is_dir()
        except Exception:
            return False

    def is_mock_mode(self) -> bool:
        """Return True when running in mock mode (forced or dir missing)."""
        if self._mock_mode:
            return True
        exists = self.check_templates_dir()
        self._mock_mode = not exists
        return self._mock_mode

    def set_mock_mode(self, enabled: bool) -> None:
        """Force mock mode on or off and clear any cached templates."""
        self._mock_mode = enabled
        self._cached_templates = None

    def get_templates_dir(self) -> str:
        """Return the configured templates directory path."""
        return self._templates_dir

    # -- YAML parsing -------------------------------------------------------

    def _parse_template_file(self, file_path: str) -> Optional[Dict[str, Any]]:
        """Parse a single YAML template file and extract metadata."""
        try:
            with open(file_path, "r", encoding="utf-8") as fh:
                content = fh.read()

            # Prefer yaml.safe_load if PyYAML is available
            if yaml is not None:
                return self._parse_with_yaml(content, file_path)

            # Fallback: regex-based parsing (same approach as the TS version)
            return self._parse_with_regex(content, file_path)
        except Exception:
            return None

    def _parse_with_yaml(self, content: str, file_path: str) -> Optional[Dict[str, Any]]:
        """Parse template metadata using PyYAML."""
        try:
            data = yaml.safe_load(content)
            if not isinstance(data, dict):
                return None

            template_id = data.get("id")
            if not template_id:
                return None

            info = data.get("info") or {}
            severity_raw = info.get("severity", "info")
            severity = str(severity_raw).lower() if severity_raw else "info"

            # Tags can be a comma-separated string or a list
            tags_raw = info.get("tags", [])
            if isinstance(tags_raw, str):
                tags = [t.strip() for t in tags_raw.split(",") if t.strip()]
            elif isinstance(tags_raw, list):
                tags = [str(t).strip() for t in tags_raw if t]
            else:
                tags = []

            # Author can be a string or list
            author_raw = info.get("author", "unknown")
            if isinstance(author_raw, list):
                author = ", ".join(str(a) for a in author_raw)
            else:
                author = str(author_raw).strip() if author_raw else "unknown"

            # Reference can be a string or list
            reference_raw = info.get("reference")
            if isinstance(reference_raw, str):
                reference = [reference_raw]
            elif isinstance(reference_raw, list):
                reference = [str(r) for r in reference_raw]
            else:
                reference = None

            rel_path = os.path.relpath(file_path, self._templates_dir)

            result: Dict[str, Any] = {
                "id": str(template_id).strip(),
                "name": str(info.get("name", template_id)).strip(),
                "severity": severity,
                "author": author,
                "tags": tags,
                "file_path": rel_path,
            }

            description = info.get("description")
            if description:
                result["description"] = str(description).strip()

            if reference:
                result["reference"] = reference

            return result
        except Exception:
            return None

    def _parse_with_regex(self, content: str, file_path: str) -> Optional[Dict[str, Any]]:
        """Fallback regex-based parsing when PyYAML is not installed."""
        import re

        id_match = re.search(r"^id:\s*(.+)$", content, re.MULTILINE)
        if not id_match:
            return None

        template_id = id_match.group(1).strip()

        name_match = re.search(r"^\s*name:\s*(.+)$", content, re.MULTILINE)
        severity_match = re.search(r"^\s*severity:\s*(.+)$", content, re.MULTILINE)
        author_match = re.search(r"^\s*author:\s*(.+)$", content, re.MULTILINE)
        tags_match = re.search(r"^\s*tags:\s*(.+)$", content, re.MULTILINE)
        description_match = re.search(
            r"^\s*description:\s*[|>]?\s*(.+)$", content, re.MULTILINE
        )

        severity = (
            severity_match.group(1).strip().lower()
            if severity_match
            else "info"
        )

        tags: List[str] = []
        if tags_match:
            tag_str = tags_match.group(1).strip()
            tags = [t.strip() for t in tag_str.split(",") if t.strip()]

        author = author_match.group(1).strip() if author_match else "unknown"

        rel_path = os.path.relpath(file_path, self._templates_dir)

        result: Dict[str, Any] = {
            "id": template_id,
            "name": name_match.group(1).strip() if name_match else template_id,
            "severity": severity,
            "author": author,
            "tags": tags,
            "file_path": rel_path,
        }

        if description_match:
            result["description"] = description_match.group(1).strip()

        return result

    # -- Recursive directory scanning ---------------------------------------

    def _find_yaml_files(self, directory: str) -> List[str]:
        """Recursively find all .yaml/.yml files under *directory*."""
        files: List[str] = []
        try:
            for entry in os.scandir(directory):
                if entry.is_dir(follow_symlinks=False):
                    # Skip hidden directories and common noise
                    if not entry.name.startswith(".") and entry.name != "node_modules":
                        files.extend(self._find_yaml_files(entry.path))
                elif entry.is_file() and (
                    entry.name.endswith(".yaml") or entry.name.endswith(".yml")
                ):
                    files.append(entry.path)
        except (PermissionError, OSError):
            pass
        return files

    # -- Template loading ---------------------------------------------------

    def load_templates(self) -> List[Dict[str, Any]]:
        """Load all templates from disk (or return mock templates)."""
        if self._cached_templates is not None:
            return self._cached_templates

        if self.is_mock_mode():
            self._cached_templates = list(MOCK_TEMPLATES)
            return self._cached_templates

        templates: List[Dict[str, Any]] = []
        yaml_files = self._find_yaml_files(self._templates_dir)

        for file_path in yaml_files:
            template = self._parse_template_file(file_path)
            if template:
                templates.append(template)

        self._cached_templates = templates
        return templates

    def clear_cache(self) -> None:
        """Clear the cached template list so next access re-reads disk."""
        self._cached_templates = None

    # -- Querying / filtering -----------------------------------------------

    def list_templates(
        self,
        *,
        severity: Optional[Union[str, List[str]]] = None,
        tags: Optional[List[str]] = None,
        author: Optional[str] = None,
        search: Optional[str] = None,
        limit: Optional[int] = None,
    ) -> Dict[str, Any]:
        """List templates with optional filtering."""
        try:
            all_templates = self.load_templates()
            filtered = list(all_templates)

            # Filter by severity
            if severity:
                sev_list = severity if isinstance(severity, list) else [severity]
                sev_lower = [s.lower() for s in sev_list]
                filtered = [t for t in filtered if t["severity"] in sev_lower]

            # Filter by tags
            if tags:
                tags_lower = [t.lower() for t in tags]
                filtered = [
                    t for t in filtered
                    if any(tag in t.get("tags", []) for tag in tags_lower)
                ]

            # Filter by author
            if author:
                author_lower = author.lower()
                filtered = [
                    t for t in filtered
                    if author_lower in t.get("author", "").lower()
                ]

            # Filter by search term
            if search:
                search_lower = search.lower()
                filtered = [
                    t for t in filtered
                    if (
                        search_lower in t["id"].lower()
                        or search_lower in t["name"].lower()
                        or search_lower in (t.get("description") or "").lower()
                        or any(
                            search_lower in tag.lower()
                            for tag in t.get("tags", [])
                        )
                    )
                ]

            total_filtered = len(filtered)

            # Apply limit
            if limit and limit > 0:
                filtered = filtered[:limit]

            return {
                "success": True,
                "templates": filtered,
                "total_count": len(all_templates),
                "filtered_count": total_filtered,
            }
        except Exception as exc:
            return {
                "success": False,
                "templates": [],
                "total_count": 0,
                "filtered_count": 0,
                "error": str(exc),
            }

    def get_template(self, template_id: str) -> Optional[Dict[str, Any]]:
        """Return a single template by ID, or None."""
        templates = self.load_templates()
        for t in templates:
            if t["id"] == template_id:
                return t
        return None

    def template_exists(self, template_id: str) -> bool:
        """Return True if a template with *template_id* is known."""
        return self.get_template(template_id) is not None

    def get_templates_by_severity(self, severity: str) -> List[Dict[str, Any]]:
        """Return all templates matching a given severity."""
        result = self.list_templates(severity=severity)
        return result["templates"]

    def get_templates_by_tags(self, tags: List[str]) -> List[Dict[str, Any]]:
        """Return all templates matching any of the given tags."""
        result = self.list_templates(tags=tags)
        return result["templates"]

    def get_template_count_by_severity(self) -> Dict[str, int]:
        """Return a mapping of severity -> count for all loaded templates."""
        templates = self.load_templates()
        counts: Dict[str, int] = {
            "info": 0,
            "low": 0,
            "medium": 0,
            "high": 0,
            "critical": 0,
        }
        for template in templates:
            sev = template.get("severity", "info")
            if sev in counts:
                counts[sev] += 1
        return counts

    def get_all_tags(self) -> List[str]:
        """Return a sorted list of all unique tags across loaded templates."""
        templates = self.load_templates()
        tag_set: set[str] = set()
        for template in templates:
            for tag in template.get("tags", []):
                tag_set.add(tag)
        return sorted(tag_set)


# ---------------------------------------------------------------------------
# Module-level singleton (lazy access via get_template_manager())
# ---------------------------------------------------------------------------

_template_manager: Optional[TemplateManager] = None


def get_template_manager() -> TemplateManager:
    """Return the lazily-initialized module-level TemplateManager singleton."""
    global _template_manager
    if _template_manager is None:
        _template_manager = TemplateManager()
    return _template_manager
