"""
Recon Report Generator - Structured 9-section reconnaissance report.

Generates a comprehensive markdown report from world model data covering
scope, assets, authentication, endpoints, inputs, network, roles, and
vulnerability candidates.
"""

from __future__ import annotations

import json
import logging
from collections import defaultdict
from typing import Any, Dict, List, Optional

logger = logging.getLogger("autopentest-mcp")


async def generate_recon_report(db, assessment_id: int) -> str:
    """Generate a structured 9-section recon report from world model data.

    Parameters
    ----------
    db : WorldModelDatabase
        Active world model database connection.
    assessment_id : int
        Assessment ID to generate the report for.

    Returns
    -------
    str
        Markdown-formatted reconnaissance report.
    """
    sections: List[str] = []

    # --- Section 0: How to Read This Report ---
    sections.append(_section_0_intro())

    # --- Section 1: Executive Scope Summary ---
    sections.append(await _section_1_scope(db))

    # --- Section 2: Technology & Service Map ---
    sections.append(await _section_2_tech_map(db))

    # --- Section 3: Authentication Flow ---
    sections.append(await _section_3_auth_flow(db))

    # --- Section 4: API Endpoint Inventory ---
    sections.append(await _section_4_endpoints(db))

    # --- Section 5: Input Vectors ---
    sections.append(await _section_5_inputs(db))

    # --- Section 6: Network Map ---
    sections.append(await _section_6_network(db))

    # --- Section 7: Role & Privilege Architecture ---
    sections.append(await _section_7_roles(db))

    # --- Section 8: Authorization Vulnerability Candidates ---
    sections.append(await _section_8_candidates(db))

    return "\n\n".join(sections)


# ---------------------------------------------------------------------------
# Section generators
# ---------------------------------------------------------------------------

def _section_0_intro() -> str:
    return """# Reconnaissance Report

## Section 0: How to Read This Report

This report summarizes all reconnaissance data collected during the assessment.
It is organized into 9 sections:

| Section | Contents |
|---------|----------|
| 1 | Executive Scope Summary - targets, boundaries, constraints |
| 2 | Technology & Service Map - discovered assets grouped by type |
| 3 | Authentication Flow - identity providers, credentials, session management |
| 4 | API Endpoint Inventory - all discovered endpoints grouped by path prefix |
| 5 | Input Vectors - all parameters and input fields across endpoints |
| 6 | Network Map - relationships between assets and services |
| 7 | Role & Privilege Architecture - user roles, permissions, hierarchy |
| 8 | Authorization Vulnerability Candidates - hypotheses for testing |

Each section includes data counts and a summary to aid Phase 2-4 planning."""


async def _section_1_scope(db) -> str:
    """Executive Scope Summary from scope configuration."""
    lines = ["## Section 1: Executive Scope Summary"]

    try:
        # Query assets for scope overview
        assets = await db.query("assets", limit=200)
        domains = set()
        ips = set()
        for a in assets:
            atype = (a.get("type") or "").lower()
            name = a.get("name") or a.get("hostname") or ""
            if atype in ("domain", "subdomain") or "." in name and not name.replace(".", "").isdigit():
                domains.add(name)
            elif atype == "ip" or name.replace(".", "").isdigit():
                ips.add(name)

        lines.append(f"\n- **Total assets discovered:** {len(assets)}")
        lines.append(f"- **Domains/subdomains:** {len(domains)}")
        if domains:
            for d in sorted(domains)[:20]:
                lines.append(f"  - `{d}`")
        lines.append(f"- **IP addresses:** {len(ips)}")
        if ips:
            for ip in sorted(ips)[:20]:
                lines.append(f"  - `{ip}`")
    except Exception as e:
        lines.append(f"\n*Error loading scope data: {e}*")

    return "\n".join(lines)


async def _section_2_tech_map(db) -> str:
    """Technology & Service Map grouped by asset type."""
    lines = ["## Section 2: Technology & Service Map"]

    try:
        assets = await db.query("assets", limit=200)
        by_type: Dict[str, list] = defaultdict(list)
        for a in assets:
            atype = a.get("type") or "unknown"
            by_type[atype].append(a)

        lines.append(f"\n**{len(assets)} assets** across {len(by_type)} types:\n")

        for atype, items in sorted(by_type.items()):
            lines.append(f"### {atype.title()} ({len(items)})")
            for item in items[:25]:
                name = item.get("name") or item.get("hostname") or "unnamed"
                tech = ""
                meta = item.get("metadata") or {}
                if isinstance(meta, dict):
                    techs = meta.get("technologies") or meta.get("tech_stack") or []
                    if isinstance(techs, list) and techs:
                        tech = f" | Tech: {', '.join(str(t) for t in techs[:5])}"
                    elif meta.get("server"):
                        tech = f" | Server: {meta['server']}"
                lines.append(f"- `{name}`{tech}")

        if not assets:
            lines.append("\n*No assets discovered yet. Run `recon_pipeline_run()` first.*")
    except Exception as e:
        lines.append(f"\n*Error loading assets: {e}*")

    return "\n".join(lines)


async def _section_3_auth_flow(db) -> str:
    """Authentication Flow from identities and credentials."""
    lines = ["## Section 3: Authentication Flow"]

    try:
        identities = await db.query("identities", limit=100)
        lines.append(f"\n**{len(identities)} identities** configured:\n")

        for ident in identities:
            name = ident.get("name") or ident.get("id") or "unnamed"
            auth_type = ident.get("auth_type") or "unknown"
            scope = ident.get("scope") or ""
            desc = ident.get("description") or ""
            lines.append(f"- **{name}** ({auth_type})")
            if scope:
                lines.append(f"  - Scope: {scope}")
            if desc:
                lines.append(f"  - {desc}")

        if not identities:
            lines.append("\n*No identities configured. Use `credentials_add()` and `wm_add_identity()`.*")
    except Exception as e:
        lines.append(f"\n*Error loading identities: {e}*")

    return "\n".join(lines)


async def _section_4_endpoints(db) -> str:
    """API Endpoint Inventory grouped by path prefix."""
    lines = ["## Section 4: API Endpoint Inventory"]

    try:
        endpoints = await db.query("endpoints", limit=500)
        lines.append(f"\n**{len(endpoints)} endpoints** discovered:\n")

        by_prefix: Dict[str, list] = defaultdict(list)
        for ep in endpoints:
            path = ep.get("path") or ep.get("url") or "/"
            parts = path.strip("/").split("/")
            prefix = f"/{parts[0]}" if parts and parts[0] else "/"
            by_prefix[prefix].append(ep)

        for prefix, eps in sorted(by_prefix.items()):
            lines.append(f"### {prefix} ({len(eps)} endpoints)")
            for ep in eps[:30]:
                method = ep.get("method") or "GET"
                path = ep.get("path") or ep.get("url") or "/"
                auth = " [AUTH]" if ep.get("auth_required") or ep.get("requires_auth") else ""
                params = ep.get("parameters") or []
                param_count = len(params) if isinstance(params, list) else 0
                param_str = f" ({param_count} params)" if param_count else ""
                lines.append(f"- `{method} {path}`{auth}{param_str}")

        if not endpoints:
            lines.append("\n*No endpoints discovered. Run `crawler_start()` or `openapi_parse()`.*")
    except Exception as e:
        lines.append(f"\n*Error loading endpoints: {e}*")

    return "\n".join(lines)


async def _section_5_inputs(db) -> str:
    """Input Vectors from endpoint parameters."""
    lines = ["## Section 5: Input Vectors"]

    try:
        endpoints = await db.query("endpoints", limit=500)
        all_params: List[Dict] = []
        by_location: Dict[str, int] = defaultdict(int)

        for ep in endpoints:
            params = ep.get("parameters") or []
            if isinstance(params, list):
                for p in params:
                    if isinstance(p, dict):
                        p["_endpoint"] = ep.get("path") or ep.get("url") or "/"
                        p["_method"] = ep.get("method") or "GET"
                        all_params.append(p)
                        loc = p.get("in") or p.get("location") or "unknown"
                        by_location[loc] += 1

        lines.append(f"\n**{len(all_params)} input parameters** across {len(endpoints)} endpoints:\n")

        if by_location:
            lines.append("### By Location")
            for loc, count in sorted(by_location.items(), key=lambda x: -x[1]):
                lines.append(f"- **{loc}**: {count} parameters")

        # Group by parameter name to find common names
        by_name: Dict[str, int] = defaultdict(int)
        for p in all_params:
            name = p.get("name") or "unnamed"
            by_name[name] += 1

        if by_name:
            lines.append("\n### Most Common Parameters")
            for name, count in sorted(by_name.items(), key=lambda x: -x[1])[:20]:
                lines.append(f"- `{name}`: appears in {count} endpoints")

        # Identify high-value input vectors
        id_params = [p for p in all_params if p.get("name", "").lower().endswith("_id") or p.get("name", "").lower() == "id"]
        file_params = [p for p in all_params if p.get("type") == "file"]
        url_params = [p for p in all_params if p.get("name", "").lower() in ("url", "redirect", "callback", "webhook", "src", "href")]

        if id_params or file_params or url_params:
            lines.append("\n### High-Value Vectors")
            if id_params:
                lines.append(f"- **ID parameters** (IDOR candidates): {len(id_params)}")
            if file_params:
                lines.append(f"- **File upload** parameters: {len(file_params)}")
            if url_params:
                lines.append(f"- **URL/redirect** parameters (SSRF candidates): {len(url_params)}")

        if not all_params:
            lines.append("\n*No parameters found. Endpoints may not have parameter metadata.*")
    except Exception as e:
        lines.append(f"\n*Error loading input vectors: {e}*")

    return "\n".join(lines)


async def _section_6_network(db) -> str:
    """Network Map from relationships."""
    lines = ["## Section 6: Network Map"]

    try:
        relationships = await db.query("relationships", limit=200)
        lines.append(f"\n**{len(relationships)} relationships** mapped:\n")

        for rel in relationships[:50]:
            source = rel.get("source_id") or rel.get("from_id") or "?"
            target = rel.get("target_id") or rel.get("to_id") or "?"
            rel_type = rel.get("type") or rel.get("relationship_type") or "connects_to"
            lines.append(f"- `{source}` --[{rel_type}]--> `{target}`")

        if not relationships:
            lines.append("\n*No relationships mapped. Use `wm_add_relationship()` to document connections.*")
    except Exception as e:
        lines.append(f"\n*Error loading relationships: {e}*")

    return "\n".join(lines)


async def _section_7_roles(db) -> str:
    """Role & Privilege Architecture from identities."""
    lines = ["## Section 7: Role & Privilege Architecture"]

    try:
        identities = await db.query("identities", limit=100)
        roles: Dict[str, list] = defaultdict(list)

        for ident in identities:
            meta = ident.get("metadata") or {}
            if isinstance(meta, dict):
                role = meta.get("role") or meta.get("user_type") or "unknown"
            else:
                role = "unknown"
            roles[role].append(ident)

        lines.append(f"\n**{len(identities)} identities** across {len(roles)} roles:\n")

        for role, idents in sorted(roles.items()):
            lines.append(f"### Role: {role} ({len(idents)} identities)")
            for ident in idents:
                name = ident.get("name") or ident.get("id") or "unnamed"
                perms = ""
                meta = ident.get("metadata") or {}
                if isinstance(meta, dict) and meta.get("permissions"):
                    perms = f" | Permissions: {', '.join(str(p) for p in meta['permissions'][:5])}"
                lines.append(f"- {name}{perms}")

        if not identities:
            lines.append("\n*No identities configured. Role mapping requires identity setup.*")
    except Exception as e:
        lines.append(f"\n*Error loading role data: {e}*")

    return "\n".join(lines)


async def _section_8_candidates(db) -> str:
    """Authorization Vulnerability Candidates from hypotheses."""
    lines = ["## Section 8: Authorization Vulnerability Candidates"]

    try:
        hypotheses = await db.query("hypotheses", limit=100)
        lines.append(f"\n**{len(hypotheses)} hypotheses** for testing:\n")

        by_status: Dict[str, int] = defaultdict(int)
        for h in hypotheses:
            status = h.get("status") or "untested"
            by_status[status] += 1

        if by_status:
            lines.append("### Status Summary")
            for status, count in sorted(by_status.items()):
                lines.append(f"- **{status}**: {count}")

        lines.append("\n### Hypothesis Details")
        for h in hypotheses[:30]:
            title = h.get("title") or h.get("description") or "Untitled"
            status = h.get("status") or "untested"
            confidence = h.get("confidence") or ""
            conf_str = f" (confidence: {confidence})" if confidence else ""
            lines.append(f"- [{status}] {title}{conf_str}")

        if not hypotheses:
            lines.append("\n*No hypotheses created. Use `wm_add_hypothesis()` during Phases 2-3.*")
    except Exception as e:
        lines.append(f"\n*Error loading hypotheses: {e}*")

    return "\n".join(lines)
