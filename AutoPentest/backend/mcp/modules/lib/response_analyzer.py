"""
Response Analyzer - Deterministic pre-analysis of HTTP request/response pairs.

Used by endpoint_probe to extract structured context about an endpoint's
behavior before the LLM decides what to test.
"""

from __future__ import annotations

import hashlib
import re
from typing import Any, Dict, List, Optional
from urllib.parse import parse_qs, urlparse

from lib.signal_detector import ERROR_INDICATORS


# ---------------------------------------------------------------------------
# Security headers to check
# ---------------------------------------------------------------------------

_SECURITY_HEADERS = {
    "Content-Security-Policy": "CSP",
    "X-Frame-Options": "clickjacking protection",
    "X-Content-Type-Options": "MIME sniffing protection",
    "Strict-Transport-Security": "HSTS",
    "X-XSS-Protection": "XSS filter",
    "Referrer-Policy": "referrer leakage protection",
    "Permissions-Policy": "browser feature restrictions",
}


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------

def analyze_response(request: Dict[str, Any], response: Dict[str, Any]) -> Dict[str, Any]:
    """Main entry point: full deterministic analysis of a request/response pair.

    Parameters
    ----------
    request : dict
        ``{method, url, headers, body}``
    response : dict
        ``{status, headers, body, timing}``

    Returns
    -------
    dict
        Structured analysis with parameters, reflected_params, response_indicators.
    """
    url = request.get("url", "")
    method = (request.get("method") or "GET").upper()
    req_body = request.get("body") or ""
    resp_body = response.get("body") or ""
    resp_headers = response.get("headers") or {}

    # Extract parameters from request
    parameters = _extract_parameters(url, method, req_body, request.get("headers") or {})

    # Detect reflected params
    reflected = detect_reflected_params(request, response)

    # Response indicators
    content_type = _get_content_type(resp_headers)
    error_indicators = detect_error_indicators(response)
    security_info = extract_security_headers(resp_headers)
    cookies = _extract_cookies(resp_headers)
    server_tech = resp_headers.get("server", resp_headers.get("Server", ""))

    return {
        "parameters": parameters,
        "reflected_params": reflected,
        "response_indicators": {
            "content_type": content_type,
            "response_type": detect_response_type(response),
            "has_sql_errors": any(e["category"] == "sql" for e in error_indicators),
            "has_stack_traces": any(e["category"] == "stackTrace" for e in error_indicators),
            "has_debug_info": any(e["category"] == "debug" for e in error_indicators),
            "has_path_disclosure": any(e["category"] == "path" for e in error_indicators),
            "error_indicators": error_indicators,
            "server_tech": server_tech,
            "security_headers_missing": security_info["missing"],
            "security_headers_present": security_info["present"],
            "cookies": cookies,
            "body_length": len(resp_body),
        },
        "fingerprint": fingerprint_response(response),
    }


def detect_reflected_params(request: Dict[str, Any], response: Dict[str, Any]) -> List[str]:
    """Check if any input parameter values appear verbatim in the response body."""
    resp_body = response.get("body") or ""
    if not resp_body:
        return []

    reflected: List[str] = []
    url = request.get("url", "")
    req_body = request.get("body") or ""

    # Check query params
    parsed = urlparse(url)
    query_params = parse_qs(parsed.query, keep_blank_values=True)
    for name, values in query_params.items():
        for val in values:
            if val and len(val) >= 3 and val in resp_body:
                reflected.append(name)
                break

    # Check body params (JSON or form-encoded)
    body_params = _parse_body_params(req_body)
    for name, val in body_params.items():
        val_str = str(val) if not isinstance(val, str) else val
        if val_str and len(val_str) >= 3 and val_str in resp_body:
            reflected.append(name)

    return list(dict.fromkeys(reflected))  # deduplicate preserving order


def detect_response_type(response: Dict[str, Any]) -> str:
    """Determine response type from content-type header and body sniffing."""
    headers = response.get("headers") or {}
    content_type = _get_content_type(headers).lower()
    body = (response.get("body") or "").strip()

    if "json" in content_type:
        return "json"
    if "xml" in content_type or "soap" in content_type:
        return "xml"
    if "html" in content_type:
        return "html"
    if "text/plain" in content_type:
        return "text"

    # Body sniffing fallback
    if body:
        if body.startswith(("{", "[")):
            return "json"
        if body.startswith("<?xml") or body.startswith("<soap"):
            return "xml"
        if body.startswith("<!DOCTYPE") or body.startswith("<html"):
            return "html"

    return "text"


def extract_security_headers(headers: Dict[str, str]) -> Dict[str, Any]:
    """Check for presence/absence of security headers."""
    # Normalize header keys to lowercase for comparison
    lower_headers = {k.lower(): v for k, v in headers.items()}

    present: List[str] = []
    missing: List[str] = []

    for header, description in _SECURITY_HEADERS.items():
        if header.lower() in lower_headers:
            present.append(header)
        else:
            missing.append(header)

    return {"present": present, "missing": missing}


def detect_error_indicators(response: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Detect error patterns in response body using signal_detector indicators."""
    body_lower = (response.get("body") or "").lower()
    if not body_lower:
        return []

    indicators: List[Dict[str, Any]] = []
    for category, patterns in ERROR_INDICATORS.items():
        for pattern in patterns:
            if pattern in body_lower:
                indicators.append({
                    "category": category,
                    "pattern": pattern,
                    "context": _extract_context(body_lower, pattern, 60),
                })
    return indicators


def fingerprint_response(response: Dict[str, Any]) -> Dict[str, Any]:
    """Create a response fingerprint for baseline comparison."""
    body = response.get("body") or ""
    timing = response.get("timing") or {}

    return {
        "status": response.get("status"),
        "content_type": _get_content_type(response.get("headers") or {}),
        "body_length": len(body),
        "body_hash": hashlib.sha256(body.encode("utf-8", errors="replace")).hexdigest()[:16],
        "timing_ms": timing.get("duration_ms", 0),
    }


# ---------------------------------------------------------------------------
# Private helpers
# ---------------------------------------------------------------------------

def _get_content_type(headers: Dict[str, str]) -> str:
    """Extract content-type, case-insensitive."""
    for k, v in headers.items():
        if k.lower() == "content-type":
            return v.split(";")[0].strip()
    return ""


def _extract_parameters(
    url: str, method: str, body: str, headers: Dict[str, str]
) -> Dict[str, Dict[str, Any]]:
    """Extract all parameters from request URL, body, and headers."""
    result: Dict[str, Dict[str, Any]] = {}

    # Query parameters
    parsed = urlparse(url)
    query_params = parse_qs(parsed.query, keep_blank_values=True)
    if query_params:
        result["query"] = {
            name: {"values": values, "type": "string"}
            for name, values in query_params.items()
        }

    # Path parameters (detect {param} patterns)
    path_params = re.findall(r"\{(\w+)\}", parsed.path)
    if path_params:
        result["path"] = {
            name: {"type": "string"} for name in path_params
        }

    # Body parameters
    if body and method in ("POST", "PUT", "PATCH"):
        body_params = _parse_body_params(body)
        if body_params:
            result["body"] = {
                name: {"value": val, "type": type(val).__name__}
                for name, val in body_params.items()
            }

    return result


def _parse_body_params(body: str) -> Dict[str, Any]:
    """Parse body as JSON or form-encoded, return param nameâ†’value dict."""
    if not body:
        return {}

    body = body.strip()

    # Try JSON
    if body.startswith(("{", "[")):
        try:
            import json
            parsed = json.loads(body)
            if isinstance(parsed, dict):
                return parsed
        except (ValueError, TypeError):
            pass

    # Try form-encoded
    try:
        params = parse_qs(body, keep_blank_values=True)
        return {k: v[0] if len(v) == 1 else v for k, v in params.items()}
    except Exception:
        pass

    return {}


def _extract_cookies(headers: Dict[str, str]) -> List[Dict[str, Any]]:
    """Extract cookie info from Set-Cookie headers."""
    cookies: List[Dict[str, Any]] = []
    for k, v in headers.items():
        if k.lower() == "set-cookie":
            parts = v.split(";")
            name_val = parts[0].strip()
            name = name_val.split("=", 1)[0].strip() if "=" in name_val else name_val
            flags_lower = v.lower()
            cookies.append({
                "name": name,
                "httponly": "httponly" in flags_lower,
                "secure": "secure" in flags_lower,
                "samesite": "samesite" in flags_lower,
            })
    return cookies


def _extract_context(text: str, pattern: str, context_chars: int = 60) -> str:
    """Extract surrounding context around a pattern match."""
    idx = text.find(pattern)
    if idx == -1:
        return ""
    start = max(0, idx - context_chars)
    end = min(len(text), idx + len(pattern) + context_chars)
    return text[start:end]
