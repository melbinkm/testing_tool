"""
Schema Fuzzer
OpenAPI schema-based fuzzing with intelligent payload generation.
Ported from fuzzer-mcp/src/schema-fuzzer.ts
"""

from __future__ import annotations

import hashlib
import os
import random
import time
from typing import Any, Dict, List, Optional

from .payload_generator import PayloadGenerator
from .signal_detector import SignalDetector


# ---------------------------------------------------------------------------
# Default configuration
# ---------------------------------------------------------------------------
DEFAULT_CONFIG: dict[str, Any] = {
    "max_payloads": int(os.environ.get("MAX_PAYLOADS", "100")),
    "max_requests_per_endpoint": int(os.environ.get("MAX_REQUESTS_PER_ENDPOINT", "500")),
    "rate_limit": int(os.environ.get("RATE_LIMIT", "10")),
    "timeout": int(os.environ.get("TIMEOUT", "30000")),
    "baseline_timeout": int(os.environ.get("BASELINE_TIMEOUT", "10000")),
}


class SchemaFuzzer:
    """OpenAPI schema-based fuzzer with intelligent payload generation."""

    def __init__(self, config: Optional[dict[str, Any]] = None) -> None:
        self.config: dict[str, Any] = {**DEFAULT_CONFIG}
        if config:
            self.config.update(config)
        self.payload_generator = PayloadGenerator(self.config["max_payloads"])
        self.signal_detector = SignalDetector()
        self.request_count: int = 0

    # ------------------------------------------------------------------
    # OpenAPI schema parsing
    # ------------------------------------------------------------------

    def parse_openapi_schema(self, schema: dict[str, Any]) -> list[dict[str, Any]]:
        """Parse an OpenAPI schema and return a list of endpoint definitions."""
        endpoints: list[dict[str, Any]] = []
        paths = schema.get("paths")
        if not paths:
            return endpoints

        valid_methods = {"get", "post", "put", "patch", "delete"}

        for path, methods in paths.items():
            for method, operation in methods.items():
                if method.lower() not in valid_methods:
                    continue

                parameters: list[dict[str, Any]] = []

                # Parse path/query/header parameters
                if operation.get("parameters"):
                    for param in operation["parameters"]:
                        parameters.append(self._parse_parameter(param))

                # Parse request body
                request_body: Optional[dict[str, Any]] = None
                rb = operation.get("requestBody")
                if rb and rb.get("content"):
                    content_type = next(iter(rb["content"]))
                    body_schema = rb["content"][content_type].get("schema", {})
                    request_body = {
                        "contentType": content_type,
                        "schema": body_schema,
                    }

                    # Extract body parameters from schema properties
                    properties = body_schema.get("properties", {})
                    required_list = body_schema.get("required", [])
                    for name, prop_schema in properties.items():
                        parameters.append({
                            "name": name,
                            "location": "body",
                            "type": prop_schema.get("type", "string"),
                            "format": prop_schema.get("format"),
                            "required": name in required_list if isinstance(required_list, list) else False,
                            "minimum": prop_schema.get("minimum"),
                            "maximum": prop_schema.get("maximum"),
                            "minLength": prop_schema.get("minLength"),
                            "maxLength": prop_schema.get("maxLength"),
                            "enum": prop_schema.get("enum"),
                        })

                endpoints.append({
                    "path": path,
                    "method": method.upper(),
                    "parameters": parameters,
                    "requestBody": request_body,
                })

        return endpoints

    # ------------------------------------------------------------------
    # Fuzzing
    # ------------------------------------------------------------------

    async def fuzz_parameter(
        self,
        endpoint: str,
        method: str,
        parameter: dict[str, Any],
        options: Optional[dict[str, Any]] = None,
    ) -> dict[str, Any]:
        """Fuzz a single parameter and return a ParameterFuzzResult dict."""
        options = options or {}
        payloads = self.payload_generator.generate_for_parameter(
            parameter,
            options.get("payload_types"),
        )

        signals: list[dict[str, Any]] = []
        baseline_response: Optional[dict[str, Any]] = None

        # Get baseline response with valid/default value
        if options.get("mock_mode", True):
            baseline_response = self._get_mock_baseline()
        else:
            default_val = parameter.get("default") if parameter.get("default") is not None else self._get_default_value(parameter)
            baseline_response = await self._make_request(
                endpoint, method, parameter, default_val, options.get("headers"),
            )

        # Fuzz with each payload
        for payload in payloads:
            if self.request_count >= self.config["max_requests_per_endpoint"]:
                break

            if options.get("mock_mode", True):
                response = self._get_mock_response(payload["value"], payload["type"])
            else:
                response = await self._make_request(
                    endpoint, method, parameter, payload["value"], options.get("headers"),
                )

            self.request_count += 1

            detected = self.signal_detector.detect_signals(
                response,
                str(payload["value"]),
                payload["type"],
                baseline_response,
            )
            signals.extend(detected)

        return {
            "endpoint": endpoint,
            "parameter": parameter.get("name", ""),
            "parameter_type": parameter.get("type", ""),
            "payloads_sent": min(len(payloads), self.config["max_requests_per_endpoint"]),
            "signals": signals,
            "baseline_response_time_ms": baseline_response.get("timing_ms") if baseline_response else None,
            "baseline_status": baseline_response.get("status") if baseline_response else None,
            "baseline_response_hash": self._hash_response(baseline_response["body"]) if baseline_response else None,
        }

    async def fuzz_endpoint(
        self,
        endpoint: str,
        method: str,
        parameters: list[dict[str, Any]],
        options: Optional[dict[str, Any]] = None,
    ) -> dict[str, Any]:
        """Fuzz all parameters of an endpoint and return an EndpointFuzzResult dict."""
        options = options or {}
        start_time = time.monotonic()
        parameter_results: list[dict[str, Any]] = []
        total_signals = 0
        total_payloads = 0

        self.request_count = 0  # Reset per endpoint

        for param in parameters:
            if self.request_count >= self.config["max_requests_per_endpoint"]:
                break

            result = await self.fuzz_parameter(endpoint, method, param, options)
            parameter_results.append(result)
            total_signals += len(result["signals"])
            total_payloads += result["payloads_sent"]

        elapsed_ms = (time.monotonic() - start_time) * 1000

        return {
            "endpoint": endpoint,
            "method": method,
            "parameters_fuzzed": len(parameter_results),
            "total_payloads_sent": total_payloads,
            "total_signals": total_signals,
            "parameter_results": parameter_results,
            "duration_ms": elapsed_ms,
        }

    # ------------------------------------------------------------------
    # HTTP request (mock placeholder)
    # ------------------------------------------------------------------

    async def _make_request(
        self,
        endpoint: str,
        method: str,
        parameter: dict[str, Any],
        value: Any,
        headers: Optional[dict[str, str]] = None,
    ) -> dict[str, Any]:
        """Make an HTTP request (stub -- returns a mock response for now)."""
        return self._get_mock_response(value, "boundary")

    # ------------------------------------------------------------------
    # Mock helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _get_mock_baseline() -> dict[str, Any]:
        """Return a mock baseline response."""
        return {
            "status": 200,
            "headers": {"content-type": "application/json"},
            "body": '{"status":"ok"}',
            "timing_ms": 50,
        }

    @staticmethod
    def _get_mock_response(value: Any, payload_type: str) -> dict[str, Any]:
        """Return a simulated response based on the payload."""
        value_str = str(value)

        # Simulate error responses for certain payloads
        if "'" in value_str and payload_type == "injection":
            return {
                "status": 500,
                "headers": {"content-type": "text/html"},
                "body": "Error: You have an error in your SQL syntax near \"'...\"",
                "timing_ms": 100,
            }

        if "<script>" in value_str and payload_type == "injection":
            return {
                "status": 200,
                "headers": {"content-type": "text/html"},
                "body": f"<html><body>Search results for: {value_str}</body></html>",
                "timing_ms": 50,
            }

        if len(value_str) > 10000:
            return {
                "status": 500,
                "headers": {"content-type": "text/plain"},
                "body": "Internal Server Error: Request entity too large",
                "timing_ms": 2000,
            }

        if "sleep" in value_str or "WAITFOR" in value_str:
            return {
                "status": 200,
                "headers": {"content-type": "application/json"},
                "body": '{"status":"ok"}',
                "timing_ms": 5000,  # Simulate time-based injection
            }

        # Default response
        return {
            "status": 200,
            "headers": {"content-type": "application/json"},
            "body": '{"status":"ok"}',
            "timing_ms": 50 + random.random() * 50,
        }

    # ------------------------------------------------------------------
    # Utility helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _get_default_value(param: dict[str, Any]) -> Any:
        """Get a sensible default value for a parameter type."""
        if param.get("default") is not None:
            return param["default"]
        if param.get("enum") and len(param["enum"]) > 0:
            return param["enum"][0]

        param_type = param.get("type", "").lower()
        if param_type in ("integer", "number"):
            return param.get("minimum", 0)
        if param_type == "boolean":
            return False
        if param_type == "string":
            return "test"
        if param_type == "array":
            return []
        if param_type == "object":
            return {}
        return ""

    @staticmethod
    def _hash_response(body: str) -> str:
        """SHA-256 hash of *body*, truncated to the first 16 hex chars."""
        return hashlib.sha256(body.encode("utf-8")).hexdigest()[:16]

    # ------------------------------------------------------------------
    # Accessors
    # ------------------------------------------------------------------

    def get_config(self) -> dict[str, Any]:
        """Return a copy of the current configuration."""
        return dict(self.config)

    def get_request_count(self) -> int:
        """Return the current request count."""
        return self.request_count

    def reset_request_count(self) -> None:
        """Reset the request counter to zero."""
        self.request_count = 0

    def get_payload_generator(self) -> PayloadGenerator:
        """Return the internal PayloadGenerator instance."""
        return self.payload_generator

    def get_signal_detector(self) -> SignalDetector:
        """Return the internal SignalDetector instance."""
        return self.signal_detector

    # ------------------------------------------------------------------
    # Private schema helpers
    # ------------------------------------------------------------------

    @staticmethod
    def _parse_parameter(param: dict[str, Any]) -> dict[str, Any]:
        """Parse a single OpenAPI parameter definition."""
        schema = param.get("schema", {})
        return {
            "name": param.get("name", ""),
            "location": param.get("in", "query"),
            "type": schema.get("type", "string"),
            "format": schema.get("format"),
            "required": param.get("required", False),
            "minimum": schema.get("minimum"),
            "maximum": schema.get("maximum"),
            "minLength": schema.get("minLength"),
            "maxLength": schema.get("maxLength"),
            "enum": schema.get("enum"),
            "pattern": schema.get("pattern"),
            "default": schema.get("default"),
        }


# Default instance for convenience
schema_fuzzer = SchemaFuzzer()
