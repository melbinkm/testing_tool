"""
Evidence Bundler - Manages creation and manipulation of evidence bundles.
Ported from TypeScript EvidenceBundler (evidence-mcp/src/bundler.ts) to Python.

Each bundle gets a unique ``EB-XXXXXXXX`` ID; each artifact gets ``ART-XXXXXXXX``.
"""

from __future__ import annotations

import uuid
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

VALID_ARTIFACT_TYPES = ("request", "response", "screenshot", "log", "config", "other")


# ---------------------------------------------------------------------------
# EvidenceBundler
# ---------------------------------------------------------------------------

class EvidenceBundler:
    """Manages evidence bundles and their artifacts in-memory."""

    def __init__(self) -> None:
        self._bundles: Dict[str, Dict[str, Any]] = {}

    # ------------------------------------------------------------------
    # ID generation
    # ------------------------------------------------------------------

    @staticmethod
    def _generate_bundle_id() -> str:
        """Generate a unique bundle ID in ``EB-XXXXXXXX`` format."""
        return f"EB-{uuid.uuid4().hex[:8].upper()}"

    @staticmethod
    def _generate_artifact_id() -> str:
        """Generate a unique artifact ID in ``ART-XXXXXXXX`` format."""
        return f"ART-{uuid.uuid4().hex[:8].upper()}"

    # ------------------------------------------------------------------
    # Bundle CRUD
    # ------------------------------------------------------------------

    def create_bundle(
        self,
        finding_id: str,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Create a new evidence bundle for *finding_id*.

        Parameters
        ----------
        finding_id : str
            The ID of the finding this evidence relates to.
        metadata : dict, optional
            Arbitrary metadata (title, severity, description, etc.).

        Returns
        -------
        dict
            The newly created bundle.

        Raises
        ------
        ValueError
            If *finding_id* is empty or not a string.
        """
        if not finding_id or not isinstance(finding_id, str):
            raise ValueError("finding_id is required and must be a string")

        bundle: Dict[str, Any] = {
            "bundle_id": self._generate_bundle_id(),
            "finding_id": finding_id,
            "created_at": datetime.now(timezone.utc).isoformat(),
            "artifacts": [],
            "metadata": metadata if metadata is not None else {},
        }

        self._bundles[bundle["bundle_id"]] = bundle
        return bundle

    def get_bundle(self, bundle_id: str) -> Optional[Dict[str, Any]]:
        """Return the bundle with *bundle_id*, or ``None``."""
        return self._bundles.get(bundle_id)

    def list_bundles(self) -> List[Dict[str, Any]]:
        """Return all bundles."""
        return list(self._bundles.values())

    def list_bundles_by_finding(self, finding_id: str) -> List[Dict[str, Any]]:
        """Return all bundles that belong to *finding_id*."""
        return [
            b for b in self._bundles.values()
            if b["finding_id"] == finding_id
        ]

    def delete_bundle(self, bundle_id: str) -> bool:
        """Delete a bundle.  Returns ``True`` if it existed."""
        return self._bundles.pop(bundle_id, None) is not None

    # ------------------------------------------------------------------
    # Artifact management
    # ------------------------------------------------------------------

    def add_artifact(
        self,
        bundle_id: str,
        artifact_input: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Add an artifact to an existing bundle.

        Parameters
        ----------
        bundle_id : str
            The bundle to add the artifact to.
        artifact_input : dict
            Must contain ``type``, ``name``, ``content``.  Optional
            ``content_type`` defaults to ``text/plain``.

        Returns
        -------
        dict
            The newly created artifact.

        Raises
        ------
        ValueError
            On missing/invalid fields or unknown bundle.
        """
        bundle = self._bundles.get(bundle_id)
        if bundle is None:
            raise ValueError(f"Bundle not found: {bundle_id}")

        art_type = artifact_input.get("type")
        if not art_type:
            raise ValueError("Artifact type is required")

        art_name = artifact_input.get("name")
        if not art_name:
            raise ValueError("Artifact name is required")

        art_content = artifact_input.get("content")
        if art_content is None:
            raise ValueError("Artifact content is required")

        if art_type not in VALID_ARTIFACT_TYPES:
            raise ValueError(
                f"Invalid artifact type: {art_type}. "
                f"Must be one of: {', '.join(VALID_ARTIFACT_TYPES)}"
            )

        artifact: Dict[str, Any] = {
            "artifact_id": self._generate_artifact_id(),
            "type": art_type,
            "name": art_name,
            "content": str(art_content),
            "content_type": artifact_input.get("content_type", "text/plain"),
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "redacted": False,
        }

        bundle["artifacts"].append(artifact)
        return artifact

    def remove_artifact(self, bundle_id: str, artifact_id: str) -> bool:
        """Remove an artifact from a bundle.  Returns ``True`` if removed."""
        bundle = self._bundles.get(bundle_id)
        if bundle is None:
            raise ValueError(f"Bundle not found: {bundle_id}")

        initial_length = len(bundle["artifacts"])
        bundle["artifacts"] = [
            a for a in bundle["artifacts"]
            if a["artifact_id"] != artifact_id
        ]
        return len(bundle["artifacts"]) < initial_length

    def get_artifact(
        self, bundle_id: str, artifact_id: str
    ) -> Optional[Dict[str, Any]]:
        """Return a specific artifact from a bundle."""
        bundle = self._bundles.get(bundle_id)
        if bundle is None:
            raise ValueError(f"Bundle not found: {bundle_id}")

        for artifact in bundle["artifacts"]:
            if artifact["artifact_id"] == artifact_id:
                return artifact
        return None

    # ------------------------------------------------------------------
    # Metadata
    # ------------------------------------------------------------------

    def update_metadata(
        self, bundle_id: str, metadata: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Merge *metadata* into an existing bundle's metadata.

        Returns the updated bundle.
        """
        bundle = self._bundles.get(bundle_id)
        if bundle is None:
            raise ValueError(f"Bundle not found: {bundle_id}")

        bundle["metadata"].update(metadata)
        return bundle

    # ------------------------------------------------------------------
    # Housekeeping
    # ------------------------------------------------------------------

    def clear(self) -> None:
        """Remove all bundles (useful for testing)."""
        self._bundles.clear()

    def get_bundle_count(self) -> int:
        """Return the number of bundles."""
        return len(self._bundles)


# ---------------------------------------------------------------------------
# Module-level singleton
# ---------------------------------------------------------------------------

_bundler_instance: Optional[EvidenceBundler] = None


def get_bundler() -> EvidenceBundler:
    """Return (or create) the module-level ``EvidenceBundler`` singleton."""
    global _bundler_instance
    if _bundler_instance is None:
        _bundler_instance = EvidenceBundler()
    return _bundler_instance


def reset_bundler() -> None:
    """Reset the singleton (primarily for testing)."""
    global _bundler_instance
    _bundler_instance = None
