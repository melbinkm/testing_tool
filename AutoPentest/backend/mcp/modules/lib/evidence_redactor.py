"""
Evidence Redactor - Removes sensitive data from evidence artifacts.
Ported from TypeScript Redactor (evidence-mcp/src/redactor.ts) to Python.

Ships with default patterns for common secret types (API keys, tokens,
passwords, credit cards, SSNs, emails, private IPs, JWTs, AWS keys,
GitHub tokens).
"""

from __future__ import annotations

import logging
import re
from typing import Any, Dict, List, Optional, Tuple

logger = logging.getLogger("autopentest-mcp")

# ---------------------------------------------------------------------------
# Default redaction patterns
# ---------------------------------------------------------------------------

DEFAULT_PATTERNS: List[Dict[str, str]] = [
    {
        "name": "api_key",
        "pattern": r"(api[_\-]?key|apikey)[=:\s][\"']?[\w\-]{20,}[\"']?",
        "replacement": r"\1=[REDACTED]",
    },
    {
        "name": "bearer_token",
        "pattern": r"Bearer\s+[\w\-._~+/]+=*",
        "replacement": "Bearer [REDACTED]",
    },
    {
        "name": "basic_auth",
        "pattern": r"Basic\s+[A-Za-z0-9+/]+=*",
        "replacement": "Basic [REDACTED]",
    },
    {
        "name": "password",
        "pattern": r"(password|passwd|pwd)[=:\s][\"']?[^\s\"']+[\"']?",
        "replacement": r"\1=[REDACTED]",
    },
    {
        "name": "credit_card",
        "pattern": r"\b\d{4}[\s\-]?\d{4}[\s\-]?\d{4}[\s\-]?\d{4}\b",
        "replacement": "[CREDIT_CARD_REDACTED]",
    },
    {
        "name": "ssn",
        "pattern": r"\b\d{3}-\d{2}-\d{4}\b",
        "replacement": "[SSN_REDACTED]",
    },
    {
        "name": "email",
        "pattern": r"[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}",
        "replacement": "[EMAIL_REDACTED]",
    },
    {
        "name": "private_ip",
        "pattern": (
            r"\b(10\.\d+\.\d+\.\d+|"
            r"192\.168\.\d+\.\d+|"
            r"172\.(1[6-9]|2\d|3[01])\.\d+\.\d+)\b"
        ),
        "replacement": "[PRIVATE_IP_REDACTED]",
    },
    {
        "name": "jwt_token",
        "pattern": r"eyJ[A-Za-z0-9\-_=]+\.eyJ[A-Za-z0-9\-_=]+\.[A-Za-z0-9\-_.+/=]*",
        "replacement": "[JWT_REDACTED]",
    },
    {
        "name": "aws_key",
        "pattern": r"AKIA[0-9A-Z]{16}",
        "replacement": "[AWS_KEY_REDACTED]",
    },
    {
        "name": "github_token",
        "pattern": r"gh[ps]_[A-Za-z0-9_]{36}",
        "replacement": "[GITHUB_TOKEN_REDACTED]",
    },
]


# ---------------------------------------------------------------------------
# Redactor
# ---------------------------------------------------------------------------

class Redactor:
    """Apply regex-based redaction patterns to text content."""

    def __init__(
        self,
        *,
        patterns: Optional[List[Dict[str, str]]] = None,
        mask_char: str = "*",
        preserve_length: bool = False,
    ) -> None:
        self._patterns: Dict[str, Dict[str, str]] = {}
        self._mask_char: str = mask_char
        self._preserve_length: bool = preserve_length

        # Load defaults first
        for pat in DEFAULT_PATTERNS:
            self._patterns[pat["name"]] = dict(pat)

        # Override / extend with caller-supplied patterns
        if patterns:
            for pat in patterns:
                self._patterns[pat["name"]] = dict(pat)

    # ------------------------------------------------------------------
    # Pattern management
    # ------------------------------------------------------------------

    def add_pattern(self, pattern: Dict[str, str]) -> None:
        """Add (or replace) a redaction pattern.

        *pattern* must contain ``name`` and ``pattern`` keys.
        """
        if not pattern.get("name") or not pattern.get("pattern"):
            raise ValueError("Pattern must have name and pattern properties")
        self._patterns[pattern["name"]] = dict(pattern)

    def remove_pattern(self, name: str) -> bool:
        """Remove a pattern by name.  Returns ``True`` if it existed."""
        return self._patterns.pop(name, None) is not None

    def get_patterns(self) -> List[Dict[str, str]]:
        """Return all configured patterns."""
        return list(self._patterns.values())

    # ------------------------------------------------------------------
    # Mask character helpers
    # ------------------------------------------------------------------

    def set_mask_char(self, char: str) -> None:
        if len(char) != 1:
            raise ValueError("Mask character must be a single character")
        self._mask_char = char

    def get_mask_char(self) -> str:
        return self._mask_char

    def set_preserve_length(self, preserve: bool) -> None:
        self._preserve_length = preserve

    # ------------------------------------------------------------------
    # Redaction
    # ------------------------------------------------------------------

    def redact(self, content: str) -> Dict[str, Any]:
        """Apply all redaction patterns to *content*.

        Returns a dict with two keys:

        * ``content`` -- the redacted string
        * ``result``  -- a :class:`dict` with ``original_length``,
          ``redacted_length``, ``patterns_applied``, and ``redaction_count``.
        """
        if not content:
            return {
                "content": "",
                "result": {
                    "original_length": 0,
                    "redacted_length": 0,
                    "patterns_applied": [],
                    "redaction_count": 0,
                },
            }

        redacted_content = content
        patterns_applied: List[str] = []
        redaction_count = 0

        for name, pattern_def in self._patterns.items():
            try:
                regex = re.compile(pattern_def["pattern"], re.IGNORECASE)
                matches = regex.findall(redacted_content)

                if matches:
                    redaction_count += len(matches)
                    patterns_applied.append(name)

                    if self._preserve_length:
                        redacted_content = regex.sub(
                            lambda m: self._mask_char * len(m.group(0)),
                            redacted_content,
                        )
                    else:
                        replacement = pattern_def.get(
                            "replacement",
                            f"[{name.upper()}_REDACTED]",
                        )
                        redacted_content = regex.sub(replacement, redacted_content)
            except re.error as exc:
                logger.error('[redactor] Invalid pattern "%s": %s', name, exc)

        return {
            "content": redacted_content,
            "result": {
                "original_length": len(content),
                "redacted_length": len(redacted_content),
                "patterns_applied": patterns_applied,
                "redaction_count": redaction_count,
            },
        }

    def redact_artifact(self, artifact: Dict[str, Any]) -> Dict[str, Any]:
        """Redact an artifact's content and return a new artifact dict.

        Returns a dict with ``artifact`` (the redacted copy) and ``result``.
        """
        outcome = self.redact(artifact.get("content", ""))
        redacted_artifact = dict(artifact)
        redacted_artifact["content"] = outcome["content"]
        redacted_artifact["redacted"] = (
            outcome["result"]["redaction_count"] > 0 or artifact.get("redacted", False)
        )
        return {
            "artifact": redacted_artifact,
            "result": outcome["result"],
        }

    def contains_sensitive_data(self, content: str) -> bool:
        """Return ``True`` if *content* matches any configured pattern."""
        if not content:
            return False

        for pattern_def in self._patterns.values():
            try:
                if re.search(pattern_def["pattern"], content, re.IGNORECASE):
                    return True
            except re.error:
                pass

        return False


# ---------------------------------------------------------------------------
# Module-level singleton
# ---------------------------------------------------------------------------

_redactor_instance: Optional[Redactor] = None


def get_redactor() -> Redactor:
    """Return (or create) the module-level ``Redactor`` singleton."""
    global _redactor_instance
    if _redactor_instance is None:
        _redactor_instance = Redactor()
    return _redactor_instance


def reset_redactor() -> None:
    """Reset the singleton (primarily for testing)."""
    global _redactor_instance
    _redactor_instance = None
