"""
Concurrency Limiter (Semaphore Pattern)

Limits the number of concurrent operations, queueing excess requests
until slots become available. Uses asyncio.Semaphore internally.

Ported from http-client-mcp/src/concurrency-limiter.ts
"""

import asyncio


class ConcurrencyLimiter:
    """Semaphore-based concurrency limiter for controlling parallel operations."""

    def __init__(self, max_concurrent: int) -> None:
        """
        Create a new concurrency limiter.

        Args:
            max_concurrent: Maximum number of concurrent operations.
                            Must be positive.

        Raises:
            ValueError: If max_concurrent is not positive.
        """
        if max_concurrent <= 0:
            raise ValueError("max_concurrent must be positive")

        self._max: int = max_concurrent
        self._semaphore: asyncio.Semaphore = asyncio.Semaphore(max_concurrent)
        self._current: int = 0
        self._queued: int = 0

    async def acquire(self) -> None:
        """
        Acquire a concurrency slot, waiting if at capacity.

        This wraps asyncio.Semaphore.acquire() while tracking the current
        active count and queue depth for status reporting.
        """
        if self._current >= self._max:
            self._queued += 1
            try:
                await self._semaphore.acquire()
            finally:
                self._queued -= 1
        else:
            await self._semaphore.acquire()

        self._current += 1

    def release(self) -> None:
        """
        Release a concurrency slot, allowing the next queued request to proceed.

        Safe to call even if no slot is currently held (will be a no-op in
        that case to match the TypeScript behavior).
        """
        if self._current <= 0:
            return  # Nothing to release

        self._current -= 1
        self._semaphore.release()

    def get_status(self) -> dict:
        """
        Get current concurrency limiter status.

        Returns:
            dict with keys:
                - "current" (int): Number of currently active operations.
                - "max" (int): Maximum allowed concurrent operations.
                - "queued" (int): Number of operations waiting for a slot.
        """
        return {
            "current": self._current,
            "max": self._max,
            "queued": self._queued,
        }

    def reset(self) -> None:
        """
        Reset the limiter to its initial state.

        Recreates the internal semaphore and resets all counters.
        """
        self._semaphore = asyncio.Semaphore(self._max)
        self._current = 0
        self._queued = 0

    def is_available(self) -> bool:
        """Check if a concurrency slot is immediately available."""
        return self._current < self._max

    def get_active_count(self) -> int:
        """Get the number of currently active operations."""
        return self._current

    def get_queue_length(self) -> int:
        """Get the number of operations waiting in the queue."""
        return self._queued
