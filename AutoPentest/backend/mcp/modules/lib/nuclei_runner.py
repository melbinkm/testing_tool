"""
Nuclei Runner

Wrapper for the Nuclei vulnerability scanner binary with mock mode support.
Provides async subprocess execution, JSON output parsing, and automatic
fallback to mock mode when the nuclei binary is not available.

Ported from nuclei-mcp/src/nuclei-runner.ts
"""
from __future__ import annotations

import asyncio
import json
import os
import re
import time
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional
from urllib.parse import urlparse


# ---------------------------------------------------------------------------
# Types (mirrored from nuclei-mcp/src/types.ts)
# ---------------------------------------------------------------------------

Severity = str  # "info" | "low" | "medium" | "high" | "critical"


class NucleiConfig:
    """Configuration for the Nuclei runner."""

    def __init__(
        self,
        nuclei_path: str = "",
        templates_dir: str = "",
        rate_limit: int = 10,
        timeout: int = 30000,
        mock_mode: bool = False,
    ) -> None:
        self.nuclei_path: str = nuclei_path or os.environ.get("NUCLEI_PATH", "nuclei")
        self.templates_dir: str = templates_dir or os.environ.get("TEMPLATES_DIR", "./nuclei-templates")
        self.rate_limit: int = rate_limit
        self.timeout: int = timeout
        self.mock_mode: bool = mock_mode

    def to_dict(self) -> Dict[str, Any]:
        return {
            "nuclei_path": self.nuclei_path,
            "templates_dir": self.templates_dir,
            "rate_limit": self.rate_limit,
            "timeout": self.timeout,
            "mock_mode": self.mock_mode,
        }


# ---------------------------------------------------------------------------
# Mock findings for testing when nuclei binary is not available
# ---------------------------------------------------------------------------

def _now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()


MOCK_FINDINGS: Dict[str, List[Dict[str, Any]]] = {
    "cves/2021/CVE-2021-44228": [
        {
            "template_id": "CVE-2021-44228",
            "template_name": "Log4j RCE (Log4Shell)",
            "severity": "critical",
            "matched_at": "{{target}}/api/endpoint",
            "matcher_name": "log4j-rce",
            "extracted_data": {"dns-callback": "detected"},
            "timestamp": _now_iso(),
        },
    ],
    "vulnerabilities/generic/xss-detection": [
        {
            "template_id": "xss-detection",
            "template_name": "Cross-Site Scripting Detection",
            "severity": "medium",
            "matched_at": "{{target}}/search?q=<script>",
            "matcher_name": "xss-reflected",
            "timestamp": _now_iso(),
        },
    ],
    "misconfiguration/http-missing-security-headers": [
        {
            "template_id": "http-missing-security-headers",
            "template_name": "Missing Security Headers",
            "severity": "info",
            "matched_at": "{{target}}/",
            "matcher_name": "missing-csp",
            "timestamp": _now_iso(),
        },
        {
            "template_id": "http-missing-security-headers",
            "template_name": "Missing Security Headers",
            "severity": "info",
            "matched_at": "{{target}}/",
            "matcher_name": "missing-x-frame-options",
            "timestamp": _now_iso(),
        },
    ],
}


# ---------------------------------------------------------------------------
# NucleiRunner
# ---------------------------------------------------------------------------

class NucleiRunner:
    """Async wrapper around the Nuclei vulnerability scanner binary."""

    def __init__(self, config: Optional[NucleiConfig] = None) -> None:
        self._config: NucleiConfig = config or NucleiConfig(
            mock_mode=os.environ.get("MOCK_MODE", "").lower() == "true",
        )
        self._binary_available: Optional[bool] = None
        self._container_name: str = os.environ.get("DEFAULT_CONTAINER_NAME", "kali-autopentest")
        self._use_docker: bool = False  # Set to True if we need Docker exec

    # -- Binary detection ---------------------------------------------------

    async def check_binary(self) -> bool:
        """Check whether the nuclei binary is available (locally or via Docker)."""
        if self._binary_available is not None:
            return self._binary_available

        # Forced mock mode -> binary not used
        if self._config.mock_mode:
            self._binary_available = False
            self._use_docker = False
            return False

        try:
            nuclei_path = self._config.nuclei_path

            # Try local execution first
            # Absolute or relative path with directory separator
            if nuclei_path.startswith("/") or "/" in nuclei_path:
                accessible = os.access(nuclei_path, os.X_OK)
                if accessible:
                    self._binary_available = True
                    self._use_docker = False
                    return True

            # Search local PATH using 'which'
            try:
                result = await self._execute_command_local("which", [nuclei_path])
                if result["exit_code"] == 0:
                    self._binary_available = True
                    self._use_docker = False
                    return True
            except Exception:
                pass

            # Local binary not available, try Docker exec (backend container -> Kali container)
            # This covers the case where MCP runs in backend but nuclei is in Kali
            try:
                result = await self._execute_command_docker("which", [nuclei_path])
                if result["exit_code"] == 0:
                    self._binary_available = True
                    self._use_docker = True
                    return True
            except Exception:
                pass

            # Not available locally or via Docker
            self._binary_available = False
            self._use_docker = False
            return False

        except Exception:
            self._binary_available = False
            self._use_docker = False
            return False

    async def is_mock_mode(self) -> bool:
        """Return True when running in mock mode (forced or binary absent)."""
        if self._config.mock_mode:
            return True
        binary_available = await self.check_binary()
        return not binary_available

    def get_config(self) -> NucleiConfig:
        """Return a copy-like reference to current configuration."""
        return self._config

    # -- Subprocess execution -----------------------------------------------

    async def _execute_command_local(
        self, command: str, args: List[str]
    ) -> Dict[str, Any]:
        """Execute command locally via asyncio.create_subprocess_exec."""
        try:
            timeout_seconds = self._config.timeout / 1000.0
            proc = await asyncio.create_subprocess_exec(
                command,
                *args,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout_bytes, stderr_bytes = await asyncio.wait_for(
                proc.communicate(), timeout=timeout_seconds
            )
            return {
                "exit_code": proc.returncode if proc.returncode is not None else 1,
                "stdout": stdout_bytes.decode("utf-8", errors="replace"),
                "stderr": stderr_bytes.decode("utf-8", errors="replace"),
            }
        except asyncio.TimeoutError:
            return {"exit_code": 1, "stdout": "", "stderr": "Command timed out"}
        except Exception as exc:
            return {"exit_code": 1, "stdout": "", "stderr": str(exc)}

    async def _execute_command_docker(
        self, command: str, args: List[str]
    ) -> Dict[str, Any]:
        """Execute command in Kali container via 'docker exec'.

        This is used when the MCP server runs in the backend container
        but nuclei binary is only available in the Kali container.
        """
        try:
            timeout_seconds = self._config.timeout / 1000.0

            # Build the command string for bash -c
            # Quote arguments that contain spaces
            quoted_args = [f"'{arg}'" if " " in arg else arg for arg in args]
            bash_command = f"{command} {' '.join(quoted_args)}"

            # Run via Docker exec
            proc = await asyncio.create_subprocess_exec(
                "docker", "exec", self._container_name, "bash", "-c", bash_command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout_bytes, stderr_bytes = await asyncio.wait_for(
                proc.communicate(), timeout=timeout_seconds
            )
            return {
                "exit_code": proc.returncode if proc.returncode is not None else 1,
                "stdout": stdout_bytes.decode("utf-8", errors="replace"),
                "stderr": stderr_bytes.decode("utf-8", errors="replace"),
            }
        except asyncio.TimeoutError:
            return {"exit_code": 1, "stdout": "", "stderr": "Command timed out (Docker exec)"}
        except Exception as exc:
            return {"exit_code": 1, "stdout": "", "stderr": f"Docker exec failed: {str(exc)}"}

    async def _execute_command(
        self, command: str, args: List[str]
    ) -> Dict[str, Any]:
        """Execute command via local or Docker exec based on binary availability.

        Dispatches to _execute_command_local or _execute_command_docker based on
        the _use_docker flag set during check_binary().
        """
        if self._use_docker:
            return await self._execute_command_docker(command, args)
        else:
            return await self._execute_command_local(command, args)

    # -- Output parsing -----------------------------------------------------

    @staticmethod
    def _parse_nuclei_output(line: str) -> Optional[Dict[str, Any]]:
        """Parse a single line of Nuclei JSON output into a finding dict."""
        try:
            output: Dict[str, Any] = json.loads(line)
            info = output.get("info") or {}
            extracted_results = output.get("extracted-results")

            return {
                "template_id": output.get("template-id", ""),
                "template_name": info.get("name"),
                "severity": (info.get("severity", "info") or "info").lower(),
                "matched_at": output.get("matched-at", ""),
                "matched_url": output.get("host"),
                "matcher_name": output.get("matcher-name"),
                "extracted_data": (
                    {"results": ", ".join(extracted_results)}
                    if extracted_results
                    else None
                ),
                "curl_command": output.get("curl-command"),
                "timestamp": output.get("timestamp", _now_iso()),
            }
        except (json.JSONDecodeError, TypeError, AttributeError):
            return None

    # -- Mock scanning ------------------------------------------------------

    async def _run_mock_scan(
        self, target: str, template_ids: List[str]
    ) -> Dict[str, Any]:
        """Return simulated scan results for testing."""
        start_time = time.monotonic()

        # Simulate a small processing delay
        await asyncio.sleep(0.05)

        findings: List[Dict[str, Any]] = []
        for template_id in template_ids:
            mock_findings = MOCK_FINDINGS.get(template_id)
            if mock_findings:
                for finding in mock_findings:
                    findings.append({
                        **finding,
                        "matched_at": finding["matched_at"].replace("{{target}}", target),
                        "matched_url": target,
                        "timestamp": _now_iso(),
                    })

        elapsed_ms = int((time.monotonic() - start_time) * 1000)
        return {
            "success": True,
            "target": target,
            "templates": template_ids,
            "findings": findings,
            "scan_time_ms": elapsed_ms,
            "mock_mode": True,
        }

    # -- Public scanning API ------------------------------------------------

    async def scan_single(self, target: str, template_id: str) -> Dict[str, Any]:
        """Scan a single target with a specific Nuclei template."""
        start_time = time.monotonic()

        # Validate URL
        parsed = urlparse(target)
        if not parsed.scheme or not parsed.netloc:
            return {
                "success": False,
                "target": target,
                "template": template_id,
                "findings": [],
                "scan_time_ms": int((time.monotonic() - start_time) * 1000),
                "error": "Invalid target URL format",
                "mock_mode": await self.is_mock_mode(),
            }

        # Mock mode
        if await self.is_mock_mode():
            return await self._run_mock_scan(target, [template_id])

        # Real scan
        try:
            args = [
                "-target", target,
                "-templates", template_id,
                "-json",
                "-rate-limit", str(self._config.rate_limit),
                "-timeout", str(self._config.timeout // 1000),
                "-silent",
            ]

            result = await self._execute_command(self._config.nuclei_path, args)
            findings: List[Dict[str, Any]] = []

            for line in result["stdout"].splitlines():
                line = line.strip()
                if not line:
                    continue
                finding = self._parse_nuclei_output(line)
                if finding:
                    findings.append(finding)

            return {
                "success": True,
                "target": target,
                "template": template_id,
                "findings": findings,
                "scan_time_ms": int((time.monotonic() - start_time) * 1000),
                "mock_mode": False,
            }
        except Exception as exc:
            return {
                "success": False,
                "target": target,
                "template": template_id,
                "findings": [],
                "scan_time_ms": int((time.monotonic() - start_time) * 1000),
                "error": str(exc),
                "mock_mode": False,
            }

    async def scan_with_templates(
        self,
        targets: List[str],
        *,
        template_ids: Optional[List[str]] = None,
        tags: Optional[List[str]] = None,
        severity: Optional[List[str]] = None,
    ) -> List[Dict[str, Any]]:
        """Scan multiple targets with optional template/tag/severity filters."""
        results: List[Dict[str, Any]] = []

        for target in targets:
            # Validate URL
            parsed = urlparse(target)
            if not parsed.scheme or not parsed.netloc:
                results.append({
                    "success": False,
                    "target": target,
                    "templates": template_ids,
                    "findings": [],
                    "scan_time_ms": 0,
                    "error": "Invalid target URL format",
                    "mock_mode": await self.is_mock_mode(),
                })
                continue

            # Mock mode
            if await self.is_mock_mode():
                mock_result = await self._run_mock_scan(
                    target,
                    template_ids or list(MOCK_FINDINGS.keys()),
                )
                results.append(mock_result)
                continue

            # Real scan
            start_time = time.monotonic()
            try:
                args = [
                    "-target", target,
                    "-json",
                    "-rate-limit", str(self._config.rate_limit),
                    "-timeout", str(self._config.timeout // 1000),
                    "-silent",
                ]

                if template_ids:
                    args.extend(["-templates", ",".join(template_ids)])

                if tags:
                    args.extend(["-tags", ",".join(tags)])

                if severity:
                    args.extend(["-severity", ",".join(severity)])

                result = await self._execute_command(self._config.nuclei_path, args)
                findings: List[Dict[str, Any]] = []

                for line in result["stdout"].splitlines():
                    line = line.strip()
                    if not line:
                        continue
                    finding = self._parse_nuclei_output(line)
                    if finding:
                        findings.append(finding)

                results.append({
                    "success": True,
                    "target": target,
                    "templates": template_ids,
                    "findings": findings,
                    "scan_time_ms": int((time.monotonic() - start_time) * 1000),
                    "mock_mode": False,
                })
            except Exception as exc:
                results.append({
                    "success": False,
                    "target": target,
                    "templates": template_ids,
                    "findings": [],
                    "scan_time_ms": int((time.monotonic() - start_time) * 1000),
                    "error": str(exc),
                    "mock_mode": False,
                })

        return results

    async def get_version(self) -> Optional[str]:
        """Return the nuclei binary version string, or None."""
        if await self.is_mock_mode():
            return "mock-mode"

        try:
            result = await self._execute_command(self._config.nuclei_path, ["-version"])

            # Nuclei writes version to stderr, not stdout
            # Format: "[INF] Nuclei Engine Version: v3.7.0"
            # Strip ANSI color codes before parsing
            output = result["stderr"] or result["stdout"]
            # Remove ANSI color codes (e.g., \x1b[34m, [[34m)
            output = re.sub(r'\x1b\[[0-9;]*m|\[\[[0-9;]*m', '', output)

            # Match version pattern (e.g., v3.7.0 or 3.7.0)
            match = re.search(r"v?(\d+\.\d+\.\d+)", output)
            return match.group(1) if match else None
        except Exception:
            return None


# ---------------------------------------------------------------------------
# Module-level singleton (lazy access via get_nuclei_runner())
# ---------------------------------------------------------------------------

_nuclei_runner: Optional[NucleiRunner] = None


def get_nuclei_runner() -> NucleiRunner:
    """Return the lazily-initialized module-level NucleiRunner singleton."""
    global _nuclei_runner
    if _nuclei_runner is None:
        _nuclei_runner = NucleiRunner()
    return _nuclei_runner
