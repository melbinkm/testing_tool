"""
Form Analyzer - Discover and interact with HTML forms for security testing.

Ported from browser-mcp TypeScript form-analyzer.ts.

Provides:
- Form discovery on a page
- Field analysis (identifies testable input types)
- Form filling and submission
- CSS selector generation for fields
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

logger = logging.getLogger("autopentest-mcp")

# Input types suitable for XSS / injection testing
_TESTABLE_INPUT_TYPES = frozenset({
    "text", "email", "search", "url", "tel",
    "password", "number",
})


class FormAnalyzer:
    """Discover and analyze HTML forms on a page for security testing."""

    async def discover_forms(self, page: Any) -> List[Dict[str, Any]]:
        """Find all forms on the current page.

        Parameters
        ----------
        page : playwright Page
            The Playwright page object.

        Returns
        -------
        list of dict
            List of DiscoveredForm dicts, each containing:
            form_id, action, method, fields, submit_button, selector.
        """
        forms = await page.evaluate("""() => {
            const forms = document.querySelectorAll('form');
            return Array.from(forms).map((form, index) => {
                // Build a selector for this form
                let selector = 'form';
                if (form.id) {
                    selector = '#' + form.id;
                } else if (form.name) {
                    selector = 'form[name="' + form.name + '"]';
                } else {
                    selector = 'form:nth-of-type(' + (index + 1) + ')';
                }

                // Discover fields
                const fields = [];
                const inputs = form.querySelectorAll(
                    'input, textarea, select'
                );
                inputs.forEach((input) => {
                    const type = input.tagName.toLowerCase() === 'textarea'
                        ? 'textarea'
                        : input.tagName.toLowerCase() === 'select'
                            ? 'select'
                            : (input.type || 'text').toLowerCase();

                    // Skip hidden, submit, button, image, file inputs
                    if (['hidden', 'submit', 'button', 'image', 'file', 'reset'].includes(type)) {
                        return;
                    }

                    const name = input.name || input.id || '';
                    const id = input.id || '';
                    const placeholder = input.placeholder || '';
                    const required = input.required || false;
                    const maxLength = input.maxLength > 0 ? input.maxLength : null;

                    fields.push({
                        name: name,
                        id: id,
                        type: type,
                        placeholder: placeholder,
                        required: required,
                        max_length: maxLength,
                        value: input.value || '',
                    });
                });

                // Find submit button
                let submitButton = null;
                const submitEl = form.querySelector(
                    'button[type="submit"], input[type="submit"], button:not([type])'
                );
                if (submitEl) {
                    let btnSelector = '';
                    if (submitEl.id) {
                        btnSelector = '#' + submitEl.id;
                    } else if (submitEl.name) {
                        btnSelector = selector + ' [name="' + submitEl.name + '"]';
                    } else {
                        btnSelector = selector + ' button[type="submit"], ' +
                                     selector + ' input[type="submit"], ' +
                                     selector + ' button:not([type])';
                    }
                    submitButton = {
                        selector: btnSelector,
                        text: (submitEl.textContent || submitEl.value || '').trim(),
                    };
                }

                return {
                    form_id: form.id || 'form-' + (index + 1),
                    action: form.action || '',
                    method: (form.method || 'GET').toUpperCase(),
                    fields: fields,
                    submit_button: submitButton,
                    selector: selector,
                    encoding: form.enctype || 'application/x-www-form-urlencoded',
                };
            });
        }""")

        logger.info("Discovered %d forms on page", len(forms))
        return forms

    async def get_form(
        self,
        page: Any,
        selector: str,
    ) -> Optional[Dict[str, Any]]:
        """Get a specific form by CSS selector.

        Parameters
        ----------
        page : playwright Page
            The Playwright page object.
        selector : str
            CSS selector that identifies the form.

        Returns
        -------
        dict or None
            DiscoveredForm dict, or None if not found.
        """
        all_forms = await self.discover_forms(page)

        # Try exact selector match first
        for form in all_forms:
            if form["selector"] == selector:
                return form

        # Try matching by form_id
        for form in all_forms:
            if form["form_id"] == selector:
                return form

        # Try if the selector can be used to locate the form directly
        for form in all_forms:
            if selector in form["selector"]:
                return form

        return None

    def get_testable_fields(self, form: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Return fields suitable for XSS / injection testing.

        Filters for text-like input types: text, email, search, url,
        tel, password, textarea, number.

        Parameters
        ----------
        form : dict
            A DiscoveredForm dict from discover_forms().

        Returns
        -------
        list of dict
            Subset of fields that are testable.
        """
        testable = []
        for field in form.get("fields", []):
            field_type = field.get("type", "text").lower()
            if field_type in _TESTABLE_INPUT_TYPES or field_type == "textarea":
                testable.append(field)
        return testable

    def get_field_selector(
        self,
        form: Dict[str, Any],
        field_name: str,
    ) -> str:
        """Build a CSS selector for a specific field within a form.

        Parameters
        ----------
        form : dict
            DiscoveredForm dict.
        field_name : str
            The name (or id) of the field.

        Returns
        -------
        str
            A CSS selector string that targets the field.
        """
        form_selector = form.get("selector", "form")

        # Find the field in the form's field list
        for field in form.get("fields", []):
            if field.get("name") == field_name or field.get("id") == field_name:
                # Prefer id-based selector
                if field.get("id"):
                    return f"#{field['id']}"
                # Fall back to name-based selector within the form
                if field.get("name"):
                    return f'{form_selector} [name="{field["name"]}"]'
                break

        # Fallback: use name attribute within form
        return f'{form_selector} [name="{field_name}"]'

    async def fill_form(
        self,
        page: Any,
        form: Dict[str, Any],
        data: Dict[str, str],
    ) -> None:
        """Fill form fields with provided data.

        Parameters
        ----------
        page : playwright Page
            The Playwright page object.
        form : dict
            DiscoveredForm dict.
        data : dict
            Mapping of field name -> value to fill.
        """
        for field_name, value in data.items():
            selector = self.get_field_selector(form, field_name)
            try:
                await page.fill(selector, value)
            except Exception as exc:
                logger.warning(
                    "Failed to fill field '%s' (selector: %s): %s",
                    field_name,
                    selector,
                    str(exc),
                )

    async def submit_form(
        self,
        page: Any,
        form: Dict[str, Any],
        wait_for_navigation: bool = True,
    ) -> None:
        """Submit a form.

        Clicks the submit button if available, otherwise evaluates
        form.submit() in JavaScript.

        Parameters
        ----------
        page : playwright Page
            The Playwright page object.
        form : dict
            DiscoveredForm dict.
        wait_for_navigation : bool
            Whether to wait for navigation after submission.
        """
        submit_button = form.get("submit_button")

        if submit_button and submit_button.get("selector"):
            if wait_for_navigation:
                try:
                    async with page.expect_navigation(timeout=5000):
                        await page.click(submit_button["selector"])
                except Exception:
                    # Navigation may not happen (AJAX form)
                    await page.click(submit_button["selector"])
            else:
                await page.click(submit_button["selector"])
        else:
            # No submit button found; submit via JavaScript
            form_selector = form.get("selector", "form")
            if wait_for_navigation:
                try:
                    async with page.expect_navigation(timeout=5000):
                        await page.evaluate(
                            f'document.querySelector("{form_selector}").submit()'
                        )
                except Exception:
                    await page.evaluate(
                        f'document.querySelector("{form_selector}").submit()'
                    )
            else:
                await page.evaluate(
                    f'document.querySelector("{form_selector}").submit()'
                )
