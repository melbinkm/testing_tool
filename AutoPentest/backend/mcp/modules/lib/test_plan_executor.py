"""
Test Plan Executor - Deterministic execution engine for endpoint test plans.

Executes library payloads and LLM-crafted payloads against endpoints,
classifies responses, tracks budgets, and generates adaptive hints
for follow-up testing.
"""

from __future__ import annotations

import hashlib
import json
import logging
import time
from typing import Any, Dict, List, Optional
from urllib.parse import parse_qs, urlencode, urlparse, urlunparse

from lib.response_classifier import ClassificationResult, ResponseClassifier

logger = logging.getLogger("autopentest-mcp")


# ---------------------------------------------------------------------------
# Budget defaults
# ---------------------------------------------------------------------------

DEFAULT_MAX_PAYLOADS = 20  # per (vuln_class, parameter) pair


# ---------------------------------------------------------------------------
# TestPlanExecutor
# ---------------------------------------------------------------------------

class TestPlanExecutor:
    """Deterministic test execution engine with budget and signal tracking.

    Parameters
    ----------
    http_client
        HttpClient instance for sending real requests.
    db
        WorldModelDatabase instance for creating findings/hypotheses.
    safety_classifier
        Optional SafetyClassifier; loaded lazily if not provided.
    """

    def __init__(
        self,
        http_client: Any,
        db: Any,
        safety_classifier: Any = None,
        mcp_service: Any = None,  # Round 11 Fix 1C: Optional MCP service for card bridging
    ) -> None:
        self._http = http_client
        self._db = db
        self._classifier = ResponseClassifier()
        self._safety = safety_classifier
        self._mcp_service = mcp_service  # For auto-creating finding cards
        # Budget tracker: key = "vuln_class:parameter" -> payloads sent count
        self._budget_used: Dict[str, int] = {}

    def _get_safety_classifier(self) -> Any:
        if self._safety is None:
            from lib.safety_classifier import get_safety_classifier
            self._safety = get_safety_classifier()
        return self._safety

    # ------------------------------------------------------------------
    # Main execution
    # ------------------------------------------------------------------

    async def execute(self, test_plan: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a test plan and return rich results.

        Parameters
        ----------
        test_plan : dict
            Structured test plan with keys:
            - endpoint_id (str)
            - base_url (str)
            - method (str)
            - path (str)
            - headers (dict, optional)
            - base_body (str, optional)
            - max_payloads (int, optional): budget per (vuln_class, parameter), default 20
            - tests (list): each test has:
                - vuln_class (str)
                - parameter (str)
                - location (str): query|body|path|header|cookie
                - use_library (bool, optional): load payloads from curated library
                - payloads (list[str], optional): explicit payloads from LLM
                - max_payloads (int, optional): per-test budget override

        Returns
        -------
        dict
            Results with per-test detail, budget tracking, adaptive hints.
        """
        start_time = time.time()
        max_payloads = test_plan.get("max_payloads", DEFAULT_MAX_PAYLOADS)
        method = (test_plan.get("method") or "GET").upper()
        base_url = test_plan.get("base_url", "")
        path = test_plan.get("path", "")
        full_url = f"{base_url.rstrip('/')}{path}" if base_url else path
        base_headers = test_plan.get("headers") or {}
        base_body = test_plan.get("base_body") or ""
        endpoint_id = test_plan.get("endpoint_id", "")

        # Send baseline request
        baseline = await self._send_baseline(full_url, method, base_headers, base_body)

        results_by_test: List[Dict[str, Any]] = []
        total_tests = 0
        vulnerable_count = 0
        passed_count = 0
        error_count = 0
        skipped_count = 0
        total_payloads_used = 0
        findings: List[Dict[str, Any]] = []

        endpoint_context = test_plan.get("endpoint_context", {})

        for test_spec in test_plan.get("tests", []):
            vuln_class = test_spec.get("vuln_class", "")
            parameter = test_spec.get("parameter", "")
            location = test_spec.get("location", "query")
            use_library = test_spec.get("use_library", False)
            explicit_payloads = test_spec.get("payloads", [])
            per_test_max = test_spec.get("max_payloads", max_payloads)
            param_meta = test_spec.get("parameter_metadata")

            total_tests += 1
            budget_key = f"{vuln_class}:{parameter}"

            # Resolve payloads
            payloads = self._resolve_payloads(
                vuln_class, use_library, explicit_payloads,
                parameter_metadata=param_meta,
                endpoint_context=endpoint_context,
            )

            if not payloads:
                results_by_test.append({
                    "vuln_class": vuln_class,
                    "parameter": parameter,
                    "location": location,
                    "status": "skipped",
                    "payloads_sent": 0,
                    "confirmed_vulnerable": False,
                    "suspicious_signals": [],
                    "clean_payloads_sample": [],
                    "note": "No payloads available for this vuln class",
                })
                skipped_count += 1
                continue

            # Execute payloads with budget tracking
            test_result = await self._execute_test(
                url=full_url,
                method=method,
                headers=base_headers,
                body=base_body,
                vuln_class=vuln_class,
                parameter=parameter,
                location=location,
                payloads=payloads,
                baseline=baseline,
                budget_key=budget_key,
                budget_max=per_test_max,
                endpoint_id=endpoint_id,
            )

            results_by_test.append(test_result)
            total_payloads_used += test_result["payloads_sent"]

            status = test_result["status"]
            if status == "vulnerable":
                vulnerable_count += 1
                if test_result.get("finding"):
                    findings.append(test_result["finding"])
            elif status == "clean":
                passed_count += 1
            elif status == "error":
                error_count += 1
            elif status == "skipped":
                skipped_count += 1
            # "suspicious" counts as neither passed nor failed

        # Compute budget remaining
        budget_remaining = {}
        for test_spec in test_plan.get("tests", []):
            bk = f"{test_spec.get('vuln_class', '')}:{test_spec.get('parameter', '')}"
            per_test_max = test_spec.get("max_payloads", max_payloads)
            used = self._budget_used.get(bk, 0)
            budget_remaining[bk] = max(0, per_test_max - used)

        # Generate adaptive hints
        adaptive_hints = self._generate_adaptive_hints(results_by_test)

        duration_ms = int((time.time() - start_time) * 1000)

        return {
            "total_tests": total_tests,
            "vulnerable_count": vulnerable_count,
            "passed_count": passed_count,
            "error_count": error_count,
            "skipped_count": skipped_count,
            "payloads_used": total_payloads_used,
            "budget_remaining": budget_remaining,
            "findings": findings,
            "results_by_test": results_by_test,
            "adaptive_hints": adaptive_hints,
            "baseline_static_findings": baseline.get("static_findings", {}),
            "duration_ms": duration_ms,
        }

    # ------------------------------------------------------------------
    # Baseline
    # ------------------------------------------------------------------

    async def _send_baseline(
        self, url: str, method: str, headers: Dict, body: str
    ) -> Dict[str, Any]:
        """Send a baseline request and fingerprint the response."""
        try:
            result = await self._http.send({
                "method": method,
                "url": url,
                "headers": headers,
                "body": body if body else None,
            })

            if result.get("success") and result.get("response"):
                resp = result["response"]
                resp_body = resp.get("body") or ""
                timing = resp.get("timing") or {}

                baseline = {
                    "status": resp.get("status", 200),
                    "body_hash": hashlib.sha256(
                        resp_body.encode("utf-8", errors="replace")
                    ).hexdigest()[:16],
                    "body_length": len(resp_body),
                    "timing_ms": timing.get("duration_ms", 0),
                }

                # Run exchange analyzer on baseline for static finding detection
                try:
                    from lib.exchange_analyzer import get_exchange_analyzer
                    baseline_analysis = get_exchange_analyzer().analyze(
                        request={"method": method, "url": url,
                                 "headers": headers, "parameters": []},
                        response={"status": resp.get("status", 200),
                                  "headers": resp.get("headers", {}),
                                  "body": resp_body[:4096]},
                    )
                    baseline["static_findings"] = {
                        "risk_signals": baseline_analysis.risk_signals,
                        "detected_technologies": baseline_analysis.detected_technologies,
                        "recommended_tests": baseline_analysis.recommended_tests,
                    }
                except Exception:
                    baseline["static_findings"] = {}

                return baseline
        except Exception as exc:
            logger.warning("Baseline request failed: %s", exc)

        return {"status": 0, "body_hash": "", "body_length": 0, "timing_ms": 50,
                "static_findings": {}}

    # ------------------------------------------------------------------
    # Per-test execution
    # ------------------------------------------------------------------

    async def _execute_test(
        self,
        url: str,
        method: str,
        headers: Dict,
        body: str,
        vuln_class: str,
        parameter: str,
        location: str,
        payloads: List[str],
        baseline: Dict[str, Any],
        budget_key: str,
        budget_max: int,
        endpoint_id: str,
    ) -> Dict[str, Any]:
        """Execute payloads for a single (vuln_class, parameter) test."""
        used_before = self._budget_used.get(budget_key, 0)
        remaining = budget_max - used_before

        suspicious_signals: List[Dict[str, Any]] = []
        clean_payloads_sample: List[Dict[str, Any]] = []
        payloads_sent = 0
        confirmed_vulnerable = False
        confirming_payload = ""
        confirming_evidence: List[str] = []
        finding_data: Optional[Dict[str, Any]] = None
        had_errors = False
        all_skipped = True

        for payload_str in payloads:
            if remaining <= 0:
                break

            # Safety check
            safety = self._get_safety_classifier()
            classification = safety.classify_payload(payload_str, vuln_class)
            if classification["level"] == "blocked":
                continue

            all_skipped = False

            # Inject payload
            try:
                injected_url, injected_body, injected_headers = self._inject_payload(
                    url, method, headers, body, parameter, location, payload_str
                )
            except Exception:
                had_errors = True
                continue

            # Send request
            try:
                result = await self._http.send({
                    "method": method,
                    "url": injected_url,
                    "headers": injected_headers,
                    "body": injected_body if injected_body else None,
                })
            except Exception as exc:
                had_errors = True
                continue

            payloads_sent += 1
            self._budget_used[budget_key] = used_before + payloads_sent
            remaining = budget_max - self._budget_used[budget_key]

            if not result.get("success") or not result.get("response"):
                had_errors = True
                continue

            resp = result["response"]

            # Classify response
            cr = self._classifier.classify(
                vuln_class=vuln_class,
                response=resp,
                baseline=baseline,
                payload=payload_str,
                parameter=parameter,
            )

            if cr.is_vulnerable:
                confirmed_vulnerable = True
                confirming_payload = payload_str
                confirming_evidence = cr.evidence

                # Create hypothesis + finding in world model
                finding_data = await self._create_finding(
                    vuln_class=vuln_class,
                    parameter=parameter,
                    payload=payload_str,
                    evidence=cr.evidence,
                    severity=cr.severity,
                    confidence=cr.confidence,
                    endpoint_id=endpoint_id,
                )

                # Update coverage matrix
                await self._update_coverage(
                    endpoint_id=endpoint_id,
                    vuln_class=vuln_class,
                    parameter=parameter,
                    status="vulnerable",
                    finding_id=finding_data.get("finding_id") if finding_data else None,
                )
                break  # Confirmed — no need to send more payloads

            elif cr.confidence >= 0.3:
                # Suspicious signal
                timing = resp.get("timing") or {}
                signal = {
                    "payload": payload_str[:500],
                    "signal": cr.signal_type,
                    "response_status": resp.get("status"),
                    "response_time_ms": timing.get("duration_ms", 0),
                    "baseline_time_ms": baseline.get("timing_ms", 0),
                    "body_snippet": (resp.get("body") or "")[:4096],
                    "confidence": cr.confidence,
                    "evidence": cr.evidence,
                }

                # Run exchange analyzer on suspicious responses for richer context
                try:
                    from lib.exchange_analyzer import get_exchange_analyzer
                    payload_analysis = get_exchange_analyzer().analyze(
                        request={"method": method, "url": url,
                                 "headers": headers, "parameters": []},
                        response={"status": resp.get("status", 0),
                                  "headers": resp.get("headers", {}),
                                  "body": (resp.get("body") or "")[:4096]},
                    )
                    signal["response_analysis"] = {
                        "risk_signals": payload_analysis.risk_signals,
                        "recommended_followup": payload_analysis.recommended_tests,
                    }
                except Exception:
                    pass

                suspicious_signals.append(signal)
            else:
                # Clean
                timing = resp.get("timing") or {}
                if len(clean_payloads_sample) < 3:
                    clean_payloads_sample.append({
                        "payload": payload_str[:100],
                        "response_status": resp.get("status"),
                        "response_time_ms": timing.get("duration_ms", 0),
                    })

        # Determine overall test status
        if confirmed_vulnerable:
            status = "vulnerable"
        elif all_skipped and payloads_sent == 0:
            status = "skipped"
        elif had_errors and payloads_sent == 0:
            status = "error"
        elif suspicious_signals:
            status = "suspicious"
        else:
            status = "clean"

        # Update coverage matrix for non-vulnerable results
        # (vulnerable results already updated in the per-payload loop above)
        if not confirmed_vulnerable and endpoint_id:
            cm_status = "passed" if status == "clean" else status
            if cm_status in ("passed", "suspicious", "error", "skipped"):
                await self._update_coverage(
                    endpoint_id=endpoint_id,
                    vuln_class=vuln_class,
                    parameter=parameter,
                    status=cm_status,
                )

        result_dict: Dict[str, Any] = {
            "vuln_class": vuln_class,
            "parameter": parameter,
            "location": location,
            "status": status,
            "payloads_sent": payloads_sent,
            "confirmed_vulnerable": confirmed_vulnerable,
            "suspicious_signals": suspicious_signals,
            "clean_payloads_sample": clean_payloads_sample,
        }

        if confirmed_vulnerable:
            result_dict["confirming_payload"] = confirming_payload
            result_dict["evidence"] = confirming_evidence
            result_dict["finding"] = finding_data

        return result_dict

    # ------------------------------------------------------------------
    # Payload resolution
    # ------------------------------------------------------------------

    def _resolve_payloads(
        self,
        vuln_class: str,
        use_library: bool,
        explicit_payloads: List[str],
        parameter_metadata: Optional[Dict[str, Any]] = None,
        endpoint_context: Optional[Dict[str, Any]] = None,
    ) -> List[str]:
        """Resolve payload strings from library or explicit list."""
        if explicit_payloads:
            return [str(p) for p in explicit_payloads]

        if not use_library:
            return []

        return self._load_library_payloads(
            vuln_class,
            parameter_metadata=parameter_metadata,
            endpoint_context=endpoint_context,
        )

    def _load_library_payloads(
        self,
        vuln_class: str,
        parameter_metadata: Optional[Dict[str, Any]] = None,
        endpoint_context: Optional[Dict[str, Any]] = None,
    ) -> List[str]:
        """Load curated payloads from the payload libraries.

        When *endpoint_context* or *parameter_metadata* are provided,
        payloads are tailored to the detected environment (e.g. DB-specific
        SQLi, context-aware XSS) and schema-aware boundary/type-confusion
        payloads are appended.
        """
        # Normalize split vuln IDs to base class for payload loading
        _VULN_CLASS_ALIASES = {
            "sqli_error": "sqli", "sqli_blind_boolean": "sqli",
            "sqli_blind_time": "sqli", "sqli_union": "sqli",
            "xss_reflected": "xss", "xss_stored": "xss", "xss_dom": "xss",
        }
        vuln_class = _VULN_CLASS_ALIASES.get(vuln_class, vuln_class)

        payloads: List[str] = []
        ctx = endpoint_context or {}

        try:
            if vuln_class == "sqli":
                db_type = ctx.get("db_type", "")
                if db_type and db_type != "generic":
                    from lib.payload_generator import PayloadGenerator
                    gen = PayloadGenerator(max_payloads=30)
                    raw = gen.get_db_payloads(db_type=db_type)
                    payloads = [str(p["value"]) for p in raw if p.get("value") is not None][:30]
                else:
                    from lib.sql_payloads import get_sql_payloads
                    payloads = [p.payload for p in get_sql_payloads()][:30]

            elif vuln_class == "xss":
                from lib.xss_payloads import get_all_payloads_flat
                all_xss = get_all_payloads_flat()
                resp_type = ctx.get("response_type", "")
                if resp_type == "json":
                    # JSON responses: skip DOM payloads, prefer WAF-bypass/polyglot
                    filtered = [p for p in all_xss if p.technique != "dom_based"]
                    payloads = [p.payload for p in filtered][:20]
                else:
                    payloads = [p.payload for p in all_xss][:20]

            elif vuln_class == "ssrf":
                from lib.ssrf_payloads import get_all_payloads_flat
                payloads = [p.payload for p in get_all_payloads_flat()][:15]

            elif vuln_class == "ssti":
                from lib.ssti_payloads import get_all_payloads_flat
                payloads = [p.payload for p in get_all_payloads_flat()][:15]

            elif vuln_class == "path_traversal":
                from lib.path_traversal_payloads import get_all_payloads_flat
                payloads = [p.payload for p in get_all_payloads_flat()][:15]

            elif vuln_class in ("injection", "overflow", "type_confusion"):
                from lib.payload_generator import PayloadGenerator
                gen = PayloadGenerator(max_payloads=15)
                type_map = {
                    "injection": ["injection"],
                    "overflow": ["overflow", "boundary"],
                    "type_confusion": ["type_confusion"],
                }
                raw = gen.get_payloads(type_map.get(vuln_class, ["injection"]))
                payloads = [str(p["value"]) for p in raw if p.get("value") is not None][:15]

            elif vuln_class == "command_injection":
                from lib.cmdi_payloads import get_cmdi_payloads
                payloads = [p.payload for p in get_cmdi_payloads()][:20]

            elif vuln_class == "nosql_injection":
                from lib.nosql_payloads import get_nosql_payloads
                payloads = [p.payload for p in get_nosql_payloads()][:20]

            elif vuln_class == "xml_injection":
                from lib.xxe_payloads import get_xxe_payloads
                payloads = [p.payload for p in get_xxe_payloads()][:15]

            elif vuln_class == "header_injection":
                from lib.header_injection_payloads import get_header_injection_payloads
                payloads = [p.payload for p in get_header_injection_payloads()][:15]

            elif vuln_class == "open_redirect":
                from lib.redirect_payloads import get_redirect_payloads
                payloads = [p.payload for p in get_redirect_payloads()][:15]

            elif vuln_class == "jwt_manipulation":
                from lib.jwt_payloads import get_jwt_payloads, build_jwt_token
                payloads = [build_jwt_token(p) for p in get_jwt_payloads()][:10]

            elif vuln_class == "cors_misconfig":
                from lib.cors_payloads import get_cors_payloads
                payloads = [p.origin_header for p in get_cors_payloads()][:10]

            # Append schema-aware payloads when parameter metadata is available
            if parameter_metadata:
                try:
                    from lib.payload_generator import PayloadGenerator
                    gen = PayloadGenerator(max_payloads=10)
                    schema_payloads = gen.generate_for_parameter(
                        parameter_metadata, types=["boundary", "type_confusion"]
                    )
                    extra = [str(p["value"]) for p in schema_payloads if p.get("value") is not None][:10]
                    # Deduplicate against existing payloads
                    existing_set = set(payloads)
                    for ep in extra:
                        if ep not in existing_set:
                            payloads.append(ep)
                            existing_set.add(ep)
                except (ImportError, Exception) as exc:
                    logger.debug("Schema-aware payload generation failed: %s", exc)

        except ImportError as exc:
            logger.warning("Failed to load payload library for %s: %s", vuln_class, exc)

        return payloads

    # ------------------------------------------------------------------
    # Payload injection
    # ------------------------------------------------------------------

    @staticmethod
    def _inject_payload(
        url: str,
        method: str,
        headers: Dict[str, str],
        body: str,
        parameter: str,
        location: str,
        payload: str,
    ) -> tuple:
        """Inject payload into the specified location.

        Returns (url, body, headers) tuple with the payload injected.
        """
        injected_url = url
        injected_body = body
        injected_headers = dict(headers)

        if location == "query":
            parsed = urlparse(url)
            params = parse_qs(parsed.query, keep_blank_values=True)
            params[parameter] = [payload]
            new_query = urlencode(params, doseq=True)
            injected_url = urlunparse(parsed._replace(query=new_query))

        elif location == "body":
            if body.strip().startswith("{"):
                # JSON body
                try:
                    body_dict = json.loads(body)
                    body_dict[parameter] = payload
                    injected_body = json.dumps(body_dict)
                except (json.JSONDecodeError, TypeError):
                    # Fallback: form-encoded
                    params = parse_qs(body, keep_blank_values=True)
                    params[parameter] = [payload]
                    injected_body = urlencode(params, doseq=True)
            else:
                # Form-encoded body
                params = parse_qs(body, keep_blank_values=True)
                params[parameter] = [payload]
                injected_body = urlencode(params, doseq=True)

        elif location == "path":
            injected_url = url.replace(f"{{{parameter}}}", payload)

        elif location == "header":
            injected_headers[parameter] = payload

        elif location == "cookie":
            existing = injected_headers.get("Cookie", "")
            sep = "; " if existing else ""
            injected_headers["Cookie"] = f"{existing}{sep}{parameter}={payload}"

        return injected_url, injected_body, injected_headers

    # ------------------------------------------------------------------
    # Finding creation
    # ------------------------------------------------------------------

    async def _create_finding(
        self,
        vuln_class: str,
        parameter: str,
        payload: str,
        evidence: List[str],
        severity: str,
        confidence: float,
        endpoint_id: str,
    ) -> Dict[str, Any]:
        """Create a hypothesis and finding in the world model."""
        try:
            hyp = await self._db.add_hypothesis(
                title=f"{vuln_class.upper()} in parameter '{parameter}'",
                description=f"Automated test detected {vuln_class} vulnerability "
                            f"in parameter '{parameter}' using payload: {payload[:100]}",
                severity=severity,
                target_id=endpoint_id or None,
            )
            await self._db.update_hypothesis(
                hypothesis_id=hyp["id"],
                status="confirmed",
                evidence=evidence,
            )
            finding = await self._db.add_finding(
                hypothesis_id=hyp["id"],
                title=f"{vuln_class.upper()} vulnerability in '{parameter}'",
                severity=severity,
                confidence=confidence,
                evidence_ids=[],
                metadata={
                    "vuln_class": vuln_class,
                    "parameter": parameter,
                    "payload": payload[:200],
                    "endpoint_id": endpoint_id,
                    "detection": "deterministic_test_plan_executor",
                },
            )

            # Round 11 Fix 1C: Bridge finding to card system
            if self._mcp_service:
                try:
                    evidence_summary = "; ".join([str(e)[:100] for e in evidence[:3]])
                    await self._mcp_service.safe_add_card(
                        card_type="finding",
                        title=f"{vuln_class.upper()} vulnerability in '{parameter}'",
                        severity=severity,
                        target_service=endpoint_id,
                        technical_analysis=f"Payload: {payload[:200]}\nEvidence: {evidence_summary}",
                        context="Detected by deterministic test plan executor",
                    )
                except Exception as card_err:
                    logger.debug(f"Failed to create card for finding: {card_err}")

            return {
                "hypothesis_id": hyp["id"],
                "finding_id": finding["id"],
                "title": finding["title"],
                "severity": severity,
                "confidence": confidence,
            }
        except Exception as exc:
            logger.warning("Failed to create finding: %s", exc)
            return {}

    # ------------------------------------------------------------------
    # Coverage matrix update
    # ------------------------------------------------------------------

    async def _update_coverage(
        self,
        endpoint_id: str,
        vuln_class: str,
        parameter: str,
        status: str,
        finding_id: Optional[str] = None,
    ) -> None:
        """Update the coverage matrix cell for this (endpoint, vuln_class, parameter)."""
        if not endpoint_id:
            return
        try:
            # Find the coverage cell
            rows = await self._db._fetchall(
                "SELECT id FROM wm_coverage_matrix "
                "WHERE assessment_id = $1 AND endpoint_id = $2 AND vuln_class = $3 AND parameter = $4",
                (self._db._assessment_id, endpoint_id, vuln_class, parameter),
            )
            for row in rows:
                cell_id = dict(row)["id"]
                await self._db.coverage_mark(
                    cell_id=cell_id,
                    status=status,
                    finding_id=finding_id,
                    result_summary=f"Tested by endpoint_execute_plan",
                )
        except Exception as exc:
            logger.warning("Failed to update coverage: %s", exc)

    # ------------------------------------------------------------------
    # Adaptive hints
    # ------------------------------------------------------------------

    def _generate_adaptive_hints(self, results: List[Dict[str, Any]]) -> str:
        """Generate a summary of suspicious signals to guide LLM payload crafting."""
        suspicious = [r for r in results if r.get("status") == "suspicious"]
        if not suspicious:
            return ""

        hints: List[str] = []
        for r in suspicious:
            vc = r["vuln_class"]
            param = r["parameter"]
            signals = r.get("suspicious_signals", [])
            if not signals:
                continue

            signal_summaries: List[str] = []
            for s in signals[:3]:  # Top 3 signals
                signal_summaries.append(
                    f"payload '{s.get('payload', '')[:50]}' -> "
                    f"{s.get('signal', 'unknown')} "
                    f"(status={s.get('response_status')}, "
                    f"time={s.get('response_time_ms', 0):.0f}ms)"
                )

            hint = (
                f"{vc}:{param} — {len(signals)} suspicious signal(s): "
                + "; ".join(signal_summaries)
                + ". Consider crafting targeted payloads based on these patterns."
            )
            hints.append(hint)

        if hints:
            return (
                "Review 'suspicious' results above. "
                + " | ".join(hints)
                + " Call endpoint_execute_plan again with explicit payloads[] "
                "for suspicious tests."
            )
        return ""
