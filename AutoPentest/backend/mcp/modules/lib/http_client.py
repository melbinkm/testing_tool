"""
HTTP Client with Correlation Headers, Rate Limiting, and Proxy Support

Sends HTTP requests with:
- Rate limiting (token bucket)
- Concurrency limiting (semaphore)
- Correlation headers for request tracking
- Optional proxy routing (for Burp Suite)
- Total request budget enforcement

Uses httpx (async) as the HTTP backend.

Ported from http-client-mcp/src/http-client.ts
"""

import asyncio
import time
import uuid

import httpx

from lib.rate_limiter import RateLimiter
from lib.concurrency_limiter import ConcurrencyLimiter


# ---------------------------------------------------------------------------
# Custom exceptions (ported from errors.ts)
# ---------------------------------------------------------------------------

class HttpClientError(Exception):
    """Base error class for HTTP client errors."""

    def __init__(self, code: str, message: str) -> None:
        super().__init__(message)
        self.code: str = code


class BudgetExhaustedError(HttpClientError):
    """Thrown when the total request budget is exhausted."""

    def __init__(self, total_requests: int, max_requests: int) -> None:
        super().__init__(
            "BUDGET_EXHAUSTED",
            f"Request budget exhausted: {total_requests}/{max_requests} requests used",
        )
        self.total_requests: int = total_requests
        self.max_requests: int = max_requests


class RequestTimeoutError(HttpClientError):
    """Thrown when a request times out."""

    def __init__(self, url: str, timeout_ms: float) -> None:
        super().__init__(
            "REQUEST_TIMEOUT",
            f"Request to {url} timed out after {timeout_ms}ms",
        )
        self.url: str = url
        self.timeout_ms: float = timeout_ms


# ---------------------------------------------------------------------------
# HttpClient
# ---------------------------------------------------------------------------

class HttpClient:
    """
    Async HTTP client with rate limiting, concurrency control, correlation
    headers, proxy support, and request budget enforcement.
    """

    def __init__(self, config: dict) -> None:
        """
        Create a new HTTP client.

        Args:
            config: Dictionary with the following keys:
                - engagement_id (str): Unique engagement identifier.
                - proxy_url (str | None): Optional proxy URL (e.g. for Burp Suite).
                - max_rps (float): Maximum requests per second.
                - max_concurrent (int): Maximum concurrent requests.
                - default_timeout (float): Default request timeout in milliseconds.
                - max_total_requests (int): Total request budget.
        """
        self._config: dict = config
        self._rate_limiter = RateLimiter(config["max_rps"])
        self._concurrency_limiter = ConcurrencyLimiter(config["max_concurrent"])

        self._total_requests: int = 0
        self._successful_requests: int = 0
        self._failed_requests: int = 0
        self._current_action_id: str = str(uuid.uuid4())

    # ------------------------------------------------------------------
    # Action management
    # ------------------------------------------------------------------

    def new_action(self) -> str:
        """
        Generate a new action ID for grouping related requests.

        Returns:
            The newly generated action UUID string.
        """
        self._current_action_id = str(uuid.uuid4())
        return self._current_action_id

    def get_action_id(self) -> str:
        """Get the current action ID."""
        return self._current_action_id

    # ------------------------------------------------------------------
    # Correlation headers
    # ------------------------------------------------------------------

    def _build_correlation_headers(self, identity_id: str | None = None) -> dict:
        """
        Build correlation headers for request tracking.

        Args:
            identity_id: Optional identity identifier for multi-identity flows.

        Returns:
            Dictionary of correlation HTTP headers.
        """
        headers: dict = {
            "X-Engagement-ID": self._config["engagement_id"],
            "X-Action-ID": self._current_action_id,
            "X-Request-ID": str(uuid.uuid4()),
        }

        if identity_id:
            headers["X-Identity-ID"] = identity_id

        return headers

    # ------------------------------------------------------------------
    # Send single request
    # ------------------------------------------------------------------

    async def send(self, request: dict, identity_id: str | None = None) -> dict:
        """
        Send a single HTTP request with rate limiting, concurrency control,
        correlation headers, and budget enforcement.

        Args:
            request: Dictionary with keys:
                - method (str): HTTP method (GET, POST, PUT, DELETE, etc.).
                - url (str): Target URL.
                - headers (dict | None): Optional request headers.
                - body (str | None): Optional request body.
                - timeout (float | None): Optional per-request timeout in ms.
            identity_id: Optional identity ID for correlation.

        Returns:
            Dictionary with keys:
                - success (bool)
                - correlation_ids (dict)
                - request (dict): Echoed request info.
                - response (dict | None): Present on success.
                - error (dict | None): Present on failure.

        Raises:
            BudgetExhaustedError: If the total request budget is exhausted.
            RequestTimeoutError: If the request times out.
        """
        # Check budget BEFORE rate limiting (fail fast)
        if self._total_requests >= self._config["max_total_requests"]:
            raise BudgetExhaustedError(
                self._total_requests, self._config["max_total_requests"]
            )

        # Wait for rate limit token
        await self._rate_limiter.wait_for_token()

        # Wait for concurrency slot
        await self._concurrency_limiter.acquire()

        correlation_headers = self._build_correlation_headers(identity_id)
        correlation_ids: dict = {
            "engagement_id": self._config["engagement_id"],
            "action_id": self._current_action_id,
            "request_id": correlation_headers["X-Request-ID"],
            "identity_id": identity_id,
        }

        # Merge headers (request headers first, then correlation headers override)
        merged_headers: dict = {
            **(request.get("headers") or {}),
            **correlation_headers,
        }

        timeout_ms = request.get("timeout") or self._config["default_timeout"]
        timeout_seconds = timeout_ms / 1000.0
        start_time_ms = time.time() * 1000  # milliseconds for timing consistency

        try:
            self._total_requests += 1

            # Build httpx timeout
            httpx_timeout = httpx.Timeout(timeout_seconds)

            # Build client kwargs
            client_kwargs: dict = {
                "timeout": httpx_timeout,
                "verify": False,  # Pen-testing context; target certs may be untrusted
            }

            # Add proxy if configured
            proxy_url = self._config.get("proxy_url")
            if proxy_url:
                client_kwargs["proxy"] = proxy_url

            async with httpx.AsyncClient(**client_kwargs) as client:
                response = await client.request(
                    method=request["method"],
                    url=request["url"],
                    headers=merged_headers,
                    content=request.get("body"),
                )

            end_time_ms = time.time() * 1000

            # Convert response headers to a plain dict
            response_headers: dict = dict(response.headers)

            http_response: dict = {
                "status": response.status_code,
                "status_text": response.reason_phrase or "",
                "headers": response_headers,
                "body": response.text,
                "timing": {
                    "start_time": start_time_ms,
                    "end_time": end_time_ms,
                    "duration_ms": end_time_ms - start_time_ms,
                },
            }

            self._successful_requests += 1

            return {
                "success": True,
                "correlation_ids": correlation_ids,
                "request": {
                    "method": request["method"],
                    "url": request["url"],
                    "headers": merged_headers,
                },
                "response": http_response,
            }

        except httpx.TimeoutException:
            self._failed_requests += 1
            raise RequestTimeoutError(request["url"], timeout_ms)

        except HttpClientError:
            # Re-raise our own errors without wrapping
            raise

        except Exception as exc:
            self._failed_requests += 1

            return {
                "success": False,
                "correlation_ids": correlation_ids,
                "request": {
                    "method": request["method"],
                    "url": request["url"],
                    "headers": merged_headers,
                },
                "error": {
                    "code": "REQUEST_ERROR",
                    "message": str(exc),
                },
            }

        finally:
            self._concurrency_limiter.release()

    # ------------------------------------------------------------------
    # Send batch
    # ------------------------------------------------------------------

    async def send_batch(self, items: list) -> dict:
        """
        Send multiple requests with concurrency control via asyncio.gather.

        Each item in *items* is a dict with:
            - request (dict): The HTTP request (same schema as send()).
            - identity_id (str | None): Optional identity ID.

        A new action ID is generated for the entire batch.

        Returns:
            Dictionary with keys:
                - total (int)
                - successful (int)
                - failed (int)
                - results (list[dict])
        """
        # Start a new action for the batch
        self.new_action()

        successful = 0
        failed = 0

        async def _execute_item(item: dict) -> dict:
            nonlocal successful, failed
            try:
                result = await self.send(
                    item["request"], item.get("identity_id")
                )
                if result["success"]:
                    successful += 1
                else:
                    failed += 1
                return result
            except Exception as exc:
                failed += 1
                correlation_ids: dict = {
                    "engagement_id": self._config["engagement_id"],
                    "action_id": self._current_action_id,
                    "request_id": str(uuid.uuid4()),
                    "identity_id": item.get("identity_id"),
                }
                error_code = (
                    exc.code if isinstance(exc, HttpClientError) else "REQUEST_ERROR"
                )
                return {
                    "success": False,
                    "correlation_ids": correlation_ids,
                    "request": {
                        "method": item["request"]["method"],
                        "url": item["request"]["url"],
                        "headers": item["request"].get("headers") or {},
                    },
                    "error": {
                        "code": error_code,
                        "message": str(exc),
                    },
                }

        results = await asyncio.gather(*[_execute_item(item) for item in items])

        return {
            "total": len(items),
            "successful": successful,
            "failed": failed,
            "results": list(results),
        }

    # ------------------------------------------------------------------
    # Stats / budget helpers
    # ------------------------------------------------------------------

    def get_stats(self) -> dict:
        """
        Get HTTP client statistics.

        Returns:
            Dictionary with keys:
                - engagement_id (str)
                - total_requests (int)
                - successful_requests (int)
                - failed_requests (int)
                - remaining_budget (int)
                - rate_limiter (dict): From RateLimiter.get_status().
                - concurrency_limiter (dict): From ConcurrencyLimiter.get_status().
        """
        return {
            "engagement_id": self._config["engagement_id"],
            "total_requests": self._total_requests,
            "successful_requests": self._successful_requests,
            "failed_requests": self._failed_requests,
            "remaining_budget": (
                self._config["max_total_requests"] - self._total_requests
            ),
            "rate_limiter": self._rate_limiter.get_status(),
            "concurrency_limiter": self._concurrency_limiter.get_status(),
        }

    def get_remaining_budget(self) -> int:
        """Get the number of remaining requests in the budget."""
        return self._config["max_total_requests"] - self._total_requests

    def is_budget_exhausted(self) -> bool:
        """Check if the request budget is exhausted."""
        return self._total_requests >= self._config["max_total_requests"]

    def reset_stats(self) -> None:
        """Reset all statistics and limiters to initial state."""
        self._total_requests = 0
        self._successful_requests = 0
        self._failed_requests = 0
        self._rate_limiter.reset()
        self._concurrency_limiter.reset()
        self._current_action_id = str(uuid.uuid4())
