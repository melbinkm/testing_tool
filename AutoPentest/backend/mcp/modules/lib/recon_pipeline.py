"""
Recon Pipeline - 6-stage automated reconnaissance orchestrator.

Calls existing mcp_service methods in sequence, auto-saves results to
the world model and backend, and tracks progress via the plans table.

Stages:
    0: subdomain_enum
    1: nmap_quick
    2: tech_detection
    3: ssl_analysis
    4: directory_discovery
    5: nuclei_scan
"""

from __future__ import annotations

import asyncio
import logging
import re
from typing import Any, Dict, List, Optional

logger = logging.getLogger("autopentest-mcp")

# Stage definitions
STAGES = [
    {"index": 0, "name": "subdomain_enum", "description": "Subdomain enumeration"},
    {"index": 1, "name": "nmap_quick", "description": "Quick Nmap port/service scan"},
    {"index": 2, "name": "tech_detection", "description": "Technology stack detection"},
    {"index": 3, "name": "ssl_analysis", "description": "SSL/TLS analysis"},
    {"index": 4, "name": "directory_discovery", "description": "Directory and endpoint discovery"},
    {"index": 5, "name": "nuclei_scan", "description": "Nuclei vulnerability scan (info/low)"},
]

STAGE_NAMES = [s["name"] for s in STAGES]


class ReconPipeline:
    """6-stage automated reconnaissance pipeline.

    Uses plan-based state tracking for idempotent resumption.
    Each stage calls existing mcp_service methods.
    """

    def __init__(self, mcp_service: Any, max_parallel: int = 3):
        self.mcp_service = mcp_service
        self.max_parallel = max_parallel
        self._semaphore = asyncio.Semaphore(max_parallel)
        self._db = None
        self._plan_id: Optional[str] = None
        self._results: Dict[str, Any] = {
            "subdomains": [],
            "live_hosts": [],
            "services": [],
            "endpoints": [],
            "findings": [],
            "technologies": [],
        }

    async def _get_db(self):
        """Get the world model database."""
        if self._db is None:
            from lib.world_model_db import get_world_model_db
            self._db = await get_world_model_db(self.mcp_service.current_assessment_id)
        return self._db

    async def _get_or_create_plan(self, domain: str) -> str:
        """Find existing plan or create a new one for this domain."""
        db = await self._get_db()
        plans = await db.query(table="plans", filters={"status": "active"}, limit=100)
        plan_title = f"Recon Pipeline: {domain}"

        for plan in plans:
            if plan.get("title") == plan_title:
                self._plan_id = plan["id"]
                return plan["id"]

        plan = await db.add_plan(
            title=plan_title,
            goal=f"Automated reconnaissance of {domain}",
            steps=[{"description": s["description"]} for s in STAGES],
        )
        self._plan_id = plan["id"]
        return plan["id"]

    async def _update_step(self, step_index: int, status: str, result: str = ""):
        """Update a plan step status."""
        if not self._plan_id:
            return
        db = await self._get_db()
        try:
            await db.update_plan(
                plan_id=self._plan_id,
                step_index=step_index,
                step_status=status,
                step_result=result,
            )
        except Exception as exc:
            logger.warning("Failed to update plan step %d: %s", step_index, exc)

    async def _get_step_status(self, step_index: int) -> str:
        """Get the current status of a plan step."""
        if not self._plan_id:
            return "pending"
        db = await self._get_db()
        plan = await db.get_by_id("plans", self._plan_id)
        if not plan:
            return "pending"
        steps = plan.get("steps", [])
        if step_index < len(steps):
            return steps[step_index].get("status", "pending")
        return "pending"

    def _get_container(self) -> Optional[str]:
        """Get the Kali container name from the assessment."""
        try:
            return getattr(self.mcp_service, "container_name", None) or "kali"
        except Exception:
            return "kali"

    # ------------------------------------------------------------------
    # Main run method
    # ------------------------------------------------------------------

    async def run(
        self,
        target_domain: str,
        skip_stages: Optional[List[str]] = None,
        resume: bool = True,
    ) -> Dict[str, Any]:
        """Execute the full 6-stage recon pipeline.

        Returns a summary of discovered assets, services, endpoints, and findings.
        """
        skip_stages = skip_stages or []
        plan_id = await self._get_or_create_plan(target_domain)

        stage_results = {}
        for stage in STAGES:
            stage_name = stage["name"]
            step_idx = stage["index"]

            # Skip if requested
            if stage_name in skip_stages:
                await self._update_step(step_idx, "skipped", "Skipped by user")
                stage_results[stage_name] = {"status": "skipped"}
                continue

            # Check for resume: skip completed steps
            if resume:
                current_status = await self._get_step_status(step_idx)
                if current_status == "done":
                    stage_results[stage_name] = {"status": "already_done"}
                    continue

            # Mark in progress
            await self._update_step(step_idx, "in_progress")

            try:
                result = await self._run_stage(stage_name, target_domain)
                await self._update_step(step_idx, "done", str(result.get("summary", "")))
                stage_results[stage_name] = {"status": "done", **result}
            except Exception as exc:
                error_msg = f"Stage {stage_name} failed: {exc}"
                logger.error(error_msg, exc_info=True)
                await self._update_step(step_idx, "done", f"ERROR: {error_msg}")
                stage_results[stage_name] = {"status": "error", "error": str(exc)}

        # After completion, populate world model with discovered assets
        await self._populate_world_model(target_domain)

        return {
            "plan_id": plan_id,
            "domain": target_domain,
            "stages": stage_results,
            "results": self._results,
            "summary": {
                "subdomains": len(self._results["subdomains"]),
                "live_hosts": len(self._results["live_hosts"]),
                "services": len(self._results["services"]),
                "endpoints": len(self._results["endpoints"]),
                "findings": len(self._results["findings"]),
                "technologies": len(self._results["technologies"]),
            },
            "next_step": "Run coverage_init to build the test matrix for discovered endpoints.",
        }

    # ------------------------------------------------------------------
    # Stage dispatch
    # ------------------------------------------------------------------

    async def _run_stage(self, stage_name: str, domain: str) -> Dict[str, Any]:
        """Run a single recon stage."""
        if stage_name == "subdomain_enum":
            return await self._stage_subdomain_enum(domain)
        elif stage_name == "nmap_quick":
            return await self._stage_nmap_quick(domain)
        elif stage_name == "tech_detection":
            return await self._stage_tech_detection(domain)
        elif stage_name == "ssl_analysis":
            return await self._stage_ssl_analysis(domain)
        elif stage_name == "directory_discovery":
            return await self._stage_directory_discovery(domain)
        elif stage_name == "nuclei_scan":
            return await self._stage_nuclei_scan(domain)
        else:
            return {"summary": f"Unknown stage: {stage_name}"}

    # ------------------------------------------------------------------
    # Individual stages
    # ------------------------------------------------------------------

    async def _stage_subdomain_enum(self, domain: str) -> Dict[str, Any]:
        """Stage 0: Subdomain enumeration."""
        try:
            result = await self.mcp_service.subdomain_enumeration(domain)
            stdout = result.get("stdout", "")

            # Parse subdomains from output
            subdomains = []
            for line in stdout.splitlines():
                line = line.strip()
                if line and "." in line and not line.startswith("#"):
                    subdomains.append(line)

            self._results["subdomains"] = subdomains
            self._results["live_hosts"].extend(subdomains)

            # Save to recon
            if subdomains and self.mcp_service:
                await self.mcp_service.safe_add_recon_batch(
                    items=[{
                        "data_type": "subdomain",
                        "name": sub,
                        "details": {"source": "recon_pipeline"},
                        "phase": "reconnaissance",
                    } for sub in subdomains]
                )

            return {
                "summary": f"Found {len(subdomains)} subdomains",
                "count": len(subdomains),
            }
        except Exception as exc:
            logger.error("Subdomain enum failed: %s", exc)
            return {"summary": f"Failed: {exc}", "count": 0}

    async def _stage_nmap_quick(self, domain: str) -> Dict[str, Any]:
        """Stage 1: Quick Nmap scan on discovered hosts."""
        hosts = self._results.get("live_hosts", [domain])
        if not hosts:
            hosts = [domain]

        services_found = []
        container = self._get_container()

        async def scan_host(host: str):
            async with self._semaphore:
                try:
                    cmd = f"nmap -sV -F --open {host} -oN -"
                    result = await self.mcp_service.execute_container_command(container, cmd)
                    stdout = result.get("stdout", "")

                    # Auto-save scan results
                    try:
                        from tools_scanning import _autosave_scan_results
                        await _autosave_scan_results("nmap", host, stdout, self.mcp_service)
                    except Exception:
                        pass

                    # Parse services
                    for line in stdout.splitlines():
                        if "/tcp" in line and "open" in line:
                            services_found.append({"host": host, "line": line.strip()})

                    return {"host": host, "status": "done"}
                except Exception as exc:
                    return {"host": host, "status": "error", "error": str(exc)}

        tasks = [scan_host(h) for h in hosts[:20]]  # Cap at 20 hosts
        await asyncio.gather(*tasks, return_exceptions=True)

        self._results["services"] = services_found

        return {
            "summary": f"Scanned {len(hosts)} hosts, found {len(services_found)} services",
            "hosts_scanned": len(hosts),
            "services_found": len(services_found),
        }

    async def _stage_tech_detection(self, domain: str) -> Dict[str, Any]:
        """Stage 2: Technology stack detection."""
        hosts = self._results.get("live_hosts", [domain])
        if not hosts:
            hosts = [domain]

        techs = []
        for host in hosts[:10]:
            try:
                url = f"https://{host}" if not host.startswith("http") else host
                result = await self.mcp_service.tech_stack_detection(url)
                stdout = result.get("stdout", "")
                if stdout:
                    techs.append({"host": host, "output": stdout[:500]})

                    # Store in knowledge store
                    db = await self._get_db()
                    try:
                        await db.store_knowledge(
                            source_tool="recon_pipeline",
                            category="scan_output",
                            title=f"Tech detection: {host}",
                            content=stdout,
                            target=host,
                        )
                    except Exception:
                        pass
            except Exception as exc:
                logger.warning("Tech detection failed for %s: %s", host, exc)

        self._results["technologies"] = techs

        return {
            "summary": f"Detected tech on {len(techs)} hosts",
            "hosts_checked": len(hosts),
        }

    async def _stage_ssl_analysis(self, domain: str) -> Dict[str, Any]:
        """Stage 3: SSL/TLS analysis."""
        hosts = self._results.get("live_hosts", [domain])
        if not hosts:
            hosts = [domain]

        analyzed = 0
        for host in hosts[:10]:
            try:
                result = await self.mcp_service.ssl_analysis(host)
                stdout = result.get("stdout", "")
                if stdout:
                    analyzed += 1
                    db = await self._get_db()
                    try:
                        await db.store_knowledge(
                            source_tool="recon_pipeline",
                            category="scan_output",
                            title=f"SSL analysis: {host}",
                            content=stdout,
                            target=host,
                        )
                    except Exception:
                        pass
            except Exception as exc:
                logger.warning("SSL analysis failed for %s: %s", host, exc)

        return {
            "summary": f"SSL analysis completed on {analyzed} hosts",
            "hosts_analyzed": analyzed,
        }

    async def _stage_directory_discovery(self, domain: str) -> Dict[str, Any]:
        """Stage 4: Directory and endpoint discovery via gobuster."""
        hosts = self._results.get("live_hosts", [domain])
        if not hosts:
            hosts = [domain]

        endpoints_found = []
        container = self._get_container()

        async def discover_host(host: str):
            async with self._semaphore:
                try:
                    url = f"https://{host}" if not host.startswith("http") else host
                    cmd = (
                        f"gobuster dir -u {url} -w /usr/share/wordlists/dirb/common.txt "
                        f"-t 20 -q --no-error"
                    )
                    result = await self.mcp_service.execute_container_command(container, cmd)
                    stdout = result.get("stdout", "")

                    # Auto-save scan results
                    try:
                        from tools_scanning import _autosave_scan_results
                        await _autosave_scan_results("gobuster", host, stdout, self.mcp_service)
                    except Exception:
                        pass

                    # Parse discovered paths
                    for line in stdout.splitlines():
                        line = line.strip()
                        if line.startswith("/") or ("Status:" in line and "(Status:" not in line):
                            path_match = re.match(r"^(/\S+)", line)
                            if path_match:
                                endpoints_found.append({
                                    "host": host,
                                    "path": path_match.group(1),
                                })

                    return {"host": host, "status": "done"}
                except Exception as exc:
                    return {"host": host, "status": "error", "error": str(exc)}

        tasks = [discover_host(h) for h in hosts[:10]]
        await asyncio.gather(*tasks, return_exceptions=True)

        self._results["endpoints"] = endpoints_found

        return {
            "summary": f"Discovered {len(endpoints_found)} endpoints across {len(hosts)} hosts",
            "endpoints_found": len(endpoints_found),
        }

    async def _stage_nuclei_scan(self, domain: str) -> Dict[str, Any]:
        """Stage 5: Nuclei scan with info/low templates."""
        hosts = self._results.get("live_hosts", [domain])
        if not hosts:
            hosts = [domain]

        targets = []
        for host in hosts[:20]:
            url = f"https://{host}" if not host.startswith("http") else host
            targets.append(url)

        findings_count = 0
        try:
            from lib.nuclei_runner import NucleiRunner
            runner = NucleiRunner(self.mcp_service)
            result = await runner.scan_with_templates(
                targets=targets,
                severity=["info", "low"],
                timeout=300,
            )

            findings = result.get("findings", [])
            findings_count = len(findings)
            self._results["findings"] = findings

            # Save findings as cards
            for finding in findings:
                try:
                    await self.mcp_service.safe_add_card(
                        card_type="observation",
                        title=finding.get("name", "Nuclei finding"),
                        severity=finding.get("severity", "INFO").upper(),
                        status="potential",
                        technical_analysis=finding.get("description", ""),
                        notes=f"Source: nuclei recon scan\nTemplate: {finding.get('template_id', '')}",
                        context=f"Target: {finding.get('host', '')}",
                    )
                except Exception:
                    pass

        except Exception as exc:
            logger.error("Nuclei scan failed: %s", exc)
            return {"summary": f"Nuclei scan failed: {exc}", "findings": 0}

        return {
            "summary": f"Nuclei scan found {findings_count} findings",
            "findings": findings_count,
        }

    # ------------------------------------------------------------------
    # Post-pipeline world model population
    # ------------------------------------------------------------------

    async def _populate_world_model(self, domain: str) -> None:
        """After pipeline completion, ensure WM has assets + endpoints + relationships."""
        db = await self._get_db()

        try:
            # Add root domain as asset
            root_asset = await db.add_asset(kind="domain", name=domain)
            root_id = root_asset["id"]

            # Add subdomains as assets with relationships
            for sub in self._results.get("subdomains", []):
                try:
                    sub_asset = await db.add_asset(kind="subdomain", name=sub)
                    await db.add_relationship(
                        source_type="asset", source_id=root_id,
                        target_type="asset", target_id=sub_asset["id"],
                        rel_type="domain_has_subdomain",
                    )
                except Exception:
                    pass

            # Add discovered endpoints
            for ep in self._results.get("endpoints", []):
                try:
                    path = ep.get("path", "/")
                    await db.add_endpoint(
                        asset_id=root_id,
                        method="GET",
                        path=path,
                    )
                except Exception:
                    pass

        except Exception as exc:
            logger.warning("World model population failed: %s", exc)

    # ------------------------------------------------------------------
    # Status and results
    # ------------------------------------------------------------------

    async def get_status(self, domain: str) -> Dict[str, Any]:
        """Get pipeline progress for a domain."""
        db = await self._get_db()
        plan_title = f"Recon Pipeline: {domain}"
        plans = await db.query(table="plans", filters={"status": "active"}, limit=100)

        for plan in plans:
            if plan.get("title") == plan_title:
                steps = plan.get("steps", [])
                stage_status = {}
                for i, stage in enumerate(STAGES):
                    if i < len(steps):
                        step = steps[i]
                        stage_status[stage["name"]] = {
                            "status": step.get("status", "pending"),
                            "result": step.get("result", ""),
                        }
                    else:
                        stage_status[stage["name"]] = {"status": "pending", "result": ""}

                completed = sum(1 for s in stage_status.values() if s["status"] in ("done", "skipped"))
                return {
                    "plan_id": plan["id"],
                    "domain": domain,
                    "status": plan.get("status", "active"),
                    "progress": f"{completed}/{len(STAGES)}",
                    "stages": stage_status,
                }

        return {
            "domain": domain,
            "status": "not_started",
            "progress": "0/6",
            "stages": {},
        }

    async def get_results(self, domain: str, stage: Optional[str] = None) -> Dict[str, Any]:
        """Get stored results. Reads from plan step results and knowledge store."""
        status = await self.get_status(domain)

        if stage:
            return {
                "domain": domain,
                "stage": stage,
                "status": status.get("stages", {}).get(stage, {}),
            }

        return {
            "domain": domain,
            "pipeline_status": status,
            "results": self._results,
        }
