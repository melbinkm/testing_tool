"""
Budget Tracker - Tracks request counts and enforces rate limits.
Ported from TypeScript budget-tracker.ts to Python.

Uses ``time.time()`` instead of ``Date.now()``.
"""

import time
from dataclasses import dataclass, field
from typing import Dict, List, Optional

from lib.scope_types import (
    BudgetExceededError,
    BudgetStatus,
    RateLimitStatus,
    ScopeConstraints,
)


@dataclass
class _RequestRecord:
    """Internal record for a single request."""
    timestamp: float
    target: Optional[str] = None
    identity_id: Optional[str] = None


class BudgetTracker:
    """Tracks requests and enforces budget / rate limits."""

    def __init__(self, constraints: ScopeConstraints) -> None:
        self.constraints = constraints
        self._requests: List[_RequestRecord] = []
        self._requests_by_target: Dict[str, int] = {}
        self._start_time: float = time.time()
        self._window_sec: float = 1.0  # 1-second sliding window for rate limiting

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def record_request(
        self,
        target: Optional[str] = None,
        identity_id: Optional[str] = None,
    ) -> bool:
        """Record a request and check limits.

        Parameters
        ----------
        target : str, optional
            Target for per-target budget tracking.
        identity_id : str, optional
            Identity ID for per-identity tracking.

        Returns
        -------
        bool
            ``True`` if the request is allowed.

        Raises
        ------
        BudgetExceededError
            If any budget or rate limit is exceeded.
        """
        now = time.time()

        # Check total budget
        if len(self._requests) >= self.constraints.budget.max_total_requests:
            raise BudgetExceededError(
                "total",
                len(self._requests),
                self.constraints.budget.max_total_requests,
            )

        # Check per-target budget
        if target:
            target_count = self._requests_by_target.get(target, 0)
            if target_count >= self.constraints.budget.max_requests_per_target:
                raise BudgetExceededError(
                    "per_target",
                    target_count,
                    self.constraints.budget.max_requests_per_target,
                )

        # Check rate limit (sliding window)
        window_start = now - self._window_sec
        recent_requests = [
            r for r in self._requests if r.timestamp >= window_start
        ]

        if len(recent_requests) >= self.constraints.rate_limits.requests_per_second:
            raise BudgetExceededError(
                "rate",
                len(recent_requests),
                self.constraints.rate_limits.requests_per_second,
            )

        # Check burst limit
        if len(recent_requests) >= self.constraints.rate_limits.burst_limit:
            raise BudgetExceededError(
                "rate",
                len(recent_requests),
                self.constraints.rate_limits.burst_limit,
            )

        # Record the request
        self._requests.append(
            _RequestRecord(
                timestamp=now,
                target=target,
                identity_id=identity_id,
            )
        )

        # Update per-target count
        if target:
            self._requests_by_target[target] = (
                self._requests_by_target.get(target, 0) + 1
            )

        # Cleanup old requests to prevent memory growth
        self._cleanup_old_requests()

        return True

    def check_request(self, target: Optional[str] = None) -> bool:
        """Check if a request would be allowed without recording it.

        Parameters
        ----------
        target : str, optional
            Target for per-target budget checking.

        Returns
        -------
        bool
            ``True`` if the request would be allowed.
        """
        try:
            # Check total budget
            if len(self._requests) >= self.constraints.budget.max_total_requests:
                return False

            # Check per-target budget
            if target:
                target_count = self._requests_by_target.get(target, 0)
                if target_count >= self.constraints.budget.max_requests_per_target:
                    return False

            # Check rate limit
            now = time.time()
            window_start = now - self._window_sec
            recent_requests = [
                r for r in self._requests if r.timestamp >= window_start
            ]

            if len(recent_requests) >= self.constraints.rate_limits.requests_per_second:
                return False

            return True
        except Exception:
            return False

    def get_status(self, identity_id: Optional[str] = None) -> BudgetStatus:
        """Get the current budget status.

        Parameters
        ----------
        identity_id : str, optional
            Identity ID for per-identity status (reserved for future use).

        Returns
        -------
        BudgetStatus
        """
        now = time.time()
        window_start = now - self._window_sec
        recent_requests = [
            r for r in self._requests if r.timestamp >= window_start
        ]

        # Build requests-by-target dict
        requests_by_target: Dict[str, int] = dict(self._requests_by_target)

        total_requests = len(self._requests)
        max_total = self.constraints.budget.max_total_requests

        return BudgetStatus(
            total_requests=total_requests,
            max_total_requests=max_total,
            remaining_requests=max(0, max_total - total_requests),
            requests_by_target=requests_by_target,
            rate_limit_status=RateLimitStatus(
                current_rate=len(recent_requests),
                max_rate=self.constraints.rate_limits.requests_per_second,
                within_limit=(
                    len(recent_requests)
                    < self.constraints.rate_limits.requests_per_second
                ),
            ),
            budget_exhausted=total_requests >= max_total,
        )

    def reset(self) -> None:
        """Reset the budget tracker for a new engagement."""
        self._requests.clear()
        self._requests_by_target.clear()
        self._start_time = time.time()

    def get_target_request_count(self, target: str) -> int:
        """Return the number of requests recorded for *target*."""
        return self._requests_by_target.get(target, 0)

    def get_total_request_count(self) -> int:
        """Return the total number of recorded requests."""
        return len(self._requests)

    def get_current_rate(self) -> int:
        """Return the number of requests in the last sliding window (1 s)."""
        now = time.time()
        window_start = now - self._window_sec
        return sum(1 for r in self._requests if r.timestamp >= window_start)

    def is_duration_exceeded(self) -> bool:
        """Return ``True`` if the maximum scan duration has been exceeded."""
        elapsed_sec = time.time() - self._start_time
        max_duration_sec = (
            self.constraints.budget.max_scan_duration_hours * 3600.0
        )
        return elapsed_sec >= max_duration_sec

    def get_elapsed_hours(self) -> float:
        """Return the elapsed scan duration in hours."""
        elapsed_sec = time.time() - self._start_time
        return elapsed_sec / 3600.0

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _cleanup_old_requests(self) -> None:
        """Remove stale requests to prevent unbounded memory growth.

        Keeps requests from the last hour.  Only runs when the internal
        list exceeds 10 000 entries.
        """
        if len(self._requests) > 10_000:
            one_hour_ago = time.time() - 3600.0
            self._requests = [
                r for r in self._requests if r.timestamp >= one_hour_ago
            ]
