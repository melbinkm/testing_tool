"""
Budget Tracker - Tracks request counts and enforces rate limits.
Ported from TypeScript budget-tracker.ts to Python.

Uses ``time.time()`` instead of ``Date.now()``.
Now supports database persistence for per-assessment budget tracking.
"""

import time
import logging
import asyncio
from dataclasses import dataclass, field
from typing import Dict, List, Optional

from lib.scope_types import (
    BudgetExceededError,
    BudgetStatus,
    RateLimitStatus,
    ScopeConstraints,
)

logger = logging.getLogger("autopentest-mcp")


@dataclass
class _RequestRecord:
    """Internal record for a single request."""
    timestamp: float
    target: Optional[str] = None
    identity_id: Optional[str] = None


class BudgetTracker:
    """Tracks requests and enforces budget / rate limits.

    Now supports optional database persistence for per-assessment budget tracking.
    Budget state survives server restarts when pool and assessment_id are provided.
    """

    def __init__(
        self,
        constraints: ScopeConstraints,
        assessment_id: Optional[int] = None,
        pool = None,
    ) -> None:
        """Initialize budget tracker.

        Parameters
        ----------
        constraints : ScopeConstraints
            Budget and rate limit constraints.
        assessment_id : int, optional
            Assessment ID for database persistence. If provided with pool,
            budget state will be loaded from and persisted to the database.
        pool : asyncpg.Pool, optional
            Database connection pool for persistence.
        """
        self.constraints = constraints
        self.assessment_id = assessment_id
        self.pool = pool
        self._requests: List[_RequestRecord] = []
        self._requests_by_target: Dict[str, int] = {}
        self._start_time: float = time.time()
        self._window_sec: float = 1.0  # 1-second sliding window for rate limiting
        self._persist_counter: int = 0  # Batch persistence every N requests
        self._persist_batch_size: int = 10  # Persist every 10 requests
        self._loaded_from_db: bool = False

    # ------------------------------------------------------------------
    # Persistence API
    # ------------------------------------------------------------------

    async def initialize(self) -> None:
        """Initialize the budget tracker by loading state from database.

        Must be called after construction if using database persistence.
        Safe to call multiple times (idempotent).
        """
        if self._loaded_from_db or not self.assessment_id or not self.pool:
            return

        await self._load_state()
        self._loaded_from_db = True

    async def _load_state(self) -> None:
        """Load budget state from the database."""
        if not self.assessment_id or not self.pool:
            return

        try:
            async with self.pool.acquire() as conn:
                row = await conn.fetchrow(
                    """
                    SELECT
                        total_requests,
                        requests_by_target,
                        recent_requests,
                        start_time
                    FROM wm_budget_state
                    WHERE assessment_id = $1
                    """,
                    self.assessment_id,
                )

            if row:
                # Restore state from database
                self._requests_by_target = dict(row["requests_by_target"])
                self._start_time = row["start_time"].timestamp() if row["start_time"] else time.time()

                # Restore recent requests (last hour only for rate limiting)
                recent_data = row["recent_requests"]
                if isinstance(recent_data, list):
                    now = time.time()
                    one_hour_ago = now - 3600.0
                    for req_data in recent_data:
                        if isinstance(req_data, dict):
                            ts = req_data.get("timestamp", 0)
                            if ts >= one_hour_ago:
                                self._requests.append(
                                    _RequestRecord(
                                        timestamp=ts,
                                        target=req_data.get("target"),
                                        identity_id=req_data.get("identity_id"),
                                    )
                                )

                # If total_requests from DB is higher than restored requests,
                # it means old requests were pruned. Create dummy records to
                # maintain accurate total count for budget enforcement.
                total_from_db = row["total_requests"]
                if total_from_db > len(self._requests):
                    # Add dummy records (old timestamps won't affect rate limiting)
                    dummy_count = total_from_db - len(self._requests)
                    dummy_time = time.time() - 7200.0  # 2 hours ago
                    for _ in range(dummy_count):
                        self._requests.append(
                            _RequestRecord(timestamp=dummy_time)
                        )

                logger.info(
                    f"Loaded budget state for assessment {self.assessment_id}: "
                    f"{total_from_db} total requests, {len(self._requests_by_target)} targets"
                )
            else:
                # No existing state - create initial row
                await self._persist_state()
                logger.info(f"Initialized new budget state for assessment {self.assessment_id}")

        except Exception as exc:
            logger.warning(f"Failed to load budget state from DB: {exc}")

    async def _persist_state(self) -> None:
        """Persist current budget state to the database."""
        if not self.assessment_id or not self.pool:
            return

        try:
            # Serialize recent requests (last hour only) for rate limiting persistence
            one_hour_ago = time.time() - 3600.0
            recent_requests = [
                {
                    "timestamp": r.timestamp,
                    "target": r.target,
                    "identity_id": r.identity_id,
                }
                for r in self._requests
                if r.timestamp >= one_hour_ago
            ]

            async with self.pool.acquire() as conn:
                await conn.execute(
                    """
                    INSERT INTO wm_budget_state
                        (assessment_id, total_requests, requests_by_target, recent_requests, start_time, last_request_time, updated_at)
                    VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
                    ON CONFLICT (assessment_id) DO UPDATE SET
                        total_requests = EXCLUDED.total_requests,
                        requests_by_target = EXCLUDED.requests_by_target,
                        recent_requests = EXCLUDED.recent_requests,
                        last_request_time = EXCLUDED.last_request_time,
                        updated_at = NOW()
                    """,
                    self.assessment_id,
                    len(self._requests),
                    self._requests_by_target,
                    recent_requests,
                    self._start_time,
                )

            logger.debug(
                f"Persisted budget state for assessment {self.assessment_id}: "
                f"{len(self._requests)} requests"
            )

        except Exception as exc:
            logger.warning(f"Failed to persist budget state to DB: {exc}")

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    async def record_request(
        self,
        target: Optional[str] = None,
        identity_id: Optional[str] = None,
    ) -> bool:
        """Record a request and check limits.

        Now async to support database persistence. For backward compatibility,
        will work synchronously if pool not configured.

        Parameters
        ----------
        target : str, optional
            Target for per-target budget tracking.
        identity_id : str, optional
            Identity ID for per-identity tracking.

        Returns
        -------
        bool
            ``True`` if the request is allowed.

        Raises
        ------
        BudgetExceededError
            If any budget or rate limit is exceeded.
        """
        now = time.time()

        # Check total budget
        if len(self._requests) >= self.constraints.budget.max_total_requests:
            raise BudgetExceededError(
                "total",
                len(self._requests),
                self.constraints.budget.max_total_requests,
            )

        # Check per-target budget
        if target:
            target_count = self._requests_by_target.get(target, 0)
            if target_count >= self.constraints.budget.max_requests_per_target:
                raise BudgetExceededError(
                    "per_target",
                    target_count,
                    self.constraints.budget.max_requests_per_target,
                )

        # Check rate limit (sliding window)
        window_start = now - self._window_sec
        recent_requests = [
            r for r in self._requests if r.timestamp >= window_start
        ]

        if len(recent_requests) >= self.constraints.rate_limits.requests_per_second:
            raise BudgetExceededError(
                "rate",
                len(recent_requests),
                self.constraints.rate_limits.requests_per_second,
            )

        # Check burst limit
        if len(recent_requests) >= self.constraints.rate_limits.burst_limit:
            raise BudgetExceededError(
                "rate",
                len(recent_requests),
                self.constraints.rate_limits.burst_limit,
            )

        # Record the request
        self._requests.append(
            _RequestRecord(
                timestamp=now,
                target=target,
                identity_id=identity_id,
            )
        )

        # Update per-target count
        if target:
            self._requests_by_target[target] = (
                self._requests_by_target.get(target, 0) + 1
            )

        # Cleanup old requests to prevent memory growth
        self._cleanup_old_requests()

        # Batched persistence (every N requests)
        if self.pool and self.assessment_id:
            self._persist_counter += 1
            if self._persist_counter >= self._persist_batch_size:
                await self._persist_state()
                self._persist_counter = 0

        return True

    def check_request(self, target: Optional[str] = None) -> bool:
        """Check if a request would be allowed without recording it.

        Parameters
        ----------
        target : str, optional
            Target for per-target budget checking.

        Returns
        -------
        bool
            ``True`` if the request would be allowed.
        """
        try:
            # Check total budget
            if len(self._requests) >= self.constraints.budget.max_total_requests:
                return False

            # Check per-target budget
            if target:
                target_count = self._requests_by_target.get(target, 0)
                if target_count >= self.constraints.budget.max_requests_per_target:
                    return False

            # Check rate limit
            now = time.time()
            window_start = now - self._window_sec
            recent_requests = [
                r for r in self._requests if r.timestamp >= window_start
            ]

            if len(recent_requests) >= self.constraints.rate_limits.requests_per_second:
                return False

            return True
        except Exception:
            return False

    def get_status(self, identity_id: Optional[str] = None) -> BudgetStatus:
        """Get the current budget status.

        Parameters
        ----------
        identity_id : str, optional
            Identity ID for per-identity status (reserved for future use).

        Returns
        -------
        BudgetStatus
        """
        now = time.time()
        window_start = now - self._window_sec
        recent_requests = [
            r for r in self._requests if r.timestamp >= window_start
        ]

        # Build requests-by-target dict
        requests_by_target: Dict[str, int] = dict(self._requests_by_target)

        total_requests = len(self._requests)
        max_total = self.constraints.budget.max_total_requests

        return BudgetStatus(
            total_requests=total_requests,
            max_total_requests=max_total,
            remaining_requests=max(0, max_total - total_requests),
            requests_by_target=requests_by_target,
            rate_limit_status=RateLimitStatus(
                current_rate=len(recent_requests),
                max_rate=self.constraints.rate_limits.requests_per_second,
                within_limit=(
                    len(recent_requests)
                    < self.constraints.rate_limits.requests_per_second
                ),
            ),
            budget_exhausted=total_requests >= max_total,
        )

    async def reset(self) -> None:
        """Reset the budget tracker for a new engagement.

        Now async to support database persistence.
        """
        self._requests.clear()
        self._requests_by_target.clear()
        self._start_time = time.time()
        self._persist_counter = 0

        # Persist reset state to DB
        if self.pool and self.assessment_id:
            await self._persist_state()

    def get_target_request_count(self, target: str) -> int:
        """Return the number of requests recorded for *target*."""
        return self._requests_by_target.get(target, 0)

    def get_total_request_count(self) -> int:
        """Return the total number of recorded requests."""
        return len(self._requests)

    def get_current_rate(self) -> int:
        """Return the number of requests in the last sliding window (1 s)."""
        now = time.time()
        window_start = now - self._window_sec
        return sum(1 for r in self._requests if r.timestamp >= window_start)

    def is_duration_exceeded(self) -> bool:
        """Return ``True`` if the maximum scan duration has been exceeded."""
        elapsed_sec = time.time() - self._start_time
        max_duration_sec = (
            self.constraints.budget.max_scan_duration_hours * 3600.0
        )
        return elapsed_sec >= max_duration_sec

    def get_elapsed_hours(self) -> float:
        """Return the elapsed scan duration in hours."""
        elapsed_sec = time.time() - self._start_time
        return elapsed_sec / 3600.0

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _cleanup_old_requests(self) -> None:
        """Remove stale requests to prevent unbounded memory growth.

        Keeps requests from the last hour.  Only runs when the internal
        list exceeds 10 000 entries.
        """
        if len(self._requests) > 10_000:
            one_hour_ago = time.time() - 3600.0
            self._requests = [
                r for r in self._requests if r.timestamp >= one_hour_ago
            ]
