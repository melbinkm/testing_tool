"""
Git-Backed Checkpoints - Phase-level rollback via git commits.

Creates git commits as checkpoints in assessment workspace directories,
enabling rollback to any previous phase state.
"""

from __future__ import annotations

import asyncio
import logging
import os
import re
import time
from dataclasses import dataclass, field
from typing import List, Optional

logger = logging.getLogger("autopentest-mcp")

_CHECKPOINT_PREFIX = "[phase:"


@dataclass
class CheckpointInfo:
    """Metadata for a single git checkpoint."""
    hash: str
    description: str
    phase: int
    timestamp: str
    files_changed: int = 0

    def to_dict(self) -> dict:
        return {
            "hash": self.hash,
            "description": self.description,
            "phase": self.phase,
            "timestamp": self.timestamp,
            "files_changed": self.files_changed,
        }


async def _run_git(workspace_dir: str, args: List[str], timeout: float = 30.0) -> tuple:
    """Run a git command in workspace_dir, returning (returncode, stdout, stderr)."""
    proc = await asyncio.create_subprocess_exec(
        "git", *args,
        cwd=workspace_dir,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )
    try:
        stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=timeout)
    except asyncio.TimeoutError:
        proc.kill()
        return (1, b"", b"timeout")
    return (proc.returncode, stdout, stderr)


async def _ensure_git_repo(workspace_dir: str) -> bool:
    """Ensure workspace_dir is a git repo; init one if needed."""
    if os.path.isdir(os.path.join(workspace_dir, ".git")):
        return True
    rc, _, stderr = await _run_git(workspace_dir, ["init"])
    if rc != 0:
        logger.error("git init failed in %s: %s", workspace_dir, stderr.decode())
        return False
    # Create initial commit so we have a valid HEAD
    gitignore_path = os.path.join(workspace_dir, ".gitignore")
    if not os.path.exists(gitignore_path):
        with open(gitignore_path, "w") as f:
            f.write("__pycache__/\n*.pyc\n.env\n")
    await _run_git(workspace_dir, ["add", "."])
    await _run_git(workspace_dir, ["commit", "-m", "Initial workspace commit", "--allow-empty"])
    return True


async def create_checkpoint(
    workspace_dir: str,
    description: str,
    phase: int,
    max_retries: int = 4,
) -> Optional[CheckpointInfo]:
    """Create a git checkpoint (commit) in workspace_dir.

    Retries with exponential backoff on git lock errors.

    Parameters
    ----------
    workspace_dir : str
        Path to the assessment workspace directory.
    description : str
        Human-readable description of the checkpoint.
    phase : int
        Current assessment phase number.
    max_retries : int
        Max retry attempts on lock errors (default 4: 1s, 2s, 4s, 8s).

    Returns
    -------
    CheckpointInfo or None
        Checkpoint metadata on success, None on failure.
    """
    os.makedirs(workspace_dir, exist_ok=True)
    if not await _ensure_git_repo(workspace_dir):
        return None

    commit_msg = f"[phase:{phase}] {description}"

    # Stage all changes
    rc, _, stderr = await _run_git(workspace_dir, ["add", "."])
    if rc != 0:
        logger.error("git add failed: %s", stderr.decode())
        return None

    # Commit with retry on lock
    delay = 1.0
    for attempt in range(max_retries + 1):
        rc, stdout, stderr = await _run_git(
            workspace_dir,
            ["commit", "-m", commit_msg, "--allow-empty"],
        )
        if rc == 0:
            break
        err_text = stderr.decode()
        if "lock" in err_text.lower() and attempt < max_retries:
            logger.warning("git lock error (attempt %d), retrying in %.1fs", attempt + 1, delay)
            await asyncio.sleep(delay)
            delay *= 2
        else:
            logger.error("git commit failed: %s", err_text)
            return None

    # Get commit hash
    rc, stdout, _ = await _run_git(workspace_dir, ["rev-parse", "HEAD"])
    if rc != 0:
        return None
    commit_hash = stdout.decode().strip()

    # Get files changed count
    rc, stdout, _ = await _run_git(workspace_dir, ["diff", "--stat", "HEAD~1..HEAD"])
    files_changed = 0
    if rc == 0:
        lines = stdout.decode().strip().split("\n")
        if lines:
            # Last line is "N files changed, ..."
            match = re.search(r"(\d+) files? changed", lines[-1])
            if match:
                files_changed = int(match.group(1))

    # Get timestamp
    rc, stdout, _ = await _run_git(workspace_dir, ["log", "-1", "--format=%ai"])
    timestamp = stdout.decode().strip() if rc == 0 else ""

    return CheckpointInfo(
        hash=commit_hash,
        description=description,
        phase=phase,
        timestamp=timestamp,
        files_changed=files_changed,
    )


async def rollback_to_checkpoint(workspace_dir: str, checkpoint_hash: str) -> bool:
    """Roll back workspace to a specific checkpoint.

    Parameters
    ----------
    workspace_dir : str
        Path to the assessment workspace directory.
    checkpoint_hash : str
        Git commit hash to roll back to.

    Returns
    -------
    bool
        True if rollback succeeded.
    """
    if not os.path.isdir(os.path.join(workspace_dir, ".git")):
        logger.error("Not a git repo: %s", workspace_dir)
        return False

    rc, _, stderr = await _run_git(workspace_dir, ["reset", "--hard", checkpoint_hash])
    if rc != 0:
        logger.error("git reset failed: %s", stderr.decode())
        return False
    return True


async def list_checkpoints(workspace_dir: str) -> List[CheckpointInfo]:
    """List all checkpoints (commits with [phase:N] prefix) in workspace_dir.

    Parameters
    ----------
    workspace_dir : str
        Path to the assessment workspace directory.

    Returns
    -------
    list[CheckpointInfo]
        Checkpoints sorted most recent first.
    """
    if not os.path.isdir(os.path.join(workspace_dir, ".git")):
        return []

    rc, stdout, _ = await _run_git(
        workspace_dir,
        ["log", "--format=%H|%s|%ai", "--all"],
    )
    if rc != 0 or not stdout:
        return []

    checkpoints = []
    for line in stdout.decode().strip().split("\n"):
        if not line:
            continue
        parts = line.split("|", 2)
        if len(parts) < 3:
            continue
        commit_hash, subject, timestamp = parts

        # Only include checkpoint commits
        if not subject.startswith(_CHECKPOINT_PREFIX):
            continue

        # Extract phase number
        match = re.match(r"\[phase:(\d+)\]\s*(.*)", subject)
        if not match:
            continue
        phase = int(match.group(1))
        description = match.group(2)

        checkpoints.append(CheckpointInfo(
            hash=commit_hash,
            description=description,
            phase=phase,
            timestamp=timestamp,
        ))

    return checkpoints
