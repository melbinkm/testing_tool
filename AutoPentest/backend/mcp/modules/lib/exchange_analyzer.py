"""
Exchange Analyzer

Analyzes HTTP request/response pairs to recommend vulnerability tests
beyond the static checklist. Provides per-request/response intelligence
for adaptive testing.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Set, Any, Optional
import re
import logging

logger = logging.getLogger(__name__)


@dataclass
class ExchangeAnalysis:
    """Analysis results for a request/response exchange."""

    recommended_tests: List[str]  # vuln spec IDs to run
    parameter_recommendations: Dict[str, List[str]]  # param -> [spec_ids]
    priority_adjustments: Dict[str, int]  # spec_id -> priority delta
    detected_technologies: List[str]  # Detected tech stack
    risk_signals: List[Dict[str, Any]]  # Notable observations
    confidence_scores: Dict[str, float] = field(default_factory=dict)  # spec_id -> confidence


class ExchangeAnalyzer:
    """
    Analyzes HTTP exchanges to recommend vulnerability tests.

    Examines request/response characteristics to identify:
    - Which tests are applicable beyond static rules
    - Which parameters are highest risk
    - What technologies are in use
    - What risk signals warrant investigation
    """

    def __init__(self):
        """Initialize the exchange analyzer."""
        pass

    def analyze(
        self,
        request: Dict[str, Any],
        response: Dict[str, Any]
    ) -> ExchangeAnalysis:
        """
        Analyze a request/response pair.

        Args:
            request: Request dict with keys:
                    - method: HTTP method
                    - url: Full URL
                    - headers: Dict of headers
                    - body: Request body (optional)
                    - parameters: List of parameter dicts (optional)

            response: Response dict with keys:
                     - status: HTTP status code
                     - headers: Dict of headers
                     - body: Response body
                     - time_ms: Response time in milliseconds (optional)

        Returns:
            ExchangeAnalysis with recommendations
        """
        analysis = ExchangeAnalysis(
            recommended_tests=[],
            parameter_recommendations={},
            priority_adjustments={},
            detected_technologies=[],
            risk_signals=[]
        )

        # Run analysis pipeline
        self._analyze_response_headers(response, analysis)
        self._analyze_response_body(response, analysis)
        self._analyze_request(request, analysis)
        self._analyze_timing(response, analysis)
        self._cross_correlate(request, response, analysis)

        return analysis

    def _analyze_response_headers(self, response: Dict[str, Any], analysis: ExchangeAnalysis) -> None:
        """Analyze response headers for security issues."""
        headers = {k.lower(): v for k, v in response.get('headers', {}).items()}

        # CORS analysis
        acao = headers.get('access-control-allow-origin', '')
        if acao:
            analysis.recommended_tests.append('cors_misconfig')
            if acao == '*':
                analysis.priority_adjustments['cors_misconfig'] = 10
                analysis.risk_signals.append({
                    'type': 'cors_wildcard',
                    'severity': 'high',
                    'detail': 'Wildcard CORS policy detected'
                })
            elif acao == 'null':
                analysis.priority_adjustments['cors_misconfig'] = 8
                analysis.risk_signals.append({
                    'type': 'cors_null',
                    'severity': 'high',
                    'detail': 'Null origin allowed in CORS'
                })

        # CORS with credentials
        acac = headers.get('access-control-allow-credentials', '')
        if acac == 'true' and acao:
            analysis.priority_adjustments['cors_misconfig'] = analysis.priority_adjustments.get('cors_misconfig', 0) + 8
            analysis.risk_signals.append({
                'type': 'cors_credentials',
                'severity': 'high',
                'detail': 'CORS allows credentials'
            })

        # Cookie security
        set_cookie = headers.get('set-cookie', '')
        if set_cookie:
            analysis.recommended_tests.append('cookie_security')

            if 'httponly' not in set_cookie.lower():
                analysis.priority_adjustments['cookie_security'] = analysis.priority_adjustments.get('cookie_security', 0) + 3
                analysis.risk_signals.append({
                    'type': 'cookie_missing_httponly',
                    'severity': 'medium',
                    'detail': 'Cookie missing HttpOnly flag'
                })

            if 'secure' not in set_cookie.lower():
                analysis.priority_adjustments['cookie_security'] = analysis.priority_adjustments.get('cookie_security', 0) + 3
                analysis.risk_signals.append({
                    'type': 'cookie_missing_secure',
                    'severity': 'medium',
                    'detail': 'Cookie missing Secure flag'
                })

            if 'samesite' not in set_cookie.lower():
                analysis.priority_adjustments['cookie_security'] = analysis.priority_adjustments.get('cookie_security', 0) + 2
                analysis.risk_signals.append({
                    'type': 'cookie_missing_samesite',
                    'severity': 'low',
                    'detail': 'Cookie missing SameSite attribute'
                })

        # Technology detection
        server = headers.get('server', '')
        if server:
            analysis.detected_technologies.append(server)
            analysis.recommended_tests.append('info_leak_headers')

            # Version numbers in server header
            if re.search(r'\d+\.\d+', server):
                analysis.risk_signals.append({
                    'type': 'version_disclosure',
                    'severity': 'info',
                    'detail': f'Server version disclosed: {server}'
                })

        x_powered_by = headers.get('x-powered-by', '')
        if x_powered_by:
            analysis.detected_technologies.append(f"X-Powered-By: {x_powered_by}")
            analysis.recommended_tests.append('info_leak_headers')

        # Content-Security-Policy analysis
        csp = headers.get('content-security-policy', '')
        if not csp:
            analysis.recommended_tests.append('clickjacking')
            analysis.recommended_tests.append('xss_dom')
            analysis.risk_signals.append({
                'type': 'missing_csp',
                'severity': 'medium',
                'detail': 'No Content-Security-Policy header'
            })

        # X-Frame-Options
        xfo = headers.get('x-frame-options', '')
        if not xfo and not csp:
            analysis.recommended_tests.append('clickjacking')

        # Strict-Transport-Security (HSTS)
        hsts = headers.get('strict-transport-security', '')
        if not hsts:
            analysis.risk_signals.append({
                'type': 'missing_hsts',
                'severity': 'medium',
                'detail': 'No Strict-Transport-Security header'
            })

        # X-Content-Type-Options
        xcto = headers.get('x-content-type-options', '')
        if not xcto:
            analysis.risk_signals.append({
                'type': 'missing_x_content_type_options',
                'severity': 'low',
                'detail': 'No X-Content-Type-Options header (MIME sniffing possible)'
            })
        elif xcto.strip().lower() != 'nosniff':
            analysis.risk_signals.append({
                'type': 'invalid_x_content_type_options',
                'severity': 'low',
                'detail': f'X-Content-Type-Options value "{xcto}" is not "nosniff"'
            })

        # X-XSS-Protection (legacy, but still checked by scanners)
        xxp = headers.get('x-xss-protection', '')
        if not xxp:
            analysis.risk_signals.append({
                'type': 'missing_x_xss_protection',
                'severity': 'info',
                'detail': 'No X-XSS-Protection header (legacy browser XSS filter not enabled)'
            })

        # Referrer-Policy
        rp = headers.get('referrer-policy', '')
        if not rp:
            analysis.risk_signals.append({
                'type': 'missing_referrer_policy',
                'severity': 'low',
                'detail': 'No Referrer-Policy header (referer leakage possible)'
            })

        # Permissions-Policy
        pp = headers.get('permissions-policy', '') or headers.get('feature-policy', '')
        if not pp:
            analysis.risk_signals.append({
                'type': 'missing_permissions_policy',
                'severity': 'info',
                'detail': 'No Permissions-Policy header'
            })

        # Cache-Control for sensitive responses
        cache_control = headers.get('cache-control', '')
        if not cache_control or 'no-store' not in cache_control.lower():
            status = response.get('status', 200)
            if status == 200:
                analysis.risk_signals.append({
                    'type': 'missing_cache_control_no_store',
                    'severity': 'low',
                    'detail': 'Response may be cached by proxies/browsers (no Cache-Control: no-store)'
                })

        # Open redirect detection via Location header
        location = headers.get('location', '')
        if location and response.get('status', 0) in (301, 302, 303, 307, 308):
            analysis.recommended_tests.append('open_redirect')
            analysis.risk_signals.append({
                'type': 'redirect_detected',
                'severity': 'info',
                'detail': f'Redirect to: {location}'
            })

    def _analyze_response_body(self, response: Dict[str, Any], analysis: ExchangeAnalysis) -> None:
        """Analyze response body for security issues."""
        body = response.get('body', '')
        if not body:
            return

        headers = {k.lower(): v for k, v in response.get('headers', {}).items()}
        content_type = headers.get('content-type', '').lower()

        # HTML-specific analysis
        if 'html' in content_type:
            self._analyze_html_body(body, analysis)

        # JSON-specific analysis
        if 'json' in content_type or body.strip().startswith('{'):
            self._analyze_json_body(body, analysis)

        # HTML error page analysis (for non-JSON 4xx/5xx responses)
        status = response.get('status', 0)
        if status >= 400 and 'html' in content_type:
            self._analyze_html_error_page(body, analysis)

        # Error message detection
        error_patterns = [
            (r'Exception in thread', 'java_exception'),
            (r'Traceback \(most recent call last\)', 'python_traceback'),
            (r'Fatal error.*on line', 'php_error'),
            (r'SQLException', 'sql_exception'),
            (r'ORA-\d{5}', 'oracle_error'),
            (r'Microsoft OLE DB Provider for SQL Server', 'mssql_error'),
            (r'MySqlException', 'mysql_exception'),
            (r'Uncaught.*Error', 'javascript_error'),
        ]

        for pattern, error_type in error_patterns:
            if re.search(pattern, body, re.IGNORECASE):
                analysis.recommended_tests.append('info_leak_errors')
                analysis.risk_signals.append({
                    'type': error_type,
                    'severity': 'medium',
                    'detail': f'Detailed error message detected: {error_type}'
                })
                break

        # Stack trace detection (Java, Python, .NET)
        if re.search(r'(at\s+\w+\.\w+\([^)]+:\d+\)|File\s+"[^"]+",\s+line\s+\d+|at\s+\w+\s+in\s+[\w/\\]+:\d+)', body):
            analysis.recommended_tests.append('info_leak_errors')
            analysis.priority_adjustments['info_leak_errors'] = analysis.priority_adjustments.get('info_leak_errors', 0) + 5

        # Template syntax in output (SSTI indicator)
        template_patterns = [
            r'\{\{.*\}\}',  # Jinja2, Handlebars
            r'\$\{.*\}',    # Freemarker, Velocity
            r'<%.*%>',      # JSP, ERB
        ]
        for pattern in template_patterns:
            if re.search(pattern, body):
                analysis.recommended_tests.append('ssti')
                analysis.priority_adjustments['ssti'] = 8
                analysis.risk_signals.append({
                    'type': 'template_syntax',
                    'severity': 'high',
                    'detail': 'Template syntax detected in output'
                })
                break

    def _analyze_html_body(self, body: str, analysis: ExchangeAnalysis) -> None:
        """Analyze HTML response body."""

        # Form detection
        forms = re.findall(r'<form[^>]*>(.*?)</form>', body, re.IGNORECASE | re.DOTALL)
        if forms:
            # Check for CSRF tokens
            has_csrf_token = False
            for form_content in forms:
                if re.search(r'(csrf|_token|authenticity_token)', form_content, re.IGNORECASE):
                    has_csrf_token = True
                    break

            if not has_csrf_token:
                analysis.recommended_tests.append('csrf')
                analysis.priority_adjustments['csrf'] = 5
                analysis.risk_signals.append({
                    'type': 'missing_csrf_token',
                    'severity': 'medium',
                    'detail': 'Forms detected without visible CSRF tokens'
                })

        # HTML comments with sensitive info
        sensitive_keywords = ['password', 'secret', 'api_key', 'token', 'credential', 'admin', 'debug', 'TODO', 'FIXME']
        comments = re.findall(r'<!--(.*?)-->', body, re.DOTALL)
        for comment in comments:
            for keyword in sensitive_keywords:
                if keyword.lower() in comment.lower():
                    analysis.recommended_tests.append('info_leak_comments')
                    analysis.risk_signals.append({
                        'type': 'sensitive_comment',
                        'severity': 'low',
                        'detail': f'Sensitive keyword in comment: {keyword}'
                    })
                    break

        # Source map references
        if 'sourceMappingURL' in body or '.map' in body:
            analysis.recommended_tests.append('info_leak_source_maps')

        # Reflected parameters (XSS indicator)
        # This would need request context - handled in _cross_correlate

    def _analyze_json_body(self, body: str, analysis: ExchangeAnalysis) -> None:
        """Analyze JSON response body."""
        try:
            import json
            data = json.loads(body)

            # Look for enumerable IDs (IDOR indicator)
            if isinstance(data, dict):
                for key in ['id', 'user_id', 'account_id', 'order_id']:
                    if key in data and isinstance(data[key], int):
                        analysis.recommended_tests.append('idor')
                        analysis.risk_signals.append({
                            'type': 'enumerable_id',
                            'severity': 'medium',
                            'detail': f'Enumerable ID field: {key}'
                        })
                        break

            # Look for role/privilege fields (privilege escalation indicator)
            privilege_keys = ['role', 'admin', 'isAdmin', 'is_admin', 'privilege', 'permissions']
            if isinstance(data, dict):
                for key in privilege_keys:
                    if key in data:
                        analysis.recommended_tests.append('privilege_escalation')
                        analysis.recommended_tests.append('mass_assignment')
                        break

        except Exception as e:
            # Not valid JSON or parsing error
            pass

    def _analyze_html_error_page(self, body: str, analysis: ExchangeAnalysis) -> None:
        """Extract useful information from HTML error pages."""
        import re

        # Extract title (often contains error type)
        title_match = re.search(r'<title>([^<]+)</title>', body, re.IGNORECASE)
        if title_match:
            title = title_match.group(1).strip()
            if any(err in title.lower() for err in ['error', 'exception', 'failed', '500', '404']):
                analysis.risk_signals.append({
                    'type': 'error_page_title',
                    'severity': 'info',
                    'detail': f'Error page title: {title[:100]}'
                })

        # Extract h1 (often contains server/framework info)
        h1_match = re.search(r'<h1[^>]*>([^<]+)</h1>', body, re.IGNORECASE)
        if h1_match:
            h1_text = h1_match.group(1).strip()
            analysis.detected_technologies.append(f"Error format: {h1_text[:50]}")

        # Extract stack trace patterns from HTML
        stack_patterns = [
            (r'at\s+[\w.$]+\(([^)]+\.java):\d+\)', 'java_stack_trace'),
            (r'File\s+"([^"]+\.py)",\s+line\s+\d+', 'python_stack_trace'),
            (r'in\s+([^\s]+\.php)\s+on\s+line\s+\d+', 'php_stack_trace'),
        ]

        for pattern, trace_type in stack_patterns:
            matches = re.findall(pattern, body)
            if matches:
                # Extract file paths (server disclosure)
                file_paths = [m if isinstance(m, str) else m[0] for m in matches[:3]]
                analysis.risk_signals.append({
                    'type': 'stack_trace_disclosure',
                    'severity': 'medium',
                    'detail': f'{trace_type}: {", ".join(file_paths)}'
                })
                analysis.recommended_tests.append('info_leak_errors')
                break

    def _analyze_request(self, request: Dict[str, Any], analysis: ExchangeAnalysis) -> None:
        """Analyze request for test recommendations."""
        headers = {k.lower(): v for k, v in request.get('headers', {}).items()}

        # JWT detection
        auth_header = headers.get('authorization', '')
        if 'bearer' in auth_header.lower() and '.' in auth_header:
            # Likely JWT
            analysis.recommended_tests.append('jwt_manipulation')
            analysis.priority_adjustments['jwt_manipulation'] = 5
            analysis.risk_signals.append({
                'type': 'jwt_detected',
                'severity': 'info',
                'detail': 'JWT token in Authorization header'
            })

        # State-changing methods should check CSRF
        method = request.get('method', 'GET').upper()
        if method in ('POST', 'PUT', 'PATCH', 'DELETE'):
            if 'csrf' not in analysis.recommended_tests:
                analysis.recommended_tests.append('csrf')

        # XML Content-Type
        content_type = headers.get('content-type', '').lower()
        if 'xml' in content_type:
            analysis.recommended_tests.append('xml_injection')
            analysis.priority_adjustments['xml_injection'] = 5

        # Parameter analysis
        parameters = request.get('parameters', [])
        for param in parameters:
            param_name = param.get('name', '').lower()
            param_value = param.get('value', '')

            # ID parameters -> IDOR
            if 'id' in param_name or param_name.endswith('_id'):
                if param_name not in analysis.parameter_recommendations:
                    analysis.parameter_recommendations[param_name] = []
                analysis.parameter_recommendations[param_name].append('idor')

            # URL parameters -> SSRF, open redirect
            if 'url' in param_name or 'redirect' in param_name or 'next' in param_name:
                if param_name not in analysis.parameter_recommendations:
                    analysis.parameter_recommendations[param_name] = []
                analysis.parameter_recommendations[param_name].extend(['ssrf', 'open_redirect'])

            # File parameters -> path traversal
            if 'file' in param_name or 'path' in param_name or 'document' in param_name:
                if param_name not in analysis.parameter_recommendations:
                    analysis.parameter_recommendations[param_name] = []
                analysis.parameter_recommendations[param_name].append('path_traversal')

            # Command-like parameters -> command injection
            if 'cmd' in param_name or 'exec' in param_name or 'command' in param_name:
                if param_name not in analysis.parameter_recommendations:
                    analysis.parameter_recommendations[param_name] = []
                analysis.parameter_recommendations[param_name].append('command_injection')

    def _analyze_timing(self, response: Dict[str, Any], analysis: ExchangeAnalysis) -> None:
        """Analyze response timing for timing attack potential."""
        time_ms = response.get('time_ms')
        if time_ms is None:
            return

        # Unusually slow responses might indicate blind injection potential
        if time_ms > 5000:
            analysis.risk_signals.append({
                'type': 'slow_response',
                'severity': 'info',
                'detail': f'Slow response time: {time_ms}ms - good for blind timing attacks'
            })
            # Boost priority for time-based attacks
            analysis.priority_adjustments['sqli_blind_time'] = analysis.priority_adjustments.get('sqli_blind_time', 0) + 3

    def _cross_correlate(self, request: Dict[str, Any], response: Dict[str, Any], analysis: ExchangeAnalysis) -> None:
        """Cross-correlate request and response for reflection-based attacks."""

        # Check for parameter reflection (XSS indicator)
        parameters = request.get('parameters', [])
        response_body = response.get('body', '')

        for param in parameters:
            param_name = param.get('name', '')
            param_value = param.get('value', '')

            if param_value and param_value in response_body:
                # Parameter reflected in response
                if param_name not in analysis.parameter_recommendations:
                    analysis.parameter_recommendations[param_name] = []

                # Prioritize XSS tests for reflected params
                analysis.parameter_recommendations[param_name].extend(['xss_reflected', 'xss_stored'])
                analysis.priority_adjustments['xss_reflected'] = analysis.priority_adjustments.get('xss_reflected', 0) + 5

                analysis.risk_signals.append({
                    'type': 'parameter_reflection',
                    'severity': 'medium',
                    'detail': f'Parameter {param_name} reflected in response'
                })

    def get_top_recommendations(self, analysis: ExchangeAnalysis, limit: int = 10) -> List[str]:
        """
        Get top N test recommendations sorted by priority.

        Args:
            analysis: ExchangeAnalysis result
            limit: Maximum number of recommendations

        Returns:
            List of vuln spec IDs sorted by priority
        """
        # Deduplicate recommendations
        unique_tests = list(dict.fromkeys(analysis.recommended_tests))

        # Sort by priority adjustments
        sorted_tests = sorted(
            unique_tests,
            key=lambda t: analysis.priority_adjustments.get(t, 0),
            reverse=True
        )

        return sorted_tests[:limit]


# Global singleton
_analyzer_instance = None

def get_exchange_analyzer() -> ExchangeAnalyzer:
    """Get the global exchange analyzer instance."""
    global _analyzer_instance
    if _analyzer_instance is None:
        _analyzer_instance = ExchangeAnalyzer()
    return _analyzer_instance
