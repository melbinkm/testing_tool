"""
Evidence Exporter - Export evidence bundles to JSON, ZIP, and reports.
Ported from TypeScript Exporter (evidence-mcp/src/exporter.ts) to Python.

Uses ``zipfile`` (stdlib) instead of ``archiver`` and ``jinja2`` instead of
Handlebars for template rendering.
"""

from __future__ import annotations

import io
import json
import os
import zipfile
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

import jinja2

from lib.evidence_redactor import Redactor

# ---------------------------------------------------------------------------
# Default Jinja2 templates
# ---------------------------------------------------------------------------

DEFAULT_MARKDOWN_TEMPLATE = """\
# Security Finding Report

## Finding: {{ finding_id }}
**Bundle ID:** {{ bundle_id }}
**Generated:** {{ generated_at }}

## Summary
{% if metadata.get("title") %}
### {{ metadata["title"] }}
{% endif %}

{% if metadata.get("severity") %}
**Severity:** {{ metadata["severity"] }}
{% endif %}

{% if metadata.get("description") %}
{{ metadata["description"] }}
{% endif %}

{% if metadata.get("cvss_score") %}
**CVSS Score:** {{ metadata["cvss_score"] }}
{% endif %}

{% if metadata.get("cwe_id") %}
**CWE:** {{ metadata["cwe_id"] }}
{% endif %}

## Artifacts
{% for artifact in artifacts %}
### {{ artifact["name"] }} ({{ artifact["type"] }})
- **ID:** {{ artifact["artifact_id"] }}
- **Timestamp:** {{ artifact["timestamp"] }}
- **Content Type:** {{ artifact["content_type"] }}
- **Redacted:** {{ artifact["redacted"] }}

```
{{ artifact["content"] }}
```

{% endfor %}

---
*Generated by Evidence MCP Server*
"""

DEFAULT_HTML_TEMPLATE = """\
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Security Finding Report - {{ finding_id }}</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .report-container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 30px;
    }
    h1 {
      color: #1a1a1a;
      border-bottom: 3px solid #dc3545;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }
    h2 {
      color: #495057;
      margin-top: 30px;
      margin-bottom: 15px;
    }
    .meta {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
    .meta-item {
      display: inline-block;
      margin-right: 30px;
      margin-bottom: 5px;
    }
    .meta-label {
      font-weight: 600;
      color: #6c757d;
    }
    .severity {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.85em;
    }
    .severity-critical { background: #dc3545; color: white; }
    .severity-high { background: #fd7e14; color: white; }
    .severity-medium { background: #ffc107; color: #333; }
    .severity-low { background: #28a745; color: white; }
    .severity-info { background: #17a2b8; color: white; }
    .description {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 15px;
      margin: 20px 0;
    }
    .artifact {
      border: 1px solid #dee2e6;
      border-radius: 4px;
      margin-bottom: 20px;
      overflow: hidden;
    }
    .artifact-header {
      background: #e9ecef;
      padding: 10px 15px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .artifact-header:hover {
      background: #dee2e6;
    }
    .artifact-title {
      font-weight: 600;
    }
    .artifact-type {
      background: #6c757d;
      color: white;
      padding: 2px 8px;
      border-radius: 3px;
      font-size: 0.8em;
    }
    .artifact-meta {
      padding: 10px 15px;
      background: #f8f9fa;
      font-size: 0.9em;
      color: #6c757d;
    }
    .artifact-content {
      padding: 15px;
      background: #1e1e1e;
      color: #d4d4d4;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.9em;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .redacted-badge {
      background: #dc3545;
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.75em;
      margin-left: 10px;
    }
    .footer {
      margin-top: 40px;
      padding-top: 20px;
      border-top: 1px solid #dee2e6;
      color: #6c757d;
      font-size: 0.9em;
      text-align: center;
    }
    details summary { cursor: pointer; }
    details summary::-webkit-details-marker { display: none; }
  </style>
</head>
<body>
  <div class="report-container">
    <h1>Security Finding Report</h1>

    <div class="meta">
      <div class="meta-item">
        <span class="meta-label">Finding ID:</span> {{ finding_id }}
      </div>
      <div class="meta-item">
        <span class="meta-label">Bundle ID:</span> {{ bundle_id }}
      </div>
      <div class="meta-item">
        <span class="meta-label">Generated:</span> {{ generated_at }}
      </div>
    </div>

    {% if metadata.get("title") %}
    <h2>{{ metadata["title"] }}</h2>
    {% endif %}

    {% if metadata.get("severity") %}
    <div style="margin: 15px 0;">
      <span class="severity severity-{{ metadata['severity']|lower }}">{{ metadata["severity"] }}</span>
      {% if metadata.get("cvss_score") %}
      <span style="margin-left: 15px;"><strong>CVSS:</strong> {{ metadata["cvss_score"] }}</span>
      {% endif %}
      {% if metadata.get("cwe_id") %}
      <span style="margin-left: 15px;"><strong>CWE:</strong> {{ metadata["cwe_id"] }}</span>
      {% endif %}
    </div>
    {% endif %}

    {% if metadata.get("description") %}
    <div class="description">
      {{ metadata["description"] }}
    </div>
    {% endif %}

    <h2>Evidence Artifacts ({{ artifacts|length }})</h2>

    {% for artifact in artifacts %}
    <details class="artifact" open>
      <summary class="artifact-header">
        <span class="artifact-title">
          {{ artifact["name"] }}
          {% if artifact["redacted"] %}<span class="redacted-badge">REDACTED</span>{% endif %}
        </span>
        <span class="artifact-type">{{ artifact["type"] }}</span>
      </summary>
      <div class="artifact-meta">
        <strong>ID:</strong> {{ artifact["artifact_id"] }} |
        <strong>Timestamp:</strong> {{ artifact["timestamp"] }} |
        <strong>Content-Type:</strong> {{ artifact["content_type"] }}
      </div>
      <pre class="artifact-content">{{ artifact["content"] }}</pre>
    </details>
    {% endfor %}

    <div class="footer">
      Generated by Evidence MCP Server
    </div>
  </div>

  <script>
    // Toggle artifact visibility
    document.querySelectorAll('.artifact-header').forEach(header => {
      header.addEventListener('click', () => {
        header.parentElement.toggleAttribute('open');
      });
    });
  </script>
</body>
</html>
"""

# ---------------------------------------------------------------------------
# Content-type to file extension mapping
# ---------------------------------------------------------------------------

_CONTENT_TYPE_EXTENSIONS: Dict[str, str] = {
    "application/json": ".json",
    "text/html": ".html",
    "text/plain": ".txt",
    "text/xml": ".xml",
    "application/xml": ".xml",
    "image/png": ".png",
    "image/jpeg": ".jpg",
    "image/gif": ".gif",
}


# ---------------------------------------------------------------------------
# Exporter
# ---------------------------------------------------------------------------

class Exporter:
    """Export evidence bundles to JSON, ZIP, and rendered reports."""

    def __init__(self, redactor: Redactor) -> None:
        self._redactor = redactor

        # Build a Jinja2 environment with the default templates
        self._jinja_env = jinja2.Environment(
            loader=jinja2.BaseLoader(),
            autoescape=False,
            undefined=jinja2.Undefined,
        )

        self._templates: Dict[str, jinja2.Template] = {
            "markdown": self._jinja_env.from_string(DEFAULT_MARKDOWN_TEMPLATE),
            "html": self._jinja_env.from_string(DEFAULT_HTML_TEMPLATE),
        }

    # ------------------------------------------------------------------
    # Template loading
    # ------------------------------------------------------------------

    def load_template(self, template_path: str) -> jinja2.Template:
        """Load a Jinja2 template from *template_path*.

        Looks in the ``templates/`` directory next to this file first,
        then falls back to treating *template_path* as an absolute path.
        """
        templates_dir = os.path.join(
            os.path.dirname(os.path.abspath(__file__)), "..", "..", "templates"
        )
        full_path = os.path.join(templates_dir, template_path)

        if not os.path.isfile(full_path):
            full_path = template_path

        if not os.path.isfile(full_path):
            raise FileNotFoundError(f"Template not found: {template_path}")

        with open(full_path, "r", encoding="utf-8") as fh:
            return self._jinja_env.from_string(fh.read())

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _prepare_bundle(
        self,
        bundle: Dict[str, Any],
        include_redacted: bool,
    ) -> Dict[str, Any]:
        """Optionally redact a bundle's artifacts.

        When *include_redacted* is ``False`` (the default for exports) every
        artifact is passed through the redactor.
        """
        if not include_redacted:
            redacted_artifacts = []
            for artifact in bundle.get("artifacts", []):
                outcome = self._redactor.redact_artifact(artifact)
                redacted_artifacts.append(outcome["artifact"])
            return {**bundle, "artifacts": redacted_artifacts}

        return bundle

    @staticmethod
    def _get_extension_for_content_type(content_type: str) -> str:
        return _CONTENT_TYPE_EXTENSIONS.get(content_type, ".txt")

    # ------------------------------------------------------------------
    # JSON export
    # ------------------------------------------------------------------

    def export_to_json(
        self,
        bundle: Dict[str, Any],
        *,
        include_redacted: bool = False,
        output_path: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Export *bundle* as a JSON document.

        Parameters
        ----------
        bundle : dict
            The evidence bundle.
        include_redacted : bool
            If ``True``, skip redaction and include raw data.
        output_path : str, optional
            Write the JSON to this file path.

        Returns
        -------
        dict
            Export result with ``success``, ``format``, ``data`` (if no
            *output_path*), ``size_bytes``, ``artifact_count``, and
            ``redacted_count``.
        """
        prepared = self._prepare_bundle(bundle, include_redacted)

        export_data = {
            "export_format": "json",
            "export_timestamp": datetime.now(timezone.utc).isoformat(),
            "bundle": prepared,
        }

        json_string = json.dumps(export_data, indent=2, default=str)
        redacted_count = sum(
            1 for a in prepared.get("artifacts", []) if a.get("redacted")
        )

        if output_path:
            os.makedirs(os.path.dirname(output_path) or ".", exist_ok=True)
            with open(output_path, "w", encoding="utf-8") as fh:
                fh.write(json_string)

        return {
            "success": True,
            "format": "json",
            "output_path": output_path,
            "data": None if output_path else json_string,
            "size_bytes": len(json_string.encode("utf-8")),
            "artifact_count": len(prepared.get("artifacts", [])),
            "redacted_count": redacted_count,
        }

    # ------------------------------------------------------------------
    # ZIP export
    # ------------------------------------------------------------------

    def export_to_zip(
        self,
        bundle: Dict[str, Any],
        *,
        include_redacted: bool = False,
        output_path: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Export *bundle* as a ZIP archive.

        Parameters
        ----------
        bundle : dict
            The evidence bundle.
        include_redacted : bool
            If ``True``, skip redaction.
        output_path : str, optional
            Write the ZIP to this file path.

        Returns
        -------
        dict
            Export result (see :meth:`export_to_json` for shape).
            ``data`` contains the base64-encoded ZIP when no *output_path*
            is given.
        """
        import base64

        prepared = self._prepare_bundle(bundle, include_redacted)
        dir_name = f"evidence-{prepared['bundle_id']}"

        buf = io.BytesIO()
        with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as zf:
            # Manifest
            manifest = {
                "bundle_id": prepared["bundle_id"],
                "finding_id": prepared["finding_id"],
                "created_at": prepared["created_at"],
                "export_timestamp": datetime.now(timezone.utc).isoformat(),
                "metadata": prepared.get("metadata", {}),
                "artifacts": [
                    {
                        "artifact_id": a["artifact_id"],
                        "type": a["type"],
                        "name": a["name"],
                        "content_type": a["content_type"],
                        "timestamp": a["timestamp"],
                        "redacted": a["redacted"],
                    }
                    for a in prepared.get("artifacts", [])
                ],
            }
            zf.writestr(
                f"{dir_name}/manifest.json",
                json.dumps(manifest, indent=2, default=str),
            )

            # Artifacts
            for artifact in prepared.get("artifacts", []):
                ext = self._get_extension_for_content_type(
                    artifact.get("content_type", "text/plain")
                )
                file_name = f"{artifact['artifact_id']}-{artifact['name']}{ext}"
                zf.writestr(
                    f"{dir_name}/artifacts/{file_name}",
                    artifact.get("content", ""),
                )

        zip_bytes = buf.getvalue()
        redacted_count = sum(
            1 for a in prepared.get("artifacts", []) if a.get("redacted")
        )

        if output_path:
            os.makedirs(os.path.dirname(output_path) or ".", exist_ok=True)
            with open(output_path, "wb") as fh:
                fh.write(zip_bytes)

        return {
            "success": True,
            "format": "zip",
            "output_path": output_path,
            "data": None if output_path else base64.b64encode(zip_bytes).decode("ascii"),
            "size_bytes": len(zip_bytes),
            "artifact_count": len(prepared.get("artifacts", [])),
            "redacted_count": redacted_count,
        }

    # ------------------------------------------------------------------
    # Report generation
    # ------------------------------------------------------------------

    def generate_report(
        self,
        bundle: Dict[str, Any],
        *,
        template: str = "markdown",
        title: Optional[str] = None,
        include_artifacts: bool = True,
        custom_template: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Render a report from *bundle* using Jinja2 templates.

        Parameters
        ----------
        bundle : dict
            The evidence bundle.
        template : str
            ``"markdown"`` or ``"html"``.
        title : str, optional
            Report title override.
        include_artifacts : bool
            Whether to include artifact contents in the report.
        custom_template : str, optional
            Path to a custom Jinja2 template file.

        Returns
        -------
        dict
            Report result with ``success``, ``template``, ``content``,
            ``finding_id``, ``bundle_id``, and ``artifact_count``.
        """
        if custom_template:
            tpl = self.load_template(custom_template)
        else:
            tpl = self._templates.get(template, self._templates["markdown"])

        metadata = bundle.get("metadata", {})
        template_data = {
            "finding_id": bundle["finding_id"],
            "bundle_id": bundle["bundle_id"],
            "created_at": bundle["created_at"],
            "generated_at": datetime.now(timezone.utc).isoformat(),
            "title": title or metadata.get("title") or f"Finding {bundle['finding_id']}",
            "metadata": metadata,
            "artifacts": bundle.get("artifacts", []) if include_artifacts else [],
        }

        content = tpl.render(**template_data)

        return {
            "success": True,
            "template": custom_template or template,
            "content": content,
            "finding_id": bundle["finding_id"],
            "bundle_id": bundle["bundle_id"],
            "artifact_count": len(bundle.get("artifacts", [])),
        }

    # ------------------------------------------------------------------
    # SARIF export
    # ------------------------------------------------------------------

    def export_to_sarif(
        self,
        bundle: Dict[str, Any],
        *,
        output_path: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Export *bundle* as a SARIF 2.1.0 JSON document.

        The bundle metadata is used to populate the SARIF finding.

        Parameters
        ----------
        bundle : dict
            The evidence bundle.
        output_path : str, optional
            Write the SARIF JSON to this file path.

        Returns
        -------
        dict
            Export result with ``success``, ``format``, ``data`` (if no
            *output_path*), ``finding_count``.
        """
        from lib.sarif_formatter import SARIFFormatter

        formatter = SARIFFormatter()

        # Build a finding dict from the bundle metadata
        metadata = bundle.get("metadata", {})
        finding = {
            "title": metadata.get("title", bundle.get("finding_id", "Unknown")),
            "severity": metadata.get("severity", "medium"),
            "description": metadata.get("description", ""),
            "url": metadata.get("url", metadata.get("target", "")),
            "vuln_type": metadata.get("vuln_type", metadata.get("type", "")),
            "confidence": metadata.get("confidence"),
            "cwe_id": metadata.get("cwe_id"),
            "cvss_vector": metadata.get("cvss_vector", metadata.get("cvss")),
            "remediation": metadata.get("remediation", ""),
            "finding_id": bundle.get("finding_id"),
        }

        sarif_doc = formatter.format_findings([finding])
        sarif_json = json.dumps(sarif_doc, indent=2, default=str)

        if output_path:
            os.makedirs(os.path.dirname(output_path) or ".", exist_ok=True)
            with open(output_path, "w", encoding="utf-8") as fh:
                fh.write(sarif_json)

        return {
            "success": True,
            "format": "sarif",
            "output_path": output_path,
            "data": None if output_path else sarif_json,
            "finding_count": len(sarif_doc.get("runs", [{}])[0].get("results", [])),
        }

    # ------------------------------------------------------------------
    # Combined export + report
    # ------------------------------------------------------------------

    def export_with_report(
        self,
        bundle: Dict[str, Any],
        *,
        export_format: str = "json",
        include_redacted: bool = False,
        output_path: Optional[str] = None,
        report_template: str = "markdown",
        report_title: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Generate a report and include it as an artifact in the export.

        Returns the same shape as :meth:`export_to_json` /
        :meth:`export_to_zip`.
        """
        report = self.generate_report(
            bundle,
            template=report_template,
            title=report_title,
        )

        ext = "html" if report_template == "html" else "md"
        content_type = "text/html" if report_template == "html" else "text/markdown"

        bundle_with_report: Dict[str, Any] = {
            **bundle,
            "artifacts": [
                *bundle.get("artifacts", []),
                {
                    "artifact_id": "REPORT",
                    "type": "other",
                    "name": f"report.{ext}",
                    "content": report["content"],
                    "content_type": content_type,
                    "timestamp": datetime.now(timezone.utc).isoformat(),
                    "redacted": False,
                },
            ],
        }

        if export_format == "zip":
            return self.export_to_zip(
                bundle_with_report,
                include_redacted=include_redacted,
                output_path=output_path,
            )
        return self.export_to_json(
            bundle_with_report,
            include_redacted=include_redacted,
            output_path=output_path,
        )


# ---------------------------------------------------------------------------
# Module-level singleton
# ---------------------------------------------------------------------------

_exporter_instance: Optional[Exporter] = None


def get_exporter(redactor: Redactor) -> Exporter:
    """Return (or create) the module-level ``Exporter`` singleton."""
    global _exporter_instance
    if _exporter_instance is None:
        _exporter_instance = Exporter(redactor)
    return _exporter_instance


def reset_exporter() -> None:
    """Reset the singleton (primarily for testing)."""
    global _exporter_instance
    _exporter_instance = None
