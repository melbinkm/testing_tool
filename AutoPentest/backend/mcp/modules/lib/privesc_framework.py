"""
Privilege Escalation Testing Framework

Discovers and generates test plans for horizontal/vertical privilege escalation
and workflow bypass vulnerabilities by analyzing world model identities and endpoints.
"""

from __future__ import annotations

import logging
import re
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional

logger = logging.getLogger("autopentest-mcp")


class EscalationType(Enum):
    """Type of privilege escalation."""
    HORIZONTAL = "horizontal"       # Same-level: user A -> user B's data
    VERTICAL = "vertical"           # Low -> high: user -> admin
    WORKFLOW_BYPASS = "workflow_bypass"  # Skip auth/approval steps


@dataclass
class PrivEscCandidate:
    """A candidate privilege escalation test case."""
    source_role: str         # The role attempting escalation (e.g., "user")
    target_role: str         # The role being targeted (e.g., "admin")
    escalation_type: EscalationType
    endpoint: str            # Target endpoint path
    parameter: str           # Parameter involved (if any)
    confidence: float        # 0.0-1.0 confidence score
    reason: str = ""         # Why this is a candidate
    method: str = "GET"      # HTTP method

    def to_dict(self) -> Dict[str, Any]:
        return {
            "source_role": self.source_role,
            "target_role": self.target_role,
            "escalation_type": self.escalation_type.value,
            "endpoint": self.endpoint,
            "parameter": self.parameter,
            "confidence": self.confidence,
            "reason": self.reason,
            "method": self.method,
        }


# Admin path patterns that suggest privileged functionality
_ADMIN_PATH_PATTERNS = [
    r"/admin",
    r"/manage",
    r"/superuser",
    r"/dashboard",
    r"/settings",
    r"/config",
    r"/internal",
    r"/api/admin",
    r"/api/v\d+/admin",
    r"/users/.*/(role|permissions|admin)",
    r"/system",
    r"/debug",
    r"/console",
]

# Role hierarchy (lower index = less privilege)
_ROLE_HIERARCHY = ["guest", "anonymous", "user", "editor", "moderator", "manager", "admin", "superadmin", "root"]


def _role_level(role: str) -> int:
    """Get numeric privilege level for a role name."""
    role_lower = role.lower().strip()
    for i, r in enumerate(_ROLE_HIERARCHY):
        if r in role_lower or role_lower in r:
            return i
    return 3  # Default to "user" level if unknown


def _is_admin_path(path: str) -> bool:
    """Check if a path looks like an admin/privileged endpoint."""
    for pattern in _ADMIN_PATH_PATTERNS:
        if re.search(pattern, path, re.IGNORECASE):
            return True
    return False


async def discover_privesc_candidates(
    db,
    assessment_id: int,
) -> List[PrivEscCandidate]:
    """Discover privilege escalation candidates from world model data.

    Analyzes identities (roles) and endpoints to find:
    - Admin paths accessible to non-admin roles (vertical)
    - User data endpoints accessible across users (horizontal)
    - Workflow endpoints that may skip authorization steps

    Parameters
    ----------
    db : WorldModelDatabase
        Active world model database.
    assessment_id : int
        Current assessment ID.

    Returns
    -------
    list[PrivEscCandidate]
        Discovered escalation candidates sorted by confidence (descending).
    """
    candidates: List[PrivEscCandidate] = []

    # Load identities and endpoints
    identities = await db.query("identities", limit=100)
    endpoints = await db.query("endpoints", limit=500)

    if not identities or not endpoints:
        return candidates

    # Classify roles
    roles_by_level: Dict[int, List[Dict]] = {}
    for ident in identities:
        meta = ident.get("metadata") or {}
        role = meta.get("role") or meta.get("user_type") or "user"
        level = _role_level(role)
        roles_by_level.setdefault(level, []).append({
            "id": ident.get("id") or ident.get("name") or "",
            "role": role,
            "level": level,
        })

    low_roles = []
    high_roles = []
    for level, idents in roles_by_level.items():
        for ident in idents:
            if level <= 3:  # guest/anonymous/user
                low_roles.append(ident)
            else:
                high_roles.append(ident)

    # Strategy 1: Admin paths accessible to low-privilege users (vertical)
    for ep in endpoints:
        path = ep.get("path") or ep.get("url") or "/"
        method = ep.get("method") or "GET"
        auth_required = ep.get("auth_required") or ep.get("requires_auth", False)

        if _is_admin_path(path):
            for low in low_roles:
                for high in high_roles:
                    confidence = 0.7 if auth_required else 0.85
                    candidates.append(PrivEscCandidate(
                        source_role=low["role"],
                        target_role=high["role"],
                        escalation_type=EscalationType.VERTICAL,
                        endpoint=path,
                        parameter="",
                        confidence=confidence,
                        reason=f"Admin path '{path}' may be accessible to {low['role']} role",
                        method=method,
                    ))
                    break  # One candidate per endpoint per low role
            if not low_roles and not auth_required:
                candidates.append(PrivEscCandidate(
                    source_role="anonymous",
                    target_role="admin",
                    escalation_type=EscalationType.VERTICAL,
                    endpoint=path,
                    parameter="",
                    confidence=0.85,
                    reason=f"Admin path '{path}' has no auth requirement",
                    method=method,
                ))

    # Strategy 2: ID-based endpoints for horizontal escalation
    for ep in endpoints:
        path = ep.get("path") or ep.get("url") or "/"
        method = ep.get("method") or "GET"
        params = ep.get("parameters") or []

        if isinstance(params, list):
            for p in params:
                if isinstance(p, dict):
                    pname = (p.get("name") or "").lower()
                    if pname.endswith("_id") or pname == "id" or pname in ("user_id", "account_id"):
                        for i, low1 in enumerate(low_roles):
                            for low2 in low_roles[i + 1:]:
                                candidates.append(PrivEscCandidate(
                                    source_role=low1["role"],
                                    target_role=low2["role"],
                                    escalation_type=EscalationType.HORIZONTAL,
                                    endpoint=path,
                                    parameter=pname,
                                    confidence=0.65,
                                    reason=f"ID parameter '{pname}' may allow cross-user access on {path}",
                                    method=method,
                                ))
                                break  # One pair per endpoint
                            break

    # Strategy 3: State-changing endpoints without CSRF as workflow bypass
    for ep in endpoints:
        path = ep.get("path") or ep.get("url") or "/"
        method = (ep.get("method") or "GET").upper()

        if method in ("POST", "PUT", "PATCH", "DELETE"):
            auth_required = ep.get("auth_required") or ep.get("requires_auth", False)
            if not auth_required:
                candidates.append(PrivEscCandidate(
                    source_role="anonymous",
                    target_role="user",
                    escalation_type=EscalationType.WORKFLOW_BYPASS,
                    endpoint=path,
                    parameter="",
                    confidence=0.5,
                    reason=f"State-changing endpoint '{method} {path}' has no auth requirement",
                    method=method,
                ))

    # Deduplicate and sort by confidence
    seen = set()
    unique: List[PrivEscCandidate] = []
    for c in candidates:
        key = (c.escalation_type, c.endpoint, c.source_role, c.parameter)
        if key not in seen:
            seen.add(key)
            unique.append(c)

    unique.sort(key=lambda c: -c.confidence)
    return unique


def generate_privesc_tests(candidates: List[PrivEscCandidate]) -> List[Dict[str, Any]]:
    """Generate test plans for privilege escalation candidates.

    Parameters
    ----------
    candidates : list[PrivEscCandidate]
        Discovered escalation candidates.

    Returns
    -------
    list[dict]
        Test plans with request templates, expected behavior, and success criteria.
    """
    plans: List[Dict[str, Any]] = []

    for cand in candidates:
        plan: Dict[str, Any] = {
            "candidate": cand.to_dict(),
            "test_steps": [],
            "success_criteria": [],
        }

        if cand.escalation_type == EscalationType.VERTICAL:
            plan["test_steps"] = [
                {
                    "step": 1,
                    "action": f"Send {cand.method} {cand.endpoint} with {cand.target_role} credentials",
                    "tool": "auth_replay_with_identity",
                    "args": {"url": cand.endpoint, "method": cand.method, "identity_id": f"<{cand.target_role}_identity>"},
                    "expected": "200 OK with admin content (baseline)",
                },
                {
                    "step": 2,
                    "action": f"Send {cand.method} {cand.endpoint} with {cand.source_role} credentials",
                    "tool": "auth_replay_with_identity",
                    "args": {"url": cand.endpoint, "method": cand.method, "identity_id": f"<{cand.source_role}_identity>"},
                    "expected": "403 Forbidden (secure) or 200 OK (vulnerable)",
                },
                {
                    "step": 3,
                    "action": f"Compare responses: if {cand.source_role} gets same content as {cand.target_role}, escalation confirmed",
                    "tool": "manual_comparison",
                    "expected": "Response bodies should differ significantly",
                },
            ]
            plan["success_criteria"] = [
                f"{cand.source_role} receives 200 OK on {cand.endpoint}",
                f"Response content matches {cand.target_role}'s response",
                f"Admin functionality accessible without {cand.target_role} role",
            ]

        elif cand.escalation_type == EscalationType.HORIZONTAL:
            plan["test_steps"] = [
                {
                    "step": 1,
                    "action": f"Send {cand.method} {cand.endpoint} with user A's ID and user A's credentials",
                    "tool": "inject_payload",
                    "args": {"url": cand.endpoint, "parameter": cand.parameter, "payload": "<user_A_id>"},
                    "expected": "200 OK with user A's data (baseline)",
                },
                {
                    "step": 2,
                    "action": f"Send {cand.method} {cand.endpoint} with user B's ID using user A's credentials",
                    "tool": "inject_payload",
                    "args": {"url": cand.endpoint, "parameter": cand.parameter, "payload": "<user_B_id>"},
                    "expected": "403 Forbidden (secure) or 200 OK with user B data (IDOR)",
                },
            ]
            plan["success_criteria"] = [
                f"User A can access user B's data via {cand.parameter} parameter",
                "Response contains different user's data",
                "No authorization check on resource ownership",
            ]

        elif cand.escalation_type == EscalationType.WORKFLOW_BYPASS:
            plan["test_steps"] = [
                {
                    "step": 1,
                    "action": f"Send {cand.method} {cand.endpoint} without any credentials",
                    "tool": "recon_endpoint",
                    "args": {"url": cand.endpoint, "method": cand.method},
                    "expected": "401/403 (secure) or 200 OK (bypass)",
                },
                {
                    "step": 2,
                    "action": "If 200 OK, verify the action was actually performed",
                    "tool": "recon_endpoint",
                    "args": {"url": cand.endpoint, "method": "GET"},
                    "expected": "State change visible without authentication",
                },
            ]
            plan["success_criteria"] = [
                f"Unauthenticated {cand.method} to {cand.endpoint} succeeds",
                "State change persists without authentication",
                "No workflow enforcement on state-changing operation",
            ]

        plans.append(plan)

    return plans
