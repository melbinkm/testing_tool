"""
Phase Orchestrator - Multi-phase penetration test orchestration with gate conditions.

Manages the 6-phase pentest lifecycle:
    1. Reconnaissance
    2. Mapping & Enumeration
    3. SAST Code Review
    4. Vulnerability Assessment
    5. Exploitation
    6. Post-Exploitation & Reporting

Phase transitions are gated by metric thresholds computed from world model data.
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

logger = logging.getLogger("autopentest-mcp")

# Number of phases in the assessment lifecycle
NUM_PHASES = 6


# ---------------------------------------------------------------------------
# Phase definitions
# ---------------------------------------------------------------------------

PHASES = [
    {
        "phase": 1,
        "name": "Reconnaissance",
        "description": "Discover the attack surface: subdomains, hosts, services.",
        "gates": {},  # Entry phase, no gates
    },
    {
        "phase": 2,
        "name": "Mapping & Enumeration",
        "description": "Map endpoints, parameters, and authentication flows.",
        "gates": {
            "min_assets": 3,
            "min_endpoints": 5,
        },
    },
    {
        "phase": 3,
        "name": "SAST Code Review",
        "description": "Static analysis of source code: clone, scan, verify, correlate.",
        "gates": {
            "min_sast_verified_pct": 100,  # Vacuously true if no SAST findings
            "min_code_audit_pct": 100,  # Vacuously true if no code_audit_queue items
            "min_sast_scanners_run": 1,  # Require â‰¥1 SAST scanner when source code is indexed
        },
    },
    {
        "phase": 4,
        "name": "Vulnerability Assessment",
        "description": "Test endpoints for vulnerability classes using coverage matrix.",
        "gates": {
            "min_confirmed_hypotheses": 1,
            "min_findings": 3,
            "min_coverage_pct": 25.0,
        },
    },
    {
        "phase": 5,
        "name": "Exploitation",
        "description": "Exploit confirmed vulnerabilities with PoC generation.",
        "gates": {
            "min_confirmed_findings": 1,
        },
    },
    {
        "phase": 6,
        "name": "Post-Exploitation & Reporting",
        "description": "Document findings, generate report, and clean up.",
        "gates": {
            "min_confirmed_findings": 1,
        },
    },
]


class PhaseOrchestrator:
    """Orchestrates multi-phase penetration testing with gate conditions."""

    PLAN_TITLE = "Assessment Phase Orchestration"

    def __init__(self, db: Any, activity_logger: Optional[Any] = None):
        self._db = db
        self._plan_id: Optional[str] = None
        self._activity_logger = activity_logger  # Fix 3: ActivityLogger integration

    async def _get_or_create_plan(self) -> str:
        """Find or create the orchestration plan."""
        plans = await self._db.query(table="plans", filters={"status": "active"}, limit=100)

        for plan in plans:
            if plan.get("title") == self.PLAN_TITLE:
                self._plan_id = plan["id"]
                return plan["id"]

        plan = await self._db.add_plan(
            title=self.PLAN_TITLE,
            goal="Track assessment phase progression with gate conditions",
            steps=[{"description": p["name"]} for p in PHASES],
        )
        self._plan_id = plan["id"]

        # Mark phase 1 as in_progress
        await self._db.update_plan(
            plan_id=plan["id"],
            step_index=0,
            step_status="in_progress",
        )

        return plan["id"]

    async def _get_current_phase(self) -> int:
        """Determine the current phase from the plan."""
        plan_id = await self._get_or_create_plan()
        plan = await self._db.get_by_id("plans", plan_id)
        if not plan:
            return 1

        steps = plan.get("steps", [])
        # Find the last in_progress step
        for i in range(len(steps) - 1, -1, -1):
            if steps[i].get("status") == "in_progress":
                return i + 1  # 1-indexed

        # If none in progress, find the last done step + 1
        for i in range(len(steps) - 1, -1, -1):
            if steps[i].get("status") == "done":
                return min(i + 2, NUM_PHASES)  # Next phase, capped at NUM_PHASES

        return 1

    async def get_metrics(self) -> Dict[str, int]:
        """Compute current metrics from world model tables."""
        metrics: Dict[str, int] = {}
        aid = self._db._assessment_id

        # Count assets
        assets_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_assets WHERE assessment_id = $1", (aid,)
        )
        metrics["assets"] = assets_row["cnt"] if assets_row else 0

        # Count endpoints
        endpoints_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_endpoints WHERE assessment_id = $1", (aid,)
        )
        metrics["endpoints"] = endpoints_row["cnt"] if endpoints_row else 0

        # Count hypotheses (total and confirmed)
        hyp_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_hypotheses WHERE assessment_id = $1", (aid,)
        )
        metrics["hypotheses"] = hyp_row["cnt"] if hyp_row else 0

        confirmed_hyp_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_hypotheses "
            "WHERE status = 'confirmed' AND assessment_id = $1", (aid,)
        )
        metrics["confirmed_hypotheses"] = confirmed_hyp_row["cnt"] if confirmed_hyp_row else 0

        # Count findings (total and confirmed)
        findings_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_findings WHERE assessment_id = $1", (aid,)
        )
        metrics["findings"] = findings_row["cnt"] if findings_row else 0

        confirmed_findings_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_findings "
            "WHERE status = 'confirmed' AND assessment_id = $1", (aid,)
        )
        metrics["confirmed_findings"] = confirmed_findings_row["cnt"] if confirmed_findings_row else 0

        # Coverage matrix percentage (Fix 3)
        coverage_row = await self._db._fetchone(
            "SELECT COUNT(*) as total, "
            "COUNT(*) FILTER (WHERE status != 'pending') as tested "
            "FROM wm_coverage_matrix WHERE assessment_id = $1", (aid,)
        )
        total = coverage_row["total"] if coverage_row else 0
        tested = coverage_row["tested"] if coverage_row else 0
        metrics["coverage_pct"] = round((tested / total) * 100, 1) if total > 0 else 0.0

        # SAST verification percentage
        sast_row = await self._db._fetchone(
            "SELECT COUNT(*) as total, "
            "COUNT(*) FILTER (WHERE metadata->>'verified' = 'true') as verified "
            "FROM wm_knowledge WHERE category = 'sast_scan_result' AND assessment_id = $1", (aid,)
        )
        sast_total = sast_row["total"] if sast_row else 0
        sast_verified = sast_row["verified"] if sast_row else 0
        metrics["sast_verified_pct"] = round((sast_verified / sast_total) * 100, 1) if sast_total > 0 else 100.0

        # SAST scanner enforcement: require scanners when source code is indexed
        source_indexed_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_knowledge "
            "WHERE category = 'source_code' AND assessment_id = $1", (aid,)
        )
        source_indexed = source_indexed_row["cnt"] if source_indexed_row else 0
        # If source code is indexed, require SAST scanners to have actually run
        # If no source code indexed (no git_repo_url), auto-pass (1 >= 1)
        metrics["sast_scanners_run"] = sast_total if source_indexed > 0 else 1

        # Code audit completion percentage
        audit_row = await self._db._fetchone(
            "SELECT COUNT(*) as total, "
            "COUNT(*) FILTER (WHERE metadata->>'reviewed' = 'true') as reviewed "
            "FROM wm_knowledge WHERE category = 'code_audit_queue' AND assessment_id = $1", (aid,)
        )
        audit_total = audit_row["total"] if audit_row else 0
        audit_reviewed = audit_row["reviewed"] if audit_row else 0
        metrics["code_audit_pct"] = round((audit_reviewed / audit_total) * 100, 1) if audit_total > 0 else 100.0

        return metrics

    def check_gates(self, target_phase: int, metrics: Dict[str, int]) -> Dict[str, Any]:
        """Check if gate conditions are met for a target phase.

        Returns ``{"met": bool, "conditions": [{name, required, actual, met}]}``.
        """
        if target_phase < 1 or target_phase > NUM_PHASES:
            return {"met": False, "conditions": [], "error": f"Invalid phase (1-{NUM_PHASES})"}

        phase_def = PHASES[target_phase - 1]
        gates = phase_def.get("gates", {})

        if not gates:
            return {"met": True, "conditions": []}

        conditions = []
        all_met = True

        _METRIC_MAP = {
            "min_assets": "assets",
            "min_endpoints": "endpoints",
            "min_hypotheses": "hypotheses",
            "min_confirmed_hypotheses": "confirmed_hypotheses",
            "min_findings": "findings",
            "min_confirmed_findings": "confirmed_findings",
            "min_coverage_pct": "coverage_pct",  # Fix 3: Coverage percentage metric
            "min_sast_verified_pct": "sast_verified_pct",  # Phase 3: SAST verification percentage
            "min_code_audit_pct": "code_audit_pct",  # Phase 3: Code audit completion percentage
            "min_sast_scanners_run": "sast_scanners_run",  # Phase 3: Require scanner when source indexed
        }

        for gate_name, required_value in gates.items():
            metric_key = _METRIC_MAP.get(gate_name, gate_name)
            actual = metrics.get(metric_key, 0)
            met = actual >= required_value
            if not met:
                all_met = False
            conditions.append({
                "name": gate_name,
                "required": required_value,
                "actual": actual,
                "met": met,
            })

        return {"met": all_met, "conditions": conditions}

    async def get_status(self) -> Dict[str, Any]:
        """Get current orchestration status, metrics, and gate conditions."""
        current_phase = await self._get_current_phase()
        metrics = await self.get_metrics()

        phase_def = PHASES[current_phase - 1]

        # Check next phase gates
        next_phase_gates = None
        if current_phase < NUM_PHASES:
            next_phase_gates = self.check_gates(current_phase + 1, metrics)

        # Calculate overall progress (Fix B5: Handle final phase completion)
        completed_phases = current_phase - 1

        # Check if final phase is actually done (not just in_progress)
        if current_phase == NUM_PHASES:
            plan_id = await self._get_or_create_plan()
            plans = await self._db.query(table="plans", filters={"id": plan_id}, limit=1)
            if plans:
                plan = plans[0]
                steps = plan.get("steps", [])
                if len(steps) >= NUM_PHASES and steps[NUM_PHASES - 1].get("status") == "done":
                    completed_phases = NUM_PHASES

        progress_pct = round((completed_phases / NUM_PHASES) * 100, 1)

        return {
            "current_phase": current_phase,
            "phase_name": phase_def["name"],
            "phase_description": phase_def["description"],
            "metrics": metrics,
            "next_phase_gates": next_phase_gates,
            "progress_pct": progress_pct,
            "phases": [
                {
                    "phase": p["phase"],
                    "name": p["name"],
                    "status": (
                        "completed" if p["phase"] < current_phase
                        else "in_progress" if p["phase"] == current_phase
                        else "pending"
                    ),
                }
                for p in PHASES
            ],
        }

    async def advance(self, target_phase: int, force: bool = False) -> Dict[str, Any]:
        """Request phase transition.

        Validates that target_phase is current_phase + 1 and all gates are met
        (unless force=True).
        """
        current_phase = await self._get_current_phase()
        metrics = await self.get_metrics()

        if target_phase != current_phase + 1 and not force:
            return {
                "success": False,
                "error": (
                    f"Can only advance to phase {current_phase + 1} "
                    f"(current: {current_phase}, requested: {target_phase}). "
                    f"Use force=true to override."
                ),
            }

        if target_phase < 1 or target_phase > NUM_PHASES:
            return {"success": False, "error": f"Invalid target phase: {target_phase}. Must be 1-{NUM_PHASES}."}

        # Check gate conditions
        gate_result = self.check_gates(target_phase, metrics)
        if not gate_result["met"] and not force:
            unmet = [c for c in gate_result["conditions"] if not c["met"]]
            return {
                "success": False,
                "error": "Gate conditions not met",
                "unmet_conditions": unmet,
                "hint": "Use force=true to override gate conditions.",
            }

        # Perform the transition
        plan_id = await self._get_or_create_plan()

        # Mark all phases from current to (target-1) as done (Round 11 Fix 3C: Richer notes)
        for phase_num in range(current_phase, target_phase):
            if 1 <= phase_num <= NUM_PHASES:
                # Build human-readable summary
                if phase_num == current_phase:
                    phase_name = PHASES[phase_num - 1]["name"]
                    result_summary = (
                        f"{phase_name} completed: "
                        f"{metrics.get('assets', 0)} assets, "
                        f"{metrics.get('endpoints', 0)} endpoints, "
                        f"{metrics.get('findings', 0)} findings discovered"
                    )
                else:
                    result_summary = "Skipped (force advance)"

                await self._db.update_plan(
                    plan_id=plan_id,
                    step_index=phase_num - 1,
                    step_status="done",
                    step_result=result_summary,
                )

        # Mark target phase as in_progress
        if target_phase >= 1 and target_phase <= NUM_PHASES:
            await self._db.update_plan(
                plan_id=plan_id,
                step_index=target_phase - 1,
                step_status="in_progress",
            )

        # Log phase transition via ActivityLogger (Fix 3)
        if self._activity_logger:
            try:
                await self._activity_logger.log_phase_transition(
                    from_phase=current_phase,
                    to_phase=target_phase,
                    reason="Manual advance" if force else "Gate conditions met",
                    forced=force and not gate_result.get("met", True),
                    metrics=metrics
                )
            except Exception as e:
                logger.warning(f"Failed to log phase transition: {e}")

        phase_def = PHASES[target_phase - 1]

        return {
            "success": True,
            "previous_phase": current_phase,
            "current_phase": target_phase,
            "phase_name": phase_def["name"],
            "forced": force and not gate_result.get("met", True),
            "message": f"Advanced to Phase {target_phase}: {phase_def['name']}",
        }

    async def update_phase_notes(self, notes: str) -> Dict[str, Any]:
        """Update notes for the current in-progress phase.

        Round 11 Fix 3C: Allows setting notes while phase is still running.

        Args:
            notes: Human-readable notes about phase progress

        Returns:
            Success status and current phase info
        """
        current_phase = await self._get_current_phase()
        plan_id = await self._get_or_create_plan()

        await self._db.update_plan(
            plan_id=plan_id,
            step_index=current_phase - 1,
            step_result=notes,
        )

        return {
            "success": True,
            "current_phase": current_phase,
            "notes_updated": True,
        }

    async def complete_assessment(self) -> Dict[str, Any]:
        """Mark the assessment as complete (final phase done).

        Called automatically when final phase work is finished. Marks the final
        phase as "done" so the UI shows all phases completed.
        """
        current_phase = await self._get_current_phase()
        if current_phase != NUM_PHASES:
            return {
                "success": False,
                "error": f"Assessment is on phase {current_phase}, not phase {NUM_PHASES}"
            }

        plan_id = await self._get_or_create_plan()
        await self._db.update_plan(
            plan_id=plan_id,
            step_index=NUM_PHASES - 1,  # Final phase index
            step_status="done",
            step_result="Assessment completed.",
        )

        # Log completion via ActivityLogger
        if self._activity_logger:
            try:
                await self._activity_logger.log_phase_transition(
                    from_phase=NUM_PHASES,
                    to_phase=NUM_PHASES,
                    reason="Assessment marked as complete",
                    forced=False,
                    metrics=await self.get_metrics()
                )
            except Exception as e:
                logger.warning(f"Failed to log assessment completion: {e}")

        return {
            "success": True,
            "message": f"Assessment marked as complete. All {NUM_PHASES} phases done."
        }
