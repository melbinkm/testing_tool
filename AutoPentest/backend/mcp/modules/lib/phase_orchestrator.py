"""
Phase Orchestrator - Multi-phase penetration test orchestration with gate conditions.

Manages the 5-phase pentest lifecycle:
    1. Reconnaissance
    2. Mapping & Enumeration
    3. Vulnerability Assessment
    4. Exploitation
    5. Post-Exploitation & Reporting

Phase transitions are gated by metric thresholds computed from world model data.
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

logger = logging.getLogger("autopentest-mcp")


# ---------------------------------------------------------------------------
# Phase definitions
# ---------------------------------------------------------------------------

PHASES = [
    {
        "phase": 1,
        "name": "Reconnaissance",
        "description": "Discover the attack surface: subdomains, hosts, services.",
        "gates": {},  # Entry phase, no gates
    },
    {
        "phase": 2,
        "name": "Mapping & Enumeration",
        "description": "Map endpoints, parameters, and authentication flows.",
        "gates": {
            "min_assets": 3,
            "min_endpoints": 5,
        },
    },
    {
        "phase": 3,
        "name": "Vulnerability Assessment",
        "description": "Test endpoints for vulnerability classes using coverage matrix.",
        "gates": {
            "min_endpoints": 5,  # Round 11 Fix 3A: Lowered from 10
            "min_findings": 1,   # Round 11 Fix 3A: Replaced min_hypotheses with min_findings
        },
    },
    {
        "phase": 4,
        "name": "Exploitation",
        "description": "Exploit confirmed vulnerabilities with PoC generation.",
        "gates": {
            "min_confirmed_hypotheses": 1,
            "min_findings": 3,           # Fix 3: Require more findings before exploitation
            "min_coverage_pct": 25.0,    # Fix 3: At least 25% of coverage matrix tested
        },
    },
    {
        "phase": 5,
        "name": "Post-Exploitation & Reporting",
        "description": "Document findings, generate report, and clean up.",
        "gates": {
            "min_confirmed_findings": 1,
        },
    },
]


class PhaseOrchestrator:
    """Orchestrates multi-phase penetration testing with gate conditions."""

    PLAN_TITLE = "Assessment Phase Orchestration"

    def __init__(self, db: Any, activity_logger: Optional[Any] = None):
        self._db = db
        self._plan_id: Optional[str] = None
        self._activity_logger = activity_logger  # Fix 3: ActivityLogger integration

    async def _get_or_create_plan(self) -> str:
        """Find or create the orchestration plan."""
        plans = await self._db.query(table="plans", filters={"status": "active"}, limit=100)

        for plan in plans:
            if plan.get("title") == self.PLAN_TITLE:
                self._plan_id = plan["id"]
                return plan["id"]

        plan = await self._db.add_plan(
            title=self.PLAN_TITLE,
            goal="Track assessment phase progression with gate conditions",
            steps=[{"description": p["name"]} for p in PHASES],
        )
        self._plan_id = plan["id"]

        # Mark phase 1 as in_progress
        await self._db.update_plan(
            plan_id=plan["id"],
            step_index=0,
            step_status="in_progress",
        )

        return plan["id"]

    async def _get_current_phase(self) -> int:
        """Determine the current phase from the plan."""
        plan_id = await self._get_or_create_plan()
        plan = await self._db.get_by_id("plans", plan_id)
        if not plan:
            return 1

        steps = plan.get("steps", [])
        # Find the last in_progress step
        for i in range(len(steps) - 1, -1, -1):
            if steps[i].get("status") == "in_progress":
                return i + 1  # 1-indexed

        # If none in progress, find the last done step + 1
        for i in range(len(steps) - 1, -1, -1):
            if steps[i].get("status") == "done":
                return min(i + 2, 5)  # Next phase, capped at 5

        return 1

    async def get_metrics(self) -> Dict[str, int]:
        """Compute current metrics from world model tables."""
        metrics: Dict[str, int] = {}
        aid = self._db._assessment_id

        # Count assets
        assets_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_assets WHERE assessment_id = $1", (aid,)
        )
        metrics["assets"] = assets_row["cnt"] if assets_row else 0

        # Count endpoints
        endpoints_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_endpoints WHERE assessment_id = $1", (aid,)
        )
        metrics["endpoints"] = endpoints_row["cnt"] if endpoints_row else 0

        # Count hypotheses (total and confirmed)
        hyp_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_hypotheses WHERE assessment_id = $1", (aid,)
        )
        metrics["hypotheses"] = hyp_row["cnt"] if hyp_row else 0

        confirmed_hyp_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_hypotheses "
            "WHERE status = 'confirmed' AND assessment_id = $1", (aid,)
        )
        metrics["confirmed_hypotheses"] = confirmed_hyp_row["cnt"] if confirmed_hyp_row else 0

        # Count findings (total and confirmed)
        findings_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_findings WHERE assessment_id = $1", (aid,)
        )
        metrics["findings"] = findings_row["cnt"] if findings_row else 0

        confirmed_findings_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM wm_findings "
            "WHERE status = 'confirmed' AND assessment_id = $1", (aid,)
        )
        metrics["confirmed_findings"] = confirmed_findings_row["cnt"] if confirmed_findings_row else 0

        # Coverage matrix percentage (Fix 3)
        coverage_row = await self._db._fetchone(
            "SELECT COUNT(*) as total, "
            "COUNT(*) FILTER (WHERE status != 'pending') as tested "
            "FROM wm_coverage_matrix WHERE assessment_id = $1", (aid,)
        )
        total = coverage_row["total"] if coverage_row else 0
        tested = coverage_row["tested"] if coverage_row else 0
        metrics["coverage_pct"] = round((tested / total) * 100, 1) if total > 0 else 0.0

        return metrics

    def check_gates(self, target_phase: int, metrics: Dict[str, int]) -> Dict[str, Any]:
        """Check if gate conditions are met for a target phase.

        Returns ``{"met": bool, "conditions": [{name, required, actual, met}]}``.
        """
        if target_phase < 1 or target_phase > 5:
            return {"met": False, "conditions": [], "error": "Invalid phase (1-5)"}

        phase_def = PHASES[target_phase - 1]
        gates = phase_def.get("gates", {})

        if not gates:
            return {"met": True, "conditions": []}

        conditions = []
        all_met = True

        _METRIC_MAP = {
            "min_assets": "assets",
            "min_endpoints": "endpoints",
            "min_hypotheses": "hypotheses",
            "min_confirmed_hypotheses": "confirmed_hypotheses",
            "min_findings": "findings",
            "min_confirmed_findings": "confirmed_findings",
            "min_coverage_pct": "coverage_pct",  # Fix 3: Coverage percentage metric
        }

        for gate_name, required_value in gates.items():
            metric_key = _METRIC_MAP.get(gate_name, gate_name)
            actual = metrics.get(metric_key, 0)
            met = actual >= required_value
            if not met:
                all_met = False
            conditions.append({
                "name": gate_name,
                "required": required_value,
                "actual": actual,
                "met": met,
            })

        return {"met": all_met, "conditions": conditions}

    async def get_status(self) -> Dict[str, Any]:
        """Get current orchestration status, metrics, and gate conditions."""
        current_phase = await self._get_current_phase()
        metrics = await self.get_metrics()

        phase_def = PHASES[current_phase - 1]

        # Check next phase gates
        next_phase_gates = None
        if current_phase < 5:
            next_phase_gates = self.check_gates(current_phase + 1, metrics)

        # Calculate overall progress (Fix B5: Handle phase 5 completion)
        completed_phases = current_phase - 1

        # Check if phase 5 is actually done (not just in_progress)
        if current_phase == 5:
            plan_id = await self._get_or_create_plan()
            plans = await self._db.query(table="plans", filters={"id": plan_id}, limit=1)
            if plans:
                plan = plans[0]
                steps = plan.get("steps", [])
                if len(steps) >= 5 and steps[4].get("status") == "done":
                    completed_phases = 5

        progress_pct = round((completed_phases / 5) * 100, 1)

        return {
            "current_phase": current_phase,
            "phase_name": phase_def["name"],
            "phase_description": phase_def["description"],
            "metrics": metrics,
            "next_phase_gates": next_phase_gates,
            "progress_pct": progress_pct,
            "phases": [
                {
                    "phase": p["phase"],
                    "name": p["name"],
                    "status": (
                        "completed" if p["phase"] < current_phase
                        else "in_progress" if p["phase"] == current_phase
                        else "pending"
                    ),
                }
                for p in PHASES
            ],
        }

    async def advance(self, target_phase: int, force: bool = False) -> Dict[str, Any]:
        """Request phase transition.

        Validates that target_phase is current_phase + 1 and all gates are met
        (unless force=True).
        """
        current_phase = await self._get_current_phase()
        metrics = await self.get_metrics()

        if target_phase != current_phase + 1 and not force:
            return {
                "success": False,
                "error": (
                    f"Can only advance to phase {current_phase + 1} "
                    f"(current: {current_phase}, requested: {target_phase}). "
                    f"Use force=true to override."
                ),
            }

        if target_phase < 1 or target_phase > 5:
            return {"success": False, "error": f"Invalid target phase: {target_phase}. Must be 1-5."}

        # Check gate conditions
        gate_result = self.check_gates(target_phase, metrics)
        if not gate_result["met"] and not force:
            unmet = [c for c in gate_result["conditions"] if not c["met"]]
            return {
                "success": False,
                "error": "Gate conditions not met",
                "unmet_conditions": unmet,
                "hint": "Use force=true to override gate conditions.",
            }

        # Perform the transition
        plan_id = await self._get_or_create_plan()

        # Mark all phases from current to (target-1) as done (Round 11 Fix 3C: Richer notes)
        for phase_num in range(current_phase, target_phase):
            if 1 <= phase_num <= 5:
                # Build human-readable summary
                if phase_num == current_phase:
                    phase_name = PHASES[phase_num - 1]["name"]
                    result_summary = (
                        f"{phase_name} completed: "
                        f"{metrics.get('assets', 0)} assets, "
                        f"{metrics.get('endpoints', 0)} endpoints, "
                        f"{metrics.get('findings', 0)} findings discovered"
                    )
                else:
                    result_summary = "Skipped (force advance)"

                await self._db.update_plan(
                    plan_id=plan_id,
                    step_index=phase_num - 1,
                    step_status="done",
                    step_result=result_summary,
                )

        # Mark target phase as in_progress
        if target_phase >= 1 and target_phase <= 5:
            await self._db.update_plan(
                plan_id=plan_id,
                step_index=target_phase - 1,
                step_status="in_progress",
            )

        # Log phase transition via ActivityLogger (Fix 3)
        if self._activity_logger:
            try:
                await self._activity_logger.log_phase_transition(
                    from_phase=current_phase,
                    to_phase=target_phase,
                    reason="Manual advance" if force else "Gate conditions met",
                    forced=force and not gate_result.get("met", True),
                    metrics=metrics
                )
            except Exception as e:
                logger.warning(f"Failed to log phase transition: {e}")

        phase_def = PHASES[target_phase - 1]

        return {
            "success": True,
            "previous_phase": current_phase,
            "current_phase": target_phase,
            "phase_name": phase_def["name"],
            "forced": force and not gate_result.get("met", True),
            "message": f"Advanced to Phase {target_phase}: {phase_def['name']}",
        }

    async def update_phase_notes(self, notes: str) -> Dict[str, Any]:
        """Update notes for the current in-progress phase.

        Round 11 Fix 3C: Allows setting notes while phase is still running.

        Args:
            notes: Human-readable notes about phase progress

        Returns:
            Success status and current phase info
        """
        current_phase = await self._get_current_phase()
        plan_id = await self._get_or_create_plan()

        await self._db.update_plan(
            plan_id=plan_id,
            step_index=current_phase - 1,
            step_result=notes,
        )

        return {
            "success": True,
            "current_phase": current_phase,
            "notes_updated": True,
        }

    async def complete_assessment(self) -> Dict[str, Any]:
        """Mark the assessment as complete (phase 5 done).

        Called automatically when phase 5 work is finished. Marks the final
        phase as "done" so the UI shows "5 Completed" instead of "1 In Progress".
        """
        current_phase = await self._get_current_phase()
        if current_phase != 5:
            return {
                "success": False,
                "error": f"Assessment is on phase {current_phase}, not phase 5"
            }

        plan_id = await self._get_or_create_plan()
        await self._db.update_plan(
            plan_id=plan_id,
            step_index=4,  # Phase 5 = index 4
            step_status="done",
            step_result="Assessment completed.",
        )

        # Log completion via ActivityLogger
        if self._activity_logger:
            try:
                await self._activity_logger.log_phase_transition(
                    from_phase=5,
                    to_phase=5,
                    reason="Assessment marked as complete",
                    forced=False,
                    metrics=await self.get_metrics()
                )
            except Exception as e:
                logger.warning(f"Failed to log assessment completion: {e}")

        return {
            "success": True,
            "message": "Assessment marked as complete. All 5 phases done."
        }
