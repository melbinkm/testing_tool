"""
Phase Orchestrator - Multi-phase penetration test orchestration with gate conditions.

Manages the 5-phase pentest lifecycle:
    1. Reconnaissance
    2. Mapping & Enumeration
    3. Vulnerability Assessment
    4. Exploitation
    5. Post-Exploitation & Reporting

Phase transitions are gated by metric thresholds computed from world model data.
"""

from __future__ import annotations

import logging
from typing import Any, Dict, List, Optional

logger = logging.getLogger("autopentest-mcp")


# ---------------------------------------------------------------------------
# Phase definitions
# ---------------------------------------------------------------------------

PHASES = [
    {
        "phase": 1,
        "name": "Reconnaissance",
        "description": "Discover the attack surface: subdomains, hosts, services.",
        "gates": {},  # Entry phase, no gates
    },
    {
        "phase": 2,
        "name": "Mapping & Enumeration",
        "description": "Map endpoints, parameters, and authentication flows.",
        "gates": {
            "min_assets": 3,
            "min_endpoints": 5,
        },
    },
    {
        "phase": 3,
        "name": "Vulnerability Assessment",
        "description": "Test endpoints for vulnerability classes using coverage matrix.",
        "gates": {
            "min_endpoints": 10,
            "min_hypotheses": 3,
        },
    },
    {
        "phase": 4,
        "name": "Exploitation",
        "description": "Exploit confirmed vulnerabilities with PoC generation.",
        "gates": {
            "min_confirmed_hypotheses": 1,
            "min_findings": 1,
        },
    },
    {
        "phase": 5,
        "name": "Post-Exploitation & Reporting",
        "description": "Document findings, generate report, and clean up.",
        "gates": {
            "min_confirmed_findings": 1,
        },
    },
]


class PhaseOrchestrator:
    """Orchestrates multi-phase penetration testing with gate conditions."""

    PLAN_TITLE = "Assessment Phase Orchestration"

    def __init__(self, db: Any):
        self._db = db
        self._plan_id: Optional[str] = None

    async def _get_or_create_plan(self) -> str:
        """Find or create the orchestration plan."""
        plans = await self._db.query(table="plans", filters={"status": "active"}, limit=100)

        for plan in plans:
            if plan.get("title") == self.PLAN_TITLE:
                self._plan_id = plan["id"]
                return plan["id"]

        plan = await self._db.add_plan(
            title=self.PLAN_TITLE,
            goal="Track assessment phase progression with gate conditions",
            steps=[{"description": p["name"]} for p in PHASES],
        )
        self._plan_id = plan["id"]

        # Mark phase 1 as in_progress
        await self._db.update_plan(
            plan_id=plan["id"],
            step_index=0,
            step_status="in_progress",
        )

        return plan["id"]

    async def _get_current_phase(self) -> int:
        """Determine the current phase from the plan."""
        plan_id = await self._get_or_create_plan()
        plan = await self._db.get_by_id("plans", plan_id)
        if not plan:
            return 1

        steps = plan.get("steps", [])
        # Find the last in_progress step
        for i in range(len(steps) - 1, -1, -1):
            if steps[i].get("status") == "in_progress":
                return i + 1  # 1-indexed

        # If none in progress, find the last done step + 1
        for i in range(len(steps) - 1, -1, -1):
            if steps[i].get("status") == "done":
                return min(i + 2, 5)  # Next phase, capped at 5

        return 1

    async def get_metrics(self) -> Dict[str, int]:
        """Compute current metrics from world model tables."""
        metrics: Dict[str, int] = {}

        # Count assets
        assets = await self._db.query(table="assets", limit=1)
        assets_row = await self._db._fetchone("SELECT COUNT(*) as cnt FROM assets")
        metrics["assets"] = assets_row["cnt"] if assets_row else 0

        # Count endpoints
        endpoints_row = await self._db._fetchone("SELECT COUNT(*) as cnt FROM endpoints")
        metrics["endpoints"] = endpoints_row["cnt"] if endpoints_row else 0

        # Count hypotheses (total and confirmed)
        hyp_row = await self._db._fetchone("SELECT COUNT(*) as cnt FROM hypotheses")
        metrics["hypotheses"] = hyp_row["cnt"] if hyp_row else 0

        confirmed_hyp_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM hypotheses WHERE status = 'confirmed'"
        )
        metrics["confirmed_hypotheses"] = confirmed_hyp_row["cnt"] if confirmed_hyp_row else 0

        # Count findings (total and confirmed)
        findings_row = await self._db._fetchone("SELECT COUNT(*) as cnt FROM findings")
        metrics["findings"] = findings_row["cnt"] if findings_row else 0

        confirmed_findings_row = await self._db._fetchone(
            "SELECT COUNT(*) as cnt FROM findings WHERE status = 'confirmed'"
        )
        metrics["confirmed_findings"] = confirmed_findings_row["cnt"] if confirmed_findings_row else 0

        return metrics

    def check_gates(self, target_phase: int, metrics: Dict[str, int]) -> Dict[str, Any]:
        """Check if gate conditions are met for a target phase.

        Returns ``{"met": bool, "conditions": [{name, required, actual, met}]}``.
        """
        if target_phase < 1 or target_phase > 5:
            return {"met": False, "conditions": [], "error": "Invalid phase (1-5)"}

        phase_def = PHASES[target_phase - 1]
        gates = phase_def.get("gates", {})

        if not gates:
            return {"met": True, "conditions": []}

        conditions = []
        all_met = True

        _METRIC_MAP = {
            "min_assets": "assets",
            "min_endpoints": "endpoints",
            "min_hypotheses": "hypotheses",
            "min_confirmed_hypotheses": "confirmed_hypotheses",
            "min_findings": "findings",
            "min_confirmed_findings": "confirmed_findings",
        }

        for gate_name, required_value in gates.items():
            metric_key = _METRIC_MAP.get(gate_name, gate_name)
            actual = metrics.get(metric_key, 0)
            met = actual >= required_value
            if not met:
                all_met = False
            conditions.append({
                "name": gate_name,
                "required": required_value,
                "actual": actual,
                "met": met,
            })

        return {"met": all_met, "conditions": conditions}

    async def get_status(self) -> Dict[str, Any]:
        """Get current orchestration status, metrics, and gate conditions."""
        current_phase = await self._get_current_phase()
        metrics = await self.get_metrics()

        phase_def = PHASES[current_phase - 1]

        # Check next phase gates
        next_phase_gates = None
        if current_phase < 5:
            next_phase_gates = self.check_gates(current_phase + 1, metrics)

        # Calculate overall progress
        completed_phases = current_phase - 1
        progress_pct = round((completed_phases / 5) * 100, 1)

        return {
            "current_phase": current_phase,
            "phase_name": phase_def["name"],
            "phase_description": phase_def["description"],
            "metrics": metrics,
            "next_phase_gates": next_phase_gates,
            "progress_pct": progress_pct,
            "phases": [
                {
                    "phase": p["phase"],
                    "name": p["name"],
                    "status": (
                        "completed" if p["phase"] < current_phase
                        else "in_progress" if p["phase"] == current_phase
                        else "pending"
                    ),
                }
                for p in PHASES
            ],
        }

    async def advance(self, target_phase: int, force: bool = False) -> Dict[str, Any]:
        """Request phase transition.

        Validates that target_phase is current_phase + 1 and all gates are met
        (unless force=True).
        """
        current_phase = await self._get_current_phase()
        metrics = await self.get_metrics()

        if target_phase != current_phase + 1 and not force:
            return {
                "success": False,
                "error": (
                    f"Can only advance to phase {current_phase + 1} "
                    f"(current: {current_phase}, requested: {target_phase}). "
                    f"Use force=true to override."
                ),
            }

        if target_phase < 1 or target_phase > 5:
            return {"success": False, "error": f"Invalid target phase: {target_phase}. Must be 1-5."}

        # Check gate conditions
        gate_result = self.check_gates(target_phase, metrics)
        if not gate_result["met"] and not force:
            unmet = [c for c in gate_result["conditions"] if not c["met"]]
            return {
                "success": False,
                "error": "Gate conditions not met",
                "unmet_conditions": unmet,
                "hint": "Use force=true to override gate conditions.",
            }

        # Perform the transition
        plan_id = await self._get_or_create_plan()

        # Mark current phase as done
        if current_phase >= 1 and current_phase <= 5:
            await self._db.update_plan(
                plan_id=plan_id,
                step_index=current_phase - 1,
                step_status="done",
                step_result=f"Phase completed. Metrics: {metrics}",
            )

        # Mark target phase as in_progress
        if target_phase >= 1 and target_phase <= 5:
            await self._db.update_plan(
                plan_id=plan_id,
                step_index=target_phase - 1,
                step_status="in_progress",
            )

        phase_def = PHASES[target_phase - 1]

        return {
            "success": True,
            "previous_phase": current_phase,
            "current_phase": target_phase,
            "phase_name": phase_def["name"],
            "forced": force and not gate_result.get("met", True),
            "message": f"Advanced to Phase {target_phase}: {phase_def['name']}",
        }
