"""
Sequence Runner - Multi-step request sequence runner for business logic testing.

Executes ordered HTTP request sequences with variable extraction, template
resolution, expectation checking, and world-model observation recording.
Supports workflow bypass testing, data ownership verification, and
credential reuse detection.

Ported from business-logic testing patterns for MCP-based pentesting.
"""

from __future__ import annotations

import asyncio
import json
import logging
import re
import time
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

from lib.http_client import HttpClient
from lib.identity_store import IdentityStore

logger = logging.getLogger("autopentest-mcp")

# ---------------------------------------------------------------------------
# Regex for template variable placeholders: {{variable_name}}
# ---------------------------------------------------------------------------
_TEMPLATE_VAR_RE = re.compile(r"\{\{(\w+)\}\}")

# JSON path array index pattern: field[0]
_ARRAY_INDEX_RE = re.compile(r"^(\w+)\[(\d+)\]$")


# ---------------------------------------------------------------------------
# Data classes
# ---------------------------------------------------------------------------

@dataclass
class RequestStep:
    """A single step in a multi-step request sequence.

    Attributes:
        name: Human-readable step name for logging and reporting.
        method: HTTP method (GET, POST, PUT, DELETE, etc.).
        url_template: URL with ``{{var}}`` placeholders resolved at runtime.
        headers: Optional headers dict, also supporting ``{{var}}`` placeholders.
        body_template: Optional request body with ``{{var}}`` placeholders.
        identity_id: Optional auth identity to use for this step.
        extract: Variable extraction rules mapping variable names to extraction
            expressions.  Supported prefixes:
            - ``$`` -- JSON path (e.g. ``$.data.token``, ``$.items[0].id``)
            - ``regex:`` -- Regular expression with capture group 1
            - ``header:`` -- Extract from a response header
        expect: Assertion rules.  Supported keys:
            - ``status`` (int) -- expected HTTP status code
            - ``body_contains`` (List[str]) -- substrings that must appear
            - ``body_not_contains`` (List[str]) -- substrings that must not appear
        on_failure: Behaviour when this step fails assertions.
            ``"stop"`` (default) aborts the sequence, ``"continue"`` proceeds
            to the next step, ``"skip_rest"`` skips remaining steps.
        delay_ms: Milliseconds to sleep before executing this step.
    """

    name: str
    method: str
    url_template: str
    headers: Dict[str, str] = field(default_factory=dict)
    body_template: Optional[str] = None
    identity_id: Optional[str] = None
    extract: Dict[str, str] = field(default_factory=dict)
    expect: Dict[str, Any] = field(default_factory=dict)
    on_failure: str = "stop"
    delay_ms: int = 0


@dataclass
class StepResult:
    """Result of executing a single :class:`RequestStep`.

    Attributes:
        step_name: Name of the executed step.
        step_index: Zero-based index in the sequence.
        success: Whether all assertions passed and the request succeeded.
        status_code: HTTP status code returned (0 on transport error).
        response_body: Raw response body text.
        extracted_vars: Variables extracted during this step.
        assertion_results: List of individual assertion outcomes.
        error: Error message if the step failed due to an exception.
        timing_ms: Wall-clock duration of the step in milliseconds.
    """

    step_name: str
    step_index: int
    success: bool
    status_code: int
    response_body: str
    extracted_vars: Dict[str, str] = field(default_factory=dict)
    assertion_results: List[Dict] = field(default_factory=list)
    error: Optional[str] = None
    timing_ms: float = 0.0


@dataclass
class SequenceResult:
    """Aggregate result of executing an entire request sequence.

    Attributes:
        success: True only if every executed step passed.
        steps_completed: Number of steps that were actually executed.
        total_steps: Total number of steps in the sequence.
        variables: Final variable context after all steps.
        step_results: Per-step results in execution order.
        failed_step: Name of the first step that failed, or None.
    """

    success: bool
    steps_completed: int
    total_steps: int
    variables: Dict[str, str] = field(default_factory=dict)
    step_results: List[StepResult] = field(default_factory=list)
    failed_step: Optional[str] = None


# ---------------------------------------------------------------------------
# SequenceRunner
# ---------------------------------------------------------------------------

class SequenceRunner:
    """Execute ordered HTTP request sequences with variable chaining.

    The runner resolves ``{{var}}`` placeholders in URLs, headers, and bodies
    from a shared variable context that grows as extraction rules pull values
    out of responses.  Assertion rules verify status codes and body content.

    Args:
        http_client: An :class:`HttpClient` instance used to send requests.
        db: Optional world-model database for recording observations.
        scope_validator: Optional :class:`TargetValidator` for URL validation.
    """

    def __init__(
        self,
        http_client: HttpClient,
        db: Any = None,
        scope_validator: Any = None,
    ) -> None:
        self._http = http_client
        self._db = db
        self._scope_validator = scope_validator

    # ------------------------------------------------------------------
    # Public: execute a full sequence
    # ------------------------------------------------------------------

    async def execute(
        self,
        steps: List[RequestStep],
        variables: Optional[Dict[str, str]] = None,
        hypothesis_id: Optional[str] = None,
    ) -> SequenceResult:
        """Execute a list of request steps in order.

        Args:
            steps: Ordered list of :class:`RequestStep` to execute.
            variables: Optional seed variables for template resolution.
            hypothesis_id: If provided, each step's result is recorded as an
                observation in the world-model database under this hypothesis.

        Returns:
            A :class:`SequenceResult` summarising the execution.
        """
        ctx: Dict[str, str] = dict(variables) if variables else {}
        step_results: List[StepResult] = []
        failed_step: Optional[str] = None
        abort = False

        for idx, step in enumerate(steps):
            if abort:
                break

            logger.info(
                "Sequence step %d/%d: %s [%s %s]",
                idx + 1,
                len(steps),
                step.name,
                step.method,
                step.url_template,
            )

            result = await self._execute_step(step, idx, ctx)
            step_results.append(result)

            # Merge extracted variables into the shared context
            ctx.update(result.extracted_vars)

            # Record observation in world model if requested
            if hypothesis_id and self._db is not None:
                try:
                    obs_content = json.dumps({
                        "step_name": result.step_name,
                        "step_index": result.step_index,
                        "success": result.success,
                        "status_code": result.status_code,
                        "extracted_vars": result.extracted_vars,
                        "assertion_results": result.assertion_results,
                        "error": result.error,
                        "timing_ms": result.timing_ms,
                    })
                    await self._db.add_observation(
                        hypothesis_id=hypothesis_id,
                        obs_type="behavior",
                        content=obs_content,
                        metadata={
                            "step_name": result.step_name,
                            "step_index": result.step_index,
                            "source": "sequence_runner",
                        },
                    )
                except Exception as exc:
                    logger.warning(
                        "Failed to record observation for step %s: %s",
                        step.name,
                        exc,
                    )

            # Handle failure behaviour
            if not result.success:
                if failed_step is None:
                    failed_step = result.step_name

                if step.on_failure == "stop":
                    logger.info(
                        "Step '%s' failed with on_failure=stop; aborting sequence.",
                        step.name,
                    )
                    abort = True
                elif step.on_failure == "skip_rest":
                    logger.info(
                        "Step '%s' failed with on_failure=skip_rest; skipping remaining steps.",
                        step.name,
                    )
                    abort = True
                else:
                    # on_failure == "continue"
                    logger.info(
                        "Step '%s' failed with on_failure=continue; proceeding.",
                        step.name,
                    )

        all_passed = all(r.success for r in step_results)

        return SequenceResult(
            success=all_passed,
            steps_completed=len(step_results),
            total_steps=len(steps),
            variables=ctx,
            step_results=step_results,
            failed_step=failed_step,
        )

    # ------------------------------------------------------------------
    # Public: workflow bypass testing
    # ------------------------------------------------------------------

    async def execute_workflow_bypass(
        self,
        steps: List[RequestStep],
        bypass_type: str,
        skip_indices: Optional[List[int]] = None,
        variables: Optional[Dict[str, str]] = None,
    ) -> Dict[str, Any]:
        """Test business logic workflow bypass scenarios.

        Args:
            steps: The normal (happy-path) sequence of steps.
            bypass_type: One of ``"skip_step"``, ``"replay_step"``,
                ``"reorder"``, or ``"direct_access"``.
            skip_indices: For ``"skip_step"`` bypass, which step indices to
                skip.  If *None*, each non-first/non-last step is tried.
            variables: Optional seed variables.

        Returns:
            Dict with ``variants_tested``, ``vulnerabilities_found``, and
            ``details`` keys.
        """
        vulnerabilities: List[Dict[str, Any]] = []
        details: List[Dict[str, Any]] = []

        if bypass_type == "skip_step":
            details, vulnerabilities = await self._bypass_skip_step(
                steps, skip_indices, variables,
            )
        elif bypass_type == "replay_step":
            details, vulnerabilities = await self._bypass_replay_step(
                steps, variables,
            )
        elif bypass_type == "reorder":
            details, vulnerabilities = await self._bypass_reorder(
                steps, variables,
            )
        elif bypass_type == "direct_access":
            details, vulnerabilities = await self._bypass_direct_access(
                steps, variables,
            )
        else:
            logger.warning("Unknown bypass_type: %s", bypass_type)

        return {
            "variants_tested": len(details),
            "vulnerabilities_found": vulnerabilities,
            "details": details,
        }

    # ------------------------------------------------------------------
    # Template resolution
    # ------------------------------------------------------------------

    @staticmethod
    def _resolve_template(template: str, variables: Dict[str, str]) -> str:
        """Replace ``{{var}}`` placeholders with values from *variables*.

        Args:
            template: String containing zero or more ``{{var}}`` placeholders.
            variables: Name-to-value mapping for substitution.

        Returns:
            The resolved string with all placeholders replaced.

        Raises:
            KeyError: If a placeholder references a variable not present in
                the context.
        """

        def _replacer(match: re.Match) -> str:
            var_name = match.group(1)
            if var_name not in variables:
                raise KeyError(
                    f"Template variable '{{{{{var_name}}}}}' is not defined. "
                    f"Available: {', '.join(sorted(variables.keys())) or '(none)'}"
                )
            return str(variables[var_name])

        return _TEMPLATE_VAR_RE.sub(_replacer, template)

    # ------------------------------------------------------------------
    # Variable extraction
    # ------------------------------------------------------------------

    @staticmethod
    def _extract_variables(
        response_body: str,
        response_headers: Dict[str, str],
        extract_rules: Dict[str, str],
    ) -> Dict[str, str]:
        """Extract variables from an HTTP response.

        Supported rule prefixes:

        - ``$`` (JSON path): Walk into the parsed JSON body using dot-notation
          and optional array indices, e.g. ``$.data.token``,
          ``$.items[0].id``.
        - ``regex:<pattern>``: Apply *pattern* to the body and return capture
          group 1.
        - ``header:<name>``: Return the value of the named response header.

        Args:
            response_body: Raw response body text.
            response_headers: Response headers (case-insensitive lookup
                recommended by caller, but we do a case-insensitive search).
            extract_rules: Mapping of variable name to extraction expression.

        Returns:
            Dict of successfully extracted variable names to string values.
            Rules that fail to match are silently skipped with a warning log.
        """
        extracted: Dict[str, str] = {}

        # Pre-parse JSON body once (may be non-JSON, that is fine)
        parsed_json: Any = None
        if response_body:
            try:
                parsed_json = json.loads(response_body)
            except (json.JSONDecodeError, ValueError):
                pass

        # Build a case-insensitive header lookup
        lower_headers: Dict[str, str] = {
            k.lower(): v for k, v in response_headers.items()
        }

        for var_name, rule in extract_rules.items():
            try:
                if rule.startswith("header:"):
                    header_name = rule[len("header:"):].strip().lower()
                    value = lower_headers.get(header_name)
                    if value is not None:
                        extracted[var_name] = value
                    else:
                        logger.warning(
                            "Extract rule '%s': header '%s' not found in response.",
                            var_name,
                            header_name,
                        )

                elif rule.startswith("regex:"):
                    pattern = rule[len("regex:"):]
                    match = re.search(pattern, response_body)
                    if match and match.lastindex and match.lastindex >= 1:
                        extracted[var_name] = match.group(1)
                    else:
                        logger.warning(
                            "Extract rule '%s': regex '%s' did not match.",
                            var_name,
                            pattern,
                        )

                elif rule.startswith("$"):
                    if parsed_json is None:
                        logger.warning(
                            "Extract rule '%s': cannot apply JSON path to non-JSON body.",
                            var_name,
                        )
                        continue

                    value = _walk_json_path(parsed_json, rule)
                    if value is not None:
                        extracted[var_name] = str(value)
                    else:
                        logger.warning(
                            "Extract rule '%s': JSON path '%s' resolved to None.",
                            var_name,
                            rule,
                        )

                else:
                    logger.warning(
                        "Extract rule '%s': unknown rule prefix in '%s'. "
                        "Expected '$', 'regex:', or 'header:'.",
                        var_name,
                        rule,
                    )
            except Exception as exc:
                logger.warning(
                    "Extract rule '%s' failed: %s",
                    var_name,
                    exc,
                )

        return extracted

    # ------------------------------------------------------------------
    # Expectation checking
    # ------------------------------------------------------------------

    @staticmethod
    def _check_expectations(
        status_code: int,
        body: str,
        expect: Dict[str, Any],
    ) -> List[Dict[str, Any]]:
        """Check response against assertion rules.

        Supported keys in *expect*:

        - ``status`` (int): Expected HTTP status code.
        - ``body_contains`` (List[str]): Substrings that must be present.
        - ``body_not_contains`` (List[str]): Substrings that must be absent.

        Args:
            status_code: Actual HTTP status code.
            body: Actual response body text.
            expect: Assertion rules dictionary.

        Returns:
            List of assertion result dicts, each with ``check``, ``passed``,
            ``expected``, and ``actual`` keys.
        """
        results: List[Dict[str, Any]] = []

        # Status code check
        if "status" in expect:
            expected_status = int(expect["status"])
            results.append({
                "check": "status",
                "passed": status_code == expected_status,
                "expected": expected_status,
                "actual": status_code,
            })

        # body_contains
        for substring in expect.get("body_contains", []):
            present = substring in body
            results.append({
                "check": "body_contains",
                "passed": present,
                "expected": substring,
                "actual": f"{'found' if present else 'not found'} in body",
            })

        # body_not_contains
        for substring in expect.get("body_not_contains", []):
            absent = substring not in body
            results.append({
                "check": "body_not_contains",
                "passed": absent,
                "expected": f"absence of '{substring}'",
                "actual": f"{'absent' if absent else 'present'} in body",
            })

        return results

    # ------------------------------------------------------------------
    # Internal: execute a single step
    # ------------------------------------------------------------------

    async def _execute_step(
        self,
        step: RequestStep,
        index: int,
        variables: Dict[str, str],
    ) -> StepResult:
        """Execute a single request step and return a :class:`StepResult`."""
        start_ms = time.time() * 1000

        try:
            # Resolve templates
            url = self._resolve_template(step.url_template, variables)
            headers = {
                k: self._resolve_template(v, variables)
                for k, v in step.headers.items()
            }
            body: Optional[str] = None
            if step.body_template is not None:
                body = self._resolve_template(step.body_template, variables)

            # Apply delay
            if step.delay_ms > 0:
                await asyncio.sleep(step.delay_ms / 1000.0)

            # Scope validation
            if self._scope_validator is not None:
                validation = self._scope_validator.validate_target(url)
                if not validation.valid:
                    elapsed = time.time() * 1000 - start_ms
                    return StepResult(
                        step_name=step.name,
                        step_index=index,
                        success=False,
                        status_code=0,
                        response_body="",
                        error=f"URL out of scope: {validation.reason}",
                        timing_ms=elapsed,
                    )

            # Send request
            result = await self._http.send(
                request={
                    "method": step.method,
                    "url": url,
                    "headers": headers,
                    "body": body,
                },
                identity_id=step.identity_id,
            )

            elapsed = time.time() * 1000 - start_ms

            if not result.get("success"):
                error_info = result.get("error", {})
                return StepResult(
                    step_name=step.name,
                    step_index=index,
                    success=False,
                    status_code=0,
                    response_body="",
                    error=error_info.get("message", "HTTP request failed"),
                    timing_ms=elapsed,
                )

            response = result["response"]
            status_code = response["status"]
            response_body = response.get("body", "")
            response_headers = response.get("headers", {})

            # Extract variables
            extracted = self._extract_variables(
                response_body, response_headers, step.extract,
            )

            # Check expectations
            assertion_results = self._check_expectations(
                status_code, response_body, step.expect,
            )
            all_passed = all(a["passed"] for a in assertion_results)

            # If no expectations defined, treat as success
            success = all_passed if assertion_results else True

            return StepResult(
                step_name=step.name,
                step_index=index,
                success=success,
                status_code=status_code,
                response_body=response_body,
                extracted_vars=extracted,
                assertion_results=assertion_results,
                timing_ms=elapsed,
            )

        except KeyError as exc:
            elapsed = time.time() * 1000 - start_ms
            return StepResult(
                step_name=step.name,
                step_index=index,
                success=False,
                status_code=0,
                response_body="",
                error=f"Template resolution error: {exc}",
                timing_ms=elapsed,
            )

        except Exception as exc:
            elapsed = time.time() * 1000 - start_ms
            logger.error("Step '%s' raised unexpected error: %s", step.name, exc)
            return StepResult(
                step_name=step.name,
                step_index=index,
                success=False,
                status_code=0,
                response_body="",
                error=str(exc),
                timing_ms=elapsed,
            )

    # ------------------------------------------------------------------
    # Internal: bypass variants
    # ------------------------------------------------------------------

    async def _bypass_skip_step(
        self,
        steps: List[RequestStep],
        skip_indices: Optional[List[int]],
        variables: Optional[Dict[str, str]],
    ) -> tuple:
        """Execute skip-step bypass: omit one or more intermediate steps."""
        details: List[Dict[str, Any]] = []
        vulns: List[Dict[str, Any]] = []

        if skip_indices is not None:
            indices_to_try = [skip_indices]
        else:
            # Try skipping each intermediate step individually
            indices_to_try = [[i] for i in range(1, len(steps) - 1)]

        for skip_set in indices_to_try:
            variant_steps = [
                s for i, s in enumerate(steps) if i not in skip_set
            ]
            skipped_names = [steps[i].name for i in skip_set if i < len(steps)]

            logger.info("Bypass skip_step: skipping steps %s", skipped_names)
            result = await self.execute(variant_steps, variables)

            detail = {
                "bypass_type": "skip_step",
                "skipped_steps": skipped_names,
                "skipped_indices": skip_set,
                "sequence_success": result.success,
                "steps_completed": result.steps_completed,
            }
            details.append(detail)

            if result.success:
                vuln = {
                    "type": "workflow_bypass",
                    "bypass_type": "skip_step",
                    "description": (
                        f"Sequence succeeded after skipping steps: "
                        f"{', '.join(skipped_names)}"
                    ),
                    "skipped_steps": skipped_names,
                }
                vulns.append(vuln)
                logger.warning(
                    "Potential vulnerability: workflow bypass via skip_step (%s)",
                    skipped_names,
                )

        return details, vulns

    async def _bypass_replay_step(
        self,
        steps: List[RequestStep],
        variables: Optional[Dict[str, str]],
    ) -> tuple:
        """Execute the sequence normally, then replay the last step."""
        details: List[Dict[str, Any]] = []
        vulns: List[Dict[str, Any]] = []

        # Run the full sequence first
        normal_result = await self.execute(steps, variables)

        if not normal_result.success:
            details.append({
                "bypass_type": "replay_step",
                "note": "Normal sequence failed; cannot test replay.",
                "sequence_success": False,
            })
            return details, vulns

        # Replay the last step using accumulated variables
        last_step = steps[-1]
        replay_result = await self._execute_step(
            last_step, len(steps), normal_result.variables,
        )

        detail = {
            "bypass_type": "replay_step",
            "replayed_step": last_step.name,
            "replay_success": replay_result.success,
            "replay_status_code": replay_result.status_code,
        }
        details.append(detail)

        if replay_result.success:
            vuln = {
                "type": "workflow_bypass",
                "bypass_type": "replay_step",
                "description": (
                    f"Step '{last_step.name}' succeeded on replay, "
                    f"indicating missing replay protection."
                ),
                "replayed_step": last_step.name,
            }
            vulns.append(vuln)
            logger.warning(
                "Potential vulnerability: replay protection missing for step '%s'.",
                last_step.name,
            )

        return details, vulns

    async def _bypass_reorder(
        self,
        steps: List[RequestStep],
        variables: Optional[Dict[str, str]],
    ) -> tuple:
        """Execute steps in reverse order, keeping the first step (auth) first."""
        details: List[Dict[str, Any]] = []
        vulns: List[Dict[str, Any]] = []

        if len(steps) < 3:
            details.append({
                "bypass_type": "reorder",
                "note": "Need at least 3 steps to test reorder.",
                "sequence_success": False,
            })
            return details, vulns

        # Keep authentication step first, reverse the rest
        reordered = [steps[0]] + list(reversed(steps[1:]))
        reordered_names = [s.name for s in reordered]

        logger.info("Bypass reorder: executing steps in order %s", reordered_names)
        result = await self.execute(reordered, variables)

        detail = {
            "bypass_type": "reorder",
            "step_order": reordered_names,
            "sequence_success": result.success,
            "steps_completed": result.steps_completed,
        }
        details.append(detail)

        if result.success:
            vuln = {
                "type": "workflow_bypass",
                "bypass_type": "reorder",
                "description": (
                    "Sequence succeeded with reordered steps, indicating "
                    "missing server-side step-order enforcement."
                ),
                "step_order": reordered_names,
            }
            vulns.append(vuln)
            logger.warning("Potential vulnerability: workflow bypass via reorder.")

        return details, vulns

    async def _bypass_direct_access(
        self,
        steps: List[RequestStep],
        variables: Optional[Dict[str, str]],
    ) -> tuple:
        """Skip straight to the final step without prior steps."""
        details: List[Dict[str, Any]] = []
        vulns: List[Dict[str, Any]] = []

        if len(steps) < 2:
            details.append({
                "bypass_type": "direct_access",
                "note": "Need at least 2 steps to test direct access.",
                "sequence_success": False,
            })
            return details, vulns

        final_step = steps[-1]
        logger.info("Bypass direct_access: jumping to final step '%s'.", final_step.name)

        result = await self.execute([final_step], variables)

        detail = {
            "bypass_type": "direct_access",
            "target_step": final_step.name,
            "sequence_success": result.success,
            "status_code": (
                result.step_results[0].status_code
                if result.step_results else 0
            ),
        }
        details.append(detail)

        if result.success:
            vuln = {
                "type": "workflow_bypass",
                "bypass_type": "direct_access",
                "description": (
                    f"Final step '{final_step.name}' succeeded without prior "
                    f"steps, indicating missing server-side workflow enforcement."
                ),
                "target_step": final_step.name,
            }
            vulns.append(vuln)
            logger.warning(
                "Potential vulnerability: direct access to final step '%s'.",
                final_step.name,
            )

        return details, vulns


# ---------------------------------------------------------------------------
# DataOwnershipTester
# ---------------------------------------------------------------------------

class DataOwnershipTester:
    """Test data ownership and IDOR/BOLA vulnerabilities.

    Verifies that resources owned by one identity are not accessible (or are
    properly redacted) when requested by a different identity.

    Args:
        http_client: An :class:`HttpClient` instance.
        identity_store: Optional :class:`IdentityStore` for building auth
            headers from identity IDs.
        scope_validator: Optional scope validator for URL checks.
    """

    def __init__(
        self,
        http_client: HttpClient,
        identity_store: Optional[IdentityStore] = None,
        scope_validator: Any = None,
    ) -> None:
        self._http = http_client
        self._identity_store = identity_store
        self._scope_validator = scope_validator

    async def test_ownership(
        self,
        url_template: str,
        resource_ids: List[str],
        owner_identity_id: str,
        other_identity_ids: List[str],
        method: str = "GET",
        headers: Optional[Dict[str, str]] = None,
    ) -> Dict[str, Any]:
        """Test that resources are only accessible to their owner.

        For each resource ID, the method sends a request as the owner identity
        (expecting success) and then as each non-owner identity (expecting
        denial or redacted data).

        Args:
            url_template: URL with ``{id}`` placeholder for the resource ID.
            resource_ids: List of resource identifiers to test.
            owner_identity_id: Identity ID of the resource owner.
            other_identity_ids: Identity IDs that should NOT have access.
            method: HTTP method to use (default ``GET``).
            headers: Additional headers to include in every request.

        Returns:
            Dict with ``resources_tested``, ``ownership_violations``, and
            ``details`` keys.
        """
        violations: List[Dict[str, Any]] = []
        details: List[Dict[str, Any]] = []
        base_headers = dict(headers) if headers else {}

        for resource_id in resource_ids:
            url = url_template.replace("{id}", str(resource_id))

            # Scope check
            if self._scope_validator is not None:
                validation = self._scope_validator.validate_target(url)
                if not validation.valid:
                    logger.warning(
                        "Ownership test: URL out of scope: %s", url,
                    )
                    continue

            # Request as owner
            owner_headers = self._build_identity_headers(
                owner_identity_id, base_headers,
            )
            owner_result = await self._send_request(method, url, owner_headers)

            if not owner_result.get("success"):
                details.append({
                    "resource_id": resource_id,
                    "note": "Owner request failed; skipping this resource.",
                    "error": owner_result.get("error", {}).get("message", "unknown"),
                })
                continue

            owner_status = owner_result["response"]["status"]
            if owner_status != 200:
                details.append({
                    "resource_id": resource_id,
                    "note": f"Owner got status {owner_status} (expected 200); skipping.",
                })
                continue

            # Request as each non-owner identity
            for other_id in other_identity_ids:
                other_headers = self._build_identity_headers(
                    other_id, base_headers,
                )
                other_result = await self._send_request(method, url, other_headers)

                if not other_result.get("success"):
                    details.append({
                        "resource_id": resource_id,
                        "other_identity": other_id,
                        "note": "Non-owner request failed (transport error).",
                    })
                    continue

                other_status = other_result["response"]["status"]
                other_body = other_result["response"].get("body", "")
                owner_body = owner_result["response"].get("body", "")

                # Proper denial: 403 or 404
                if other_status in (403, 404):
                    details.append({
                        "resource_id": resource_id,
                        "other_identity": other_id,
                        "status": other_status,
                        "access_denied": True,
                        "violation": False,
                    })
                    continue

                # Non-owner got 200 -- check for data leakage
                comparison = self._compare_responses(
                    {"body": owner_body, "status": owner_status},
                    {"body": other_body, "status": other_status},
                )

                detail = {
                    "resource_id": resource_id,
                    "other_identity": other_id,
                    "status": other_status,
                    "access_denied": False,
                    "violation": comparison["leaked"],
                    "leaked_fields": comparison.get("leaked_fields", []),
                    "comparison_details": comparison.get("details", ""),
                }
                details.append(detail)

                if comparison["leaked"]:
                    violation = {
                        "resource_id": resource_id,
                        "other_identity": other_id,
                        "status": other_status,
                        "leaked_fields": comparison["leaked_fields"],
                        "description": (
                            f"Identity '{other_id}' accessed resource '{resource_id}' "
                            f"owned by '{owner_identity_id}' and received leaked data."
                        ),
                    }
                    violations.append(violation)
                    logger.warning(
                        "Ownership violation: identity '%s' accessed resource '%s'.",
                        other_id,
                        resource_id,
                    )

        return {
            "resources_tested": len(resource_ids),
            "ownership_violations": violations,
            "details": details,
        }

    @staticmethod
    def _compare_responses(
        owner_response: Dict[str, Any],
        other_response: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Compare owner and non-owner responses to detect data leakage.

        Parses both bodies as JSON (if possible) and checks whether the
        non-owner response contains the same keys and values as the owner
        response.

        Args:
            owner_response: Dict with ``body`` and ``status`` keys.
            other_response: Dict with ``body`` and ``status`` keys.

        Returns:
            Dict with ``leaked`` (bool), ``leaked_fields`` (List[str]), and
            ``details`` (str) keys.
        """
        owner_body = owner_response.get("body", "")
        other_body = other_response.get("body", "")

        # Attempt JSON comparison
        owner_json: Any = None
        other_json: Any = None
        try:
            owner_json = json.loads(owner_body) if owner_body else None
        except (json.JSONDecodeError, ValueError):
            pass
        try:
            other_json = json.loads(other_body) if other_body else None
        except (json.JSONDecodeError, ValueError):
            pass

        if isinstance(owner_json, dict) and isinstance(other_json, dict):
            leaked_fields: List[str] = []
            owner_keys = set(owner_json.keys())
            other_keys = set(other_json.keys())
            common_keys = owner_keys & other_keys

            for key in common_keys:
                if owner_json[key] == other_json[key] and owner_json[key] is not None:
                    leaked_fields.append(key)

            if leaked_fields:
                return {
                    "leaked": True,
                    "leaked_fields": leaked_fields,
                    "details": (
                        f"Non-owner response contains {len(leaked_fields)} "
                        f"matching field(s): {', '.join(leaked_fields)}"
                    ),
                }
            return {
                "leaked": False,
                "leaked_fields": [],
                "details": "No matching field values detected.",
            }

        # Fallback: raw body comparison
        if owner_body and other_body and owner_body == other_body:
            return {
                "leaked": True,
                "leaked_fields": ["<entire_body>"],
                "details": "Non-owner response body is identical to owner response.",
            }

        return {
            "leaked": False,
            "leaked_fields": [],
            "details": "Responses differ or could not be compared as JSON.",
        }

    def _build_identity_headers(
        self,
        identity_id: str,
        base_headers: Dict[str, str],
    ) -> Dict[str, str]:
        """Build request headers using the identity store.

        Falls back to an empty auth header set if the identity store is not
        configured or the identity is not found.
        """
        headers = dict(base_headers)

        if self._identity_store is not None:
            identity = self._identity_store.get_identity(identity_id)
            if identity is not None:
                auth_headers = IdentityStore.build_auth_headers(identity)
                headers.update(auth_headers)
            else:
                logger.warning("Identity '%s' not found in store.", identity_id)

        return headers

    async def _send_request(
        self,
        method: str,
        url: str,
        headers: Dict[str, str],
    ) -> Dict[str, Any]:
        """Send a single HTTP request, catching exceptions gracefully."""
        try:
            return await self._http.send(
                request={"method": method, "url": url, "headers": headers},
            )
        except Exception as exc:
            logger.error("HTTP request to %s failed: %s", url, exc)
            return {
                "success": False,
                "error": {"code": "REQUEST_ERROR", "message": str(exc)},
            }


# ---------------------------------------------------------------------------
# CredentialReuseTester
# ---------------------------------------------------------------------------

class CredentialReuseTester:
    """Test whether a credential grants access to unintended endpoints.

    Sends a captured credential (bearer token, cookie, API key, etc.)
    to a list of target endpoints and checks for successful authentication.

    Args:
        http_client: An :class:`HttpClient` instance.
        scope_validator: Optional scope validator for URL checks.
    """

    def __init__(
        self,
        http_client: HttpClient,
        scope_validator: Any = None,
    ) -> None:
        self._http = http_client
        self._scope_validator = scope_validator

    async def test_credential_reuse(
        self,
        credential: Dict[str, str],
        target_endpoints: List[str],
        method: str = "GET",
    ) -> Dict[str, Any]:
        """Test a credential against multiple endpoints.

        Args:
            credential: Dict with keys:
                - ``type``: One of ``"bearer"``, ``"basic"``, ``"cookie"``,
                  ``"api_key"``.
                - ``value``: The credential value (token, key, cookie string).
                - ``header_name``: Optional custom header name (defaults are
                  chosen based on type).
            target_endpoints: List of endpoint URLs to test.
            method: HTTP method for the probe requests.

        Returns:
            Dict with ``endpoints_tested``, ``successful_auth``, and
            ``details`` keys.
        """
        successful: List[Dict[str, Any]] = []
        details: List[Dict[str, Any]] = []

        cred_type = credential.get("type", "bearer")
        cred_value = credential.get("value", "")
        header_name = credential.get("header_name")

        for endpoint in target_endpoints:
            # Scope validation
            if self._scope_validator is not None:
                validation = self._scope_validator.validate_target(endpoint)
                if not validation.valid:
                    details.append({
                        "endpoint": endpoint,
                        "tested": False,
                        "reason": f"Out of scope: {validation.reason}",
                    })
                    continue

            headers = self._build_credential_headers(
                cred_type, cred_value, header_name,
            )

            try:
                result = await self._http.send(
                    request={
                        "method": method,
                        "url": endpoint,
                        "headers": headers,
                    },
                )
            except Exception as exc:
                details.append({
                    "endpoint": endpoint,
                    "tested": True,
                    "authenticated": False,
                    "error": str(exc),
                })
                continue

            if not result.get("success"):
                error_msg = result.get("error", {}).get("message", "unknown")
                details.append({
                    "endpoint": endpoint,
                    "tested": True,
                    "authenticated": False,
                    "error": error_msg,
                })
                continue

            status = result["response"]["status"]
            body = result["response"].get("body", "")
            authenticated = self._is_authenticated_response(status, body)

            detail = {
                "endpoint": endpoint,
                "tested": True,
                "authenticated": authenticated,
                "status_code": status,
            }
            details.append(detail)

            if authenticated:
                successful.append({
                    "endpoint": endpoint,
                    "status_code": status,
                    "credential_type": cred_type,
                })
                logger.warning(
                    "Credential reuse: %s credential accepted at %s (status %d).",
                    cred_type,
                    endpoint,
                    status,
                )

        return {
            "endpoints_tested": len(target_endpoints),
            "successful_auth": successful,
            "details": details,
        }

    @staticmethod
    def _build_credential_headers(
        cred_type: str,
        cred_value: str,
        header_name: Optional[str] = None,
    ) -> Dict[str, str]:
        """Build HTTP headers for the given credential type.

        Args:
            cred_type: Credential type (bearer, basic, cookie, api_key).
            cred_value: The raw credential value.
            header_name: Optional override for the header name.

        Returns:
            Dict of header name to value.
        """
        if header_name:
            return {header_name: cred_value}

        if cred_type == "bearer":
            return {"Authorization": f"Bearer {cred_value}"}
        elif cred_type == "basic":
            return {"Authorization": f"Basic {cred_value}"}
        elif cred_type == "cookie":
            return {"Cookie": cred_value}
        elif cred_type == "api_key":
            return {"X-API-Key": cred_value}
        else:
            logger.warning("Unknown credential type '%s'; using Authorization.", cred_type)
            return {"Authorization": cred_value}

    @staticmethod
    def _is_authenticated_response(status: int, body: str) -> bool:
        """Heuristically determine whether a response indicates success.

        A response is considered authenticated if:
        - Status is 2xx, AND
        - The body does not look like a login page redirect or auth error.

        Args:
            status: HTTP status code.
            body: Response body text.

        Returns:
            True if the response appears to be an authenticated success.
        """
        if status < 200 or status >= 300:
            return False

        # Check for common login/auth failure indicators in the body
        lower_body = body.lower()
        auth_failure_indicators = [
            "login",
            "sign in",
            "sign_in",
            "unauthorized",
            "authentication required",
            "access denied",
            "invalid token",
            "token expired",
            "session expired",
        ]

        for indicator in auth_failure_indicators:
            if indicator in lower_body:
                return False

        return True


# ---------------------------------------------------------------------------
# Helpers (module-level)
# ---------------------------------------------------------------------------

def _walk_json_path(data: Any, path: str) -> Any:
    """Walk a simple JSON path expression and return the resolved value.

    Supports dot-notation paths with optional array indices:
    ``$.data.token``, ``$.items[0].id``, ``$.nested.list[2].value``.

    The leading ``$`` and ``.`` are stripped; the remaining segments are
    traversed in order against *data*.

    Args:
        data: Parsed JSON value (dict, list, scalar).
        path: JSON path expression starting with ``$``.

    Returns:
        The resolved value, or *None* if any segment fails to resolve.
    """
    # Strip leading "$" and optional leading "."
    stripped = path.lstrip("$").lstrip(".")
    if not stripped:
        return data

    segments = stripped.split(".")
    current = data

    for segment in segments:
        if current is None:
            return None

        # Check for array index notation: field[N]
        arr_match = _ARRAY_INDEX_RE.match(segment)
        if arr_match:
            field_name = arr_match.group(1)
            arr_index = int(arr_match.group(2))

            if isinstance(current, dict):
                current = current.get(field_name)
            else:
                return None

            if isinstance(current, list) and 0 <= arr_index < len(current):
                current = current[arr_index]
            else:
                return None
        else:
            # Plain field access
            if isinstance(current, dict):
                current = current.get(segment)
            elif isinstance(current, list):
                # Allow integer-like segment for list indexing
                try:
                    idx = int(segment)
                    if 0 <= idx < len(current):
                        current = current[idx]
                    else:
                        return None
                except ValueError:
                    return None
            else:
                return None

    return current
