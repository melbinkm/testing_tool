"""GraphQL security testing tools."""
import json
import logging
import re
from typing import List, Dict, Any, Optional

logger = logging.getLogger(__name__)

try:
    from mcp.types import Tool, TextContent
except ImportError:
    from unittest.mock import MagicMock
    Tool = MagicMock
    TextContent = MagicMock

from lib.tool_helpers import _get_db, _json_content, _error_content, _get_http_client


INTROSPECTION_QUERY = """
{
  __schema {
    types {
      name
      kind
      fields {
        name
        type { name kind ofType { name kind } }
        args { name type { name kind ofType { name kind } } }
      }
    }
    queryType { name }
    mutationType { name }
    subscriptionType { name }
  }
}
"""

SENSITIVE_FIELD_PATTERNS = [
    "email", "password", "token", "secret", "key", "admin", "role",
    "ssn", "credit", "card", "auth", "session", "private", "internal"
]


def get_graphql_tools() -> List[Tool]:
    return [
        Tool(
            name="graphql_introspect",
            description="Send GraphQL introspection query to discover schema. Extracts types, fields, mutations, and flags sensitive fields.",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {"type": "string", "description": "GraphQL endpoint URL"},
                    "headers": {"type": "object", "description": "Optional HTTP headers (e.g., Authorization)"}
                },
                "required": ["url"]
            }
        ),
        Tool(
            name="graphql_query",
            description="Execute an arbitrary GraphQL query or mutation with optional identity-based authentication.",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {"type": "string"},
                    "query": {"type": "string", "description": "GraphQL query or mutation string"},
                    "variables": {"type": "object", "description": "Query variables"},
                    "operation_name": {"type": "string"},
                    "headers": {"type": "object"},
                    "identity_id": {"type": "string", "description": "Identity to use for authentication"}
                },
                "required": ["url", "query"]
            }
        ),
        Tool(
            name="graphql_fuzz_schema",
            description="Probe GraphQL field names via error message analysis when introspection is disabled. Parses 'Did you mean' suggestions.",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {"type": "string"},
                    "headers": {"type": "object"},
                    "known_types": {"type": "array", "items": {"type": "string"}, "description": "Known type names to probe"},
                    "max_requests": {"type": "integer", "default": 100}
                },
                "required": ["url"]
            }
        ),
        Tool(
            name="graphql_alias_idor",
            description="Test for IDOR via GraphQL aliases. Constructs batched aliased queries across multiple IDs and compares access.",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {"type": "string"},
                    "query_template": {"type": "string", "description": "Query template with {id} placeholder, e.g. 'user(id:\"{id}\"){email name}'"},
                    "ids": {"type": "array", "items": {"type": "string"}, "description": "List of IDs to test"},
                    "headers": {"type": "object"},
                    "identity_id": {"type": "string"}
                },
                "required": ["url", "query_template", "ids"]
            }
        ),
        Tool(
            name="graphql_batch",
            description="Send batched GraphQL queries as JSON array. Tests batch support and rate limit bypass.",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {"type": "string"},
                    "queries": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "query": {"type": "string"},
                                "variables": {"type": "object"},
                                "operationName": {"type": "string"}
                            }
                        },
                        "description": "List of query objects to send in a batch"
                    },
                    "headers": {"type": "object"}
                },
                "required": ["url", "queries"]
            }
        ),
    ]


async def handle_graphql_tool(name: str, args: dict, mcp_service) -> List[TextContent]:
    if name == "graphql_introspect":
        return await _handle_graphql_introspect(args, mcp_service)
    elif name == "graphql_query":
        return await _handle_graphql_query(args, mcp_service)
    elif name == "graphql_fuzz_schema":
        return await _handle_graphql_fuzz_schema(args, mcp_service)
    elif name == "graphql_alias_idor":
        return await _handle_graphql_alias_idor(args, mcp_service)
    elif name == "graphql_batch":
        return await _handle_graphql_batch(args, mcp_service)
    return _error_content(f"Unknown graphql tool: {name}")


async def _handle_graphql_introspect(args: dict, mcp_service) -> List[TextContent]:
    url = args["url"]
    headers = args.get("headers", {})

    client = _get_http_client(mcp_service)

    payload = {"query": INTROSPECTION_QUERY}

    try:
        resp = await client.send("POST", url, json=payload, headers=headers)

        if resp.status_code != 200:
            return _json_content({
                "introspection_enabled": False,
                "status_code": resp.status_code,
                "message": "Introspection query returned non-200 status"
            })

        data = resp.json()
        schema = data.get("data", {}).get("__schema", {})

        if not schema:
            errors = data.get("errors", [])
            return _json_content({
                "introspection_enabled": False,
                "errors": [e.get("message", str(e)) for e in errors],
                "message": "Introspection disabled or returned errors"
            })

        # Parse types
        types = schema.get("types", [])
        user_types = [t for t in types if t.get("name") and not t["name"].startswith("__")]

        # Find sensitive fields
        sensitive_findings = []
        for t in user_types:
            for field in (t.get("fields") or []):
                fname = field.get("name", "").lower()
                if any(pat in fname for pat in SENSITIVE_FIELD_PATTERNS):
                    sensitive_findings.append(f"{t['name']}.{field['name']}")

        # Find mutations
        mutation_type_name = (schema.get("mutationType") or {}).get("name")
        mutations = []
        if mutation_type_name:
            for t in types:
                if t.get("name") == mutation_type_name:
                    mutations = [f.get("name") for f in (t.get("fields") or [])]

        return _json_content({
            "introspection_enabled": True,
            "type_count": len(user_types),
            "types": [t["name"] for t in user_types],
            "mutation_count": len(mutations),
            "mutations": mutations,
            "sensitive_fields": sensitive_findings,
            "query_type": (schema.get("queryType") or {}).get("name"),
            "mutation_type": mutation_type_name,
        })
    except Exception as e:
        return _error_content(f"Introspection failed: {e}")


async def _handle_graphql_query(args: dict, mcp_service) -> List[TextContent]:
    url = args["url"]
    query = args["query"]
    variables = args.get("variables", {})
    operation_name = args.get("operation_name")
    headers = args.get("headers", {})

    identity_id = args.get("identity_id")
    if identity_id:
        try:
            db = await _get_db(mcp_service)
            rows = await db.query("identities", {"id": identity_id})
            if rows:
                meta = rows[0].get("metadata") or {}
                if isinstance(meta, str):
                    meta = json.loads(meta)
                token = meta.get("token") or meta.get("access_token")
                if token:
                    headers["Authorization"] = f"Bearer {token}"
        except Exception:
            pass

    client = _get_http_client(mcp_service)

    payload = {"query": query, "variables": variables}
    if operation_name:
        payload["operationName"] = operation_name

    try:
        resp = await client.send("POST", url, json=payload, headers=headers)

        body = {}
        try:
            body = resp.json()
        except Exception:
            pass

        return _json_content({
            "status_code": resp.status_code,
            "data": body.get("data"),
            "errors": body.get("errors"),
            "has_errors": bool(body.get("errors")),
            "response_headers": dict(resp.headers)
        })
    except Exception as e:
        return _error_content(f"GraphQL query failed: {e}")


async def _handle_graphql_fuzz_schema(args: dict, mcp_service) -> List[TextContent]:
    url = args["url"]
    headers = args.get("headers", {})
    known_types = args.get("known_types", ["Query", "Mutation", "User", "Post", "Product", "Order"])
    max_requests = args.get("max_requests", 100)

    client = _get_http_client(mcp_service)

    discovered = {}
    request_count = 0

    # Try __typename probe first
    try:
        resp = await client.send("POST", url, json={"query": "{ __typename }"}, headers=headers)
        request_count += 1
        body = resp.json()
        if body.get("data", {}).get("__typename"):
            discovered["query_root"] = body["data"]["__typename"]
    except Exception:
        pass

    # Probe common field names and parse suggestions from errors
    probe_fields = ["id", "user", "users", "me", "profile", "admin", "viewer", "node", "nodes",
                    "search", "list", "get", "create", "update", "delete", "login", "logout"]

    suggestions = []
    for field in probe_fields:
        if request_count >= max_requests:
            break
        try:
            resp = await client.send("POST", url, json={"query": f"{{ {field} }}"}, headers=headers)
            request_count += 1
            body = resp.json()
            for error in body.get("errors", []):
                msg = error.get("message", "")
                # Parse "Did you mean X?" suggestions
                if "Did you mean" in msg:
                    found = re.findall(r'"([^"]+)"', msg)
                    suggestions.extend(found)
                # Parse "Cannot query field X" - means field doesn't exist but others might
                if "Cannot query field" in msg and "on type" in msg:
                    type_match = re.search(r'on type "([^"]+)"', msg)
                    if type_match:
                        discovered[f"type_hint_{field}"] = type_match.group(1)
        except Exception:
            continue

    return _json_content({
        "introspection_disabled": True,
        "requests_sent": request_count,
        "discovered": discovered,
        "field_suggestions": list(set(suggestions)),
        "message": f"Schema fuzzing complete. Found {len(suggestions)} field suggestions via error messages."
    })


async def _handle_graphql_alias_idor(args: dict, mcp_service) -> List[TextContent]:
    url = args["url"]
    query_template = args["query_template"]
    ids = args["ids"]
    headers = args.get("headers", {})

    identity_id = args.get("identity_id")
    if identity_id:
        try:
            db = await _get_db(mcp_service)
            rows = await db.query("identities", {"id": identity_id})
            if rows:
                meta = rows[0].get("metadata") or {}
                if isinstance(meta, str):
                    meta = json.loads(meta)
                token = meta.get("token") or meta.get("access_token")
                if token:
                    headers["Authorization"] = f"Bearer {token}"
        except Exception:
            pass

    client = _get_http_client(mcp_service)

    if len(ids) > 20:
        ids = ids[:20]

    # Build aliased query
    aliases = []
    for i, id_val in enumerate(ids):
        aliased = query_template.replace("{id}", id_val)
        aliases.append(f"a{i}: {aliased}")

    full_query = "{ " + "\n".join(aliases) + " }"

    try:
        resp = await client.send("POST", url, json={"query": full_query}, headers=headers)

        body = resp.json()
        data = body.get("data", {})
        errors = body.get("errors", [])

        # Analyze results
        results = []
        for i, id_val in enumerate(ids):
            alias = f"a{i}"
            result_data = data.get(alias)
            results.append({
                "id": id_val,
                "alias": alias,
                "data_returned": result_data is not None,
                "data": result_data
            })

        accessible_ids = [r["id"] for r in results if r["data_returned"]]
        inaccessible_ids = [r["id"] for r in results if not r["data_returned"]]

        return _json_content({
            "status_code": resp.status_code,
            "total_ids_tested": len(ids),
            "accessible_ids": accessible_ids,
            "inaccessible_ids": inaccessible_ids,
            "idor_indicators": len(accessible_ids) > 1,
            "results": results,
            "errors": [e.get("message") for e in errors]
        })
    except Exception as e:
        return _error_content(f"GraphQL alias IDOR test failed: {e}")


async def _handle_graphql_batch(args: dict, mcp_service) -> List[TextContent]:
    url = args["url"]
    queries = args["queries"]
    headers = args.get("headers", {})

    client = _get_http_client(mcp_service)

    try:
        # Send as JSON array
        resp = await client.send("POST", url, json=queries, headers=headers)

        body = None
        batch_supported = False
        try:
            body = resp.json()
            batch_supported = isinstance(body, list)
        except Exception:
            pass

        return _json_content({
            "status_code": resp.status_code,
            "batch_supported": batch_supported,
            "query_count": len(queries),
            "response_count": len(body) if isinstance(body, list) else 0,
            "response": body,
            "message": "Batch supported - potential rate limit bypass" if batch_supported else "Batch not supported or returned non-array response"
        })
    except Exception as e:
        return _error_content(f"GraphQL batch test failed: {e}")
