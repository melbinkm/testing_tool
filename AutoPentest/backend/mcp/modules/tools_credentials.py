"""
Credentials Management Tools - credentials_add, credentials_list
"""
import re
from typing import List
from mcp.types import Tool, TextContent


def get_credentials_tools() -> List[Tool]:
    """Get credentials management tool definitions"""
    return [
        Tool(
            name="credentials_add",
            description=(
                "Add discovered authentication credentials with automatic placeholder generation AND automatic validation "
                "testing. Supports bearer tokens, cookies, basic auth, API keys, SSH credentials, and custom formats. "
                "Generates {{PLACEHOLDER}} for safe credential reference in commands. For basic_auth type with username/ "
                "password + target URL, automatically tests credential validity and creates CRITICAL finding if valid. "
                "Essential for managing discovered credentials and using them in subsequent testing without exposing raw values. "

                "**When to use:** Phase 2-4 (Mapping/Assessment/Exploitation) when discovering credentials via: config "
                "file leaks (tokens in code), SQL injection (dumped passwords), IDOR (accessed other user tokens), "
                "XSS (stolen cookies), source code (hardcoded keys), authentication bypass (extracted tokens), HTML comments "
                "(<!-- admin:admin123 -->). Store immediately for use in crawler_start(identity_id), http_send(identity_id), "
                "sequence_execute(), or execute() commands with placeholder substitution. Auto-testing validates discovered "
                "credentials and creates findings for valid default credentials. "

                "**Dependencies:** Requires load_assessment() first. Follow with credentials_list() to see placeholders, "
                "then use placeholder in execute() commands for automatic substitution. Alternative to auth_get_identities() "
                "for dynamically discovered credentials (not pre-configured test accounts). Auto-testing requires target URL "
                "and uses test_credential() helper from auth_tester. "

                "**Budget impact:** LOW for storage + MEDIUM for auto-testing (1 login request if basic_auth with target). "
                "Credential securely stored with encryption at rest. Placeholder generation instant (<10ms). Auto-test adds "
                "~500ms-2s per credential (POST /login). Set auto_test=false to skip testing and save budget. "

                "**Failure modes:** 'Placeholder already exists' if duplicate name/type combination (choose different name). "
                "Missing credential value fields (token, username, password) stores placeholder but won't work in commands "
                "(add values later or recreate). Auto-test may fail if: target unreachable, login endpoint not /login (override "
                "with login_path param), non-standard auth flow (disable with auto_test=false). "

                "**Risk level:** SAFE - local secure storage only. Credentials encrypted at rest, never logged in plaintext. "
                "Placeholder system prevents accidental credential exposure. AUTO-TEST = MEDIUM RISK - sends real credentials "
                "to target login endpoint (1 login attempt), logged in target's auth logs. May trigger account lockout if "
                "credential invalid. Only use with explicit permission to test authentication. Set auto_test=false for safe "
                "storage without testing. "

                "**Returns:** Confirmation with name, type, auto-generated placeholder ({{TYPE_NAME}}), usage instructions, "
                "test result (âœ… VALID/âŒ INVALID/âš ï¸ Not tested), and finding creation status. If valid credential detected, "
                "creates 'Valid Default Credentials' CRITICAL finding with proof. Use placeholder in: execute('curl -H "
                "\"Authorization: Bearer {{BEARER_TOKEN_API}}\" URL'), crawler_start(), http_send(), or any tool supporting "
                "identity_id/credential references."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "credential_type": {
                        "type": "string",
                        "enum": ["bearer_token", "cookie", "basic_auth", "api_key", "ssh", "custom"],
                        "description": "Type of credential"
                    },
                    "name": {
                        "type": "string",
                        "description": "Descriptive name (e.g., 'Fleet Manager Auth') - placeholder will be auto-generated"
                    },
                    "placeholder": {
                        "type": "string",
                        "description": "Optional: Custom placeholder (auto-generated from name if not provided)"
                    },
                    "token": {
                        "type": "string",
                        "description": "Token value (for bearer_token, api_key)"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username (for basic_auth, ssh)"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password (for basic_auth, ssh)"
                    },
                    "cookie_value": {
                        "type": "string",
                        "description": "Cookie string (for cookie type)"
                    },
                    "custom_data": {
                        "type": "object",
                        "description": "Custom data (JSON object for custom type)"
                    },
                    "service": {
                        "type": "string",
                        "description": "Service name (SSH, API, Web, etc.)"
                    },
                    "target": {
                        "type": "string",
                        "description": "Target URL or IP"
                    },
                    "notes": {
                        "type": "string",
                        "description": "Additional notes (e.g., 'Found in config file', 'Expires in 15 min')"
                    },
                    "auto_test": {
                        "type": "boolean",
                        "description": "Auto-test credential validity (default: true). For basic_auth with target URL, attempts login and creates finding if valid. Set false to skip testing."
                    },
                    "login_path": {
                        "type": "string",
                        "description": "Login endpoint path for auto-testing (default: /login). Only used if auto_test=true."
                    }
                },
                "required": ["credential_type", "name"]
            }
        ),
        Tool(
            name="credentials_list",
            description=(
                "List all stored credentials with placeholders, types, targets, and metadata. Essential reference for "
                "seeing available credentials and their placeholders for use in execute() commands. Filter by credential_type "
                "for focused view. Shows summary by type and detailed list with usage examples. "

                "**When to use:** Phase 2-4 after credentials_add() to review stored credentials. Use to: see available "
                "placeholders for execute() commands, verify credential was stored correctly, review discovered credentials "
                "before using, plan credential reuse testing (sequence_credential_reuse), check credential metadata (target, "
                "service, notes). "

                "**Dependencies:** Requires load_assessment() and prior credentials_add() calls. Returns empty if no "
                "credentials stored yet. Use placeholders returned here in execute(), crawler_start(identity_id), "
                "http_send(identity_id), or other tools supporting credentials. "

                "**Budget impact:** LOW - local database query, no network requests. Returns all credentials (typically <50). "
                "Completes <50ms. Credentials encrypted in storage, decrypted on retrieval. "

                "**Failure modes:** 'No credentials found' if nothing stored yet (expected early in assessment). Filter by "
                "invalid credential_type returns empty (no error, silently filters). "

                "**Risk level:** SAFE - read-only query showing credential metadata and placeholders. Does NOT return actual "
                "credential values (tokens, passwords) - only references (placeholders). Actual credentials used internally "
                "when placeholder referenced. No network activity or target interaction. "

                "**Returns:** Formatted list with: count, summary by type (bearer_token: 3, cookie: 1), detailed entries "
                "(name, type, placeholder, target, service, notes preview, created_at), usage tip. Use placeholders in "
                "commands for automatic credential substitution without exposing values."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "credential_type": {
                        "type": "string",
                        "enum": ["bearer_token", "cookie", "basic_auth", "api_key", "ssh", "custom"],
                        "description": "Filter by type (optional)"
                    }
                },
                "required": []
            }
        ),
    ]


async def handle_credentials_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route credentials tool calls to the appropriate handler"""
    if name == "credentials_add":
        return await _handle_credentials_add(arguments, mcp_service)
    elif name == "credentials_list":
        return await _handle_credentials_list(arguments, mcp_service)
    return [TextContent(type="text", text=f"Unknown credentials tool: {name}")]


async def _handle_credentials_add(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle credentials_add - Add authentication credentials"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    credential_type = arguments["credential_type"]
    name = arguments["name"]

    # Auto-generate placeholder if not provided
    if "placeholder" in arguments and arguments["placeholder"]:
        placeholder = arguments["placeholder"]
    else:
        # Generate placeholder from name and type
        clean_name = re.sub(r'[^A-Z0-9\s]', '', name.upper()).replace(' ', '_')
        type_prefix = credential_type.upper().replace('_', '_')
        placeholder = f"{{{{{type_prefix}_{clean_name}}}}}"

    # Prepare credential data
    credential_data = {
        "credential_type": credential_type,
        "name": name,
        "placeholder": placeholder,
        "discovered_by": "claude"  # Marked as added by Claude
    }

    # Add optional fields if present
    optional_fields = ["token", "username", "password", "cookie_value", "custom_data", "service", "target", "notes"]
    for field in optional_fields:
        if field in arguments:
            credential_data[field] = arguments[field]

    # Auto-test credential if basic_auth with username/password and target provided
    auto_test = arguments.get("auto_test", True)  # Default to True
    test_result = None

    if auto_test and credential_type == "basic_auth" and credential_data.get("username") and credential_data.get("password") and credential_data.get("target"):
        # Import the test helper from auth_tester
        from modules.tools_auth_tester import test_credential
        import logging
        logger = logging.getLogger("autopentest-mcp")

        logger.info(f"Auto-testing credential: {credential_data.get('username')}@{credential_data.get('target')}")

        test_result = await test_credential(
            target_url=credential_data["target"],
            username=credential_data["username"],
            password=credential_data["password"],
            method="form",  # Default to form login, could be made configurable
            login_path=arguments.get("login_path", "/login")
        )

        # If credential is valid, create a CRITICAL finding
        if test_result.get("valid"):
            logger.info(f"Credential test SUCCESSFUL: {credential_data.get('username')}:{credential_data.get('password')}")

            # Redact password from test result for proof (can't use backslashes in f-strings)
            redacted_result = re.sub(r'"password": "[^"]*"', '"password": "[REDACTED]"', str(test_result))

            # Create finding for valid default credentials
            await mcp_service.safe_add_card(
                card_type="finding",
                title=f"Valid Default Credentials: {name}",
                severity="CRITICAL",
                status="confirmed",
                technical_analysis=(
                    f"Tested credential {credential_data['username']}:{credential_data['password']} "
                    f"against {credential_data['target']} and successfully authenticated.\n\n"
                    f"**Status Code:** {test_result.get('status_code')}\n"
                    f"**Session Token:** {'Yes' if test_result.get('session_token') else 'No'}\n"
                    f"**Redirect:** {test_result.get('redirect_url', 'None')}"
                ),
                proof=f"```json\n{redacted_result}\n```",
                remediation=(
                    "1. Change default credentials immediately\n"
                    "2. Enforce strong password policy\n"
                    "3. Implement account lockout after failed login attempts\n"
                    "4. Require password change on first login"
                ),
                context=f"Auto-tested by credentials_add tool",
            )
        else:
            logger.info(f"Credential test FAILED: {credential_data.get('username')}:{credential_data.get('password')} - {test_result.get('error', 'Invalid')}")

    # API call to create credential
    try:
        response = await mcp_service.http_client.post(
            f"{mcp_service.backend_url}/assessments/{mcp_service.current_assessment_id}/credentials",
            json=credential_data
        )
        response.raise_for_status()
        result = response.json()

        # Format response
        response_text = f"Credential added: **{name}**\n\n"
        response_text += f"**Type:** {credential_type}\n"
        response_text += f"**Placeholder:** `{placeholder}`\n"

        if credential_data.get("target"):
            response_text += f"**Target:** {credential_data['target']}\n"

        if credential_data.get("service"):
            response_text += f"**Service:** {credential_data['service']}\n"

        # Add test results if available
        if test_result:
            if test_result.get("valid"):
                response_text += f"\nðŸ”“ **Credential Test:** âœ… VALID - Login successful!\n"
                response_text += f"   - Status: {test_result.get('status_code')}\n"
                response_text += f"   - Session: {'Obtained' if test_result.get('session_token') else 'None'}\n"
                response_text += f"   - **Finding created:** Valid Default Credentials (CRITICAL)\n"
            elif test_result.get("error"):
                response_text += f"\nðŸ”“ **Credential Test:** âš ï¸  Could not test - {test_result.get('error')}\n"
            else:
                response_text += f"\nðŸ”“ **Credential Test:** âŒ INVALID - Login failed (status: {test_result.get('status_code')})\n"

        response_text += f"\n**Usage:** Use `{placeholder}` in your execute commands.\n"
        response_text += f"**Example:** `execute('curl -H \"Authorization: Bearer {placeholder}\" https://api.example.com')`"

        return [TextContent(type="text", text=response_text)]

    except Exception as e:
        error_msg = str(e)
        if "409" in error_msg or "already exists" in error_msg.lower():
            return [TextContent(
                type="text",
                text=f"Error: Placeholder '{placeholder}' already exists for this assessment. Choose a different placeholder."
            )]
        else:
            return [TextContent(
                type="text",
                text=f"Error adding credential: {error_msg}"
            )]


async def _handle_credentials_list(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle credentials_list - List all credentials"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    # Filter by type if specified
    credential_type = arguments.get("credential_type")

    # API call to list credentials
    try:
        url = f"{mcp_service.backend_url}/assessments/{mcp_service.current_assessment_id}/credentials"
        if credential_type:
            url += f"?credential_type={credential_type}"

        response = await mcp_service.http_client.get(url)
        response.raise_for_status()
        result = response.json()

        credentials = result.get("credentials", [])
        total = result.get("total", 0)
        by_type = result.get("by_type", {})

        if total == 0:
            return [TextContent(
                type="text",
                text="No credentials found for this assessment.\n\nUse `credentials_add` to add authentication tokens, cookies, or other credentials."
            )]

        # Format response
        response_text = f"**Available Credentials ({total}):**\n\n"

        # Summary by type
        if by_type:
            response_text += "**By Type:**\n"
            for cred_type, count in by_type.items():
                response_text += f"- {cred_type}: {count}\n"
            response_text += "\n"

        # Detailed list
        response_text += "**Credentials:**\n\n"
        for i, cred in enumerate(credentials, 1):
            response_text += f"{i}. **{cred['name']}** ({cred['credential_type']})\n"
            response_text += f"   - Placeholder: `{cred['placeholder']}`\n"

            if cred.get("target"):
                response_text += f"   - Target: {cred['target']}\n"

            if cred.get("service"):
                response_text += f"   - Service: {cred['service']}\n"

            if cred.get("notes"):
                notes_preview = cred['notes'][:80] + "..." if len(cred['notes']) > 80 else cred['notes']
                response_text += f"   - Notes: {notes_preview}\n"

            response_text += f"   - Added: {cred.get('created_at', 'N/A')}\n"
            response_text += "\n"

        response_text += "**Tip:** Use placeholders in execute commands for automatic substitution."

        return [TextContent(type="text", text=response_text)]

    except Exception as e:
        return [TextContent(
            type="text",
            text=f"Error listing credentials: {str(e)}"
        )]
