"""
Coverage Tools - coverage_init, coverage_next, coverage_mark, coverage_report.

Deterministic coverage engine that ensures every endpoint is tested for every
applicable vulnerability class using the correct tool with the right arguments.
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict, List

from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _json_content(data: Any) -> List[TextContent]:
    """Return a single-element TextContent list with *data* as JSON."""
    return [TextContent(type="text", text=json.dumps(data, indent=2, default=str))]


def _error_content(message: str) -> List[TextContent]:
    """Return a JSON error object wrapped in TextContent."""
    return [TextContent(type="text", text=json.dumps({"success": False, "error": message}, indent=2))]


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_coverage_tools() -> List[Tool]:
    """Return the four coverage tools."""
    return [
        # 1 ---- coverage_init ----------------------------------------------
        Tool(
            name="coverage_init",
            description=(
                "Build a deterministic coverage matrix from world model endpoints. "
                "Each endpoint is mapped to applicable vulnerability classes with "
                "exact tool invocations and priority scores."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "base_url": {
                        "type": "string",
                        "description": "Base URL of the target (e.g. 'https://api.example.com')",
                    },
                    "endpoint_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Optional: limit to specific endpoint IDs. If omitted, uses all endpoints.",
                    },
                    "vuln_classes": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": (
                            "Optional: limit to specific vuln classes. "
                            "Choices: sqli, xss, idor, injection, auth_bypass, ssrf, "
                            "path_traversal, overflow, type_confusion, info_disclosure, "
                            "misconfig, nuclei"
                        ),
                    },
                },
                "required": ["base_url"],
            },
        ),

        # 2 ---- coverage_next ----------------------------------------------
        Tool(
            name="coverage_next",
            description=(
                "Get the next N untested coverage cells with exact tool invocation "
                "details. Returns cell_id, endpoint info, vuln_class, priority, "
                "and the precise tool_call to execute."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "vuln_class": {
                        "type": "string",
                        "description": "Filter to a specific vulnerability class",
                    },
                    "endpoint_id": {
                        "type": "string",
                        "description": "Filter to a specific endpoint",
                    },
                    "limit": {
                        "type": "integer",
                        "minimum": 1,
                        "maximum": 50,
                        "description": "Number of cells to return (default: 5)",
                    },
                },
            },
        ),

        # 3 ---- coverage_mark ----------------------------------------------
        Tool(
            name="coverage_mark",
            description=(
                "Record the result of a coverage test. Sets the cell status and "
                "optionally links a finding. When status=vulnerable, automatically "
                "creates a has_finding relationship in the graph."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "cell_id": {
                        "type": "string",
                        "description": "Coverage cell ID (from coverage_next)",
                    },
                    "status": {
                        "type": "string",
                        "enum": ["passed", "vulnerable", "skipped", "error"],
                        "description": "Test result status",
                    },
                    "finding_id": {
                        "type": "string",
                        "description": "Finding ID if status=vulnerable (from wm_add_finding)",
                    },
                    "result_summary": {
                        "type": "string",
                        "description": "Brief description of the test result",
                    },
                },
                "required": ["cell_id", "status"],
            },
        ),

        # 4 ---- coverage_report --------------------------------------------
        Tool(
            name="coverage_report",
            description=(
                "Get coverage statistics and structured queries. Shows total cells, "
                "completion percentage, breakdown by status and vuln class, and gaps."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "endpoint_id": {
                        "type": "string",
                        "description": "Filter report to a specific endpoint",
                    },
                    "vuln_class": {
                        "type": "string",
                        "description": "Filter report to a specific vulnerability class",
                    },
                    "query": {
                        "type": "string",
                        "enum": [
                            "untested_endpoints",
                            "coverage_by_vuln_class",
                            "findings_by_endpoint",
                            "vulnerable_endpoints",
                            "high_priority_gaps",
                        ],
                        "description": "Pre-built structured query to run (optional)",
                    },
                },
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_coverage_tool(
    name: str,
    arguments: dict,
    mcp_service: Any = None,
) -> List[TextContent]:
    """Dispatch a coverage tool call to the appropriate handler."""
    try:
        if name == "coverage_init":
            return await _handle_coverage_init(arguments, mcp_service)
        elif name == "coverage_next":
            return await _handle_coverage_next(arguments, mcp_service)
        elif name == "coverage_mark":
            return await _handle_coverage_mark(arguments, mcp_service)
        elif name == "coverage_report":
            return await _handle_coverage_report(arguments, mcp_service)
    except _NoAssessmentError:
        return _error_content(
            "No assessment loaded. Use 'load_assessment' first before using coverage tools."
        )
    except Exception as exc:
        logger.error("Coverage tool %s failed: %s", name, exc, exc_info=True)
        return _error_content(f"Error in {name}: {exc}")

    return _error_content(f"Unknown coverage tool: {name}")


# ---------------------------------------------------------------------------
# Lazy database initialisation
# ---------------------------------------------------------------------------

class _NoAssessmentError(Exception):
    pass


async def _get_db(mcp_service=None):
    """Return the world-model database for the current assessment."""
    if mcp_service is None or mcp_service.current_assessment_id is None:
        raise _NoAssessmentError()
    from lib.world_model_db import get_world_model_db
    return await get_world_model_db(mcp_service.current_assessment_id)


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_coverage_init(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle coverage_init - build coverage matrix from world model endpoints."""
    base_url = arguments.get("base_url")
    if not base_url or not isinstance(base_url, str):
        return _error_content("base_url is required and must be a string")

    endpoint_ids = arguments.get("endpoint_ids")
    vuln_classes = arguments.get("vuln_classes")

    db = await _get_db(mcp_service)

    # Query endpoints from world model
    if endpoint_ids and isinstance(endpoint_ids, list):
        endpoints = []
        for ep_id in endpoint_ids:
            ep = await db.get_by_id("endpoints", ep_id)
            if ep:
                endpoints.append(ep)
    else:
        endpoints = await db.query(table="endpoints", limit=1000)

    if not endpoints:
        return _error_content(
            "No endpoints found in the world model. "
            "Use wm_add_endpoint or openapi_parse to add endpoints first."
        )

    # Build coverage matrix using tracker
    from lib.coverage_tracker import CoverageTracker
    rows = CoverageTracker.build_matrix(
        endpoints=endpoints,
        base_url=base_url,
        vuln_classes=vuln_classes,
    )

    if not rows:
        return _json_content({
            "success": True,
            "created": 0,
            "skipped_existing": 0,
            "total_cells": 0,
            "message": "No coverage cells to create (no applicable vuln classes for given endpoints).",
        })

    # Insert into database
    result = await db.coverage_init_rows(rows)

    return _json_content({
        "success": True,
        "created": result["created"],
        "skipped_existing": result["skipped_existing"],
        "total_cells": result["created"] + result["skipped_existing"],
        "endpoints_covered": len(endpoints),
        "message": (
            f"Coverage matrix initialized: {result['created']} new cells created, "
            f"{result['skipped_existing']} already existed. "
            f"Covering {len(endpoints)} endpoints."
        ),
    })


async def _handle_coverage_next(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle coverage_next - get next untested cells with tool invocation details."""
    vuln_class = arguments.get("vuln_class")
    endpoint_id = arguments.get("endpoint_id")
    limit = arguments.get("limit", 5)

    if not isinstance(limit, int) or limit < 1:
        limit = 5
    limit = min(limit, 50)

    db = await _get_db(mcp_service)
    cells = await db.coverage_next(
        vuln_class=vuln_class,
        endpoint_id=endpoint_id,
        limit=limit,
    )

    # Enrich with tool_call from coverage tracker
    from lib.coverage_tracker import CoverageTracker

    enriched = []
    for cell in cells:
        ep = cell.get("endpoint", {})
        tool_args = cell.get("tool_args", {})

        enriched.append({
            "cell_id": cell["id"],
            "endpoint_id": cell["endpoint_id"],
            "endpoint": ep,
            "vuln_class": cell["vuln_class"],
            "priority": cell["priority"],
            "tool_call": {
                "tool_name": cell.get("tool_name", ""),
                "arguments": tool_args,
            },
        })

    return _json_content({
        "success": True,
        "count": len(enriched),
        "cells": enriched,
        "message": (
            f"{len(enriched)} pending test(s) returned."
            if enriched else "No pending tests. Coverage may be complete."
        ),
    })


async def _handle_coverage_mark(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle coverage_mark - record test result for a coverage cell."""
    cell_id = arguments.get("cell_id")
    if not cell_id or not isinstance(cell_id, str):
        return _error_content("cell_id is required and must be a string")

    status = arguments.get("status")
    if not status or status not in ("passed", "vulnerable", "skipped", "error"):
        return _error_content("status is required and must be one of: passed, vulnerable, skipped, error")

    finding_id = arguments.get("finding_id")
    result_summary = arguments.get("result_summary")

    db = await _get_db(mcp_service)
    cell = await db.coverage_mark(
        cell_id=cell_id,
        status=status,
        finding_id=finding_id,
        result_summary=result_summary,
    )

    # Auto-create graph relationships on vulnerable status
    if status == "vulnerable" and finding_id:
        try:
            await db.add_relationship(
                source_type="endpoint",
                source_id=cell["endpoint_id"],
                target_type="finding",
                target_id=finding_id,
                rel_type="has_finding",
            )
        except Exception as rel_exc:
            logger.warning("Auto-relationship (has_finding) failed: %s", rel_exc)

    return _json_content({
        "success": True,
        "cell": cell,
        "message": f"Coverage cell {cell_id} marked as '{status}'.",
    })


async def _handle_coverage_report(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle coverage_report - get coverage statistics and structured queries."""
    endpoint_id = arguments.get("endpoint_id")
    vuln_class = arguments.get("vuln_class")
    query_type = arguments.get("query")

    db = await _get_db(mcp_service)

    # If a structured query is requested, run it
    if query_type:
        results = await db.coverage_query(
            query_type=query_type,
            filters={"endpoint_id": endpoint_id} if endpoint_id else {},
        )
        return _json_content({
            "success": True,
            "query": query_type,
            "count": len(results),
            "results": results,
        })

    # Otherwise return aggregate report
    report = await db.coverage_report(
        endpoint_id=endpoint_id,
        vuln_class=vuln_class,
    )

    return _json_content({
        "success": True,
        **report,
        "message": (
            f"Coverage: {report['coverage_pct']}% complete "
            f"({report['total_cells']} total cells, "
            f"{len(report['gaps'])} gaps remaining)."
        ),
    })
