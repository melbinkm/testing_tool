"""
Coverage Tools - coverage_init, coverage_next, coverage_mark, coverage_report,
                 coverage_discover, coverage_refresh.

Deterministic coverage engine that ensures every endpoint is tested for every
applicable vulnerability class using the correct tool with the right arguments.

Discovery feedback loop tools (coverage_discover, coverage_refresh) detect new
endpoints and incrementally extend the coverage matrix.
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict, List

from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _json_content(data: Any) -> List[TextContent]:
    """Return a single-element TextContent list with *data* as JSON."""
    return [TextContent(type="text", text=json.dumps(data, indent=2, default=str))]


def _error_content(message: str) -> List[TextContent]:
    """Return a JSON error object wrapped in TextContent."""
    return [TextContent(type="text", text=json.dumps({"success": False, "error": message}, indent=2))]


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_coverage_tools() -> List[Tool]:
    """Return the six coverage tools (4 original + 2 discovery feedback loop)."""
    return [
        # 1 ---- coverage_init ----------------------------------------------
        Tool(
            name="coverage_init",
            description=(
                "Build deterministic coverage matrix from world model endpoints. Creates grid of (endpoint × vuln_class) "
                "coverage cells, each with exact tool invocation (tool name + arguments), priority score (0-100 based "
                "on risk/impact), and initial status='untested'. Ensures systematic testing of every endpoint for every "
                "applicable vulnerability without redundancy. Foundation of intelligent test orchestration. "

                "**When to use:** Phase 2-3 (Mapping/Assessment) after discovering endpoints via crawler_start(), "
                "openapi_parse(), or manual wm_add_endpoint(). Essential setup before systematic testing. Call once "
                "per target base_url after endpoint discovery complete. Use coverage_discover() instead for "
                "incremental additions during testing. Use endpoint_ids filter to build matrix for subset. "

                "**Dependencies:** Requires wm_add_endpoint() or openapi_parse() to have populated world model with "
                "endpoints first. Query wm_query(table='endpoints') to verify endpoints exist. Follow with "
                "coverage_next() to get prioritized tests, then coverage_mark() to record results. Use "
                "coverage_refresh() later to add newly discovered endpoints without losing existing results. "

                "**Budget impact:** LOW - local database computation, no network requests. Matrix generation takes "
                "<1 second for 100 endpoints × 12 vuln classes = 1200 cells. Priority scores calculated based on "
                "endpoint characteristics (has auth, handles IDs, accepts user input). "

                "**Failure modes:** Empty matrix if no endpoints in world model for base_url (run crawler or parser "
                "first). Duplicate cells silently skipped (idempotent - safe to call multiple times). Invalid "
                "vuln_classes filter returns empty matrix. "

                "**Risk level:** SAFE - local matrix construction only, no network activity or target interaction. "
                "Creates structured test plan but doesn't execute anything. "

                "**Returns:** Matrix summary with: total_cells (count), endpoints_covered (count), vuln_classes[] "
                "(list), priority_distribution (high/medium/low counts), cells_by_status (all untested initially). "
                "Use coverage_next() to retrieve cells with exact tool invocations for systematic testing."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "base_url": {
                        "type": "string",
                        "description": "Base URL of the target (e.g. 'https://api.example.com')",
                    },
                    "endpoint_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Optional: limit to specific endpoint IDs. If omitted, uses all endpoints.",
                    },
                    "vuln_classes": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": (
                            "Optional: limit to specific vuln classes. "
                            "Choices: sqli, xss, idor, injection, auth_bypass, ssrf, "
                            "path_traversal, overflow, type_confusion, info_disclosure, "
                            "misconfig, nuclei"
                        ),
                    },
                },
                "required": ["base_url"],
            },
        ),

        # 2 ---- coverage_next ----------------------------------------------
        Tool(
            name="coverage_next",
            description=(
                "Get next N untested coverage cells sorted by priority (high to low). Each cell includes exact tool "
                "invocation details: tool name (endpoint_execute_plan, nuclei_scan_template, etc.), complete arguments "
                "object, endpoint info (URL, method, parameters), vuln_class, priority score. Enables systematic testing "
                "without manual tool selection - just execute the returned tool_calls. Core orchestration tool. "

                "**When to use:** Phase 3 (Assessment) repeatedly in testing loop after coverage_init(). Pattern: "
                "(1) coverage_next(limit=5) to get next tests, (2) execute each tool_call, (3) coverage_mark() "
                "results, (4) repeat. Use vuln_class filter to focus on specific vulnerabilities (e.g., vuln_class='sqli' "
                "for SQL injection sweep). Use endpoint_id filter to exhaust one endpoint. Check priority scores - "
                "stop when priority<30 (low-value tests). "

                "**Dependencies:** Requires coverage_init() or coverage_discover() to have built matrix first. Returns "
                "empty if all cells tested (check coverage_report() for completion). Follow returned tool_calls with "
                "actual execution (endpoint_execute_plan, nuclei_scan_template, etc.), then coverage_mark() to record. "

                "**Budget impact:** LOW - local database query sorted by priority and filtered by status='untested'. "
                "Returns instantly with top N cells. No network requests. "

                "**Failure modes:** Empty results if: (1) coverage matrix not built yet (run coverage_init first), "
                "(2) all cells tested (check coverage_report), (3) filters too restrictive (remove vuln_class/"
                "endpoint_id filters). Priority scores may seem arbitrary - based on heuristics (endpoint with auth "
                "required = higher priority). "

                "**Risk level:** SAFE - read-only query returning test recommendations. Does not execute any tests. "
                "Returned tool_calls contain HIGH RISK operations - execute with caution. "

                "**Returns:** Array of coverage cells with: cell_id (use in coverage_mark), endpoint (URL, method, "
                "parameters, auth_required), vuln_class, priority (0-100), tool_call (exact invocation: tool='endpoint_execute_plan', "
                "arguments={...}), rationale (why this test matters). Use tool_call.tool as function name and "
                "tool_call.arguments as parameters for systematic execution."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "vuln_class": {
                        "type": "string",
                        "description": "Filter to a specific vulnerability class",
                    },
                    "endpoint_id": {
                        "type": "string",
                        "description": "Filter to a specific endpoint",
                    },
                    "limit": {
                        "type": "integer",
                        "minimum": 1,
                        "maximum": 50,
                        "description": "Number of cells to return (default: 5)",
                    },
                },
            },
        ),

        # 3 ---- coverage_mark ----------------------------------------------
        Tool(
            name="coverage_mark",
            description=(
                "Record coverage test result by updating cell status (passed/vulnerable/skipped/error). Links finding "
                "when status='vulnerable' and automatically creates has_finding relationship in world model graph. "
                "Tracks testing progress and prevents redundant testing (cell won't appear in coverage_next() again). "
                "Essential bookkeeping for systematic testing workflow. "

                "**When to use:** Phase 3 (Assessment) immediately after executing a coverage_next() tool_call. Pattern: "
                "(1) coverage_next() returns cells, (2) execute tool_call, (3) coverage_mark(cell_id, status) to "
                "record result. Use status='vulnerable' + finding_id when test finds vulnerability (from add_card() "
                "or wm_add_finding()). Use status='passed' when no vulnerability. Use status='error' when tool failed "
                "(network error, timeout). Use status='skipped' when intentionally not testing. "

                "**Dependencies:** Requires cell_id from coverage_next(). For status='vulnerable', requires finding_id "
                "from add_card() or wm_add_finding(). No follow-up required - updates matrix in place. Cell immediately "
                "excluded from future coverage_next() queries. Check coverage_report() to see progress. "

                "**Budget impact:** LOW - local database update, no network requests. Completes <50ms. Updates coverage "
                "cell status and optionally creates graph relationship. "

                "**Failure modes:** 'Cell not found' if cell_id invalid (from stale coverage_next() result after "
                "coverage_refresh). 'Finding not found' if finding_id invalid. Missing finding_id when status='vulnerable' "
                "allowed but reduces traceability (link vulnerabilities to cells for reporting). Duplicate marking "
                "silently updates (idempotent - last status wins). "

                "**Risk level:** SAFE - local bookkeeping only, no network activity or target interaction. Records "
                "test outcomes for progress tracking. "

                "**Returns:** Simple confirmation 'Cell {ID} marked as {status}'. If status='vulnerable', also returns "
                "'Graph relationship created: cell -> finding'. Updated status immediately reflected in coverage_report() "
                "and excluded from coverage_next(). Use result_summary for notes on test outcome."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "cell_id": {
                        "type": "string",
                        "description": "Coverage cell ID (from coverage_next)",
                    },
                    "status": {
                        "type": "string",
                        "enum": ["passed", "vulnerable", "skipped", "error"],
                        "description": "Test result status",
                    },
                    "finding_id": {
                        "type": "string",
                        "description": "Finding ID if status=vulnerable (from wm_add_finding)",
                    },
                    "result_summary": {
                        "type": "string",
                        "description": "Brief description of the test result",
                    },
                },
                "required": ["cell_id", "status"],
            },
        ),

        # 4 ---- coverage_report --------------------------------------------
        Tool(
            name="coverage_report",
            description=(
                "Get comprehensive coverage statistics and analytics. Shows: total cells, completion percentage, "
                "breakdown by status (passed/vulnerable/untested/error/skipped), breakdown by vuln_class, untested "
                "endpoints, findings mapped to endpoints. Supports pre-built queries for common analytics. Essential "
                "for progress tracking and identifying gaps. "

                "**When to use:** Phase 3-5 (Assessment/Reporting) periodically to check testing progress. Use every "
                "20-30 coverage_mark() calls to see completion percentage. Use query='high_priority_gaps' to find "
                "important untested cells. Use query='vulnerable_endpoints' to see attack surface. Use "
                "query='untested_endpoints' to find endpoints with no testing. Filter by endpoint_id or vuln_class "
                "for focused reports. Essential for phase transition decisions (advance when >80% complete). "

                "**Dependencies:** Requires coverage_init() to have built matrix. Returns meaningful stats after some "
                "coverage_mark() calls (all untested initially). No follow-up required - pure analytics query. Use "
                "findings in report for update_phase() documentation. "

                "**Budget impact:** ZERO - local database aggregation, no network requests. Returns instantly even "
                "for matrices with 1000+ cells. Complex queries (joins across coverage/endpoints/findings) complete <500ms. "

                "**Failure modes:** Empty report if coverage matrix not built (run coverage_init first). Percentage "
                "calculations may show 0% if no cells marked yet (expected early in testing). Pre-built queries "
                "return empty if no matches (e.g., query='vulnerable_endpoints' returns empty if no vulnerabilities). "

                "**Risk level:** SAFE - read-only analytics query, no network activity or target interaction. "

                "**Returns:** Comprehensive stats JSON with: total_cells, tested_cells, completion_percentage (0-100), "
                "status_breakdown {passed: N, vulnerable: N, untested: N, error: N, skipped: N}, vuln_class_breakdown "
                "{sqli: {tested: N, vulnerable: N}, xss: {...}}, high_priority_gaps[] (untested cells with priority>70), "
                "vulnerable_endpoints[] (endpoints with findings). Use completion_percentage for phase decisions, "
                "high_priority_gaps for test planning, vulnerable_endpoints for reporting."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "endpoint_id": {
                        "type": "string",
                        "description": "Filter report to a specific endpoint",
                    },
                    "vuln_class": {
                        "type": "string",
                        "description": "Filter report to a specific vulnerability class",
                    },
                    "query": {
                        "type": "string",
                        "enum": [
                            "untested_endpoints",
                            "coverage_by_vuln_class",
                            "findings_by_endpoint",
                            "vulnerable_endpoints",
                            "high_priority_gaps",
                        ],
                        "description": "Pre-built structured query to run (optional)",
                    },
                },
            },
        ),

        # 5 ---- coverage_discover ------------------------------------------
        Tool(
            name="coverage_discover",
            description=(
                "Detect endpoints discovered since timestamp and automatically extend coverage matrix incrementally. "
                "Discovery feedback loop tool: when new endpoints found during testing (crawler finds authenticated "
                "pages, auth bypass reveals admin endpoints, JavaScript extraction finds hidden APIs), this adds them "
                "to coverage matrix without losing existing test results. Enables adaptive testing as attack surface "
                "grows. auto_extend=true creates coverage cells immediately. "

                "**When to use:** Phase 3-4 (Assessment/Exploitation) after events that discover new endpoints: "
                "(1) after crawler_start() with credentials finds new pages, (2) after auth bypass exploitation "
                "reveals privileged endpoints, (3) after openapi_parse() loads new spec, (4) periodically every "
                "50-100 coverage_mark() calls to catch background discoveries. Use since parameter with last "
                "coverage_discover() timestamp for incremental updates. "

                "**Dependencies:** Requires coverage_init() to have built initial matrix. Get since timestamp from "
                "last coverage_discover() call or use orchestration_status() started_at. Checks wm_query(table='endpoints') "
                "for new entries. Follow with coverage_next() to get tests for newly added endpoints. Use "
                "coverage_refresh() instead for full rebuild. "

                "**Budget impact:** LOW - local database query + coverage cell creation for new endpoints. Queries "
                "world model endpoints with timestamp filter. New endpoints × vuln_classes = new cells (e.g., 5 new "
                "endpoints × 12 vuln classes = 60 new cells). Completes <2 seconds. "

                "**Failure modes:** Empty results if no endpoints discovered after since timestamp (expected if no "
                "discoveries). Invalid since format (not ISO-8601) causes error. auto_extend=false returns discovered "
                "endpoints but doesn't add to matrix (use for preview). Since timestamp too old may return many endpoints. "

                "**Risk level:** SAFE - local matrix extension only, no network activity or target interaction. "
                "Detects what crawler/parser tools have discovered. "

                "**Returns:** Discovery summary with: discovered_endpoints[] (URLs/methods found after since), "
                "cells_added (count of new coverage cells if auto_extend=true), discovery_sources (which tools found "
                "them: crawler, parser, manual), timestamp (use for next since parameter). Use discovered_endpoints "
                "to verify new attack surface, cells_added to track matrix growth."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "base_url": {
                        "type": "string",
                        "description": "Base URL of the target (e.g. 'https://api.example.com')",
                    },
                    "since": {
                        "type": "string",
                        "description": (
                            "ISO datetime cutoff — only endpoints discovered after this "
                            "time are included (e.g. '2024-01-15T10:30:00Z')"
                        ),
                    },
                    "auto_extend": {
                        "type": "boolean",
                        "description": "Automatically add new endpoints to coverage matrix (default: true)",
                    },
                    "vuln_classes": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Limit coverage extension to specific vuln classes (optional)",
                    },
                },
                "required": ["base_url", "since"],
            },
        ),

        # 6 ---- coverage_refresh -------------------------------------------
        Tool(
            name="coverage_refresh",
            description=(
                "Incrementally rebuild entire coverage matrix from current world model endpoints, preserving existing "
                "test results (passed/vulnerable/error statuses). Re-scans all wm_endpoints and creates coverage cells "
                "for any missing (endpoint × vuln_class) combinations. Idempotent - safe to call multiple times, "
                "won't duplicate existing cells. Use when coverage_discover() incremental updates insufficient or "
                "after major endpoint changes. "

                "**When to use:** Phase 3-4 (Assessment/Exploitation) when: (1) many new endpoints discovered at once "
                "(>20), making coverage_discover() inefficient, (2) endpoint definitions changed (parameters updated, "
                "methods modified), (3) want to add new vuln_classes to existing endpoints (change vuln_classes filter), "
                "(4) troubleshooting coverage gaps (ensure no missed combinations). NOT needed for routine operation - "
                "prefer coverage_discover() for incremental updates. "

                "**Dependencies:** Requires coverage_init() to have built initial matrix. Queries wm_query(table='endpoints') "
                "for all endpoints matching base_url. Preserves all existing coverage_mark() results - only adds missing "
                "cells. Safe to call after coverage_discover(), coverage_init(), or coverage_mark(). "

                "**Budget impact:** MEDIUM - full matrix scan and cell creation. Queries all endpoints and compares "
                "against existing coverage cells. Time proportional to endpoint count × vuln_classes: 100 endpoints × "
                "12 vuln classes = 1200 potential cells, completes <3 seconds. Creates only missing cells (typically "
                "<10% of total after initial coverage_init). "

                "**Failure modes:** Expensive on large matrices (500+ endpoints) - prefer coverage_discover() unless "
                "necessary. No endpoints in world model returns empty (run crawler/parser first). Duplicate cell "
                "creation silently skipped (INSERT OR IGNORE). "

                "**Risk level:** SAFE - local matrix rebuild only, no network activity or target interaction. "
                "Preserves all test results, purely additive operation. "

                "**Returns:** Refresh summary with: total_endpoints_scanned, existing_cells (preserved from prior "
                "testing), new_cells_added (missing combinations created), vuln_classes[] (applied), preserved_results "
                "{passed: N, vulnerable: N, error: N}. Use new_cells_added to verify gaps filled, check coverage_report() "
                "for updated completion percentage."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "base_url": {
                        "type": "string",
                        "description": "Base URL of the target (e.g. 'https://api.example.com')",
                    },
                    "vuln_classes": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Limit to specific vuln classes (optional)",
                    },
                },
                "required": ["base_url"],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_coverage_tool(
    name: str,
    arguments: dict,
    mcp_service: Any = None,
) -> List[TextContent]:
    """Dispatch a coverage tool call to the appropriate handler."""
    try:
        if name == "coverage_init":
            return await _handle_coverage_init(arguments, mcp_service)
        elif name == "coverage_next":
            return await _handle_coverage_next(arguments, mcp_service)
        elif name == "coverage_mark":
            return await _handle_coverage_mark(arguments, mcp_service)
        elif name == "coverage_report":
            return await _handle_coverage_report(arguments, mcp_service)
        elif name == "coverage_discover":
            return await _handle_coverage_discover(arguments, mcp_service)
        elif name == "coverage_refresh":
            return await _handle_coverage_refresh(arguments, mcp_service)
    except _NoAssessmentError:
        return _error_content(
            "No assessment loaded. Use 'load_assessment' first before using coverage tools."
        )
    except Exception as exc:
        logger.error("Coverage tool %s failed: %s", name, exc, exc_info=True)
        return _error_content(f"Error in {name}: {exc}")

    return _error_content(f"Unknown coverage tool: {name}")


# ---------------------------------------------------------------------------
# Lazy database initialisation
# ---------------------------------------------------------------------------

class _NoAssessmentError(Exception):
    pass


async def _get_db(mcp_service=None):
    """Return the world-model database for the current assessment."""
    if mcp_service is None or mcp_service.current_assessment_id is None:
        raise _NoAssessmentError()
    from lib.world_model_db import get_world_model_db
    return await get_world_model_db(mcp_service.current_assessment_id)


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_coverage_init(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle coverage_init - build coverage matrix from world model endpoints."""
    base_url = arguments.get("base_url")
    if not base_url or not isinstance(base_url, str):
        return _error_content("base_url is required and must be a string")

    endpoint_ids = arguments.get("endpoint_ids")
    vuln_classes = arguments.get("vuln_classes")

    db = await _get_db(mcp_service)

    # Query endpoints from world model
    if endpoint_ids and isinstance(endpoint_ids, list):
        endpoints = []
        for ep_id in endpoint_ids:
            ep = await db.get_by_id("endpoints", ep_id)
            if ep:
                endpoints.append(ep)
    else:
        endpoints = await db.query(table="endpoints", limit=1000)

    if not endpoints:
        return _error_content(
            "No endpoints found in the world model. "
            "Use wm_add_endpoint or openapi_parse to add endpoints first."
        )

    # Build coverage matrix using tracker
    from lib.coverage_tracker import CoverageTracker
    rows = CoverageTracker.build_matrix(
        endpoints=endpoints,
        base_url=base_url,
        vuln_classes=vuln_classes,
    )

    if not rows:
        return _json_content({
            "success": True,
            "created": 0,
            "skipped_existing": 0,
            "total_cells": 0,
            "message": "No coverage cells to create (no applicable vuln classes for given endpoints).",
        })

    # Insert into database
    result = await db.coverage_init_rows(rows)

    return _json_content({
        "success": True,
        "created": result["created"],
        "skipped_existing": result["skipped_existing"],
        "total_cells": result["created"] + result["skipped_existing"],
        "endpoints_covered": len(endpoints),
        "message": (
            f"Coverage matrix initialized: {result['created']} new cells created, "
            f"{result['skipped_existing']} already existed. "
            f"Covering {len(endpoints)} endpoints."
        ),
    })


async def _handle_coverage_next(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle coverage_next - get next untested cells with tool invocation details."""
    vuln_class = arguments.get("vuln_class")
    endpoint_id = arguments.get("endpoint_id")
    limit = arguments.get("limit", 5)

    if not isinstance(limit, int) or limit < 1:
        limit = 5
    limit = min(limit, 50)

    db = await _get_db(mcp_service)
    cells = await db.coverage_next(
        vuln_class=vuln_class,
        endpoint_id=endpoint_id,
        limit=limit,
    )

    # Enrich with tool_call from coverage tracker
    from lib.coverage_tracker import CoverageTracker

    enriched = []
    for cell in cells:
        ep = cell.get("endpoint", {})
        tool_args = cell.get("tool_args", {})

        enriched.append({
            "cell_id": cell["id"],
            "endpoint_id": cell["endpoint_id"],
            "endpoint": ep,
            "vuln_class": cell["vuln_class"],
            "priority": cell["priority"],
            "tool_call": {
                "tool_name": cell.get("tool_name", ""),
                "arguments": tool_args,
            },
        })

    return _json_content({
        "success": True,
        "count": len(enriched),
        "cells": enriched,
        "message": (
            f"{len(enriched)} pending test(s) returned."
            if enriched else "No pending tests. Coverage may be complete."
        ),
    })


async def _handle_coverage_mark(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle coverage_mark - record test result for a coverage cell."""
    cell_id = arguments.get("cell_id")
    if not cell_id or not isinstance(cell_id, str):
        return _error_content("cell_id is required and must be a string")

    status = arguments.get("status")
    if not status or status not in ("passed", "vulnerable", "skipped", "error"):
        return _error_content("status is required and must be one of: passed, vulnerable, skipped, error")

    finding_id = arguments.get("finding_id")
    result_summary = arguments.get("result_summary")

    db = await _get_db(mcp_service)
    cell = await db.coverage_mark(
        cell_id=cell_id,
        status=status,
        finding_id=finding_id,
        result_summary=result_summary,
    )

    # Auto-create graph relationships on vulnerable status
    if status == "vulnerable" and finding_id:
        try:
            await db.add_relationship(
                source_type="endpoint",
                source_id=cell["endpoint_id"],
                target_type="finding",
                target_id=finding_id,
                rel_type="has_finding",
            )
        except Exception as rel_exc:
            logger.warning("Auto-relationship (has_finding) failed: %s", rel_exc)

    return _json_content({
        "success": True,
        "cell": cell,
        "message": f"Coverage cell {cell_id} marked as '{status}'.",
    })


async def _handle_coverage_report(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle coverage_report - get coverage statistics and structured queries."""
    endpoint_id = arguments.get("endpoint_id")
    vuln_class = arguments.get("vuln_class")
    query_type = arguments.get("query")

    db = await _get_db(mcp_service)

    # If a structured query is requested, run it
    if query_type:
        results = await db.coverage_query(
            query_type=query_type,
            filters={"endpoint_id": endpoint_id} if endpoint_id else {},
        )
        return _json_content({
            "success": True,
            "query": query_type,
            "count": len(results),
            "results": results,
        })

    # Otherwise return aggregate report
    report = await db.coverage_report(
        endpoint_id=endpoint_id,
        vuln_class=vuln_class,
    )

    return _json_content({
        "success": True,
        **report,
        "message": (
            f"Coverage: {report['coverage_pct']}% complete "
            f"({report['total_cells']} total cells, "
            f"{len(report['gaps'])} gaps remaining)."
        ),
    })


async def _handle_coverage_discover(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle coverage_discover - detect new endpoints and extend coverage matrix."""
    base_url = arguments.get("base_url")
    if not base_url or not isinstance(base_url, str):
        return _error_content("base_url is required and must be a string")

    since = arguments.get("since")
    if not since or not isinstance(since, str):
        return _error_content("since is required (ISO datetime string)")

    auto_extend = arguments.get("auto_extend", True)
    vuln_classes = arguments.get("vuln_classes")

    db = await _get_db(mcp_service)

    from lib.discovery_monitor import DiscoveryMonitor

    monitor = DiscoveryMonitor(db)

    # Check for new endpoints
    events = await monitor.check_new_endpoints(since)

    result = {
        "new_endpoints": len(events),
        "by_priority": {
            "high": len([e for e in events if e.priority == "high"]),
            "medium": len([e for e in events if e.priority == "medium"]),
            "low": len([e for e in events if e.priority == "low"]),
        },
        "endpoints": [
            {
                "endpoint_id": e.endpoint_id,
                "method": e.method,
                "path": e.path,
                "source": e.source,
                "priority": e.priority,
            }
            for e in events
        ],
    }

    # Auto-extend coverage matrix
    if auto_extend and events:
        extend_result = await monitor.extend_coverage(events, base_url, vuln_classes)
        result["coverage_extension"] = extend_result

    # Get updated metrics
    try:
        metrics = await monitor.update_phase_metrics()
        result["phase_metrics"] = metrics
    except Exception as exc:
        logger.debug("Phase metrics update skipped: %s", exc)

    # Generate recommendations
    summary = await monitor.get_discovery_summary(since)
    result["recommendations"] = summary.get("recommendations", [])

    return _json_content({
        "success": True,
        **result,
        "message": (
            f"Discovery check: {len(events)} new endpoint(s) found since {since}."
            + (
                f" Coverage extended with {result.get('coverage_extension', {}).get('new_cells_created', 0)} new cells."
                if auto_extend and events else ""
            )
        ),
    })


async def _handle_coverage_refresh(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle coverage_refresh - incrementally rebuild coverage matrix."""
    base_url = arguments.get("base_url")
    if not base_url or not isinstance(base_url, str):
        return _error_content("base_url is required and must be a string")

    vuln_classes = arguments.get("vuln_classes")

    db = await _get_db(mcp_service)

    # Get all endpoints from world model
    endpoints = await db.query(table="endpoints", limit=1000)

    if not endpoints:
        return _json_content({
            "success": True,
            "created": 0,
            "skipped_existing": 0,
            "total_endpoints": 0,
            "message": "No endpoints in world model.",
        })

    # Get existing coverage report to show before/after
    try:
        report_before = await db.coverage_report()
        cells_before = report_before.get("total_cells", 0)
    except Exception:
        cells_before = 0

    # Build matrix for all endpoints (idempotent - ON CONFLICT DO NOTHING)
    from lib.coverage_tracker import CoverageTracker
    rows = CoverageTracker.build_matrix(
        endpoints=endpoints,
        base_url=base_url,
        vuln_classes=vuln_classes,
    )

    if not rows:
        return _json_content({
            "success": True,
            "created": 0,
            "skipped_existing": cells_before,
            "total_endpoints": len(endpoints),
            "message": "No new coverage cells needed.",
        })

    result = await db.coverage_init_rows(rows)

    return _json_content({
        "success": True,
        "created": result["created"],
        "skipped_existing": result["skipped_existing"],
        "total_endpoints": len(endpoints),
        "cells_before": cells_before,
        "cells_after": cells_before + result["created"],
        "message": (
            f"Coverage refreshed: {result['created']} new cells added, "
            f"{result['skipped_existing']} already existed. "
            f"Total: {cells_before + result['created']} cells "
            f"covering {len(endpoints)} endpoints."
        ),
    })
