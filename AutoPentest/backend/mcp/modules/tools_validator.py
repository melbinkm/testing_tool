"""
Validator Tools - validate_repro, validate_negative_control,
                  validate_cross_identity, validate_promote

Ported from validator-mcp TypeScript server to Python.
Provides finding validation with reproduction, negative controls,
cross-identity verification, and confidence scoring.
"""
from __future__ import annotations

import json
import os
from typing import Any, Dict, List, Optional

from mcp.types import Tool, TextContent


# ---------------------------------------------------------------------------
# Lazy-initialized singletons
# ---------------------------------------------------------------------------

_repro_runner = None
_control_runner = None
_confidence_scorer = None

# Configuration from environment variables
REPRO_COUNT = int(os.environ.get("REPRO_COUNT", "3"))
REQUIRE_NEGATIVE_CONTROL = os.environ.get("REQUIRE_NEGATIVE_CONTROL", "true").lower() != "false"

VALID_CONTROL_TYPES = ["unauthenticated", "invalid_token", "different_user", "modified_request"]


def _get_repro_runner():
    """Lazily initialize and return the ReproRunner singleton."""
    global _repro_runner
    if _repro_runner is None:
        from lib.repro_runner import ReproRunner
        _repro_runner = ReproRunner(REPRO_COUNT)
    return _repro_runner


def _get_control_runner():
    """Lazily initialize and return the ControlRunner singleton."""
    global _control_runner
    if _control_runner is None:
        from lib.control_runner import ControlRunner
        _control_runner = ControlRunner()
    return _control_runner


def _get_confidence_scorer():
    """Lazily initialize and return the ConfidenceScorer singleton."""
    global _confidence_scorer
    if _confidence_scorer is None:
        from lib.confidence_scorer import ConfidenceScorer
        _confidence_scorer = ConfidenceScorer()
    return _confidence_scorer


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_validator_tools() -> List[Tool]:
    """Get validator tool definitions."""
    return [
        Tool(
            name="validate_repro",
            description="Reproduce a finding N times to confirm it is consistent and reproducible",
            inputSchema={
                "type": "object",
                "properties": {
                    "finding": {
                        "type": "object",
                        "description": "The finding to reproduce",
                        "properties": {
                            "finding_id": {
                                "type": "string",
                                "description": "Unique identifier for the finding"
                            },
                            "title": {
                                "type": "string",
                                "description": "Finding title"
                            },
                            "request": {
                                "type": "object",
                                "description": "HTTP request configuration",
                                "properties": {
                                    "method": {
                                        "type": "string",
                                        "description": "HTTP method"
                                    },
                                    "url": {
                                        "type": "string",
                                        "description": "Request URL"
                                    },
                                    "headers": {
                                        "type": "object",
                                        "description": "Request headers (optional)"
                                    },
                                    "body": {
                                        "type": "string",
                                        "description": "Request body (optional)"
                                    }
                                },
                                "required": ["method", "url"]
                            },
                            "expected": {
                                "type": "object",
                                "description": "Expected response characteristics (optional)",
                                "properties": {
                                    "status_code": {
                                        "type": "number",
                                        "description": "Expected status code"
                                    },
                                    "body_contains": {
                                        "type": "array",
                                        "items": {"type": "string"},
                                        "description": "Patterns body should contain"
                                    },
                                    "body_not_contains": {
                                        "type": "array",
                                        "items": {"type": "string"},
                                        "description": "Patterns body should not contain"
                                    },
                                    "body_regex": {
                                        "type": "string",
                                        "description": "Regex pattern to match"
                                    }
                                }
                            }
                        },
                        "required": ["finding_id", "title", "request"]
                    },
                    "count": {
                        "type": "number",
                        "description": f"Number of reproduction attempts (default: {REPRO_COUNT})"
                    }
                },
                "required": ["finding"]
            }
        ),
        Tool(
            name="validate_negative_control",
            description="Run a negative control test to verify the vulnerability does not exist in control scenarios",
            inputSchema={
                "type": "object",
                "properties": {
                    "finding": {
                        "type": "object",
                        "description": "The finding to test",
                        "properties": {
                            "finding_id": {"type": "string"},
                            "title": {"type": "string"},
                            "request": {
                                "type": "object",
                                "properties": {
                                    "method": {"type": "string"},
                                    "url": {"type": "string"},
                                    "headers": {"type": "object"},
                                    "body": {"type": "string"}
                                },
                                "required": ["method", "url"]
                            }
                        },
                        "required": ["finding_id", "title", "request"]
                    },
                    "control_config": {
                        "type": "object",
                        "description": "Negative control configuration",
                        "properties": {
                            "control_type": {
                                "type": "string",
                                "enum": VALID_CONTROL_TYPES,
                                "description": "Type of negative control to run"
                            },
                            "modified_headers": {
                                "type": "object",
                                "description": "Headers to use instead (optional)"
                            },
                            "modified_body": {
                                "type": "string",
                                "description": "Body to use instead (optional)"
                            },
                            "remove_auth": {
                                "type": "boolean",
                                "description": "Whether to remove auth headers"
                            },
                            "expected_status": {
                                "type": "number",
                                "description": "Expected status code (optional)"
                            }
                        },
                        "required": ["control_type"]
                    }
                },
                "required": ["finding", "control_config"]
            }
        ),
        Tool(
            name="validate_cross_identity",
            description="Test a finding with multiple identities to verify authorization is enforced",
            inputSchema={
                "type": "object",
                "properties": {
                    "finding": {
                        "type": "object",
                        "description": "The finding to test",
                        "properties": {
                            "finding_id": {"type": "string"},
                            "title": {"type": "string"},
                            "request": {
                                "type": "object",
                                "properties": {
                                    "method": {"type": "string"},
                                    "url": {"type": "string"},
                                    "headers": {"type": "object"},
                                    "body": {"type": "string"}
                                },
                                "required": ["method", "url"]
                            }
                        },
                        "required": ["finding_id", "title", "request"]
                    },
                    "identities": {
                        "type": "array",
                        "description": "Array of identities to test",
                        "items": {
                            "type": "object",
                            "properties": {
                                "identity_id": {
                                    "type": "string",
                                    "description": "Identity identifier"
                                },
                                "auth_header": {
                                    "type": "string",
                                    "description": "Authentication header value"
                                },
                                "auth_type": {
                                    "type": "string",
                                    "enum": ["bearer", "basic", "api_key", "cookie"],
                                    "description": "Type of authentication"
                                },
                                "cookies": {
                                    "type": "object",
                                    "description": "Cookies for cookie auth type"
                                },
                                "should_have_access": {
                                    "type": "boolean",
                                    "description": "Whether this identity should have access"
                                }
                            },
                            "required": ["identity_id", "should_have_access"]
                        }
                    }
                },
                "required": ["finding", "identities"]
            }
        ),
        Tool(
            name="validate_promote",
            description="Calculate confidence score and determine if finding should be promoted to confirmed",
            inputSchema={
                "type": "object",
                "properties": {
                    "finding_id": {
                        "type": "string",
                        "description": "The finding ID to evaluate"
                    },
                    "repro_result": {
                        "type": "object",
                        "description": "Result from validate_repro (optional)"
                    },
                    "negative_control_result": {
                        "type": "object",
                        "description": "Result from validate_negative_control (optional)"
                    },
                    "cross_identity_result": {
                        "type": "object",
                        "description": "Result from validate_cross_identity (optional)"
                    }
                },
                "required": ["finding_id"]
            }
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler routing
# ---------------------------------------------------------------------------

async def handle_validator_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route validator tool calls to the appropriate handler."""
    if name == "validate_repro":
        return await _handle_validate_repro(arguments, mcp_service)
    elif name == "validate_negative_control":
        return await _handle_validate_negative_control(arguments, mcp_service)
    elif name == "validate_cross_identity":
        return await _handle_validate_cross_identity(arguments, mcp_service)
    elif name == "validate_promote":
        return _handle_validate_promote(arguments, mcp_service)
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": f"Unknown validator tool: {name}"
    }))]


# ---------------------------------------------------------------------------
# Error helper
# ---------------------------------------------------------------------------

def _error_response(error_msg: str) -> List[TextContent]:
    """Return a standardized error response as JSON."""
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": error_msg
    }))]


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_validate_repro(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle validate_repro - Reproduce a finding N times."""
    finding = arguments.get("finding")
    if not finding:
        return _error_response("finding is required")

    # Validate finding structure
    if not finding.get("finding_id") or not finding.get("title") or not finding.get("request"):
        return _error_response("finding must have finding_id, title, and request")

    request = finding.get("request", {})
    if not request.get("method") or not request.get("url"):
        return _error_response("finding.request must have method and url")

    count: Optional[int] = arguments.get("count")

    try:
        repro_runner = _get_repro_runner()
        result = await repro_runner.run_repro(finding, count)

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "result": result,
        }, indent=2))]

    except Exception as exc:
        return _error_response(f"Reproduction failed: {exc}")


async def _handle_validate_negative_control(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle validate_negative_control - Run a negative control test."""
    finding = arguments.get("finding")
    control_config = arguments.get("control_config")

    if not finding or not control_config:
        return _error_response("finding and control_config are required")

    # Validate finding structure
    request = finding.get("request", {})
    if not finding.get("finding_id") or not request.get("method") or not request.get("url"):
        return _error_response("finding must have finding_id and request with method and url")

    # Validate control config
    control_type = control_config.get("control_type", "")
    if control_type not in VALID_CONTROL_TYPES:
        return _error_response(
            f"Invalid control_type. Must be one of: {', '.join(VALID_CONTROL_TYPES)}"
        )

    try:
        control_runner = _get_control_runner()
        result = await control_runner.run_negative_control(finding, control_config)

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "result": result,
        }, indent=2))]

    except Exception as exc:
        return _error_response(f"Negative control test failed: {exc}")


async def _handle_validate_cross_identity(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle validate_cross_identity - Test with multiple identities."""
    finding = arguments.get("finding")
    identities = arguments.get("identities")

    if not finding or not identities:
        return _error_response("finding and identities are required")

    # Validate finding structure
    request = finding.get("request", {})
    if not finding.get("finding_id") or not request.get("method") or not request.get("url"):
        return _error_response("finding must have finding_id and request with method and url")

    # Validate identities
    if not isinstance(identities, list) or len(identities) == 0:
        return _error_response("identities must be a non-empty array")

    for identity in identities:
        if not identity.get("identity_id") or identity.get("should_have_access") is None:
            return _error_response(
                "Each identity must have identity_id and should_have_access"
            )

    try:
        control_runner = _get_control_runner()
        result = await control_runner.run_cross_identity(finding, identities)

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "result": result,
        }, indent=2))]

    except Exception as exc:
        return _error_response(f"Cross-identity test failed: {exc}")


def _handle_validate_promote(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle validate_promote - Calculate confidence score and recommendation."""
    finding_id = arguments.get("finding_id")
    if not finding_id:
        return _error_response("finding_id is required")

    inputs: Dict[str, Any] = {
        "finding_id": finding_id,
        "repro_result": arguments.get("repro_result"),
        "negative_control_result": arguments.get("negative_control_result"),
        "cross_identity_result": arguments.get("cross_identity_result"),
    }

    # Check if at least one validation result is provided
    if (
        inputs["repro_result"] is None
        and inputs["negative_control_result"] is None
        and inputs["cross_identity_result"] is None
    ):
        return _error_response(
            "At least one validation result (repro_result, negative_control_result, "
            "or cross_identity_result) is required"
        )

    # Check if negative control is required but not provided
    if REQUIRE_NEGATIVE_CONTROL and inputs["negative_control_result"] is None:
        return [TextContent(type="text", text=json.dumps({
            "success": False,
            "error": "negative_control_result is required (REQUIRE_NEGATIVE_CONTROL is enabled)",
            "hint": "Run validate_negative_control first, or set REQUIRE_NEGATIVE_CONTROL=false",
        }))]

    try:
        scorer = _get_confidence_scorer()
        confidence = scorer.calculate_confidence(inputs)

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "confidence": confidence,
            "promoted": confidence["recommendation"] == "promote",
        }, indent=2))]

    except Exception as exc:
        return _error_response(f"Confidence scoring failed: {exc}")
