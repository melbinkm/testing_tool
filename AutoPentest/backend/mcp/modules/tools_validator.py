"""
Validator Tools - validate_repro, validate_negative_control,
                  validate_cross_identity, validate_promote

Ported from validator-mcp TypeScript server to Python.
Provides finding validation with reproduction, negative controls,
cross-identity verification, and confidence scoring.
"""
from __future__ import annotations

import json
import os
from typing import Any, Dict, List, Optional

from mcp.types import Tool, TextContent


# ---------------------------------------------------------------------------
# Lazy-initialized singletons with per-assessment cache invalidation
# ---------------------------------------------------------------------------

_repro_runner = None
_repro_runner_key = None
_control_runner = None
_control_runner_key = None
_confidence_scorer = None

# Configuration from environment variables
REPRO_COUNT = int(os.environ.get("REPRO_COUNT", "3"))
REQUIRE_NEGATIVE_CONTROL = os.environ.get("REQUIRE_NEGATIVE_CONTROL", "true").lower() != "false"

VALID_CONTROL_TYPES = ["unauthenticated", "invalid_token", "different_user", "modified_request"]


def _get_repro_runner(mcp_service=None):
    """Lazily initialize and return the ReproRunner singleton with audited HTTP client."""
    global _repro_runner, _repro_runner_key
    cache_key = getattr(mcp_service, "current_assessment_id", None)
    if _repro_runner is None or _repro_runner_key != cache_key:
        from lib.repro_runner import ReproRunner
        from lib.http_client_factory import create_audit_http_client
        http_client = create_audit_http_client(mcp_service) if mcp_service else None
        _repro_runner = ReproRunner(REPRO_COUNT, http_client=http_client)
        _repro_runner_key = cache_key
    return _repro_runner


def _get_control_runner(mcp_service=None):
    """Lazily initialize and return the ControlRunner singleton with audited HTTP client."""
    global _control_runner, _control_runner_key
    cache_key = getattr(mcp_service, "current_assessment_id", None)
    if _control_runner is None or _control_runner_key != cache_key:
        from lib.control_runner import ControlRunner
        from lib.http_client_factory import create_audit_http_client
        http_client = create_audit_http_client(mcp_service) if mcp_service else None
        _control_runner = ControlRunner(http_client=http_client)
        _control_runner_key = cache_key
    return _control_runner


def _get_confidence_scorer():
    """Lazily initialize and return the ConfidenceScorer singleton."""
    global _confidence_scorer
    if _confidence_scorer is None:
        from lib.confidence_scorer import ConfidenceScorer
        _confidence_scorer = ConfidenceScorer()
    return _confidence_scorer


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_validator_tools() -> List[Tool]:
    """Get validator tool definitions."""
    return [
        Tool(
            name="validate_repro",
            description=(
                "Reproduce a finding N times (default 3) to confirm it is consistent and reproducible. "
                "Executes the same HTTP request multiple times and verifies the response matches expected "
                "characteristics (status code, body patterns, regex matches). Essential for ruling out "
                "false positives and timing-dependent behaviors. "

                "**When to use:** Phase 4 (Exploitation) after discovering a potential vulnerability. "
                "Call this immediately after detecting suspicious behavior (error messages, SQL errors, "
                "XXE responses, auth bypasses) to confirm it's reproducible. Required before creating "
                "confirmed findings or evidence bundles. "

                "**Dependencies:** Requires add_card(type='finding') to have been called first to create "
                "the finding record. Follow with validate_negative_control() to rule out false positives, "
                "then validate_promote() to calculate confidence and promote to confirmed status. "

                "**Budget impact:** LOW - default 3 requests per validation (configurable via count parameter). "
                "Each reproduction attempt = 1 HTTP request. Completes in <5 seconds for fast endpoints. "

                "**Failure modes:** 'Not reproducible' (0% or <67% success rate) indicates timing-dependent "
                "behavior, rate limiting, or false positive - try increasing count to 5-10 attempts. "
                "WAF/IPS may block subsequent requests (first succeeds, rest fail) - indicates detection. "
                "Network timeouts usually mean endpoint is overloaded or DDoS protection triggered. "
                "If consistently fails, downgrade finding to 'observation' not 'vulnerability'. "

                "**Risk level:** CAUTION - Sends the same potentially malicious payload multiple times. "
                "May trigger rate limiting, account lockouts, or IDS alerts if payload is aggressive. "
                "Less risky than initial discovery since you're repeating a known payload. "

                "**Returns:** Validation result with success rate percentage, consistency analysis, timing "
                "statistics, and recommendation (reproducible/not_reproducible). Use success_rate >= 67% "
                "as threshold for reproducibility. Automatically includes all request/response pairs for "
                "evidence collection."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "finding": {
                        "type": "object",
                        "description": "The finding to reproduce",
                        "properties": {
                            "finding_id": {
                                "type": "string",
                                "description": "Unique identifier for the finding"
                            },
                            "title": {
                                "type": "string",
                                "description": "Finding title"
                            },
                            "request": {
                                "type": "object",
                                "description": "HTTP request configuration",
                                "properties": {
                                    "method": {
                                        "type": "string",
                                        "description": "HTTP method"
                                    },
                                    "url": {
                                        "type": "string",
                                        "description": "Request URL"
                                    },
                                    "headers": {
                                        "type": "object",
                                        "description": "Request headers (optional)"
                                    },
                                    "body": {
                                        "type": ["string", "null"],
                                        "description": "Request body (optional, null for GET requests)"
                                    }
                                },
                                "required": ["method", "url"]
                            },
                            "expected": {
                                "type": "object",
                                "description": "Expected response characteristics (optional)",
                                "properties": {
                                    "status_code": {
                                        "type": "number",
                                        "description": "Expected status code"
                                    },
                                    "body_contains": {
                                        "type": "array",
                                        "items": {"type": "string"},
                                        "description": "Patterns body should contain"
                                    },
                                    "body_not_contains": {
                                        "type": "array",
                                        "items": {"type": "string"},
                                        "description": "Patterns body should not contain"
                                    },
                                    "body_regex": {
                                        "type": "string",
                                        "description": "Regex pattern to match"
                                    }
                                }
                            }
                        },
                        "required": ["finding_id", "title", "request"]
                    },
                    "count": {
                        "type": "number",
                        "description": f"Number of reproduction attempts (default: {REPRO_COUNT})"
                    }
                },
                "required": ["finding"]
            }
        ),
        Tool(
            name="validate_negative_control",
            description=(
                "Run a negative control test to verify the vulnerability does not exist in control "
                "scenarios. Tests that the finding is truly a vulnerability and not a false positive by "
                "sending modified requests that should NOT trigger the vulnerability (e.g., removing auth, "
                "using benign input, testing with different user). Critical for ruling out false positives "
                "from error-based and blind detection techniques. "

                "**When to use:** Phase 4 (Exploitation) immediately after validate_repro() confirms "
                "reproducibility. Essential for SQLi, XSS, XXE, SSRF, and injection vulnerabilities where "
                "error messages can be misleading. Use before validate_promote() to strengthen confidence. "

                "**Dependencies:** Requires validate_repro() to have been called first with passing result. "
                "For auth-related findings, use validate_cross_identity() in addition to this. Follow with "
                "validate_promote() which uses this result in confidence scoring. "

                "**Budget impact:** LOW - 1-2 requests per control test. control_type determines request count: "
                "unauthenticated/invalid_token/different_user = 1 request, modified_request = 1 request per variation. "

                "**Failure modes:** 'Control also vulnerable' (negative control triggered vulnerability) indicates "
                "false positive - the detection technique is too broad. 'Cannot reach control state' means auth "
                "removal or modification failed - use different control_type. 'Unexpected control response' means "
                "control behaved differently than baseline - verify expected_status is correct. If control test "
                "fails but reproduction succeeds, finding is still valid but may need different control approach. "

                "**Risk level:** CAUTION - Sends modified benign payloads. Less risky than initial testing since "
                "control requests use safe inputs. May trigger auth failures or access denials (expected behavior). "

                "**Returns:** Control test result with pass/fail status, control response details, and analysis. "
                "'passed' = control did NOT trigger vulnerability (good, confirms true positive). 'failed' = "
                "control also triggered vulnerability (bad, indicates false positive). Includes comparison with "
                "original finding response for differential analysis."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "finding": {
                        "type": "object",
                        "description": "The finding to test",
                        "properties": {
                            "finding_id": {"type": "string"},
                            "title": {"type": "string"},
                            "request": {
                                "type": "object",
                                "properties": {
                                    "method": {"type": "string"},
                                    "url": {"type": "string"},
                                    "headers": {"type": "object"},
                                    "body": {"type": "string"}
                                },
                                "required": ["method", "url"]
                            }
                        },
                        "required": ["finding_id", "title", "request"]
                    },
                    "control_config": {
                        "type": "object",
                        "description": "Negative control configuration",
                        "properties": {
                            "control_type": {
                                "type": "string",
                                "enum": VALID_CONTROL_TYPES,
                                "description": "Type of negative control to run"
                            },
                            "modified_headers": {
                                "type": "object",
                                "description": "Headers to use instead (optional)"
                            },
                            "modified_body": {
                                "type": ["string", "null"],
                                "description": "Body to use instead (optional, null for GET requests)"
                            },
                            "remove_auth": {
                                "type": "boolean",
                                "description": "Whether to remove auth headers"
                            },
                            "expected_status": {
                                "type": "number",
                                "description": "Expected status code (optional)"
                            }
                        },
                        "required": ["control_type"]
                    }
                },
                "required": ["finding", "control_config"]
            }
        ),
        Tool(
            name="validate_cross_identity",
            description=(
                "Test a finding with multiple identities to verify authorization is properly enforced. "
                "Replays the same request using different user credentials to detect IDOR (Insecure Direct "
                "Object Reference), privilege escalation, and horizontal/vertical authorization bypass "
                "vulnerabilities. Compares responses across identities to identify access control failures. "

                "**When to use:** Phase 4 (Exploitation) for authorization-related findings (IDOR, privilege "
                "escalation, missing access controls). Use after validate_repro() for findings that access "
                "user-specific resources (e.g., /api/users/{id}, /orders/{id}, /profile). Essential for "
                "any finding where authorization should restrict access but doesn't. "

                "**Dependencies:** Requires auth_get_identities() or credentials_add() to have loaded test "
                "identities first. Requires validate_repro() to confirm base finding. Use alongside "
                "validate_negative_control() (unauthenticated case) for comprehensive authz testing. Follow "
                "with validate_promote() which uses this result in confidence scoring. "

                "**Budget impact:** MEDIUM - N requests where N = number of identities tested. Typical: 2-5 "
                "identities (admin, user1, user2, unauthenticated, expired_token) = 2-5 requests. For IDOR "
                "enumeration, use sequence_data_ownership() instead which is optimized for bulk testing. "

                "**Failure modes:** 'All identities have access' indicates the endpoint is public or finding is "
                "false positive. 'No identities have access' means request format is broken or endpoint was fixed. "
                "'Inconsistent responses' means authorization is unstable - retry with fresh credentials. "
                "'Authentication expired' requires re-running auth flow to get fresh tokens. If some identities "
                "fail unexpectedly, check should_have_access flags are correct. "

                "**Risk level:** HIGH RISK - Actively tests authorization bypass with real user credentials. "
                "May access other users' data if IDOR exists. Highly detectable in access logs (multiple users "
                "accessing same resource rapidly). May trigger anomaly detection or account monitoring alerts. "
                "Only use with explicit authorization to test with multiple accounts. "

                "**Returns:** Cross-identity test result with per-identity response comparison, access control "
                "analysis, and violation summary. Shows which identities could access resource when they "
                "shouldn't (authz failures) and which were correctly denied. Includes response diffs for "
                "identifying data leakage patterns."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "finding": {
                        "type": "object",
                        "description": "The finding to test",
                        "properties": {
                            "finding_id": {"type": "string"},
                            "title": {"type": "string"},
                            "request": {
                                "type": "object",
                                "properties": {
                                    "method": {"type": "string"},
                                    "url": {"type": "string"},
                                    "headers": {"type": "object"},
                                    "body": {"type": "string"}
                                },
                                "required": ["method", "url"]
                            }
                        },
                        "required": ["finding_id", "title", "request"]
                    },
                    "identities": {
                        "type": "array",
                        "description": "Array of identities to test",
                        "items": {
                            "type": "object",
                            "properties": {
                                "identity_id": {
                                    "type": "string",
                                    "description": "Identity identifier"
                                },
                                "auth_header": {
                                    "type": "string",
                                    "description": "Authentication header value"
                                },
                                "auth_type": {
                                    "type": "string",
                                    "enum": ["bearer", "basic", "api_key", "cookie"],
                                    "description": "Type of authentication"
                                },
                                "cookies": {
                                    "type": "object",
                                    "description": "Cookies for cookie auth type"
                                },
                                "should_have_access": {
                                    "type": "boolean",
                                    "description": "Whether this identity should have access"
                                }
                            },
                            "required": ["identity_id", "should_have_access"]
                        }
                    }
                },
                "required": ["finding", "identities"]
            }
        ),
        Tool(
            name="validate_promote",
            description=(
                "Calculate confidence score (0.0-1.0) and determine if finding should be promoted from "
                "'potential' to 'confirmed' status. Analyzes results from validate_repro(), validate_negative_control(), "
                "and validate_cross_identity() to compute weighted confidence score using scoring algorithm. "
                "Recommendation: promote if confidence >= 0.70, manual_review if 0.50-0.70, reject if < 0.50. "

                "**When to use:** Phase 4 (Exploitation) after completing validation workflow. Call this as the "
                "final step after running validate_repro() (required) and optionally validate_negative_control() "
                "and validate_cross_identity(). Use before creating evidence_bundle() and poc_generate() to "
                "ensure you're documenting confirmed vulnerabilities, not false positives. "

                "**Dependencies:** Requires at least ONE validation result: validate_repro() (most important), "
                "validate_negative_control() (required if REQUIRE_NEGATIVE_CONTROL=true), or validate_cross_identity() "
                "(for authz findings). Follow with update_card() to set status='confirmed' if promoted=true, "
                "then evidence_bundle() and poc_generate() for documentation. "

                "**Budget impact:** LOW - local computation only, no HTTP requests. Analyzes existing validation "
                "results to calculate confidence. Completes instantly (<100ms). "

                "**Failure modes:** 'No validation results' error if you haven't run any validation tools first - "
                "run validate_repro() at minimum. 'Negative control required' error if REQUIRE_NEGATIVE_CONTROL=true "
                "but negative_control_result not provided - run validate_negative_control() or set env var to false. "
                "Low confidence score (<0.70) indicates weak validation - add more validation tests or downgrade "
                "to observation. "

                "**Risk level:** SAFE - Read-only analysis of validation results, no network requests or target "
                "interaction. Pure computation to assist decision-making. "

                "**Returns:** Confidence score object with overall confidence (0.0-1.0), breakdown by validation "
                "type (repro_confidence, control_confidence, identity_confidence), recommendation ('promote', "
                "'manual_review', 'reject'), and detailed reasoning. Use promoted=true field to decide whether to "
                "create confirmed finding card and proceed with evidence collection. Confidence >= 0.90 = high "
                "confidence, 0.70-0.89 = medium, 0.50-0.69 = low, <0.50 = very low (likely false positive)."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "finding_id": {
                        "type": "string",
                        "description": "The finding ID to evaluate"
                    },
                    "repro_result": {
                        "type": "object",
                        "description": "Result from validate_repro (optional)"
                    },
                    "negative_control_result": {
                        "type": "object",
                        "description": "Result from validate_negative_control (optional)"
                    },
                    "cross_identity_result": {
                        "type": "object",
                        "description": "Result from validate_cross_identity (optional)"
                    }
                },
                "required": ["finding_id"]
            }
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler routing
# ---------------------------------------------------------------------------

async def handle_validator_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route validator tool calls to the appropriate handler."""
    if name == "validate_repro":
        return await _handle_validate_repro(arguments, mcp_service)
    elif name == "validate_negative_control":
        return await _handle_validate_negative_control(arguments, mcp_service)
    elif name == "validate_cross_identity":
        return await _handle_validate_cross_identity(arguments, mcp_service)
    elif name == "validate_promote":
        return _handle_validate_promote(arguments, mcp_service)
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": f"Unknown validator tool: {name}"
    }))]


# ---------------------------------------------------------------------------
# Error helper
# ---------------------------------------------------------------------------

def _error_response(error_msg: str) -> List[TextContent]:
    """Return a standardized error response as JSON."""
    return [TextContent(type="text", text=json.dumps({
        "success": False,
        "error": error_msg
    }))]


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_validate_repro(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle validate_repro - Reproduce a finding N times."""
    finding = arguments.get("finding")
    if not finding:
        return _error_response("finding is required")

    # Validate finding structure
    if not finding.get("finding_id") or not finding.get("title") or not finding.get("request"):
        return _error_response("finding must have finding_id, title, and request")

    request = finding.get("request", {})
    if not request.get("method") or not request.get("url"):
        return _error_response("finding.request must have method and url")

    count: Optional[int] = arguments.get("count")

    try:
        repro_runner = _get_repro_runner(mcp_service)
        result = await repro_runner.run_repro(finding, count)

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "result": result,
        }, indent=2))]

    except Exception as exc:
        return _error_response(f"Reproduction failed: {exc}")


async def _handle_validate_negative_control(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle validate_negative_control - Run a negative control test."""
    finding = arguments.get("finding")
    control_config = arguments.get("control_config")

    if not finding or not control_config:
        return _error_response("finding and control_config are required")

    # Validate finding structure
    request = finding.get("request", {})
    if not finding.get("finding_id") or not request.get("method") or not request.get("url"):
        return _error_response("finding must have finding_id and request with method and url")

    # Validate control config
    control_type = control_config.get("control_type", "")
    if control_type not in VALID_CONTROL_TYPES:
        return _error_response(
            f"Invalid control_type. Must be one of: {', '.join(VALID_CONTROL_TYPES)}"
        )

    try:
        control_runner = _get_control_runner(mcp_service)
        result = await control_runner.run_negative_control(finding, control_config)

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "result": result,
        }, indent=2))]

    except Exception as exc:
        return _error_response(f"Negative control test failed: {exc}")


async def _handle_validate_cross_identity(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle validate_cross_identity - Test with multiple identities."""
    finding = arguments.get("finding")
    identities = arguments.get("identities")

    if not finding or not identities:
        return _error_response("finding and identities are required")

    # Validate finding structure
    request = finding.get("request", {})
    if not finding.get("finding_id") or not request.get("method") or not request.get("url"):
        return _error_response("finding must have finding_id and request with method and url")

    # Validate identities
    if not isinstance(identities, list) or len(identities) == 0:
        return _error_response("identities must be a non-empty array")

    for identity in identities:
        if not identity.get("identity_id") or identity.get("should_have_access") is None:
            return _error_response(
                "Each identity must have identity_id and should_have_access"
            )

    try:
        control_runner = _get_control_runner(mcp_service)
        result = await control_runner.run_cross_identity(finding, identities)

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "result": result,
        }, indent=2))]

    except Exception as exc:
        return _error_response(f"Cross-identity test failed: {exc}")


def _handle_validate_promote(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle validate_promote - Calculate confidence score and recommendation."""
    finding_id = arguments.get("finding_id")
    if not finding_id:
        return _error_response("finding_id is required")

    inputs: Dict[str, Any] = {
        "finding_id": finding_id,
        "repro_result": arguments.get("repro_result"),
        "negative_control_result": arguments.get("negative_control_result"),
        "cross_identity_result": arguments.get("cross_identity_result"),
    }

    # Check if at least one validation result is provided
    if (
        inputs["repro_result"] is None
        and inputs["negative_control_result"] is None
        and inputs["cross_identity_result"] is None
    ):
        return _error_response(
            "At least one validation result (repro_result, negative_control_result, "
            "or cross_identity_result) is required"
        )

    # Check if negative control is required but not provided
    if REQUIRE_NEGATIVE_CONTROL and inputs["negative_control_result"] is None:
        return [TextContent(type="text", text=json.dumps({
            "success": False,
            "error": "negative_control_result is required (REQUIRE_NEGATIVE_CONTROL is enabled)",
            "hint": "Run validate_negative_control first, or set REQUIRE_NEGATIVE_CONTROL=false",
        }))]

    try:
        scorer = _get_confidence_scorer()
        confidence = scorer.calculate_confidence(inputs)

        return [TextContent(type="text", text=json.dumps({
            "success": True,
            "confidence": confidence,
            "promoted": confidence["recommendation"] == "promote",
        }, indent=2))]

    except Exception as exc:
        return _error_response(f"Confidence scoring failed: {exc}")
