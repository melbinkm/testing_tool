"""
Reconnaissance Management Tools - add_recon_data, list_recon
"""
from typing import List
from mcp.types import Tool, TextContent


def get_recon_tools() -> List[Tool]:
    """Get reconnaissance management tool definitions"""
    return [
        Tool(
            name="add_recon_data",
            description="Add reconnaissance data (single entry or batch). Provide either (data_type + name) for single entry OR entries array for batch.",
            inputSchema={
                "type": "object",
                "properties": {
                    # Single entry mode
                    "data_type": {
                        "type": "string",
                        "description": "Type discovered (lowercase snake_case). Examples: endpoint, subdomain, service, technology, database, credential, port, vulnerability"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name/value of the discovered data"
                    },
                    "details": {
                        "type": "object",
                        "description": "Additional details (JSON object)"
                    },
                    "discovered_in_phase": {
                        "type": "string",
                        "description": "Phase where this was discovered"
                    },
                    # Batch mode
                    "entries": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "data_type": {
                                    "type": "string",
                                    "description": "Type discovered (lowercase snake_case). Examples: endpoint, subdomain, service, technology, database, credential, port, vulnerability"
                                },
                                "name": {
                                    "type": "string",
                                    "description": "Name/value of the discovered data"
                                },
                                "details": {
                                    "type": "object",
                                    "description": "Additional details (JSON object)"
                                },
                                "discovered_in_phase": {
                                    "type": "string",
                                    "description": "Phase where this was discovered"
                                }
                            },
                            "required": ["data_type", "name"]
                        },
                        "description": "Array of recon data entries to add (batch mode)"
                    }
                }
                # Note: No required fields - validation happens in handler
                # Handler will check: must have either (data_type AND name) OR entries
            }
        ),
        Tool(
            name="list_recon",
            description="List reconnaissance data with optional filters",
            inputSchema={
                "type": "object",
                "properties": {
                    "data_type": {
                        "type": "string",
                        "description": "Filter by data type (optional). Use any category available in the assessment."
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Maximum number of recon items to return",
                        "default": 50
                    }
                },
                "required": []
            }
        ),
    ]


async def handle_recon_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route recon tool calls to the appropriate handler"""
    if name == "add_recon_data":
        return await _handle_add_recon_data(arguments, mcp_service)
    elif name == "list_recon":
        return await _handle_list_recon(arguments, mcp_service)
    return [TextContent(type="text", text=f"Unknown recon tool: {name}")]


async def _handle_add_recon_data(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle add_recon_data - Single or batch mode"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    # Batch mode
    if "entries" in arguments:
        entries = arguments["entries"]
        if not entries:
            return [TextContent(type="text", text="No entries provided.")]

        # API will validate and normalize data_types via Pydantic
        # Batch call to backend
        try:
            response = await mcp_service.http_client.post(
                f"{mcp_service.backend_url}/assessments/{mcp_service.current_assessment_id}/recon/batch",
                json={"entries": entries}
            )
            response.raise_for_status()
            result = response.json()

            # Format summary
            summary_parts = []
            for data_type, count in result.get("summary", {}).items():
                summary_parts.append(f"{count} {data_type}(s)")

            summary_text = ", ".join(summary_parts) if summary_parts else "unknown types"

            return [TextContent(
                type="text",
                text=f"Added {result.get('created_count', len(entries))} recon entries: {summary_text}"
            )]

        except Exception as e:
            return [TextContent(
                type="text",
                text=f"Error adding batch recon data: {str(e)}"
            )]

    # Single mode - capture ID from response
    else:
        result = await mcp_service.add_recon_data(
            assessment_id=mcp_service.current_assessment_id,
            data_type=arguments["data_type"],
            name=arguments["name"],
            details=arguments.get("details"),
            discovered_in_phase=arguments.get("discovered_in_phase")
        )

        recon_id = result.get("id", "unknown")

        return [TextContent(
            type="text",
            text=f"Recon data added: {arguments['data_type']} -> {arguments['name']} [ID: {recon_id}]"
        )]


async def _handle_list_recon(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle list_recon - List recon data with optional filters"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    full_data = await mcp_service.get_assessment_full_data(mcp_service.current_assessment_id)
    recon_data = full_data.get('recon_data', [])

    # Apply data_type filter if provided
    data_type_filter = arguments.get("data_type")
    if data_type_filter:
        recon_data = [r for r in recon_data if r.get('data_type') == data_type_filter]

    limit = arguments.get("limit", 50)
    recon_data = recon_data[:limit]

    if not recon_data:
        return [TextContent(type="text", text="No recon data found.")]

    response = f"**Reconnaissance Data ({len(recon_data)}):**\n\n"
    for recon in recon_data:
        recon_id = recon.get('id', 'N/A')
        data_type = recon.get('data_type', 'UNKNOWN')
        name = recon.get('name', 'Unnamed')
        phase = recon.get('discovered_in_phase', 'N/A')

        response += f"**ID: {recon_id}** | [{data_type}] {name}\n"
        response += f"  - Discovered in: {phase}\n"

        details = recon.get('details')
        if details:
            response += f"  - Details: {details}\n"

        response += "\n"

    return [TextContent(type="text", text=response)]
