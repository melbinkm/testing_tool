"""
Reconnaissance Management Tools - add_recon_data, list_recon
"""
from typing import List
from mcp.types import Tool, TextContent


def get_recon_tools() -> List[Tool]:
    """Get reconnaissance management tool definitions"""
    return [
        Tool(
            name="add_recon_data",
            description=(
                "Add reconnaissance data discovered during assessment. Supports single entry or batch mode for "
                "efficient bulk imports. Records discovered assets (subdomains, IPs, endpoints, services, technologies, "
                "databases, credentials, ports, vulnerabilities) with metadata. Essential for documenting discovery "
                "phase findings and building comprehensive asset inventory. "

                "**When to use:** Phase 1-2 (Recon/Mapping) to record discovered assets. Use single mode for ad-hoc "
                "discoveries, batch mode for bulk imports from tool output (subdomain_enum, scan, crawler results). "
                "Prefer world model tools (wm_add_asset, wm_add_endpoint) for structured relationships, use this for "
                "quick flat-list discoveries. Common after: subdomain_enum (batch subdomains), scan (ports/services), "
                "tech_detection (technologies), crawler_start (endpoints). "

                "**Dependencies:** Requires load_assessment() first. No follow-up required - data stored for reference. "
                "Use list_recon() to query stored data. Alternative to wm_add_* for simpler flat storage without relationships. "

                "**Budget impact:** LOW - local database insert, no network requests. Single entry <10ms, batch 100 "
                "entries <200ms. "

                "**Failure modes:** Invalid data_type causes categorization issues but doesn't block (stored as provided). "
                "Duplicate entries allowed (no deduplication). Empty batch returns error. "

                "**Risk level:** SAFE - local data storage only, no network activity or target interaction. Documentation tool. "

                "**Returns:** Single mode returns recon_id for reference. Batch mode returns created_count and summary by "
                "data_type (N subdomains, M services). Use for building discovery inventory and phase documentation."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    # Single entry mode
                    "data_type": {
                        "type": "string",
                        "description": "Type discovered (lowercase snake_case). Examples: endpoint, subdomain, service, technology, database, credential, port, vulnerability"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name/value of the discovered data"
                    },
                    "details": {
                        "type": "object",
                        "description": "Additional details (JSON object)"
                    },
                    "discovered_in_phase": {
                        "type": "string",
                        "description": "Phase where this was discovered"
                    },
                    # Batch mode
                    "entries": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "data_type": {
                                    "type": "string",
                                    "description": "Type discovered (lowercase snake_case). Examples: endpoint, subdomain, service, technology, database, credential, port, vulnerability"
                                },
                                "name": {
                                    "type": "string",
                                    "description": "Name/value of the discovered data"
                                },
                                "details": {
                                    "type": "object",
                                    "description": "Additional details (JSON object)"
                                },
                                "discovered_in_phase": {
                                    "type": "string",
                                    "description": "Phase where this was discovered"
                                }
                            },
                            "required": ["data_type", "name"]
                        },
                        "description": "Array of recon data entries to add (batch mode)"
                    }
                }
                # Note: No required fields - validation happens in handler
                # Handler will check: must have either (data_type AND name) OR entries
            }
        ),
        Tool(
            name="list_recon",
            description=(
                "List reconnaissance data with optional filtering by data_type and pagination. Retrieves stored "
                "discoveries from add_recon_data() for review, analysis, and reporting. Useful for reviewing what "
                "was discovered during recon phase and planning next testing steps. "

                "**When to use:** Phase 1-2 (Recon/Mapping) after add_recon_data() to review discoveries. Use to: "
                "see all subdomains found, list discovered services/ports, review detected technologies, check "
                "credential/vulnerability findings. Filter by data_type for focused review (e.g., data_type='subdomain'). "
                "Use before scope_validate_target() to verify discoveries are in scope. "

                "**Dependencies:** Requires load_assessment() and prior add_recon_data() calls. Returns empty if no "
                "recon data stored yet. Alternative query method to wm_query(table='assets') for flat-list view. "

                "**Budget impact:** LOW - local database query, no network requests. Returns up to limit (default 50) "
                "entries. Completes <100ms for typical datasets. "

                "**Failure modes:** 'No recon data found' if nothing stored yet (expected early in assessment). Invalid "
                "data_type filter returns empty (silently filters, no error). Large result sets truncated to limit. "

                "**Risk level:** SAFE - read-only query of stored data, no network activity or target interaction. "

                "**Returns:** Formatted list with: ID, data_type, name, discovered_in_phase, details. Use to review "
                "discovery progress, plan scope validation, identify testing targets, generate recon summary reports."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "data_type": {
                        "type": "string",
                        "description": "Filter by data type (optional). Use any category available in the assessment."
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Maximum number of recon items to return",
                        "default": 50
                    }
                },
                "required": []
            }
        ),
    ]


async def handle_recon_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route recon tool calls to the appropriate handler"""
    if name == "add_recon_data":
        return await _handle_add_recon_data(arguments, mcp_service)
    elif name == "list_recon":
        return await _handle_list_recon(arguments, mcp_service)
    return [TextContent(type="text", text=f"Unknown recon tool: {name}")]


async def _handle_add_recon_data(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle add_recon_data - Single or batch mode"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    # Batch mode
    if "entries" in arguments:
        entries = arguments["entries"]
        if not entries:
            return [TextContent(type="text", text="No entries provided.")]

        # API will validate and normalize data_types via Pydantic
        # Batch call to backend
        try:
            response = await mcp_service.http_client.post(
                f"{mcp_service.backend_url}/assessments/{mcp_service.current_assessment_id}/recon/batch",
                json={"entries": entries}
            )
            response.raise_for_status()
            result = response.json()

            # Format summary
            summary_parts = []
            for data_type, count in result.get("summary", {}).items():
                summary_parts.append(f"{count} {data_type}(s)")

            summary_text = ", ".join(summary_parts) if summary_parts else "unknown types"

            return [TextContent(
                type="text",
                text=f"Added {result.get('created_count', len(entries))} recon entries: {summary_text}"
            )]

        except Exception as e:
            return [TextContent(
                type="text",
                text=f"Error adding batch recon data: {str(e)}"
            )]

    # Single mode - capture ID from response
    else:
        result = await mcp_service.add_recon_data(
            assessment_id=mcp_service.current_assessment_id,
            data_type=arguments["data_type"],
            name=arguments["name"],
            details=arguments.get("details"),
            discovered_in_phase=arguments.get("discovered_in_phase")
        )

        recon_id = result.get("id", "unknown")

        return [TextContent(
            type="text",
            text=f"Recon data added: {arguments['data_type']} -> {arguments['name']} [ID: {recon_id}]"
        )]


async def _handle_list_recon(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle list_recon - List recon data with optional filters"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    full_data = await mcp_service.get_assessment_full_data(mcp_service.current_assessment_id)
    recon_data = full_data.get('recon_data', [])

    # Apply data_type filter if provided
    data_type_filter = arguments.get("data_type")
    if data_type_filter:
        recon_data = [r for r in recon_data if r.get('data_type') == data_type_filter]

    limit = arguments.get("limit", 50)
    recon_data = recon_data[:limit]

    if not recon_data:
        return [TextContent(type="text", text="No recon data found.")]

    response = f"**Reconnaissance Data ({len(recon_data)}):**\n\n"
    for recon in recon_data:
        recon_id = recon.get('id', 'N/A')
        data_type = recon.get('data_type', 'UNKNOWN')
        name = recon.get('name', 'Unnamed')
        phase = recon.get('discovered_in_phase', 'N/A')

        response += f"**ID: {recon_id}** | [{data_type}] {name}\n"
        response += f"  - Discovered in: {phase}\n"

        details = recon.get('details')
        if details:
            response += f"  - Details: {details}\n"

        response += "\n"

    return [TextContent(type="text", text=response)]
