"""
Evidence Tools - evidence_bundle, evidence_add_artifact, evidence_export,
evidence_generate_report, evidence_validate.

Ported from the evidence-mcp TypeScript server to Python, following the
same pattern as tools_scope.py and tools_fuzzer.py.
"""

from __future__ import annotations

import json
import logging
import os
from typing import Any, Dict, List

from mcp.types import Tool, TextContent

from lib.evidence_bundler import get_bundler
from lib.evidence_redactor import get_redactor
from lib.evidence_exporter import get_exporter

logger = logging.getLogger("autopentest-mcp")

# ---------------------------------------------------------------------------
# Environment configuration
# ---------------------------------------------------------------------------

EVIDENCE_DIR = os.environ.get("EVIDENCE_DIR", "./evidence")
REDACT_SECRETS = os.environ.get("REDACT_SECRETS", "true").lower() != "false"


from lib.tool_helpers import _json_content, _error_content, _get_db
from lib.hallucination_filter import validate_finding, verify_evidence_integrity


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_evidence_tools() -> List[Tool]:
    """Return the five evidence tools."""
    return [
        Tool(
            name="evidence_bundle",
            description=(
                "Create a new evidence bundle for a security finding. Initializes a structured evidence "
                "collection container for organizing requests, responses, screenshots, logs, and configs "
                "related to a vulnerability. Returns unique bundle_id for adding artifacts. Bundles can be "
                "exported as ZIP, JSON, or SARIF 2.1.0 for CI/CD integration. "

                "**When to use:** Phase 4 (Exploitation) or Phase 5 (Reporting) after validate_promote() "
                "confirms a finding is reproducible and should be documented. Create one bundle per confirmed "
                "vulnerability for organized evidence collection. Use before adding artifacts or generating "
                "PoCs. Essential for professional pentest reporting. "

                "**Dependencies:** Requires a finding_id from add_card(type='finding') or wm_add_finding(). "
                "Typically called after validate_promote() indicates promotion to confirmed status. Follow "
                "with evidence_add_artifact() to populate bundle, then evidence_export() or "
                "evidence_generate_report() for deliverables. "

                "**Budget impact:** LOW - Local operation, no HTTP requests. Creates in-memory data structure "
                "and optional info card in assessment. Completes instantly (<50ms). "

                "**Failure modes:** 'Invalid finding_id' if finding_id doesn't exist - verify you created "
                "the finding first. 'Metadata validation failed' if metadata contains non-serializable objects - "
                "use strings, numbers, lists, dicts only. No other expected failures. "

                "**Risk level:** SAFE - Local data structure creation only, no network activity or target "
                "interaction. Evidence is stored locally in EVIDENCE_DIR (default: ./evidence). "

                "**Returns:** Bundle creation confirmation with bundle_id (UUID), finding_id, created_at "
                "timestamp, and usage instructions. Store bundle_id for subsequent evidence_add_artifact() "
                "calls. Optionally includes metadata fields (title, severity, cvss_score, cwe_id) for "
                "report generation. Bundle automatically tracked in assessment as info card."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "finding_id": {
                        "type": "string",
                        "description": "The ID of the finding this evidence relates to",
                    },
                    "metadata": {
                        "type": "object",
                        "description": (
                            "Optional metadata (title, severity, description, "
                            "cvss_score, cwe_id, etc.)"
                        ),
                        "additionalProperties": True,
                    },
                },
                "required": ["finding_id"],
            },
        ),
        Tool(
            name="evidence_add_artifact",
            description=(
                "Add an artifact (request, response, screenshot, log, config, other) to an evidence bundle. "
                "Artifacts are pieces of evidence that prove vulnerability existence: HTTP request/response "
                "pairs, browser screenshots, tool output logs, configuration files, PoC scripts. Supports "
                "automatic sensitive data detection with warnings (secrets/tokens/passwords redacted on export). "

                "**When to use:** Phase 4-5 (Exploitation/Reporting) after evidence_bundle() creates container. "
                "Add artifacts immediately after validation tests: validate_repro() responses, browser_screenshot() "
                "captures, poc_generate() scripts, execute() tool outputs, http_send() exchanges. Typical workflow: "
                "1 bundle â†’ 5-10 artifacts (baseline request, malicious request, vulnerable response, screenshot, PoC). "

                "**Dependencies:** Requires evidence_bundle() to have been called first to get bundle_id. "
                "Artifact content can come from: validate_repro() results, http_send() responses, "
                "browser_screenshot() output, poc_generate() scripts, wm_recall() stored data. Follow with "
                "evidence_export() or evidence_generate_report() once all artifacts added. "

                "**Budget impact:** LOW - Local file storage operation, no HTTP requests. Artifact content is "
                "stored in-memory and optionally persisted to disk. Large artifacts (>1MB screenshots, long logs) "
                "may increase bundle size but don't affect request budget. Completes in <100ms per artifact. "

                "**Failure modes:** 'Bundle not found' if bundle_id doesn't exist - call evidence_bundle() first. "
                "'Invalid artifact type' if type not in [request, response, screenshot, log, config, other] - use "
                "'other' for custom types. 'Content too large' warning if artifact >10MB (will be truncated on "
                "export). Sensitive data detected triggers 'redaction warning' (passwords, API keys, tokens found). "

                "**Risk level:** SAFE - Local storage only, no network activity. Sensitive data automatically "
                "detected and flagged for redaction on export (unless include_redacted=true). REDACT_SECRETS=true "
                "by default protects against accidental credential exposure in reports. "

                "**Returns:** Artifact confirmation with artifact_id (UUID), bundle_id, artifact type, name, "
                "timestamp, and optional sensitive_data_warning if credentials/tokens detected. Returns immediately "
                "after storage. Use artifact_id for tracking but not required for export (bundle includes all artifacts). "
                "Check sensitive_data_warning field - if present, verify you want to include this artifact or sanitize "
                "content manually before proceeding."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "bundle_id": {
                        "type": "string",
                        "description": "The evidence bundle ID to add the artifact to",
                    },
                    "artifact": {
                        "type": "object",
                        "description": "The artifact to add",
                        "properties": {
                            "type": {
                                "type": "string",
                                "enum": [
                                    "request", "response", "screenshot",
                                    "log", "config", "other",
                                ],
                                "description": "Type of artifact",
                            },
                            "name": {
                                "type": "string",
                                "description": "Name/label for the artifact",
                            },
                            "content": {
                                "type": "string",
                                "description": "Content of the artifact",
                            },
                            "content_type": {
                                "type": "string",
                                "description": "MIME type of the content (default: text/plain)",
                            },
                        },
                        "required": ["type", "name", "content"],
                    },
                },
                "required": ["bundle_id", "artifact"],
            },
        ),
        Tool(
            name="evidence_export",
            description=(
                "Export an evidence bundle as ZIP, JSON, or SARIF 2.1.0 format. ZIP creates portable archive "
                "with all artifacts as separate files. JSON exports structured bundle data for programmatic "
                "processing. SARIF exports vulnerability findings in industry-standard format for CI/CD "
                "integration (GitHub Security, Azure DevOps, SonarQube). Sensitive data (API keys, passwords, "
                "tokens) automatically redacted by default unless include_redacted=true. "

                "**When to use:** Phase 5 (Reporting) after evidence_bundle() and evidence_add_artifact() "
                "complete evidence collection. Use SARIF format for CI/CD pipeline integration and automated "
                "security gates. Use ZIP for client deliverables and offline analysis. Use JSON for custom "
                "post-processing or integration with other tools. "

                "**Dependencies:** Requires evidence_bundle() and typically 3+ evidence_add_artifact() calls "
                "to populate bundle. No follow-up tools required - export is final step in evidence workflow. "
                "For report generation instead of raw export, use evidence_generate_report() which creates "
                "formatted HTML/Markdown reports. "

                "**Budget impact:** LOW - Local file I/O only, no HTTP requests. ZIP creation for large bundles "
                "(100+ artifacts) may take 1-2 seconds. JSON/SARIF export completes in <500ms. Output file size "
                "typically 1-10MB depending on screenshots and logs included. "

                "**Failure modes:** 'Bundle not found' if bundle_id invalid - verify bundle exists. 'No artifacts' "
                "warning if bundle is empty (still exports but useless). 'Redaction failed' if sensitive data "
                "detection crashes (falls back to no redaction). 'Output path permission denied' if writing to "
                "read-only location - use default EVIDENCE_DIR instead. Large bundles (>100MB) may cause memory "
                "issues during ZIP creation. "

                "**Risk level:** SAFE with default settings (redaction enabled) - secrets automatically removed. "
                "CAUTION if include_redacted=true - raw credentials and tokens included in export, only use for "
                "internal documentation or when you've manually sanitized artifacts. Never share unredacted "
                "exports with clients or external parties. "

                "**Returns:** Export result with format, bundle_id, artifact_count, redacted_count (items "
                "sanitized), size_bytes, output_path (if saved to file), and data (if returned in-memory). "
                "For SARIF exports, includes finding_count showing vulnerabilities reported. ZIP exports include "
                "manifest.json + artifact files. JSON exports include complete bundle structure. Use output_path "
                "for file location or data field for in-memory content (base64 for ZIP, object for JSON/SARIF)."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "bundle_id": {
                        "type": "string",
                        "description": "The evidence bundle ID to export",
                    },
                    "format": {
                        "type": "string",
                        "enum": ["zip", "json", "sarif"],
                        "description": "Export format (sarif for CI/CD integration)",
                    },
                    "include_redacted": {
                        "type": "boolean",
                        "description": (
                            "If true, skip redaction and include raw data "
                            "(default: false)"
                        ),
                    },
                    "output_path": {
                        "type": "string",
                        "description": "Optional file path to save the export",
                    },
                },
                "required": ["bundle_id", "format"],
            },
        ),
        Tool(
            name="evidence_generate_report",
            description=(
                "Generate a professional security finding report from an evidence bundle using built-in "
                "Markdown or HTML templates, or custom Jinja2 templates. Creates structured vulnerability "
                "reports with executive summary, technical details, proof-of-concept evidence, CVSS scores, "
                "CWE mappings, remediation guidance, and embedded artifacts. Ideal for client deliverables "
                "and internal documentation. "

                "**When to use:** Phase 5 (Reporting) as the final step after evidence_bundle() and "
                "evidence_add_artifact() complete evidence collection. Use Markdown for technical documentation "
                "and developer-focused reports. Use HTML for executive presentations and client deliverables "
                "with professional styling. Use custom_template for organization-specific report formats. "

                "**Dependencies:** Requires evidence_bundle() with at least 1 artifact added via "
                "evidence_add_artifact(). Bundle metadata (title, severity, cvss_score, cwe_id, description) "
                "from evidence_bundle() call used to populate report sections. No follow-up tools - this is "
                "the final deliverable. For raw exports instead, use evidence_export(). "

                "**Budget impact:** LOW - Local template rendering only, no HTTP requests. Markdown generation "
                "completes in <200ms. HTML rendering with styling takes <500ms. Large bundles (50+ artifacts) "
                "or custom templates with complex logic may take 1-2 seconds. Output size typically 100KB-5MB "
                "depending on include_artifacts setting. "

                "**Failure modes:** 'Bundle not found' if bundle_id invalid. 'Template not found' if "
                "custom_template path doesn't exist. 'Template rendering failed' if custom Jinja2 template "
                "has syntax errors. 'Missing metadata' warning if bundle lacks title/severity (report still "
                "generates but sections may be incomplete). Large artifact contents (full HTTP logs) may "
                "bloat report size - set include_artifacts=false for summary-only reports. "

                "**Risk level:** SAFE - Local rendering only, no network activity. Sensitive data automatically "
                "redacted in report output (uses same redactor as evidence_export). HTML templates use safe "
                "escaping to prevent XSS in artifact content. Custom templates evaluated in sandboxed Jinja2 "
                "environment with no filesystem or network access. "

                "**Returns:** Report generation result with template type, bundle_id, finding_id, artifact_count, "
                "and content (rendered report as string). Markdown content includes proper heading hierarchy "
                "and code blocks. HTML content includes CSS styling, responsive layout, and syntax highlighting. "
                "Use content field directly for display or save to file for distribution. Report includes "
                "automatic sections: Vulnerability Summary, Technical Details, Reproduction Steps, Evidence "
                "Artifacts, Impact Assessment, Remediation Recommendations."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "bundle_id": {
                        "type": "string",
                        "description": "The evidence bundle ID",
                    },
                    "template": {
                        "type": "string",
                        "enum": ["markdown", "html"],
                        "description": "Report template format",
                    },
                    "title": {
                        "type": "string",
                        "description": "Optional report title",
                    },
                    "include_artifacts": {
                        "type": "boolean",
                        "description": "Include artifact contents in report (default: true)",
                    },
                    "custom_template": {
                        "type": "string",
                        "description": "Path to a custom Jinja2 template file",
                    },
                },
                "required": ["bundle_id", "template"],
            },
        ),
        Tool(
            name="evidence_validate",
            description=(
                "Validate all findings for the current assessment against evidence artifacts. "
                "Checks for speculative language, missing evidence references, unsupported claims, "
                "and evidence integrity. Returns per-finding validation results with issues and "
                "confidence scores. Use before report generation to ensure finding quality."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "finding_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Optional list of specific finding IDs to validate. If empty, validates all findings.",
                    },
                },
                "required": [],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_evidence_tool(
    name: str,
    arguments: dict,
    mcp_service,
) -> List[TextContent]:
    """Dispatch an evidence tool call to the appropriate handler.

    Parameters
    ----------
    name : str
        Tool name (one of the four evidence_* tools).
    arguments : dict
        Arguments supplied by the caller.
    mcp_service :
        The MCP service instance (unused by evidence tools but kept for
        interface parity with other tool modules).
    """
    if name == "evidence_bundle":
        return await _handle_evidence_bundle(arguments, mcp_service)
    elif name == "evidence_add_artifact":
        return _handle_add_artifact(arguments)
    elif name == "evidence_export":
        return _handle_export(arguments)
    elif name == "evidence_generate_report":
        return await _handle_generate_report(arguments, mcp_service)
    elif name == "evidence_validate":
        return await _handle_evidence_validate(arguments, mcp_service)

    return _error_content(f"Unknown evidence tool: {name}")


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

async def _handle_evidence_bundle(arguments: dict, mcp_service=None) -> List[TextContent]:
    """Create a new evidence bundle."""
    finding_id = arguments.get("finding_id")
    if not finding_id or not isinstance(finding_id, str):
        return _error_content("finding_id is required and must be a string")

    try:
        metadata = arguments.get("metadata") or {}
        if not isinstance(metadata, dict):
            metadata = {}

        bundler = get_bundler()
        bundle = bundler.create_bundle(finding_id, metadata)

        # Link evidence bundle to backend as an info card
        if mcp_service:
            bundle_id = bundle["bundle_id"]
            title = metadata.get("title", finding_id)
            await mcp_service.safe_add_card(
                card_type="info",
                title=f"Evidence: {title}",
                context=f"Bundle: {bundle_id}, Finding: {finding_id}",
                notes=json.dumps(metadata, default=str)[:2000],
            )

        return _json_content({
            "success": True,
            "bundle_id": bundle["bundle_id"],
            "finding_id": bundle["finding_id"],
            "created_at": bundle["created_at"],
            "message": (
                f'Evidence bundle created. Use bundle_id '
                f'"{bundle["bundle_id"]}" to add artifacts.'
            ),
        })

    except Exception as exc:
        return _error_content(f"Error creating bundle: {exc}")


def _handle_add_artifact(arguments: dict) -> List[TextContent]:
    """Add an artifact to an evidence bundle."""
    bundle_id = arguments.get("bundle_id")
    if not bundle_id or not isinstance(bundle_id, str):
        return _error_content("bundle_id is required and must be a string")

    artifact_input = arguments.get("artifact")
    if not artifact_input or not isinstance(artifact_input, dict):
        return _error_content("artifact is required and must be an object")

    try:
        bundler = get_bundler()
        artifact = bundler.add_artifact(bundle_id, artifact_input)

        # Check for sensitive data if redaction is enabled
        sensitive_data_warning = None
        if REDACT_SECRETS:
            redactor = get_redactor()
            if redactor.contains_sensitive_data(artifact["content"]):
                sensitive_data_warning = (
                    "Artifact contains sensitive data that will be "
                    "redacted on export"
                )

        return _json_content({
            "success": True,
            "artifact_id": artifact["artifact_id"],
            "bundle_id": bundle_id,
            "type": artifact["type"],
            "name": artifact["name"],
            "timestamp": artifact["timestamp"],
            "sensitive_data_warning": sensitive_data_warning,
        })

    except Exception as exc:
        return _error_content(f"Error adding artifact: {exc}")


def _handle_export(arguments: dict) -> List[TextContent]:
    """Export an evidence bundle."""
    bundle_id = arguments.get("bundle_id")
    if not bundle_id or not isinstance(bundle_id, str):
        return _error_content("bundle_id is required and must be a string")

    fmt = arguments.get("format")
    if fmt not in ("zip", "json", "sarif"):
        return _error_content('format must be "zip", "json", or "sarif"')

    bundler = get_bundler()
    bundle = bundler.get_bundle(bundle_id)
    if bundle is None:
        return _error_content(f"Bundle not found: {bundle_id}")

    include_redacted = arguments.get("include_redacted") is True
    output_path = arguments.get("output_path")
    if output_path is not None and not isinstance(output_path, str):
        output_path = None

    try:
        if fmt == "sarif":
            # SARIF 2.1.0 export
            redactor = get_redactor()
            exporter = get_exporter(redactor)
            result = exporter.export_to_sarif(
                bundle,
                output_path=output_path,
            )
            return _json_content({
                "success": True,
                "format": "sarif",
                "bundle_id": bundle_id,
                "output_path": result.get("output_path"),
                "data": result.get("data"),
                "finding_count": result.get("finding_count", 0),
            })

        redactor = get_redactor()
        exporter = get_exporter(redactor)

        if fmt == "zip":
            result = exporter.export_to_zip(
                bundle,
                include_redacted=include_redacted,
                output_path=output_path,
            )
        else:
            result = exporter.export_to_json(
                bundle,
                include_redacted=include_redacted,
                output_path=output_path,
            )

        return _json_content({
            "success": result["success"],
            "format": result["format"],
            "bundle_id": bundle_id,
            "artifact_count": result["artifact_count"],
            "redacted_count": result["redacted_count"],
            "size_bytes": result["size_bytes"],
            "output_path": result.get("output_path"),
            "data": result.get("data"),
        })

    except Exception as exc:
        return _error_content(f"Error exporting bundle: {exc}")


async def _handle_generate_report(arguments: dict, mcp_service=None) -> List[TextContent]:
    """Generate a report from an evidence bundle with validation pre-step."""
    bundle_id = arguments.get("bundle_id")
    if not bundle_id or not isinstance(bundle_id, str):
        return _error_content("bundle_id is required and must be a string")

    template = arguments.get("template")
    if template not in ("markdown", "html"):
        return _error_content('template must be "markdown" or "html"')

    bundler = get_bundler()
    bundle = bundler.get_bundle(bundle_id)
    if bundle is None:
        return _error_content(f"Bundle not found: {bundle_id}")

    title = arguments.get("title")
    if title is not None and not isinstance(title, str):
        title = None

    include_artifacts = arguments.get("include_artifacts") is not False

    custom_template = arguments.get("custom_template")
    if custom_template is not None and not isinstance(custom_template, str):
        custom_template = None

    try:
        # Pre-step: validate findings if database available
        validation_summary = None
        if mcp_service and mcp_service.current_assessment_id:
            try:
                db = await _get_db(mcp_service)
                findings = await db.query("findings")
                valid_count = 0
                invalid_count = 0
                warnings = []
                for f in findings:
                    result = validate_finding(f)
                    if result.is_valid:
                        valid_count += 1
                    else:
                        invalid_count += 1
                        warnings.append({
                            "finding_id": f.get("id"),
                            "title": f.get("title"),
                            "issues": result.issues,
                        })
                validation_summary = {
                    "total_findings": len(findings),
                    "valid_count": valid_count,
                    "invalid_count": invalid_count,
                    "warnings": warnings[:10],
                }
            except Exception as val_exc:
                logger.warning("Finding validation pre-step failed: %s", val_exc)

        redactor = get_redactor()
        exporter = get_exporter(redactor)

        result = exporter.generate_report(
            bundle,
            template=template,
            title=title,
            include_artifacts=include_artifacts,
            custom_template=custom_template,
        )

        response = {
            "success": result["success"],
            "template": result["template"],
            "bundle_id": result["bundle_id"],
            "finding_id": result["finding_id"],
            "artifact_count": result["artifact_count"],
            "content": result["content"],
        }

        if validation_summary:
            response["validation_summary"] = validation_summary

        return _json_content(response)

    except Exception as exc:
        return _error_content(f"Error generating report: {exc}")


async def _handle_evidence_validate(arguments: dict, mcp_service=None) -> List[TextContent]:
    """Validate all findings for current assessment against evidence."""
    try:
        db = await _get_db(mcp_service)
    except ValueError as e:
        return _error_content(str(e))

    finding_ids = arguments.get("finding_ids") or []

    try:
        if finding_ids:
            findings = []
            for fid in finding_ids:
                f = await db.get_by_id("findings", fid)
                if f:
                    findings.append(f)
        else:
            findings = await db.query("findings")

        valid_count = 0
        invalid_count = 0
        issues_by_finding = {}

        for finding in findings:
            fid = finding.get("id", "unknown")

            # Run structural validation
            result = validate_finding(finding)

            # Run evidence integrity check
            integrity = await verify_evidence_integrity(fid, db)
            if not integrity.is_valid:
                result.issues.extend(integrity.issues)
                result.is_valid = False
                result.confidence = min(result.confidence, integrity.confidence)

            if result.is_valid:
                valid_count += 1
            else:
                invalid_count += 1
                issues_by_finding[fid] = {
                    "title": finding.get("title"),
                    "severity": finding.get("severity"),
                    "issues": result.issues,
                    "confidence": result.confidence,
                }

        return _json_content({
            "success": True,
            "total_findings": len(findings),
            "valid_count": valid_count,
            "invalid_count": invalid_count,
            "issues_by_finding": issues_by_finding,
        })

    except Exception as exc:
        return _error_content(f"Error validating findings: {exc}")
