"""
Cards Management Tools - add_card, list_cards, update_card, delete_card
"""
from typing import List
from mcp.types import Tool, TextContent


def get_cards_tools() -> List[Tool]:
    """Get card management tool definitions"""
    return [
        Tool(
            name="add_card",
            description=(
                "Add a card to the assessment: finding (confirmed vulnerability), observation (suspicious behavior "
                "not yet confirmed), or info (general notes). Returns the created card ID for later reference in "
                "validation and evidence tools. Cards are the primary documentation mechanism in AutoPentest. "

                "**When to use:** Phase 3-4 to document discoveries. Use finding for confirmed vulnerabilities "
                "(after testing confirms exploitability - SQL injection works, XSS fires, IDOR accesses other "
                "user data). Use observation for suspicious behavior (error messages, verbose output, timing "
                "differences, unusual responses) that needs further investigation. Use info for general notes "
                "(configuration details, technology versions, interesting endpoints). ALWAYS create finding card "
                "before validate_repro() or evidence_bundle() - these tools require card_id. "

                "**Dependencies:** Requires load_assessment() first. Follow findings with validate_repro(card_id) "
                "to confirm reproducibility, then validate_promote() to calculate confidence. Follow observations "
                "with more testing to either promote to finding or dismiss. Info cards need no follow-up. Cards "
                "visible in load_assessment() output and web interface. "

                "**Budget impact:** LOW - local database insert, no network requests. Stores card data in PostgreSQL. "
                "Completes <50ms. No limits on card count or content length. "

                "**Failure modes:** 'No assessment loaded' if load_assessment() not called. 'severity required "
                "for findings' if you create finding without severity. Missing proof/technical_analysis fields "
                "allowed but reduces report quality (add them via update_card() later). Duplicate titles allowed "
                "(no deduplication - intentional for tracking multiple instances). "

                "**Risk level:** SAFE - local documentation tool, no network activity or target interaction. "
                "Creates permanent record visible to user and included in final report. "

                "**Returns:** Card ID (integer) for use in validation/evidence tools, plus confirmation message "
                "with title and severity. Example: 'Finding added: SQL Injection in login [ID: 42]'. Use ID in: "
                "validate_repro(finding_id=42), evidence_bundle(finding_id=42), wm_add_finding(card_id=42)."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "card_type": {
                        "type": "string",
                        "enum": ["finding", "observation", "info"],
                        "description": "Type of card to create"
                    },
                    "title": {
                        "type": "string",
                        "description": "Card title (vulnerability name for findings)"
                    },
                    "target_service": {
                        "type": "string",
                        "description": "Target or service affected"
                    },
                    "severity": {
                        "type": "string",
                        "enum": ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"],
                        "description": "Severity level (required for findings)"
                    },
                    "status": {
                        "type": "string",
                        "enum": ["confirmed", "potential", "untested"],
                        "description": "Status of finding (default: confirmed)"
                    },
                    "technical_analysis": {
                        "type": "string",
                        "description": "Technical analysis and notes"
                    },
                    "proof": {
                        "type": "string",
                        "description": "Proof of concept or evidence"
                    },
                    "notes": {
                        "type": "string",
                        "description": "Observation notes"
                    },
                    "context": {
                        "type": "string",
                        "description": "Contextual information"
                    }
                },
                "required": ["card_type", "title"]
            }
        ),
        Tool(
            name="list_cards",
            description=(
                "List all cards (findings, observations, infos) with optional filtering by type and severity. "
                "Shows card ID, type, title, target, status, and content preview. Essential for reviewing what's "
                "been discovered, planning validation work, and generating reports. Excludes false_positive cards "
                "(hidden from AI view after user marks them). "

                "**When to use:** Phase 2-5 to review documented discoveries. Use to: check what findings exist "
                "before starting validation (list findings to see what needs validate_repro), review observations "
                "to decide which need more testing, verify card was created correctly after add_card(), generate "
                "findings summary for update_phase(), prioritize work (focus on CRITICAL/HIGH findings first). "
                "Call periodically (every 30-50 tool calls) to track progress. "

                "**Dependencies:** Requires load_assessment() and prior add_card() calls. Returns empty if no "
                "cards created yet (expected early in Phase 1-2). Filter by card_type='finding' to focus on "
                "vulnerabilities, severity='CRITICAL' for urgent issues. Use card IDs returned here in "
                "validate_repro(), update_card(), delete_card(). "

                "**Budget impact:** LOW - local database query, no network requests. Returns up to limit (default "
                "50) cards with content previews truncated to 100 chars. Completes <200ms for typical assessments "
                "(<100 cards). False positives filtered automatically. "

                "**Failure modes:** 'No cards found' if nothing created yet or filters too restrictive (remove "
                "filters to see all cards). Empty severity filter returns all severities. Large result sets "
                "(>50 cards) truncated to limit - use multiple calls with card_type filter for focused view. "

                "**Risk level:** SAFE - read-only query of stored data, no network activity or target interaction. "
                "Shows only cards you created (or were loaded from assessment). "

                "**Returns:** Formatted list with card ID, type badge, severity (findings only), title, target, "
                "status (findings only), and content preview (first 100 chars of technical_analysis/notes/context). "
                "Example: 'ID: 42 | [FINDING] [HIGH] SQL Injection in login\\n  - Target: https://example.com/login\\n  "
                "- Status: confirmed\\n  - Content: Union-based SQLi via username parameter allows data extraction...'. "
                "Use for progress tracking, validation planning, and report generation."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "card_type": {
                        "type": "string",
                        "enum": ["finding", "observation", "info"],
                        "description": "Filter by card type (optional, shows all if not specified)"
                    },
                    "severity": {
                        "type": "string",
                        "enum": ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"],
                        "description": "Filter findings by severity (optional)"
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Maximum number of cards to return",
                        "default": 50
                    }
                },
                "required": []
            }
        ),
        Tool(
            name="update_card",
            description=(
                "Update an existing card's fields by ID. Supports updating any field: title, target_service, "
                "severity, status, technical_analysis, proof, notes, context. Use to refine findings after "
                "additional testing, add proof of concept after validation, update severity based on impact "
                "assessment, or change status after confirmation. Partial updates allowed - only specify fields "
                "to change. "

                "**When to use:** Phase 3-5 after creating card with add_card(). Common scenarios: add proof "
                "after validate_repro() confirms exploitability (update proof field with reproduction steps), "
                "upgrade severity after risk_score() calculates higher impact, change status from 'potential' "
                "to 'confirmed' after validation (or use validate_promote() which does this automatically), "
                "enhance technical_analysis with additional research, update title for clarity. "

                "**Dependencies:** Requires load_assessment() and add_card() to have created the card first. "
                "Get card_id from add_card() return value or list_cards() output. No follow-up required - "
                "updates immediately visible in web interface and load_assessment() output. Can call multiple "
                "times to incrementally enhance card. "

                "**Budget impact:** LOW - local database update, no network requests. PATCH operation updates "
                "only specified fields, leaving others unchanged. Completes <50ms regardless of field count. "

                "**Failure modes:** 'No assessment loaded' if load_assessment() not called. 'Card not found' if "
                "card_id invalid or card was deleted. 'No fields to update' if you call with only card_id (must "
                "specify at least one field to update). Invalid severity/status values rejected by schema validation. "

                "**Risk level:** SAFE - local data modification only, no network activity or target interaction. "
                "Updates existing card record in database. Previous values overwritten (not versioned - make sure "
                "you want to replace, not append). "

                "**Returns:** Simple confirmation 'Card {ID} updated successfully'. Updated content immediately "
                "reflected in list_cards() and load_assessment() output. Use for iterative refinement of findings "
                "as you learn more during testing and validation."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "card_id": {
                        "type": "integer",
                        "description": "ID of the card to update"
                    },
                    "title": {
                        "type": "string",
                        "description": "New title"
                    },
                    "target_service": {
                        "type": "string",
                        "description": "Updated target/service"
                    },
                    "severity": {
                        "type": "string",
                        "enum": ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"],
                        "description": "New severity level (findings only)"
                    },
                    "status": {
                        "type": "string",
                        "enum": ["confirmed", "potential", "untested"],
                        "description": "Updated status (findings only)"
                    },
                    "technical_analysis": {
                        "type": "string",
                        "description": "Updated technical analysis"
                    },
                    "proof": {
                        "type": "string",
                        "description": "Updated proof of concept"
                    },
                    "notes": {
                        "type": "string",
                        "description": "Updated notes (observations)"
                    },
                    "context": {
                        "type": "string",
                        "description": "Updated context (info cards)"
                    }
                },
                "required": ["card_id"]
            }
        ),
        Tool(
            name="delete_card",
            description=(
                "Permanently delete a card by ID. Removes finding, observation, or info card from the assessment. "
                "Use sparingly - prefer update_card() to fix mistakes or change status to 'false_positive' instead "
                "of deleting (false positives hidden from AI but preserved for audit trail). Deletion is permanent "
                "and cannot be undone. "

                "**When to use:** Phase 3-5 when card was created by mistake (duplicate entry, wrong assessment "
                "loaded, test data that shouldn't be in real assessment). PREFER alternatives: use update_card() "
                "to change status to 'false_positive' if finding doesn't actually exist (preserves audit trail), "
                "use update_card() to fix incorrect data rather than delete/recreate. Only delete for true mistakes. "

                "**Dependencies:** Requires load_assessment() and add_card() to have created the card first. "
                "Get card_id from add_card() return value or list_cards() output. CAUTION: If card was referenced "
                "in validation (validate_repro), evidence (evidence_bundle), or world model (wm_add_finding), "
                "those references become orphaned (won't break but less useful). "

                "**Budget impact:** LOW - local database delete, no network requests. Completes <50ms. Deletion "
                "permanent - card removed from PostgreSQL immediately. "

                "**Failure modes:** 'No assessment loaded' if load_assessment() not called. 'Card not found' if "
                "card_id invalid or already deleted (silently succeeds if card doesn't exist - idempotent). "
                "No confirmation prompt - deletion happens immediately. "

                "**Risk level:** SAFE - local data deletion only, no network activity or target interaction. "
                "CAUTION: Permanent action that cannot be undone. User won't see deleted cards in web interface "
                "or future load_assessment() calls. Consider marking false_positive instead. "

                "**Returns:** Simple confirmation 'Card {ID} deleted successfully'. Card immediately removed from "
                "list_cards() and load_assessment() output. Orphaned references in validation/evidence tools won't "
                "cause errors but will show 'card not found' if you try to use the ID later."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "card_id": {
                        "type": "integer",
                        "description": "ID of the card to delete"
                    }
                },
                "required": ["card_id"]
            }
        ),
    ]


async def handle_cards_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route card tool calls to the appropriate handler"""
    if name == "add_card":
        return await _handle_add_card(arguments, mcp_service)
    elif name == "list_cards":
        return await _handle_list_cards(arguments, mcp_service)
    elif name == "update_card":
        return await _handle_update_card(arguments, mcp_service)
    elif name == "delete_card":
        return await _handle_delete_card(arguments, mcp_service)
    return [TextContent(type="text", text=f"Unknown cards tool: {name}")]


async def _handle_add_card(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle add_card - Unified handler for finding/observation/info with ID return"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    card_type = arguments["card_type"]
    title = arguments["title"]

    # Build card data - include all provided fields
    card_data = {
        "card_type": card_type,
        "title": title,
    }

    # Add all optional fields if provided (don't filter by type - backend accepts all)
    optional_fields = [
        "target_service", "severity", "status",
        "technical_analysis", "proof", "notes", "context"
    ]
    for field in optional_fields:
        if field in arguments and arguments[field] is not None:
            card_data[field] = arguments[field]

    # Validate severity for findings
    if card_type == "finding" and "severity" not in card_data:
        return [TextContent(type="text", text="severity is required for findings")]

    # Set default status for findings
    if card_type == "finding" and "status" not in card_data:
        card_data["status"] = "confirmed"

    # Fix C2: Route through safe_add_card() for section_number, wm_findings sync, coverage marking
    result = await mcp_service.safe_add_card(**card_data)

    if not result.ok:
        return [TextContent(type="text", text=f"Failed to create card: {result.reason}")]

    card_id = result.data.get("id", "unknown") if result.data else "unknown"

    # Format response based on type
    if card_type == "finding":
        return [TextContent(
            type="text",
            text=f"Finding added: {title} ({arguments.get('severity', 'N/A')}) [ID: {card_id}]"
        )]
    elif card_type == "observation":
        return [TextContent(
            type="text",
            text=f"Observation added: {title} [ID: {card_id}]"
        )]
    else:  # info
        return [TextContent(
            type="text",
            text=f"Info added: {title} [ID: {card_id}]"
        )]


async def _handle_list_cards(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle list_cards - List all cards with optional filters"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    # Get full data
    full_data = await mcp_service.get_assessment_full_data(mcp_service.current_assessment_id)
    cards = full_data.get('cards', [])

    # Filter out false positives (hidden from AI)
    cards = [c for c in cards if c.get('status') != 'false_positive']

    # Apply card_type filter if provided
    card_type_filter = arguments.get("card_type")
    if card_type_filter:
        cards = [c for c in cards if c.get('card_type') == card_type_filter]

    # Apply severity filter if provided (for findings)
    severity_filter = arguments.get("severity")
    if severity_filter:
        cards = [c for c in cards if c.get('severity') == severity_filter]

    # Apply limit
    limit = arguments.get("limit", 50)
    cards = cards[:limit]

    if not cards:
        filter_msg = f" (type: {card_type_filter})" if card_type_filter else ""
        return [TextContent(type="text", text=f"No cards found{filter_msg}.")]

    response = f"**Cards ({len(cards)}):**\n\n"

    for card in cards:
        card_id = card.get('id', 'N/A')
        card_type = card.get('card_type', 'unknown')
        title = card.get('title', 'Untitled')
        target = card.get('target_service', 'N/A')

        # Type badge
        type_badge = f"[{card_type.upper()}]"
        if card_type == "finding":
            severity = card.get('severity', 'UNKNOWN')
            status = card.get('status', 'N/A')
            response += f"**ID: {card_id}** | {type_badge} [{severity}] {title}\n"
            response += f"  - Target: {target}\n"
            response += f"  - Status: {status}\n"
        else:
            response += f"**ID: {card_id}** | {type_badge} {title}\n"
            response += f"  - Target: {target}\n"

        # Show preview of content
        analysis = card.get('technical_analysis') or card.get('notes') or card.get('context')
        if analysis:
            preview = analysis[:100] + "..." if len(analysis) > 100 else analysis
            response += f"  - Content: {preview}\n"

        response += "\n"

    return [TextContent(type="text", text=response)]


async def _handle_update_card(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle update_card - Update any card by ID"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    card_id = arguments["card_id"]

    # Build update payload (only include provided fields)
    update_data = {}
    for field in ["title", "target_service", "severity", "status",
                  "technical_analysis", "proof", "notes", "context"]:
        if field in arguments:
            update_data[field] = arguments[field]

    if not update_data:
        return [TextContent(type="text", text="No fields to update provided.")]

    # Call backend API to update
    response = await mcp_service.http_client.patch(
        f"{mcp_service.backend_url}/assessments/{mcp_service.current_assessment_id}/cards/{card_id}",
        json=update_data
    )
    response.raise_for_status()

    return [TextContent(
        type="text",
        text=f"Card {card_id} updated successfully"
    )]


async def _handle_delete_card(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle delete_card - Delete any card by ID"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    card_id = arguments["card_id"]

    # Call backend API to delete
    response = await mcp_service.http_client.delete(
        f"{mcp_service.backend_url}/assessments/{mcp_service.current_assessment_id}/cards/{card_id}"
    )
    response.raise_for_status()

    return [TextContent(
        type="text",
        text=f"Card {card_id} deleted successfully"
    )]
