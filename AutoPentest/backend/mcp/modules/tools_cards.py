"""
Cards Management Tools - add_card, list_cards, update_card, delete_card
"""
from typing import List
from mcp.types import Tool, TextContent


def get_cards_tools() -> List[Tool]:
    """Get card management tool definitions"""
    return [
        Tool(
            name="add_card",
            description="Add a card (finding, observation, or info) - returns the created card ID",
            inputSchema={
                "type": "object",
                "properties": {
                    "card_type": {
                        "type": "string",
                        "enum": ["finding", "observation", "info"],
                        "description": "Type of card to create"
                    },
                    "title": {
                        "type": "string",
                        "description": "Card title (vulnerability name for findings)"
                    },
                    "target_service": {
                        "type": "string",
                        "description": "Target or service affected"
                    },
                    "severity": {
                        "type": "string",
                        "enum": ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"],
                        "description": "Severity level (required for findings)"
                    },
                    "status": {
                        "type": "string",
                        "enum": ["confirmed", "potential", "untested"],
                        "description": "Status of finding (default: confirmed)"
                    },
                    "technical_analysis": {
                        "type": "string",
                        "description": "Technical analysis and notes"
                    },
                    "proof": {
                        "type": "string",
                        "description": "Proof of concept or evidence"
                    },
                    "notes": {
                        "type": "string",
                        "description": "Observation notes"
                    },
                    "context": {
                        "type": "string",
                        "description": "Contextual information"
                    }
                },
                "required": ["card_type", "title"]
            }
        ),
        Tool(
            name="list_cards",
            description="List all cards with optional type filter",
            inputSchema={
                "type": "object",
                "properties": {
                    "card_type": {
                        "type": "string",
                        "enum": ["finding", "observation", "info"],
                        "description": "Filter by card type (optional, shows all if not specified)"
                    },
                    "severity": {
                        "type": "string",
                        "enum": ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"],
                        "description": "Filter findings by severity (optional)"
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Maximum number of cards to return",
                        "default": 50
                    }
                },
                "required": []
            }
        ),
        Tool(
            name="update_card",
            description="Update an existing card by ID",
            inputSchema={
                "type": "object",
                "properties": {
                    "card_id": {
                        "type": "integer",
                        "description": "ID of the card to update"
                    },
                    "title": {
                        "type": "string",
                        "description": "New title"
                    },
                    "target_service": {
                        "type": "string",
                        "description": "Updated target/service"
                    },
                    "severity": {
                        "type": "string",
                        "enum": ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"],
                        "description": "New severity level (findings only)"
                    },
                    "status": {
                        "type": "string",
                        "enum": ["confirmed", "potential", "untested"],
                        "description": "Updated status (findings only)"
                    },
                    "technical_analysis": {
                        "type": "string",
                        "description": "Updated technical analysis"
                    },
                    "proof": {
                        "type": "string",
                        "description": "Updated proof of concept"
                    },
                    "notes": {
                        "type": "string",
                        "description": "Updated notes (observations)"
                    },
                    "context": {
                        "type": "string",
                        "description": "Updated context (info cards)"
                    }
                },
                "required": ["card_id"]
            }
        ),
        Tool(
            name="delete_card",
            description="Delete a card by ID (finding, observation, or info)",
            inputSchema={
                "type": "object",
                "properties": {
                    "card_id": {
                        "type": "integer",
                        "description": "ID of the card to delete"
                    }
                },
                "required": ["card_id"]
            }
        ),
    ]


async def handle_cards_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route card tool calls to the appropriate handler"""
    if name == "add_card":
        return await _handle_add_card(arguments, mcp_service)
    elif name == "list_cards":
        return await _handle_list_cards(arguments, mcp_service)
    elif name == "update_card":
        return await _handle_update_card(arguments, mcp_service)
    elif name == "delete_card":
        return await _handle_delete_card(arguments, mcp_service)
    return [TextContent(type="text", text=f"Unknown cards tool: {name}")]


async def _handle_add_card(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle add_card - Unified handler for finding/observation/info with ID return"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    card_type = arguments["card_type"]
    title = arguments["title"]

    # Build card data - include all provided fields
    card_data = {
        "card_type": card_type,
        "title": title,
    }

    # Add all optional fields if provided (don't filter by type - backend accepts all)
    optional_fields = [
        "target_service", "severity", "status",
        "technical_analysis", "proof", "notes", "context"
    ]
    for field in optional_fields:
        if field in arguments and arguments[field] is not None:
            card_data[field] = arguments[field]

    # Validate severity for findings
    if card_type == "finding" and "severity" not in card_data:
        return [TextContent(type="text", text="severity is required for findings")]

    # Set default status for findings
    if card_type == "finding" and "status" not in card_data:
        card_data["status"] = "confirmed"

    # Create card via backend API
    result = await mcp_service.add_card(
        assessment_id=mcp_service.current_assessment_id,
        **card_data
    )

    card_id = result.get("id", "unknown")

    # Format response based on type
    if card_type == "finding":
        return [TextContent(
            type="text",
            text=f"Finding added: {title} ({arguments.get('severity', 'N/A')}) [ID: {card_id}]"
        )]
    elif card_type == "observation":
        return [TextContent(
            type="text",
            text=f"Observation added: {title} [ID: {card_id}]"
        )]
    else:  # info
        return [TextContent(
            type="text",
            text=f"Info added: {title} [ID: {card_id}]"
        )]


async def _handle_list_cards(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle list_cards - List all cards with optional filters"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    # Get full data
    full_data = await mcp_service.get_assessment_full_data(mcp_service.current_assessment_id)
    cards = full_data.get('cards', [])

    # Filter out false positives (hidden from AI)
    cards = [c for c in cards if c.get('status') != 'false_positive']

    # Apply card_type filter if provided
    card_type_filter = arguments.get("card_type")
    if card_type_filter:
        cards = [c for c in cards if c.get('card_type') == card_type_filter]

    # Apply severity filter if provided (for findings)
    severity_filter = arguments.get("severity")
    if severity_filter:
        cards = [c for c in cards if c.get('severity') == severity_filter]

    # Apply limit
    limit = arguments.get("limit", 50)
    cards = cards[:limit]

    if not cards:
        filter_msg = f" (type: {card_type_filter})" if card_type_filter else ""
        return [TextContent(type="text", text=f"No cards found{filter_msg}.")]

    response = f"**Cards ({len(cards)}):**\n\n"

    for card in cards:
        card_id = card.get('id', 'N/A')
        card_type = card.get('card_type', 'unknown')
        title = card.get('title', 'Untitled')
        target = card.get('target_service', 'N/A')

        # Type badge
        type_badge = f"[{card_type.upper()}]"
        if card_type == "finding":
            severity = card.get('severity', 'UNKNOWN')
            status = card.get('status', 'N/A')
            response += f"**ID: {card_id}** | {type_badge} [{severity}] {title}\n"
            response += f"  - Target: {target}\n"
            response += f"  - Status: {status}\n"
        else:
            response += f"**ID: {card_id}** | {type_badge} {title}\n"
            response += f"  - Target: {target}\n"

        # Show preview of content
        analysis = card.get('technical_analysis') or card.get('notes') or card.get('context')
        if analysis:
            preview = analysis[:100] + "..." if len(analysis) > 100 else analysis
            response += f"  - Content: {preview}\n"

        response += "\n"

    return [TextContent(type="text", text=response)]


async def _handle_update_card(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle update_card - Update any card by ID"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    card_id = arguments["card_id"]

    # Build update payload (only include provided fields)
    update_data = {}
    for field in ["title", "target_service", "severity", "status",
                  "technical_analysis", "proof", "notes", "context"]:
        if field in arguments:
            update_data[field] = arguments[field]

    if not update_data:
        return [TextContent(type="text", text="No fields to update provided.")]

    # Call backend API to update
    response = await mcp_service.http_client.patch(
        f"{mcp_service.backend_url}/assessments/{mcp_service.current_assessment_id}/cards/{card_id}",
        json=update_data
    )
    response.raise_for_status()

    return [TextContent(
        type="text",
        text=f"Card {card_id} updated successfully"
    )]


async def _handle_delete_card(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle delete_card - Delete any card by ID"""
    if not mcp_service.current_assessment_id:
        return [TextContent(type="text", text="No assessment loaded. Use 'load_assessment' first.")]

    card_id = arguments["card_id"]

    # Call backend API to delete
    response = await mcp_service.http_client.delete(
        f"{mcp_service.backend_url}/assessments/{mcp_service.current_assessment_id}/cards/{card_id}"
    )
    response.raise_for_status()

    return [TextContent(
        type="text",
        text=f"Card {card_id} deleted successfully"
    )]
