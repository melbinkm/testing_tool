"""
Scanning & Reconnaissance Tools - scan, subdomain_enum, ssl_analysis, tech_detection, tool_help
"""
import asyncio
import json
import logging
import re
from typing import List
from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")


async def _validate_scope(target: str, mcp_service) -> str | None:
    """Check target against per-assessment scope. Returns error message or None."""
    if not mcp_service.current_assessment_id:
        return None  # No assessment selected, skip validation
    if not mcp_service.scope_provider:
        return None  # Scope provider not initialized, skip validation

    try:
        validator = await mcp_service.scope_provider.get_validator(
            mcp_service.current_assessment_id
        )
        if validator is None:
            return None  # No scope configured, skip validation
        result = validator.validate_target(target)
        if not result.valid:
            return f"Target out of scope: {target} â€” {result.reason}"
    except Exception as e:
        logger.warning(f"Scope validation failed: {e}")
        pass
    return None


def get_scanning_tools() -> List[Tool]:
    return [
        Tool(
            name="scan",
            description=(
                "Run security scans with common tools. Supports nmap (port/service/vuln scanning), "
                "gobuster/ffuf/dirb (directory discovery), and nikto (web server vulnerability scanning). "

                "**When to use:** Phase 1 (Recon) after confirming target is in scope. Use nmap_quick for "
                "initial port discovery, nmap_full for comprehensive service enumeration, or nmap_vuln "
                "for known vulnerability checks. Use gobuster/ffuf for web directory discovery. "

                "**Dependencies:** Call scope_validate_target() first to ensure target is in scope. "
                "Follow with tech_detection() and ssl_analysis() on discovered services. "

                "**Budget impact:** MEDIUM-HIGH - nmap_full and directory scans generate 100-1000 requests. "
                "nmap_quick is lower cost (~100 requests). Directory scans cost varies by wordlist size. "

                "**Failure modes:** Firewalls may block scans (empty results = likely filtered). Directory "
                "scans may return 0 results if app uses non-standard paths - try authenticated crawler "
                "instead. Nmap vuln scripts may timeout on slow targets - reduce scope or use nmap_quick. "

                "**Risk level:** CAUTION - Active reconnaissance detectable by IDS/IPS. Nmap vuln scripts "
                "may trigger security alerts. Directory scans generate high request volume. "

                "**Returns:** Scan output with auto-parsed recon data. Nmap: port/service/version details. "
                "Directory scans: discovered paths with status codes. Nikto: potential vulnerabilities. "
                "All results auto-saved to recon data and knowledge store for later recall."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "type": {
                        "type": "string",
                        "enum": ["nmap_quick", "nmap_full", "nmap_vuln", "dirb", "nikto", "gobuster", "ffuf"],
                        "description": "Scan type: nmap_quick (fast top ports), nmap_full (all ports + version), nmap_vuln (vuln scripts), dirb/gobuster/ffuf (web fuzzing), nikto (web server scan)"
                    },
                    "target": {
                        "type": "string",
                        "description": "Target IP, domain, or URL (include http:// for web scans)"
                    },
                    "ports": {
                        "type": "string",
                        "description": "Port specification for nmap (e.g., '80,443', '1-1000', '22,80,443,8080'). Default: top 100 for quick, all for full."
                    },
                    "wordlist": {
                        "type": "string",
                        "enum": ["common", "medium", "large", "dirb", "raft-small", "raft-medium"],
                        "description": "Wordlist for directory/file discovery. common=fast, medium=balanced, large=thorough. Default: common"
                    },
                    "extensions": {
                        "type": "string",
                        "description": "File extensions to check (e.g., 'php,html,js,txt'). Applies to gobuster/ffuf/dirb."
                    },
                    "threads": {
                        "type": "integer",
                        "description": "Number of threads for parallel scanning. Default: 10 for web fuzzers."
                    },
                    "extra_flags": {
                        "type": "string",
                        "description": "Additional flags to pass to the underlying tool (e.g., '-sC' for nmap scripts, '--follow-redirect' for ffuf)"
                    }
                },
                "required": ["type", "target"]
            }
        ),
        Tool(
            name="subdomain_enum",
            description=(
                "Perform comprehensive subdomain enumeration using subfinder and amass. "
                "Discovers subdomains via DNS records, certificate transparency logs, "
                "search engines, and passive sources. "

                "**When to use:** Phase 1 (Recon) after identifying the primary domain. "
                "Call this before service scanning to discover the full attack surface. "
                "Essential for expanding scope from a single domain to all associated subdomains. "

                "**Dependencies:** Run after scope_validate_target() confirms domain is in scope. "
                "Follow up with scan(type='nmap_quick') on discovered subdomains to identify services. "
                "For each subdomain, validate scope before testing. "

                "**Budget impact:** LOW - passive reconnaissance only, no requests to target. "
                "Queries public databases and DNS records. Completes in 30-120 seconds typically. "

                "**Failure modes:** May return empty if domain is new/unlisted in public databases. "
                "In this case, proceed with directory discovery on the main domain. Some discovered "
                "subdomains may be out of scope - validate each with scope_validate_target() before "
                "testing. Private subdomains (internal networks) won't be found. "

                "**Risk level:** SAFE - passive reconnaissance, no interaction with target systems. "
                "No requests sent to target infrastructure. "

                "**Returns:** List of discovered subdomains with parent domain linkage. Automatically "
                "stores in world model as subdomain assets and recon data for later reference. Results "
                "also saved to knowledge store for full-text search."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "domain": {
                        "type": "string",
                        "description": "Domain to enumerate subdomains for"
                    }
                },
                "required": ["domain"]
            }
        ),
        Tool(
            name="ssl_analysis",
            description=(
                "Analyze SSL/TLS certificate of target. Extracts certificate details including "
                "issuer, expiration date, subject alternative names (SANs), and cryptographic "
                "algorithms. Useful for discovering additional domains/subdomains in SANs. "

                "**When to use:** Phase 1 (Recon) after discovering HTTPS services via port scan. "
                "Particularly valuable for finding related domains listed in certificate SANs. "
                "Run on port 443 or any other HTTPS port discovered. "

                "**Dependencies:** Target must have SSL/TLS enabled (port 443 or custom HTTPS port). "
                "Run after scan() identifies open HTTPS services. Validate each discovered SAN "
                "domain with scope_validate_target() before testing. "

                "**Budget impact:** LOW - single TLS handshake per target (~1 request). "
                "Completes in under 5 seconds per host. "

                "**Failure modes:** Fails if target doesn't support TLS/SSL or uses client certificate "
                "authentication. Self-signed certificates still work (analysis succeeds regardless of "
                "trust). If connection refused, ensure port 443 is open via scan() first. "

                "**Risk level:** SAFE - Read-only TLS handshake, standard browser-like behavior. "
                "No vulnerability exploitation or unusual requests. "

                "**Returns:** Certificate details including subject, issuer, validity dates, SANs, "
                "and signature algorithm. Any SAN domains found can be tested as additional targets. "
                "Results auto-saved to knowledge store for later reference."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target": {
                        "type": "string",
                        "description": "Target host:port (default port 443)"
                    }
                },
                "required": ["target"]
            }
        ),
        Tool(
            name="tech_detection",
            description=(
                "Detect technology stack of a website using Wappalyzer and WhatWeb. Identifies "
                "web servers, frameworks, CMS platforms, JavaScript libraries, analytics tools, "
                "and backend technologies. "

                "**When to use:** Phase 1 (Recon) after confirming a web service is accessible. "
                "Run on all discovered web servers to identify potential attack vectors based on "
                "known vulnerabilities in detected technologies. Essential for targeting exploits "
                "to specific versions. "

                "**Dependencies:** Target must be an HTTP/HTTPS service responding to requests. "
                "Run after scan() confirms web service is accessible. Follow with nuclei_scan_template() "
                "filtered to detected technologies (e.g., 'wordpress', 'apache', 'nginx'). "

                "**Budget impact:** LOW - 2-3 HTTP requests per target (HEAD, GET, and fingerprint "
                "requests). Completes in under 10 seconds per host. "

                "**Failure modes:** May miss technologies if server blocks fingerprinting tools or "
                "if app uses heavily customized/obscured stack. JavaScript-heavy SPAs may require "
                "browser-based detection (use browser_navigate instead). Returns partial results "
                "rather than failing completely. "

                "**Risk level:** SAFE - Standard HTTP requests similar to browser traffic. No "
                "exploitation attempts. May be logged as reconnaissance activity but not malicious. "

                "**Returns:** Technology stack report with identified software, versions (when detectable), "
                "and categories (web server, CMS, framework, etc.). Use this to inform nuclei template "
                "selection and custom exploit targeting. Auto-saved to recon data and knowledge store."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "URL to analyze"
                    }
                },
                "required": ["url"]
            }
        ),
        Tool(
            name="tool_help",
            description=(
                "Get help documentation for a specific Kali Linux tool. Checks if tool is available "
                "in the container and displays usage information from --help, -h, or man pages. "

                "**When to use:** Before using execute() with unfamiliar tools. When you need to "
                "verify exact command syntax, available flags, or tool capabilities. Use this to "
                "discover tool features before crafting custom commands. "

                "**Dependencies:** Tool must be installed in the Kali container. If tool_help() "
                "returns 'not available', the tool either isn't installed or isn't in PATH. "

                "**Budget impact:** LOW - no target interaction, only container command execution. "
                "Completes in under 2 seconds. "

                "**Failure modes:** Some tools don't provide --help output (returns empty or error). "
                "In this case, consult external documentation or use execute() with known syntax. "
                "Tools that require X11/GUI won't show meaningful help in CLI mode. "

                "**Risk level:** SAFE - no target interaction, only local container introspection. "

                "**Returns:** Tool help text showing usage, flags, examples, and options. Use this "
                "to construct valid execute() commands with correct syntax."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "tool": {
                        "type": "string",
                        "description": "Name of the tool to get help for"
                    }
                },
                "required": ["tool"]
            }
        ),
        Tool(
            name="check_subdomain_takeover",
            description=(
                "Check subdomains for takeover vulnerabilities by resolving CNAME chains and matching "
                "against known provider fingerprints. Detects dangling DNS records pointing to "
                "unclaimed resources on cloud providers (GitHub Pages, S3, Heroku, Azure, etc.). "

                "**When to use:** Phase 1 (Recon) after subdomain_enum() discovers subdomains. "
                "Run on all discovered subdomains to identify takeover opportunities. "

                "**Dependencies:** Run after subdomain_enum() or provide subdomains manually. "
                "If empty, auto-fetches subdomains from wm_assets. "

                "**Budget impact:** LOW-MEDIUM - 1 DNS query + 1 HTTP request per subdomain. "

                "**Risk level:** SAFE - passive DNS resolution + single HTTP GET per subdomain."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "subdomains": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Subdomains to check. If empty, auto-fetches from wm_assets."
                    }
                }
            }
        ),
    ]


async def handle_scanning_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    if name == "scan":
        return await _handle_scan(arguments, mcp_service)
    elif name == "subdomain_enum":
        return await _handle_subdomain_enum(arguments, mcp_service)
    elif name == "ssl_analysis":
        return await _handle_ssl_analysis(arguments, mcp_service)
    elif name == "tech_detection":
        return await _handle_tech_detection(arguments, mcp_service)
    elif name == "tool_help":
        return await _handle_tool_help(arguments, mcp_service)
    elif name == "check_subdomain_takeover":
        return await _handle_check_subdomain_takeover(arguments, mcp_service)
    return [TextContent(type="text", text=f"Unknown scanning tool: {name}")]


async def _handle_scan(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle scan with enhanced options for custom ports, wordlists, extensions, and more"""
    if not mcp_service.current_container:
        return [TextContent(type="text", text="No container selected for scanning.")]

    scan_type = arguments["type"]
    target = arguments["target"]

    # Scope validation
    scope_error = await _validate_scope(target, mcp_service)
    if scope_error:
        return [TextContent(type="text", text=scope_error)]

    # Optional parameters
    ports = arguments.get("ports")
    wordlist = arguments.get("wordlist", "common")
    extensions = arguments.get("extensions")
    threads = arguments.get("threads", 10)
    extra_flags = arguments.get("extra_flags", "")

    # Wordlist mapping (paths for Kali)
    WORDLISTS = {
        "common": "/usr/share/dirb/wordlists/common.txt",
        "medium": "/usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt",
        "large": "/usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-big.txt",
        "dirb": "/usr/share/dirb/wordlists/big.txt",
        "raft-small": "/usr/share/seclists/Discovery/Web-Content/raft-small-words.txt",
        "raft-medium": "/usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt"
    }

    selected_wordlist = WORDLISTS.get(wordlist, WORDLISTS["common"])

    # Build commands dynamically based on scan type
    if scan_type == "nmap_quick":
        # Fast scan with version detection
        port_arg = f"-p {ports}" if ports else "-F"  # -F = fast (top 100 ports)
        command = f"nmap -sV {port_arg} {extra_flags} {target}".strip()

    elif scan_type == "nmap_full":
        # Comprehensive scan with all ports
        port_arg = f"-p {ports}" if ports else "-p-"  # All ports
        command = f"nmap -sS -sV -O -T4 {port_arg} {extra_flags} {target}".strip()

    elif scan_type == "nmap_vuln":
        # Vulnerability script scan
        port_arg = f"-p {ports}" if ports else ""
        command = f"nmap -sV --script=vuln {port_arg} {extra_flags} {target}".strip()

    elif scan_type == "gobuster":
        # Ensure target has protocol
        url = target if target.startswith(("http://", "https://")) else f"http://{target}"
        ext_arg = f"-x {extensions}" if extensions else ""
        command = f"gobuster dir -u {url} -w {selected_wordlist} -t {threads} {ext_arg} {extra_flags}".strip()

    elif scan_type == "ffuf":
        # Fast web fuzzer - ensure target has FUZZ placeholder or add one
        url = target if target.startswith(("http://", "https://")) else f"http://{target}"
        if "FUZZ" not in url:
            url = f"{url.rstrip('/')}/FUZZ"
        ext_arg = f"-e {extensions}" if extensions else ""
        command = f"ffuf -u {url} -w {selected_wordlist} -t {threads} {ext_arg} {extra_flags}".strip()

    elif scan_type == "dirb":
        url = target if target.startswith(("http://", "https://")) else f"http://{target}"
        ext_arg = f"-X .{extensions.replace(',', ',.')}" if extensions else ""
        command = f"dirb {url} {selected_wordlist} {ext_arg} {extra_flags}".strip()

    elif scan_type == "nikto":
        command = f"nikto -h {target} {extra_flags}".strip()

    else:
        return [TextContent(type="text", text=f"Unknown scan type: {scan_type}")]

    # Check if tool is available
    tool_name = command.split()[0]
    if not await mcp_service.check_tool_availability(tool_name):
        return [TextContent(type="text",
                            text=f"Tool `{tool_name}` not available in container.")]

    response = f"**Starting {scan_type} scan on `{target}`**\n"
    response += f"Command: `{command}`\n\n"

    result = await mcp_service.execute_container_command(
        mcp_service.current_container, command
    )

    if result["success"]:
        response += f"**Results:**\n```\n{result['stdout']}\n```"
        if result.get("stderr"):
            response += f"\n**Warnings:**\n```\n{result['stderr']}\n```"

        # Auto-save scan results to backend
        stdout = result.get("stdout", "")
        autosave_warnings = await _autosave_scan_results(scan_type, target, stdout, mcp_service)
        if autosave_warnings:
            response += f"\n**Autosave warnings ({len(autosave_warnings)}):**\n"
            for w in autosave_warnings:
                response += f"- {w}\n"

        # Auto-capture full scan output to knowledge store
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="scan", category="scan_output",
            title=f"{scan_type} scan on {target}",
            content=stdout,
            target=target,
            metadata={"scan_type": scan_type, "command": command},
            tags=[scan_type, "scan"],
        )
    else:
        error_msg = result.get("stderr") or result.get("error", "Unknown error")
        response += f"**Scan failed:**\n```\n{error_msg}\n```"

    return [TextContent(type="text", text=response)]


async def _autosave_scan_results(scan_type: str, target: str, stdout: str, mcp_service) -> List[str]:
    """Parse scan output and auto-save findings/recon to backend.

    Returns a list of warning messages for any failures during autosave.
    """
    warnings: List[str] = []
    if not mcp_service or not stdout:
        return warnings

    try:
        if scan_type.startswith("nmap"):
            # Parse nmap output for open ports/services
            # Match lines like: "80/tcp   open  http    Apache httpd 2.4.49"
            recon_entries = []
            for line in stdout.splitlines():
                match = re.match(r'(\d+)/tcp\s+open\s+(\S+)\s*(.*)', line)
                if match:
                    port, service, version = match.groups()
                    recon_entries.append({
                        "data_type": "service",
                        "name": f"{target}:{port} ({service})",
                        "details": {
                            "port": int(port),
                            "service": service,
                            "version": version.strip(),
                            "target": target,
                        },
                        "discovered_in_phase": "reconnaissance",
                    })
            if recon_entries:
                result = await mcp_service.safe_add_recon_batch(recon_entries)
                if not result.ok:
                    warnings.append(f"nmap recon save failed: {result.reason}")

        elif scan_type in ("gobuster", "ffuf", "dirb"):
            # Parse discovered paths
            recon_entries = []
            for line in stdout.splitlines():
                # gobuster: "/admin (Status: 200) [Size: 1234]"
                gob_match = re.match(r'(/\S+)\s+\(Status:\s*(\d+)\)', line)
                if gob_match:
                    path, status = gob_match.groups()
                    if status in ("200", "301", "302", "403"):
                        recon_entries.append({
                            "data_type": "endpoint",
                            "name": f"GET {path}",
                            "details": {"path": path, "status_code": int(status), "target": target},
                            "discovered_in_phase": "reconnaissance",
                        })
                    continue
                # ffuf: "admin [Status: 200, Size: 1234, ...]"
                ffuf_match = re.match(r'(\S+)\s+\[Status:\s*(\d+)', line)
                if ffuf_match:
                    word, status = ffuf_match.groups()
                    if status in ("200", "301", "302", "403"):
                        recon_entries.append({
                            "data_type": "endpoint",
                            "name": f"GET /{word}",
                            "details": {"path": f"/{word}", "status_code": int(status), "target": target},
                            "discovered_in_phase": "reconnaissance",
                        })
            if recon_entries:
                result = await mcp_service.safe_add_recon_batch(recon_entries)
                if not result.ok:
                    warnings.append(f"dir scan recon save failed: {result.reason}")

                # Auto-create wm_endpoints from discovered paths (Part 1F)
                await _autocreate_wm_endpoints(recon_entries, target, mcp_service)

        elif scan_type == "nikto":
            # Parse nikto output for findings (lines with OSVDB or CVE)
            for line in stdout.splitlines():
                if "OSVDB" in line or "CVE" in line:
                    # Clean up the line
                    clean = line.strip().lstrip("+ ")
                    if clean:
                        result = await mcp_service.safe_add_card(
                            card_type="observation",
                            title=f"Nikto: {clean[:80]}",
                            severity="MEDIUM",
                            target_service=target,
                            technical_analysis=clean,
                            context="Source: nikto scan",
                        )
                        if not result.ok and not result.skipped:
                            warnings.append(f"nikto card save failed: {result.reason}")
    except Exception as e:
        logger.warning(f"_autosave_scan_results failed: {e}")
        warnings.append(f"autosave exception: {e}")

    return warnings


async def _autocreate_wm_endpoints(
    recon_entries: List[dict], target: str, mcp_service
) -> None:
    """Auto-create wm_endpoints from directory scan recon entries (best-effort)."""
    try:
        if mcp_service.current_assessment_id is None:
            return

        from lib.world_model_db import get_world_model_db
        from urllib.parse import urlparse

        db = await get_world_model_db(mcp_service.current_assessment_id)

        # Parse host from target
        parsed = urlparse(target if "://" in target else f"http://{target}")
        host = parsed.hostname or target

        # Get or create domain asset
        existing_assets = await db.query("assets", filters={"name": host}, limit=1)
        if existing_assets:
            asset_id = existing_assets[0]["id"]
        else:
            asset = await db.add_asset(kind="domain", name=host)
            asset_id = asset["id"]

        # Create endpoints
        for entry in recon_entries:
            path = entry.get("details", {}).get("path", "")
            if path:
                try:
                    await db.add_endpoint(
                        asset_id=asset_id, method="GET", path=path
                    )
                except Exception:
                    pass  # Duplicate or other error
    except Exception as exc:
        logger.debug("_autocreate_wm_endpoints failed: %s", exc)


async def _handle_subdomain_enum(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle subdomain_enum"""
    domain = arguments["domain"]

    # Scope validation
    scope_error = await _validate_scope(domain, mcp_service)
    if scope_error:
        return [TextContent(type="text", text=scope_error)]

    result = await mcp_service.subdomain_enumeration(domain)

    if not result["success"]:
        return [TextContent(type="text", text=f"Error: {result['error']}")]

    response = f"**Subdomain Enumeration for `{domain}`:**\n\n"

    # Collect unique subdomains from all results
    all_subdomains = set()
    for i, cmd_result in enumerate(result["results"], 1):
        response += f"**Method {i}:** `{cmd_result['command'].split()[0]}`\n"
        if cmd_result["success"] and cmd_result["output"]:
            response += f"```\n{cmd_result['output']}\n```\n"
            # Parse subdomains from output (one per line)
            for line in cmd_result["output"].splitlines():
                sub = line.strip()
                if sub and "." in sub and not sub.startswith("["):
                    all_subdomains.add(sub)
        elif cmd_result["error"]:
            response += f"Error: {cmd_result['error']}\n"
        response += "\n"

    # Auto-save discovered subdomains as recon
    if all_subdomains:
        recon_entries = [
            {
                "data_type": "subdomain",
                "name": sub,
                "details": {"parent_domain": domain},
                "discovered_in_phase": "reconnaissance",
            }
            for sub in sorted(all_subdomains)
        ]
        await mcp_service.safe_add_recon_batch(recon_entries)

    # Auto-capture to knowledge store
    from lib.knowledge_capture import capture_knowledge
    await capture_knowledge(
        mcp_service, source_tool="subdomain_enum", category="scan_output",
        title=f"Subdomain enumeration: {domain}",
        content=response,
        target=domain,
        tags=["subdomain", "scan"],
    )

    return [TextContent(type="text", text=response)]


async def _handle_ssl_analysis(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle ssl_analysis"""
    target = arguments["target"]

    # Scope validation
    scope_error = await _validate_scope(target, mcp_service)
    if scope_error:
        return [TextContent(type="text", text=scope_error)]

    result = await mcp_service.ssl_analysis(target)

    if not result["success"]:
        return [TextContent(type="text", text=f"Error: {result['error']}")]

    response = f"**SSL Analysis for `{target}`:**\n\n"

    for cmd_result in result["results"]:
        if cmd_result["success"] and cmd_result["output"]:
            response += f"**{cmd_result['command'].replace('openssl x509 -noout -', '').title()}:**\n"
            response += f"```\n{cmd_result['output']}\n```\n\n"
        elif cmd_result["error"]:
            response += f"Error in {cmd_result['command']}: {cmd_result['error']}\n\n"

    # Auto-capture to knowledge store
    from lib.knowledge_capture import capture_knowledge
    await capture_knowledge(
        mcp_service, source_tool="ssl_analysis", category="scan_output",
        title=f"SSL analysis: {target}",
        content=response,
        target=target,
        tags=["ssl", "scan"],
    )

    return [TextContent(type="text", text=response)]


async def _handle_tech_detection(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle tech_detection"""
    url = arguments["url"]

    # Scope validation
    scope_error = await _validate_scope(url, mcp_service)
    if scope_error:
        return [TextContent(type="text", text=scope_error)]

    result = await mcp_service.tech_stack_detection(url)

    if not result["success"]:
        return [TextContent(type="text", text=f"Error: {result['error']}")]

    response = f"**Technology Detection for `{url}`:**\n\n"

    for cmd_result in result["results"]:
        if cmd_result["success"] and cmd_result["output"]:
            response += f"**{cmd_result['command'].split()[0].upper()}:**\n"
            response += f"```\n{cmd_result['output']}\n```\n\n"
        elif cmd_result["error"]:
            response += f"Error with {cmd_result['command']}: {cmd_result['error']}\n\n"

    # Auto-capture to knowledge store
    from lib.knowledge_capture import capture_knowledge
    await capture_knowledge(
        mcp_service, source_tool="tech_detection", category="scan_output",
        title=f"Tech detection: {url}",
        content=response,
        target=url,
        tags=["tech_detection", "scan"],
    )

    return [TextContent(type="text", text=response)]


async def _handle_tool_help(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle tool_help"""
    if not mcp_service.current_container:
        return [TextContent(type="text", text="No container selected.")]

    tool = arguments["tool"]

    # First check if tool is available
    available = await mcp_service.check_tool_availability(tool)
    if not available:
        return [TextContent(type="text",
                            text=f"Tool `{tool}` not available in container `{mcp_service.current_container}`")]

    response = f"**Help for `{tool}`:**\n\n"

    # Try different help options in sequence
    help_commands = [f"{tool} -h", f"{tool} --help", f"{tool} help", f"man {tool}"]

    for help_cmd in help_commands:
        result = await mcp_service.execute_container_command(
            mcp_service.current_container, help_cmd
        )

        if result["success"] and result.get("stdout"):
            response += f"**Command:** `{help_cmd}`\n"
            response += f"```\n{result['stdout']}\n```"
            break
        elif result.get("stderr") and "usage" in result["stderr"].lower():
            response += f"**Command:** `{help_cmd}`\n"
            response += f"```\n{result['stderr']}\n```"
            break
    else:
        response += f"No help documentation found for `{tool}`"

    return [TextContent(type="text", text=response)]


# ---------------------------------------------------------------------------
# Subdomain Takeover Detection
# ---------------------------------------------------------------------------

TAKEOVER_FINGERPRINTS = {
    "github.io": ("GitHub Pages", "There isn't a GitHub Pages site here"),
    "s3.amazonaws.com": ("AWS S3", "NoSuchBucket"),
    "amazonaws.com": ("AWS", "NoSuchBucket"),
    "herokuapp.com": ("Heroku", "No such app"),
    "cloudfront.net": ("CloudFront", "The request could not be satisfied"),
    "azurewebsites.net": ("Azure", "404 Web Site not found"),
    "azure-api.net": ("Azure API", "404 Resource Not Found"),
    "fastly.net": ("Fastly", "Fastly error: unknown domain"),
    "netlify.app": ("Netlify", "Not Found - Request ID"),
    "vercel.app": ("Vercel", "The deployment could not be found"),
    "surge.sh": ("Surge", "project not found"),
    "bitbucket.io": ("Bitbucket", "Repository not found"),
    "ghost.io": ("Ghost", "The thing you were looking for is no longer here"),
    "myshopify.com": ("Shopify", "Sorry, this shop is currently unavailable"),
    "zendesk.com": ("Zendesk", "Help Center Closed"),
    "helpscoutdocs.com": ("Help Scout", "No settings were found for this company"),
    "readme.io": ("ReadMe", "Project doesnt exist"),
    "tictail.com": ("Tictail", "to target URL: https://tictail.com"),
}


async def _handle_check_subdomain_takeover(args: dict, mcp_service) -> List[TextContent]:
    """Check subdomains for takeover vulnerabilities."""
    import httpx

    subdomains = args.get("subdomains", [])

    # Auto-fetch from wm_assets if not provided
    if not subdomains:
        try:
            from lib.tool_helpers import _get_db
            db = await _get_db(mcp_service)
            assets = await db.query("assets", {"kind": "subdomain"})
            subdomains = [a["name"] for a in assets if a.get("name")]
        except Exception:
            pass

    if not subdomains:
        return [TextContent(type="text", text=json.dumps({
            "success": False,
            "error": "No subdomains provided and none found in wm_assets",
        }))]

    results = []

    for subdomain in subdomains:
        result = {
            "subdomain": subdomain,
            "cname_chain": [],
            "provider": None,
            "fingerprint_match": None,
            "confidence": "none",
            "takeover_possible": False,
        }

        # Resolve CNAME chain
        cname_chain = []
        try:
            if hasattr(mcp_service, "execute_container_command"):
                dig_output = await mcp_service.execute_container_command(
                    "kali", f"dig +short CNAME {subdomain}"
                )
                raw = dig_output.get("stdout", "") if isinstance(dig_output, dict) else str(dig_output)
                cname_chain = [
                    line.strip().rstrip(".")
                    for line in raw.strip().split("\n")
                    if line.strip()
                ]
            else:
                proc = await asyncio.create_subprocess_exec(
                    "dig", "+short", "CNAME", subdomain,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
                stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=10.0)
                cname_output = stdout.decode() if stdout else ""
                cname_chain = [
                    line.strip().rstrip(".")
                    for line in cname_output.strip().split("\n")
                    if line.strip()
                ]
        except Exception as e:
            result["cname_error"] = str(e)

        result["cname_chain"] = cname_chain

        # Check terminal CNAME against fingerprints
        terminal = cname_chain[-1] if cname_chain else subdomain

        matched_provider = None
        for fingerprint_domain, (provider_name, _) in TAKEOVER_FINGERPRINTS.items():
            if fingerprint_domain in terminal:
                matched_provider = provider_name
                result["provider"] = provider_name
                result["confidence"] = "medium"
                break

        # HTTP body check
        if matched_provider:
            try:
                async with httpx.AsyncClient(timeout=10, follow_redirects=True, verify=False) as client:
                    resp = await client.get(f"http://{subdomain}")
                    body = resp.text

                    for fp_domain, (prov, fp_string) in TAKEOVER_FINGERPRINTS.items():
                        if prov == matched_provider and fp_string.lower() in body.lower():
                            result["fingerprint_match"] = fp_string
                            result["takeover_possible"] = True
                            result["confidence"] = "high"
                            break
            except Exception as http_err:
                result["http_check_error"] = str(http_err)
                err_str = str(http_err)
                if "NXDOMAIN" in err_str or "Name or service not known" in err_str:
                    result["takeover_possible"] = True
                    result["confidence"] = "medium"

        results.append(result)

    vulnerable = [r for r in results if r["takeover_possible"]]

    return [TextContent(type="text", text=json.dumps({
        "total_checked": len(results),
        "vulnerable_count": len(vulnerable),
        "vulnerable": vulnerable,
        "results": results,
    }, indent=2))]
