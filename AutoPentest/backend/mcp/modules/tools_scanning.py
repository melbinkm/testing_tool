"""
Scanning & Reconnaissance Tools - scan, subdomain_enum, ssl_analysis, tech_detection, tool_help
"""
import json
import logging
import re
from typing import List
from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")


def get_scanning_tools() -> List[Tool]:
    return [
        Tool(
            name="scan",
            description="Run security scans with common tools. Use optional parameters for advanced control, or use execute() for full flexibility.",
            inputSchema={
                "type": "object",
                "properties": {
                    "type": {
                        "type": "string",
                        "enum": ["nmap_quick", "nmap_full", "nmap_vuln", "dirb", "nikto", "gobuster", "ffuf"],
                        "description": "Scan type: nmap_quick (fast top ports), nmap_full (all ports + version), nmap_vuln (vuln scripts), dirb/gobuster/ffuf (web fuzzing), nikto (web server scan)"
                    },
                    "target": {
                        "type": "string",
                        "description": "Target IP, domain, or URL (include http:// for web scans)"
                    },
                    "ports": {
                        "type": "string",
                        "description": "Port specification for nmap (e.g., '80,443', '1-1000', '22,80,443,8080'). Default: top 100 for quick, all for full."
                    },
                    "wordlist": {
                        "type": "string",
                        "enum": ["common", "medium", "large", "dirb", "raft-small", "raft-medium"],
                        "description": "Wordlist for directory/file discovery. common=fast, medium=balanced, large=thorough. Default: common"
                    },
                    "extensions": {
                        "type": "string",
                        "description": "File extensions to check (e.g., 'php,html,js,txt'). Applies to gobuster/ffuf/dirb."
                    },
                    "threads": {
                        "type": "integer",
                        "description": "Number of threads for parallel scanning. Default: 10 for web fuzzers."
                    },
                    "extra_flags": {
                        "type": "string",
                        "description": "Additional flags to pass to the underlying tool (e.g., '-sC' for nmap scripts, '--follow-redirect' for ffuf)"
                    }
                },
                "required": ["type", "target"]
            }
        ),
        Tool(
            name="subdomain_enum",
            description="Perform subdomain enumeration using subfinder/amass",
            inputSchema={
                "type": "object",
                "properties": {
                    "domain": {
                        "type": "string",
                        "description": "Domain to enumerate subdomains for"
                    }
                },
                "required": ["domain"]
            }
        ),
        Tool(
            name="ssl_analysis",
            description="Analyze SSL certificate of target",
            inputSchema={
                "type": "object",
                "properties": {
                    "target": {
                        "type": "string",
                        "description": "Target host:port (default port 443)"
                    }
                },
                "required": ["target"]
            }
        ),
        Tool(
            name="tech_detection",
            description="Detect technology stack of a website",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "URL to analyze"
                    }
                },
                "required": ["url"]
            }
        ),
        Tool(
            name="tool_help",
            description="Get help documentation for a specific tool (checks availability and shows usage)",
            inputSchema={
                "type": "object",
                "properties": {
                    "tool": {
                        "type": "string",
                        "description": "Name of the tool to get help for"
                    }
                },
                "required": ["tool"]
            }
        ),
    ]


async def handle_scanning_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    if name == "scan":
        return await _handle_scan(arguments, mcp_service)
    elif name == "subdomain_enum":
        return await _handle_subdomain_enum(arguments, mcp_service)
    elif name == "ssl_analysis":
        return await _handle_ssl_analysis(arguments, mcp_service)
    elif name == "tech_detection":
        return await _handle_tech_detection(arguments, mcp_service)
    elif name == "tool_help":
        return await _handle_tool_help(arguments, mcp_service)
    return [TextContent(type="text", text=f"Unknown scanning tool: {name}")]


async def _handle_scan(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle scan with enhanced options for custom ports, wordlists, extensions, and more"""
    if not mcp_service.current_container:
        return [TextContent(type="text", text="No container selected for scanning.")]

    scan_type = arguments["type"]
    target = arguments["target"]

    # Optional parameters
    ports = arguments.get("ports")
    wordlist = arguments.get("wordlist", "common")
    extensions = arguments.get("extensions")
    threads = arguments.get("threads", 10)
    extra_flags = arguments.get("extra_flags", "")

    # Wordlist mapping (paths for Kali)
    WORDLISTS = {
        "common": "/usr/share/dirb/wordlists/common.txt",
        "medium": "/usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-medium.txt",
        "large": "/usr/share/seclists/Discovery/Web-Content/DirBuster-2007_directory-list-2.3-big.txt",
        "dirb": "/usr/share/dirb/wordlists/big.txt",
        "raft-small": "/usr/share/seclists/Discovery/Web-Content/raft-small-words.txt",
        "raft-medium": "/usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt"
    }

    selected_wordlist = WORDLISTS.get(wordlist, WORDLISTS["common"])

    # Build commands dynamically based on scan type
    if scan_type == "nmap_quick":
        # Fast scan with version detection
        port_arg = f"-p {ports}" if ports else "-F"  # -F = fast (top 100 ports)
        command = f"nmap -sV {port_arg} {extra_flags} {target}".strip()

    elif scan_type == "nmap_full":
        # Comprehensive scan with all ports
        port_arg = f"-p {ports}" if ports else "-p-"  # All ports
        command = f"nmap -sS -sV -O -T4 {port_arg} {extra_flags} {target}".strip()

    elif scan_type == "nmap_vuln":
        # Vulnerability script scan
        port_arg = f"-p {ports}" if ports else ""
        command = f"nmap -sV --script=vuln {port_arg} {extra_flags} {target}".strip()

    elif scan_type == "gobuster":
        # Ensure target has protocol
        url = target if target.startswith(("http://", "https://")) else f"http://{target}"
        ext_arg = f"-x {extensions}" if extensions else ""
        command = f"gobuster dir -u {url} -w {selected_wordlist} -t {threads} {ext_arg} {extra_flags}".strip()

    elif scan_type == "ffuf":
        # Fast web fuzzer - ensure target has FUZZ placeholder or add one
        url = target if target.startswith(("http://", "https://")) else f"http://{target}"
        if "FUZZ" not in url:
            url = f"{url.rstrip('/')}/FUZZ"
        ext_arg = f"-e {extensions}" if extensions else ""
        command = f"ffuf -u {url} -w {selected_wordlist} -t {threads} {ext_arg} {extra_flags}".strip()

    elif scan_type == "dirb":
        url = target if target.startswith(("http://", "https://")) else f"http://{target}"
        ext_arg = f"-X .{extensions.replace(',', ',.')}" if extensions else ""
        command = f"dirb {url} {selected_wordlist} {ext_arg} {extra_flags}".strip()

    elif scan_type == "nikto":
        command = f"nikto -h {target} {extra_flags}".strip()

    else:
        return [TextContent(type="text", text=f"Unknown scan type: {scan_type}")]

    # Check if tool is available
    tool_name = command.split()[0]
    if not await mcp_service.check_tool_availability(tool_name):
        return [TextContent(type="text",
                            text=f"Tool `{tool_name}` not available in container.")]

    response = f"**Starting {scan_type} scan on `{target}`**\n"
    response += f"Command: `{command}`\n\n"

    result = await mcp_service.execute_container_command(
        mcp_service.current_container, command
    )

    if result["success"]:
        response += f"**Results:**\n```\n{result['stdout']}\n```"
        if result.get("stderr"):
            response += f"\n**Warnings:**\n```\n{result['stderr']}\n```"

        # Auto-save scan results to backend
        stdout = result.get("stdout", "")
        await _autosave_scan_results(scan_type, target, stdout, mcp_service)

        # Auto-capture full scan output to knowledge store
        from lib.knowledge_capture import capture_knowledge
        await capture_knowledge(
            mcp_service, source_tool="scan", category="scan_output",
            title=f"{scan_type} scan on {target}",
            content=stdout,
            target=target,
            metadata={"scan_type": scan_type, "command": command},
            tags=[scan_type, "scan"],
        )
    else:
        error_msg = result.get("stderr") or result.get("error", "Unknown error")
        response += f"**Scan failed:**\n```\n{error_msg}\n```"

    return [TextContent(type="text", text=response)]


async def _autosave_scan_results(scan_type: str, target: str, stdout: str, mcp_service) -> None:
    """Parse scan output and auto-save findings/recon to backend."""
    if not mcp_service or not stdout:
        return

    try:
        if scan_type.startswith("nmap"):
            # Parse nmap output for open ports/services
            # Match lines like: "80/tcp   open  http    Apache httpd 2.4.49"
            recon_entries = []
            for line in stdout.splitlines():
                match = re.match(r'(\d+)/tcp\s+open\s+(\S+)\s*(.*)', line)
                if match:
                    port, service, version = match.groups()
                    recon_entries.append({
                        "data_type": "service",
                        "name": f"{target}:{port} ({service})",
                        "details": {
                            "port": int(port),
                            "service": service,
                            "version": version.strip(),
                            "target": target,
                        },
                        "discovered_in_phase": "reconnaissance",
                    })
            if recon_entries:
                await mcp_service.safe_add_recon_batch(recon_entries)

        elif scan_type in ("gobuster", "ffuf", "dirb"):
            # Parse discovered paths
            recon_entries = []
            for line in stdout.splitlines():
                # gobuster: "/admin (Status: 200) [Size: 1234]"
                gob_match = re.match(r'(/\S+)\s+\(Status:\s*(\d+)\)', line)
                if gob_match:
                    path, status = gob_match.groups()
                    if status in ("200", "301", "302", "403"):
                        recon_entries.append({
                            "data_type": "endpoint",
                            "name": f"GET {path}",
                            "details": {"path": path, "status_code": int(status), "target": target},
                            "discovered_in_phase": "reconnaissance",
                        })
                    continue
                # ffuf: "admin [Status: 200, Size: 1234, ...]"
                ffuf_match = re.match(r'(\S+)\s+\[Status:\s*(\d+)', line)
                if ffuf_match:
                    word, status = ffuf_match.groups()
                    if status in ("200", "301", "302", "403"):
                        recon_entries.append({
                            "data_type": "endpoint",
                            "name": f"GET /{word}",
                            "details": {"path": f"/{word}", "status_code": int(status), "target": target},
                            "discovered_in_phase": "reconnaissance",
                        })
            if recon_entries:
                await mcp_service.safe_add_recon_batch(recon_entries)

        elif scan_type == "nikto":
            # Parse nikto output for findings (lines with OSVDB or CVE)
            for line in stdout.splitlines():
                if "OSVDB" in line or "CVE" in line:
                    # Clean up the line
                    clean = line.strip().lstrip("+ ")
                    if clean:
                        await mcp_service.safe_add_card(
                            card_type="observation",
                            title=f"Nikto: {clean[:80]}",
                            severity="MEDIUM",
                            target_service=target,
                            technical_analysis=clean,
                            context="Source: nikto scan",
                        )
    except Exception as e:
        logger.warning(f"_autosave_scan_results failed: {e}")


async def _handle_subdomain_enum(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle subdomain_enum"""
    domain = arguments["domain"]

    result = await mcp_service.subdomain_enumeration(domain)

    if not result["success"]:
        return [TextContent(type="text", text=f"Error: {result['error']}")]

    response = f"**Subdomain Enumeration for `{domain}`:**\n\n"

    # Collect unique subdomains from all results
    all_subdomains = set()
    for i, cmd_result in enumerate(result["results"], 1):
        response += f"**Method {i}:** `{cmd_result['command'].split()[0]}`\n"
        if cmd_result["success"] and cmd_result["output"]:
            response += f"```\n{cmd_result['output']}\n```\n"
            # Parse subdomains from output (one per line)
            for line in cmd_result["output"].splitlines():
                sub = line.strip()
                if sub and "." in sub and not sub.startswith("["):
                    all_subdomains.add(sub)
        elif cmd_result["error"]:
            response += f"Error: {cmd_result['error']}\n"
        response += "\n"

    # Auto-save discovered subdomains as recon
    if all_subdomains:
        recon_entries = [
            {
                "data_type": "subdomain",
                "name": sub,
                "details": {"parent_domain": domain},
                "discovered_in_phase": "reconnaissance",
            }
            for sub in sorted(all_subdomains)
        ]
        await mcp_service.safe_add_recon_batch(recon_entries)

    # Auto-capture to knowledge store
    from lib.knowledge_capture import capture_knowledge
    await capture_knowledge(
        mcp_service, source_tool="subdomain_enum", category="scan_output",
        title=f"Subdomain enumeration: {domain}",
        content=response,
        target=domain,
        tags=["subdomain", "scan"],
    )

    return [TextContent(type="text", text=response)]


async def _handle_ssl_analysis(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle ssl_analysis"""
    target = arguments["target"]

    result = await mcp_service.ssl_analysis(target)

    if not result["success"]:
        return [TextContent(type="text", text=f"Error: {result['error']}")]

    response = f"**SSL Analysis for `{target}`:**\n\n"

    for cmd_result in result["results"]:
        if cmd_result["success"] and cmd_result["output"]:
            response += f"**{cmd_result['command'].replace('openssl x509 -noout -', '').title()}:**\n"
            response += f"```\n{cmd_result['output']}\n```\n\n"
        elif cmd_result["error"]:
            response += f"Error in {cmd_result['command']}: {cmd_result['error']}\n\n"

    # Auto-capture to knowledge store
    from lib.knowledge_capture import capture_knowledge
    await capture_knowledge(
        mcp_service, source_tool="ssl_analysis", category="scan_output",
        title=f"SSL analysis: {target}",
        content=response,
        target=target,
        tags=["ssl", "scan"],
    )

    return [TextContent(type="text", text=response)]


async def _handle_tech_detection(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle tech_detection"""
    url = arguments["url"]

    result = await mcp_service.tech_stack_detection(url)

    if not result["success"]:
        return [TextContent(type="text", text=f"Error: {result['error']}")]

    response = f"**Technology Detection for `{url}`:**\n\n"

    for cmd_result in result["results"]:
        if cmd_result["success"] and cmd_result["output"]:
            response += f"**{cmd_result['command'].split()[0].upper()}:**\n"
            response += f"```\n{cmd_result['output']}\n```\n\n"
        elif cmd_result["error"]:
            response += f"Error with {cmd_result['command']}: {cmd_result['error']}\n\n"

    # Auto-capture to knowledge store
    from lib.knowledge_capture import capture_knowledge
    await capture_knowledge(
        mcp_service, source_tool="tech_detection", category="scan_output",
        title=f"Tech detection: {url}",
        content=response,
        target=url,
        tags=["tech_detection", "scan"],
    )

    return [TextContent(type="text", text=response)]


async def _handle_tool_help(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle tool_help"""
    if not mcp_service.current_container:
        return [TextContent(type="text", text="No container selected.")]

    tool = arguments["tool"]

    # First check if tool is available
    available = await mcp_service.check_tool_availability(tool)
    if not available:
        return [TextContent(type="text",
                            text=f"Tool `{tool}` not available in container `{mcp_service.current_container}`")]

    response = f"**Help for `{tool}`:**\n\n"

    # Try different help options in sequence
    help_commands = [f"{tool} -h", f"{tool} --help", f"{tool} help", f"man {tool}"]

    for help_cmd in help_commands:
        result = await mcp_service.execute_container_command(
            mcp_service.current_container, help_cmd
        )

        if result["success"] and result.get("stdout"):
            response += f"**Command:** `{help_cmd}`\n"
            response += f"```\n{result['stdout']}\n```"
            break
        elif result.get("stderr") and "usage" in result["stderr"].lower():
            response += f"**Command:** `{help_cmd}`\n"
            response += f"```\n{result['stderr']}\n```"
            break
    else:
        response += f"No help documentation found for `{tool}`"

    return [TextContent(type="text", text=response)]
