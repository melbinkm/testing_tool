"""
Sequence Tools - Multi-step request sequences for business logic testing.

Tools:
  1. sequence_execute           - Execute a multi-step request sequence
  2. sequence_workflow_bypass   - Test workflow bypass vulnerabilities
  3. sequence_data_ownership    - Verify data ownership enforcement
  4. sequence_credential_reuse  - Test discovered credentials against endpoints
"""

from __future__ import annotations

import json
import logging
from typing import Any, Dict, List

from mcp.types import Tool, TextContent

logger = logging.getLogger("autopentest-mcp")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _json_content(data: Any) -> List[TextContent]:
    """Return a single-element TextContent list with *data* as JSON."""
    return [TextContent(type="text", text=json.dumps(data, indent=2, default=str))]


def _error_content(message: str) -> List[TextContent]:
    """Return a JSON error object wrapped in TextContent."""
    return [TextContent(type="text", text=json.dumps({"success": False, "error": message}, indent=2))]


# ---------------------------------------------------------------------------
# Lazy init helpers
# ---------------------------------------------------------------------------

class _NoAssessmentError(Exception):
    pass


async def _get_db(mcp_service=None):
    """Return the world-model database for the current assessment."""
    if mcp_service is None or mcp_service.current_assessment_id is None:
        raise _NoAssessmentError()
    from lib.world_model_db import get_world_model_db
    return await get_world_model_db(mcp_service.current_assessment_id)


def _get_http_client(mcp_service=None):
    """Get or create an audited HTTP client."""
    from lib.http_client_factory import create_audit_http_client
    return create_audit_http_client(mcp_service)


async def _get_identity_store(mcp_service):
    """Get identity store populated from world model identities."""
    try:
        from lib.identity_store import IdentityStore, Identity
        store = IdentityStore()
        if mcp_service and getattr(mcp_service, "current_assessment_id", None):
            from lib.world_model_db import get_world_model_db
            db = await get_world_model_db(mcp_service.current_assessment_id)
            identities = await db.query("identities", limit=100)
            for ident in identities:
                store.add_identity(Identity(
                    id=ident.get("id", ""),
                    type=ident.get("auth_type", "bearer"),
                    scope=ident.get("scope", ""),
                    auth_header=ident.get("metadata", {}).get("auth_header", ""),
                    cookies=ident.get("metadata", {}).get("cookies"),
                    should_have_access=ident.get("metadata", {}).get("should_have_access", True),
                    description=ident.get("description", ""),
                ))
        return store
    except Exception:
        return None


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_sequence_tools() -> List[Tool]:
    """Return the four sequence/business-logic testing tools."""
    return [
        # 1 ---- sequence_execute ---------------------------------------
        Tool(
            name="sequence_execute",
            description=(
                "Execute a multi-step request sequence with variable extraction between steps. Supports "
                "{{variable}} template placeholders in URLs, headers, and request bodies. Extracts values from "
                "responses using JSON path ($.data.token), regex (regex:csrf=(\\w+)), or headers (header:Set-Cookie). "
                "Essential for testing multi-step workflows: login → get CSRF → action → verify, OAuth flows, "
                "checkout processes, file upload workflows, and any business logic requiring sequential operations. "

                "**When to use:** Phase 3-4 (Assessment/Exploitation) for testing complex business logic workflows "
                "that span multiple requests. Use when: testing requires authentication token extraction (login then "
                "use token), CSRF protection needs to be extracted and replayed, resource IDs must be extracted from "
                "creation response (POST /users → extract user_id → GET /users/{id}), stateful workflows require "
                "ordered steps (cart add → checkout → payment), verifying proper workflow enforcement. "

                "**Dependencies:** Optionally requires wm_add_hypothesis(hypothesis_id) to link observations to "
                "hypothesis for structured testing. Use auth_get_identities() to get identity_id values for "
                "authenticated steps. Follow with sequence_workflow_bypass() to test if step skipping is possible, "
                "or wm_add_observation() to record interesting workflow behaviors. "

                "**Budget impact:** MEDIUM - N requests where N = number of steps. Typical workflows: 2-5 steps. "
                "Complex workflows (OAuth, multi-factor auth) may be 5-10 steps. Each step = 1 HTTP request. Add "
                "optional delay_ms between steps for rate-limit compliance. Check scope_check_budget() before long sequences. "

                "**Failure modes:** 'Variable extraction failed' if JSON path/regex doesn't match response - verify "
                "extraction pattern with actual response format. 'Template resolution failed' if {{var}} undefined - "
                "ensure variable extracted in prior step or provided in initial variables. 'Step assertion failed' "
                "causes stop by default (use on_failure='continue' to proceed). 'Authentication failed' mid-sequence "
                "indicates token expiration - adjust workflow or use fresh credentials. Network timeouts in long "
                "sequences - increase step timeout or reduce delay_ms. "

                "**Risk level:** HIGH RISK - Executes user-defined multi-step request sequences with actual payloads. "
                "Risk level depends on step actions: read-only GET sequences = moderate risk, sequences with POST/PUT/DELETE "
                "= high risk (may modify data, create resources, trigger workflows). All steps logged with correlation "
                "for audit. Detectable in logs as rapid sequential requests from same source. "

                "**Returns:** Execution result with: success (boolean), steps_completed (N of M), total_steps, variables "
                "(final variable state after all extractions), failed_step (name if stopped), step_results array "
                "(per-step status/extracted vars/assertions/timing). Use step_results to: debug extraction failures, "
                "verify assertions passed, analyze timing for race conditions, capture evidence for workflow bypasses. "
                "Auto-stores observations in world model if hypothesis_id provided."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "steps": {
                        "type": "array",
                        "description": "Ordered list of request steps to execute",
                        "items": {
                            "type": "object",
                            "properties": {
                                "name": {
                                    "type": "string",
                                    "description": "Step name (e.g. 'login', 'get_token')",
                                },
                                "method": {
                                    "type": "string",
                                    "enum": ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"],
                                    "description": "HTTP method",
                                },
                                "url_template": {
                                    "type": "string",
                                    "description": "URL with {{var}} placeholders",
                                },
                                "headers": {
                                    "type": "object",
                                    "description": "Request headers (supports {{var}} placeholders)",
                                },
                                "body_template": {
                                    "type": "string",
                                    "description": "Request body (supports {{var}} placeholders)",
                                },
                                "identity_id": {
                                    "type": "string",
                                    "description": "Identity ID for auth context",
                                },
                                "extract": {
                                    "type": "object",
                                    "description": (
                                        "Variables to extract from response. "
                                        "Values: '$.json.path', 'regex:pattern(group)', 'header:Name'"
                                    ),
                                },
                                "expect": {
                                    "type": "object",
                                    "description": (
                                        "Assertions: {status: 200, body_contains: [...], "
                                        "body_not_contains: [...]}"
                                    ),
                                },
                                "on_failure": {
                                    "type": "string",
                                    "enum": ["stop", "continue", "skip_rest"],
                                    "description": "Behavior on assertion failure (default: stop)",
                                },
                                "delay_ms": {
                                    "type": "integer",
                                    "description": "Delay in ms before this step (default: 0)",
                                },
                            },
                            "required": ["name", "method", "url_template"],
                        },
                    },
                    "variables": {
                        "type": "object",
                        "description": "Initial variables for template resolution",
                    },
                    "hypothesis_id": {
                        "type": "string",
                        "description": "Link observations to a world model hypothesis",
                    },
                },
                "required": ["steps"],
            },
        ),

        # 2 ---- sequence_workflow_bypass --------------------------------
        Tool(
            name="sequence_workflow_bypass",
            description=(
                "Test workflow bypass vulnerabilities by manipulating step order and execution. Provides happy-path "
                "workflow steps then applies bypass strategies: skip_step (skip validation/payment steps), replay_step "
                "(double-spend by replaying order), reorder (execute steps in wrong order), direct_access (jump to "
                "final step skipping prerequisites). Automatically tests common bypass patterns and detects vulnerabilities "
                "where workflow enforcement is weak. "

                "**When to use:** Phase 3-4 (Assessment/Exploitation) after running sequence_execute() successfully "
                "with happy-path to understand normal workflow. Test workflows with business logic: payment flows "
                "(can skip payment step?), approval workflows (can skip manager approval?), multi-factor auth (can "
                "bypass 2FA step?), checkout process (can skip inventory check?), workflow state machines (can jump "
                "to 'approved' without validation?). Essential for business logic vulnerability testing. "

                "**Dependencies:** Requires sequence_execute() to have validated happy-path workflow first. Use same "
                "step definitions from successful sequence_execute(). Optionally use auth_get_identities() for identity_id "
                "values. Follow with validate_repro() if bypass successful, evidence_bundle() to document finding, "
                "and add_card(type='finding', title='Workflow Bypass: skip_step') for confirmed vulnerabilities. "

                "**Budget impact:** MEDIUM to HIGH - Tests multiple bypass variants. skip_step: N-1 requests (skip "
                "each step once). replay_step: N+1 requests (replay last). reorder: N requests. direct_access: 1 "
                "request. Total budget: ~2-5x normal workflow execution. For 5-step workflow, expect 10-25 requests. "
                "Check scope_check_budget() before testing. "

                "**Failure modes:** 'All variants blocked' indicates proper workflow enforcement (expected for secure "
                "apps, not a failure). 'Extraction failed in bypass' may occur if skipping step that extracts required "
                "variable - bypass might still work with hardcoded values. 'Some bypasses succeed' is CRITICAL FINDING "
                "- indicates business logic flaw. 'Network errors' in rapid testing may indicate rate limiting - add "
                "delay_ms to steps. "

                "**Risk level:** HIGH RISK - Actively attempts to bypass business logic controls. May: skip payment "
                "steps (free orders), bypass approval workflows (unauthorized actions), circumvent authentication "
                "(MFA bypass), trigger inconsistent state (inventory errors), create audit gaps. Highly detectable: "
                "unusual request patterns, missing intermediate steps in logs, rapid workflow testing. May trigger "
                "fraud detection or anomaly alerts. Only test with explicit permission. "

                "**Returns:** Bypass test results with: variants_tested (number of bypass patterns tested), "
                "vulnerabilities_found array (successful bypasses with details), bypass_type (skip_step/replay_step/"
                "reorder/direct_access), per-variant results (success/failure/response analysis). Automatically creates "
                "finding cards for detected vulnerabilities. Use vulnerabilities_found to: identify which steps can "
                "be skipped, understand bypass technique, estimate severity, plan remediation. High/Critical severity "
                "if payment/approval/auth steps bypassable."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "steps": {
                        "type": "array",
                        "description": "The happy-path request steps (same format as sequence_execute)",
                        "items": {
                            "type": "object",
                            "properties": {
                                "name": {"type": "string"},
                                "method": {"type": "string"},
                                "url_template": {"type": "string"},
                                "headers": {"type": "object"},
                                "body_template": {"type": "string"},
                                "identity_id": {"type": "string"},
                                "extract": {"type": "object"},
                                "expect": {"type": "object"},
                                "on_failure": {"type": "string"},
                                "delay_ms": {"type": "integer"},
                            },
                            "required": ["name", "method", "url_template"],
                        },
                    },
                    "bypass_type": {
                        "type": "string",
                        "enum": ["skip_step", "replay_step", "reorder", "direct_access"],
                        "description": "Type of workflow bypass to test",
                    },
                    "skip_indices": {
                        "type": "array",
                        "items": {"type": "integer"},
                        "description": "Step indices to skip (for skip_step bypass type)",
                    },
                    "variables": {
                        "type": "object",
                        "description": "Initial variables for template resolution",
                    },
                },
                "required": ["steps", "bypass_type"],
            },
        ),

        # 3 ---- sequence_data_ownership --------------------------------
        Tool(
            name="sequence_data_ownership",
            description=(
                "Verify data ownership enforcement across resource IDs and user identities. Tests whether user A's "
                "data is properly protected from user B by sending requests as the owner and as other identities, "
                "comparing responses to detect IDOR (Insecure Direct Object Reference), data leakage, and horizontal "
                "privilege escalation. Optimized for bulk IDOR enumeration across many resource IDs. "

                "**When to use:** Phase 3-4 (Assessment/Exploitation) for systematic IDOR testing on endpoints with "
                "resource IDs (e.g., /api/users/{id}, /orders/{id}, /documents/{id}). Use after auth_diff_test() "
                "identifies authorization issues on single resource. Essential for: bulk IDOR enumeration (test "
                "user1's access to user2,user3,...userN resources), data leakage detection (comparing response content "
                "across identities), horizontal privilege escalation (user accessing peer users' data), systematic "
                "authorization testing across resource inventory. "

                "**Dependencies:** Requires auth_get_identities() to get owner_identity_id and other_identity_ids. "
                "Requires resource_ids array (get from wm_query, crawler results, or manual enumeration). Follow with "
                "validate_repro() for confirmed violations, validate_cross_identity() for additional validation, "
                "evidence_bundle() to document findings, http_send_batch() to extract full leaked data if needed. "

                "**Budget impact:** HIGH - (M resources) × (N identities) requests. Example: 20 resources × 3 identities "
                "= 60 requests. Typical IDOR tests: 10-100 resources, 2-5 identities = 20-500 requests. Budget-intensive "
                "for comprehensive testing. Check scope_check_budget() before large tests. Consider testing subset first "
                "(5 resources) to verify IDOR exists before full enumeration. "

                "**Failure modes:** 'All identities blocked' indicates proper authz enforcement (expected for secure "
                "apps). 'Owner identity also blocked' suggests invalid credentials or endpoint requires additional "
                "permissions. 'Inconsistent results' across resources may indicate: rate limiting (add delays), "
                "resource-specific permissions (not universal IDOR), time-based access (test timing). 'Many violations' "
                "is CRITICAL FINDING indicating systemic authz failure. "

                "**Risk level:** HIGH RISK - Bulk enumeration of user resources with multiple identities. May access "
                "large volumes of other users' sensitive data if IDOR exists. Highly detectable: rapid enumeration "
                "pattern, multiple users accessing same resource set, sequential ID testing. May trigger rate limiting, "
                "anomaly detection, or fraud alerts. Compliance risk if accessing PII without authorization. Only test "
                "with explicit permission. "

                "**Returns:** Ownership test results with: resources_tested (count), ownership_violations array "
                "(resource_id + identity pairs where non-owner accessed owner data), per-resource access matrix "
                "(which identities could access which resources), data_comparison (response diffs showing leaked data). "
                "Automatically creates finding cards for detected violations. Use violations array to: quantify IDOR "
                "impact (N resources exposed), identify accessible resource IDs for data exfiltration, estimate severity "
                "(how much data leaked), plan evidence collection (which examples to document)."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "url_template": {
                        "type": "string",
                        "description": "URL with {id} placeholder for resource ID (e.g. '/api/users/{id}/profile')",
                    },
                    "resource_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of resource IDs to test",
                    },
                    "owner_identity_id": {
                        "type": "string",
                        "description": "Identity ID of the resource owner",
                    },
                    "other_identity_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Identity IDs of non-owners to test access with",
                    },
                    "method": {
                        "type": "string",
                        "enum": ["GET", "POST", "PUT", "DELETE", "PATCH"],
                        "description": "HTTP method (default: GET)",
                    },
                    "headers": {
                        "type": "object",
                        "description": "Additional headers for each request",
                    },
                },
                "required": ["url_template", "resource_ids", "owner_identity_id", "other_identity_ids"],
            },
        ),

        # 4 ---- sequence_credential_reuse ------------------------------
        Tool(
            name="sequence_credential_reuse",
            description=(
                "Test discovered credentials against multiple endpoints to find where they grant access. Takes a "
                "credential (bearer token, cookie, API key, basic auth) and systematically tests it against endpoint "
                "list, identifying successful authentications. Essential for: credential scope analysis (which endpoints "
                "accept this token?), lateral movement detection (can API token access web endpoints?), authentication "
                "bypass verification (does leaked token grant access?). "

                "**When to use:** Phase 3-4 (Assessment/Exploitation) after discovering credentials via: config file "
                "leaks (tokens in source), XSS (stolen cookies), IDOR (accessed other user's tokens), SQL injection "
                "(dumped credentials), source code (hardcoded keys). Use to map credential scope and identify "
                "unauthorized access. Essential after finding: leaked API keys (test against all API endpoints), "
                "stolen session cookies (test against authenticated pages), discovered JWT tokens (test scope). "

                "**Dependencies:** Requires credential_id from credentials_add() or wm_add_identity(). Requires "
                "target_endpoints array from wm_query(table='endpoints'), crawler_results(), or manual list. Follow "
                "with auth_diff_test() to compare access levels, validate_repro() to confirm findings, evidence_bundle() "
                "to document credential scope, wm_add_finding() for unauthorized access discoveries. "

                "**Budget impact:** MEDIUM - N requests where N = number of endpoints tested. Typical: 10-50 endpoints "
                "= 10-50 requests. Comprehensive testing: 100+ endpoints. Budget-efficient for scoping credentials. "
                "Check scope_check_budget() before testing large endpoint lists. Consider testing subset of critical "
                "endpoints first (admin, payment, user data) before full scan. "

                "**Failure modes:** 'No successful authentications' may indicate: credential expired/revoked (expected), "
                "wrong auth format for these endpoints (try different header/cookie format), IP restrictions (credential "
                "tied to specific IP), all endpoints tested are public (no auth required). 'All endpoints accept' "
                "suggests overly permissive credential (critical finding). 'Some endpoints accept' is typical - "
                "analyze which categories (admin vs user, API vs web). "

                "**Risk level:** HIGH RISK - Tests potentially compromised credentials against production endpoints. "
                "May grant unauthorized access if credential is valid. Detectable: unusual access patterns, credential "
                "used from unexpected IP/location, rapid endpoint enumeration, single credential accessing many "
                "resources. May trigger: account monitoring alerts, fraud detection, session invalidation. Only test "
                "credentials you're authorized to use or discovered through legitimate testing. "

                "**Returns:** Credential reuse test results with: endpoints_tested (count), successful_auth array "
                "(endpoints that accepted credential with status/response details), failed_auth array (rejected "
                "endpoints), credential_scope_analysis (categorization of accessible endpoints: admin/user/api/web). "
                "Automatically creates finding cards for successful unauthorized access. Use successful_auth to: "
                "understand credential scope, identify lateral movement opportunities, assess breach impact, prioritize "
                "credential revocation, map trust boundaries."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "credential_id": {
                        "type": "string",
                        "description": "Credential ID from the credentials store",
                    },
                    "target_endpoints": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of endpoint URLs to test the credential against",
                    },
                    "method": {
                        "type": "string",
                        "enum": ["GET", "POST", "PUT", "DELETE", "PATCH"],
                        "description": "HTTP method (default: GET)",
                    },
                },
                "required": ["credential_id", "target_endpoints"],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_sequence_tool(
    name: str,
    arguments: dict,
    mcp_service: Any = None,
) -> List[TextContent]:
    """Dispatch a sequence tool call to the appropriate handler."""
    try:
        if name == "sequence_execute":
            return await _handle_sequence_execute(arguments, mcp_service)
        elif name == "sequence_workflow_bypass":
            return await _handle_workflow_bypass(arguments, mcp_service)
        elif name == "sequence_data_ownership":
            return await _handle_data_ownership(arguments, mcp_service)
        elif name == "sequence_credential_reuse":
            return await _handle_credential_reuse(arguments, mcp_service)
    except _NoAssessmentError:
        return _error_content(
            "No assessment loaded. Use 'load_assessment' first."
        )
    except Exception as exc:
        logger.error("Sequence tool %s failed: %s", name, exc, exc_info=True)
        return _error_content(f"Error in {name}: {exc}")

    return _error_content(f"Unknown sequence tool: {name}")


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

def _parse_steps(raw_steps: List[Dict]) -> list:
    """Convert raw dicts from MCP arguments to RequestStep objects."""
    from lib.sequence_runner import RequestStep

    steps = []
    for raw in raw_steps:
        steps.append(RequestStep(
            name=raw.get("name", f"step_{len(steps) + 1}"),
            method=raw.get("method", "GET"),
            url_template=raw.get("url_template", ""),
            headers=raw.get("headers", {}),
            body_template=raw.get("body_template"),
            identity_id=raw.get("identity_id"),
            extract=raw.get("extract", {}),
            expect=raw.get("expect", {}),
            on_failure=raw.get("on_failure", "stop"),
            delay_ms=raw.get("delay_ms", 0),
        ))
    return steps


async def _handle_sequence_execute(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle sequence_execute - run a multi-step request sequence."""
    raw_steps = arguments.get("steps")
    if not raw_steps or not isinstance(raw_steps, list):
        return _error_content("steps is required and must be a non-empty array")

    steps = _parse_steps(raw_steps)
    variables = arguments.get("variables", {})
    hypothesis_id = arguments.get("hypothesis_id")

    from lib.sequence_runner import SequenceRunner

    http_client = _get_http_client(mcp_service)
    db = None
    if mcp_service and getattr(mcp_service, "current_assessment_id", None):
        try:
            db = await _get_db(mcp_service)
        except Exception:
            pass

    scope_validator = None
    try:
        from lib.scope_loader import load_scope_from_env
        from lib.scope_validator import TargetValidator
        scope = load_scope_from_env()
        if scope:
            scope_validator = TargetValidator(scope)
    except Exception:
        pass

    runner = SequenceRunner(
        http_client=http_client,
        db=db,
        scope_validator=scope_validator,
    )

    result = await runner.execute(
        steps=steps,
        variables=variables,
        hypothesis_id=hypothesis_id,
    )

    # Convert dataclass to dict for JSON serialization
    result_dict = {
        "success": result.success,
        "steps_completed": result.steps_completed,
        "total_steps": result.total_steps,
        "variables": result.variables,
        "failed_step": result.failed_step,
        "step_results": [
            {
                "step_name": sr.step_name,
                "step_index": sr.step_index,
                "success": sr.success,
                "status_code": sr.status_code,
                "extracted_vars": sr.extracted_vars,
                "assertion_results": sr.assertion_results,
                "error": sr.error,
                "timing_ms": sr.timing_ms,
            }
            for sr in result.step_results
        ],
    }

    return _json_content({
        "success": True,
        **result_dict,
        "message": (
            f"Sequence {'completed' if result.success else 'failed'}: "
            f"{result.steps_completed}/{result.total_steps} steps completed."
            + (f" Failed at: {result.failed_step}" if result.failed_step else "")
        ),
    })


async def _handle_workflow_bypass(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle sequence_workflow_bypass - test workflow bypass vulnerabilities."""
    raw_steps = arguments.get("steps")
    if not raw_steps or not isinstance(raw_steps, list):
        return _error_content("steps is required and must be a non-empty array")

    bypass_type = arguments.get("bypass_type")
    if not bypass_type or bypass_type not in ("skip_step", "replay_step", "reorder", "direct_access"):
        return _error_content("bypass_type is required: skip_step, replay_step, reorder, direct_access")

    steps = _parse_steps(raw_steps)
    skip_indices = arguments.get("skip_indices")
    variables = arguments.get("variables", {})

    from lib.sequence_runner import SequenceRunner

    http_client = _get_http_client(mcp_service)
    db = None
    if mcp_service and getattr(mcp_service, "current_assessment_id", None):
        try:
            db = await _get_db(mcp_service)
        except Exception:
            pass

    scope_validator = None
    try:
        from lib.scope_loader import load_scope_from_env
        from lib.scope_validator import TargetValidator
        scope = load_scope_from_env()
        if scope:
            scope_validator = TargetValidator(scope)
    except Exception:
        pass

    runner = SequenceRunner(
        http_client=http_client,
        db=db,
        scope_validator=scope_validator,
    )

    result = await runner.execute_workflow_bypass(
        steps=steps,
        bypass_type=bypass_type,
        skip_indices=skip_indices,
        variables=variables,
    )

    # Auto-create findings for discovered vulnerabilities
    if mcp_service and result.get("vulnerabilities_found"):
        for vuln in result["vulnerabilities_found"]:
            await mcp_service.safe_add_card(
                card_type="finding",
                title=f"Workflow Bypass: {vuln.get('bypass_type', bypass_type)}",
                severity="HIGH",
                status="confirmed",
                target_service=vuln.get("url", args.get("base_url", "")),
                technical_analysis=json.dumps(vuln, default=str)[:2000],
                context=f"Source: sequence_workflow_bypass ({bypass_type})",
            )

    return _json_content({
        "success": True,
        **result,
        "message": (
            f"Workflow bypass test ({bypass_type}): "
            f"{result.get('variants_tested', 0)} variants tested, "
            f"{len(result.get('vulnerabilities_found', []))} vulnerabilities found."
        ),
    })


async def _handle_data_ownership(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle sequence_data_ownership - verify data ownership enforcement."""
    url_template = arguments.get("url_template")
    if not url_template or not isinstance(url_template, str):
        return _error_content("url_template is required")

    resource_ids = arguments.get("resource_ids")
    if not resource_ids or not isinstance(resource_ids, list):
        return _error_content("resource_ids is required and must be a non-empty array")

    owner_identity_id = arguments.get("owner_identity_id")
    if not owner_identity_id:
        return _error_content("owner_identity_id is required")

    other_identity_ids = arguments.get("other_identity_ids")
    if not other_identity_ids or not isinstance(other_identity_ids, list):
        return _error_content("other_identity_ids is required and must be a non-empty array")

    method = arguments.get("method", "GET")
    headers = arguments.get("headers")

    from lib.sequence_runner import DataOwnershipTester

    http_client = _get_http_client(mcp_service)
    identity_store = await _get_identity_store(mcp_service)

    scope_validator = None
    try:
        from lib.scope_loader import load_scope_from_env
        from lib.scope_validator import TargetValidator
        scope = load_scope_from_env()
        if scope:
            scope_validator = TargetValidator(scope)
    except Exception:
        pass

    tester = DataOwnershipTester(
        http_client=http_client,
        identity_store=identity_store,
        scope_validator=scope_validator,
    )

    result = await tester.test_ownership(
        url_template=url_template,
        resource_ids=resource_ids,
        owner_identity_id=owner_identity_id,
        other_identity_ids=other_identity_ids,
        method=method,
        headers=headers,
    )

    # Auto-create findings for ownership violations
    if mcp_service and result.get("ownership_violations"):
        for violation in result["ownership_violations"]:
            await mcp_service.safe_add_card(
                card_type="finding",
                title=f"Data Ownership Violation: {violation.get('resource_id', 'unknown')}",
                severity="HIGH",
                status="confirmed",
                target_service=violation.get("url", args.get("url_template", "")),
                technical_analysis=json.dumps(violation, default=str)[:2000],
                context="Source: sequence_data_ownership",
            )

    return _json_content({
        "success": True,
        **result,
        "message": (
            f"Data ownership test: {result.get('resources_tested', 0)} resources tested, "
            f"{len(result.get('ownership_violations', []))} violations found."
        ),
    })


async def _handle_credential_reuse(arguments: dict, mcp_service: Any = None) -> List[TextContent]:
    """Handle sequence_credential_reuse - test credentials against endpoints."""
    credential_id = arguments.get("credential_id")
    if not credential_id or not isinstance(credential_id, str):
        return _error_content("credential_id is required")

    target_endpoints = arguments.get("target_endpoints")
    if not target_endpoints or not isinstance(target_endpoints, list):
        return _error_content("target_endpoints is required and must be a non-empty array")

    method = arguments.get("method", "GET")

    # Look up the credential from backend API or world model
    credential = None
    try:
        if mcp_service and mcp_service.http_client:
            resp = await mcp_service.http_client.get(
                f"{mcp_service.backend_url}/assessments/{mcp_service.current_assessment_id}/credentials"
            )
            if resp.status_code == 200:
                for cred in resp.json().get("credentials", []):
                    if cred.get("id") == credential_id or cred.get("name") == credential_id:
                        credential = {
                            "type": cred.get("type", "bearer"),
                            "value": cred.get("token") or cred.get("password", ""),
                            "header_name": "Authorization",
                            "id": credential_id,
                            "username": cred.get("username"),
                        }
                        break
    except Exception:
        pass

    if not credential:
        # Fallback: Try getting from world model identities
        try:
            if mcp_service and getattr(mcp_service, "current_assessment_id", None):
                db = await _get_db(mcp_service)
                identity = await db.get_by_id("identities", credential_id)
                if identity:
                    credential = {
                        "type": identity.get("auth_type", "bearer"),
                        "value": identity.get("metadata", {}).get("token", ""),
                        "header_name": "Authorization",
                        "id": credential_id,
                    }
        except Exception:
            pass

    if not credential:
        return _error_content(f"Credential not found: {credential_id}")

    from lib.sequence_runner import CredentialReuseTester

    http_client = _get_http_client(mcp_service)

    scope_validator = None
    try:
        from lib.scope_loader import load_scope_from_env
        from lib.scope_validator import TargetValidator
        scope = load_scope_from_env()
        if scope:
            scope_validator = TargetValidator(scope)
    except Exception:
        pass

    tester = CredentialReuseTester(
        http_client=http_client,
        scope_validator=scope_validator,
    )

    result = await tester.test_credential_reuse(
        credential=credential,
        target_endpoints=target_endpoints,
        method=method,
    )

    # Auto-create findings for successful credential reuse
    if mcp_service and result.get("successful_auth"):
        for auth in result["successful_auth"]:
            await mcp_service.safe_add_card(
                card_type="finding",
                title=f"Credential Reuse: {auth.get('endpoint', 'unknown')}",
                severity="MEDIUM",
                status="confirmed",
                target_service=auth.get("endpoint", ""),
                technical_analysis=json.dumps(auth, default=str)[:2000],
                context=f"Source: sequence_credential_reuse (credential: {credential_id})",
            )

    return _json_content({
        "success": True,
        **result,
        "message": (
            f"Credential reuse test: {result.get('endpoints_tested', 0)} endpoints tested, "
            f"{len(result.get('successful_auth', []))} accepted the credential."
        ),
    })
