"""
HTTP Client Tools - http_send, http_send_batch, http_get_stats

Ports the http-client-mcp TypeScript server's 3 tools to Python.
Provides rate-limited, proxy-aware HTTP request capabilities with
correlation headers and concurrency control.
"""
import json
import os
from typing import List
from urllib.parse import urlparse

from mcp.types import Tool, TextContent
from lib.http_client import HttpClient


# Lazily initialized HTTP client instance
_http_client: HttpClient = None


def _get_http_client() -> HttpClient:
    """Lazily initialize and return the HttpClient singleton."""
    global _http_client
    if _http_client is None:
        _http_client = HttpClient(
            engagement_id=os.environ.get("ENGAGEMENT_ID", "default"),
            proxy_url=os.environ.get("PROXY_URL"),
            max_rps=int(os.environ.get("MAX_RPS", "10")),
            max_concurrent=int(os.environ.get("MAX_CONCURRENT", "5")),
            default_timeout=int(os.environ.get("DEFAULT_TIMEOUT", "30000")),
            max_total_requests=int(os.environ.get("MAX_TOTAL_REQUESTS", "10000")),
        )
    return _http_client


def _validate_url(url: str) -> bool:
    """Validate that a URL has a valid format with scheme and netloc."""
    try:
        parsed = urlparse(url)
        return parsed.scheme in ("http", "https") and bool(parsed.netloc)
    except Exception:
        return False


def get_http_tools() -> List[Tool]:
    """Get HTTP client tool definitions."""
    return [
        Tool(
            name="http_send",
            description="Send a single HTTP request with rate limiting and correlation headers. Supports proxy routing (e.g., through Burp Suite).",
            inputSchema={
                "type": "object",
                "properties": {
                    "method": {
                        "type": "string",
                        "enum": ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"],
                        "description": "HTTP method to use"
                    },
                    "url": {
                        "type": "string",
                        "description": "Target URL (must include http:// or https://)"
                    },
                    "headers": {
                        "type": "object",
                        "description": "Optional HTTP headers as key-value pairs"
                    },
                    "body": {
                        "type": "string",
                        "description": "Optional request body"
                    },
                    "timeout": {
                        "type": "number",
                        "description": "Request timeout in milliseconds (overrides default)"
                    },
                    "identity_id": {
                        "type": "string",
                        "description": "Optional identity ID for correlation tracking"
                    }
                },
                "required": ["method", "url"]
            }
        ),
        Tool(
            name="http_send_batch",
            description="Send multiple HTTP requests with concurrency control and rate limiting. All requests share the same rate limiter and budget.",
            inputSchema={
                "type": "object",
                "properties": {
                    "requests": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "method": {
                                    "type": "string",
                                    "enum": ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"],
                                    "description": "HTTP method to use"
                                },
                                "url": {
                                    "type": "string",
                                    "description": "Target URL (must include http:// or https://)"
                                },
                                "headers": {
                                    "type": "object",
                                    "description": "Optional HTTP headers as key-value pairs"
                                },
                                "body": {
                                    "type": "string",
                                    "description": "Optional request body"
                                },
                                "timeout": {
                                    "type": "number",
                                    "description": "Request timeout in milliseconds"
                                },
                                "identity_id": {
                                    "type": "string",
                                    "description": "Optional identity ID for correlation tracking"
                                }
                            },
                            "required": ["method", "url"]
                        },
                        "description": "Array of HTTP requests to send concurrently"
                    }
                },
                "required": ["requests"]
            }
        ),
        Tool(
            name="http_get_stats",
            description="Get HTTP client statistics including total requests sent, rate limit info, and budget remaining.",
            inputSchema={
                "type": "object",
                "properties": {},
                "required": []
            }
        ),
    ]


async def handle_http_tool(name: str, arguments: dict, mcp_service) -> List[TextContent]:
    """Route HTTP tool calls to the appropriate handler."""
    if name == "http_send":
        return await _handle_http_send(arguments, mcp_service)
    elif name == "http_send_batch":
        return await _handle_http_send_batch(arguments, mcp_service)
    elif name == "http_get_stats":
        return await _handle_http_get_stats(arguments, mcp_service)
    return [TextContent(type="text", text=json.dumps({
        "error": "UNKNOWN_TOOL",
        "message": f"Unknown HTTP tool: {name}"
    }))]


async def _handle_http_send(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle http_send - Send a single HTTP request."""
    method = arguments.get("method")
    url = arguments.get("url")

    if not method or not url:
        return [TextContent(type="text", text=json.dumps({
            "error": "INVALID_PARAMS",
            "message": "Both 'method' and 'url' are required"
        }))]

    if not _validate_url(url):
        return [TextContent(type="text", text=json.dumps({
            "error": "INVALID_URL",
            "message": f"Invalid URL format: {url}. Must include http:// or https:// scheme."
        }))]

    try:
        client = _get_http_client()
        result = await client.send(
            method=method,
            url=url,
            headers=arguments.get("headers"),
            body=arguments.get("body"),
            timeout=arguments.get("timeout"),
            identity_id=arguments.get("identity_id"),
        )
        return [TextContent(type="text", text=json.dumps(result))]
    except Exception as e:
        return [TextContent(type="text", text=json.dumps({
            "error": "REQUEST_FAILED",
            "message": str(e)
        }))]


async def _handle_http_send_batch(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle http_send_batch - Send multiple HTTP requests with concurrency control."""
    requests = arguments.get("requests")

    if not requests or not isinstance(requests, list):
        return [TextContent(type="text", text=json.dumps({
            "error": "INVALID_PARAMS",
            "message": "'requests' must be a non-empty array"
        }))]

    # Validate all request URLs before sending any
    for i, req in enumerate(requests):
        if not req.get("method") or not req.get("url"):
            return [TextContent(type="text", text=json.dumps({
                "error": "INVALID_PARAMS",
                "message": f"Request at index {i} is missing required 'method' or 'url'"
            }))]
        if not _validate_url(req["url"]):
            return [TextContent(type="text", text=json.dumps({
                "error": "INVALID_URL",
                "message": f"Invalid URL format at index {i}: {req['url']}. Must include http:// or https:// scheme."
            }))]

    try:
        client = _get_http_client()
        result = await client.send_batch(requests)
        return [TextContent(type="text", text=json.dumps(result))]
    except Exception as e:
        return [TextContent(type="text", text=json.dumps({
            "error": "BATCH_REQUEST_FAILED",
            "message": str(e)
        }))]


async def _handle_http_get_stats(arguments: dict, mcp_service) -> List[TextContent]:
    """Handle http_get_stats - Get HTTP client statistics."""
    try:
        client = _get_http_client()
        stats = client.get_stats()
        return [TextContent(type="text", text=json.dumps(stats))]
    except Exception as e:
        return [TextContent(type="text", text=json.dumps({
            "error": "STATS_FAILED",
            "message": str(e)
        }))]
