"""
Scope Guard Tools - Validate targets, manage allowlists, track budgets.

Ports the 6 tools from the scope-guard-mcp TypeScript server to Python,
following the same pattern as tools_assessment.py.
"""

import json
import logging
import os
from dataclasses import asdict
from typing import Any, Dict, List, Optional

from mcp.types import Tool, TextContent

from lib.scope_types import (
    EngagementScope,
    ValidationResult,
    BudgetStatus,
    ScopeValidationError,
    BudgetExceededError,
)
from lib.scope_loader import load_scope_from_env
from lib.scope_validator import TargetValidator
from lib.budget_tracker import BudgetTracker

logger = logging.getLogger("autopentest-mcp")

# ---------------------------------------------------------------------------
# NOTE: Module-level _scope_state dict REMOVED - now using per-assessment
# scope via AssessmentScopeProvider in service.py
# ---------------------------------------------------------------------------


from lib.tool_helpers import _json_content, _error_content


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_scope_tools() -> List[Tool]:
    """Return the six scope-guard tools."""
    return [
        Tool(
            name="scope_validate_target",
            description=(
                "Validate if a target (URL, domain, or IP address) is within the engagement scope allowlist. "
                "Checks against configured domains, IP ranges, ports, and services. Returns validation result "
                "with in_scope boolean and detailed reason. Essential safety mechanism to prevent testing "
                "unauthorized targets. Used automatically by http_send(), scan(), and other tools if scope "
                "configured. "

                "**When to use:** Phase 1-4 (All phases) BEFORE testing any new target. Required before: "
                "subdomain_enum(), scan(), crawler_start(), http_send(), nuclei_scan_template(). Call when "
                "discovering new subdomains, IP addresses, or redirects to verify they're authorized. Prevents "
                "accidental out-of-scope testing that could violate engagement terms or trigger legal issues. "

                "**Dependencies:** Requires SCOPE_FILE environment variable pointing to engagement scope "
                "YAML/JSON with allowlist configuration. No follow-up tools required - validation is binary "
                "(proceed or stop). If validation fails, use scope_get_allowlist() to see permitted targets. "
                "Many tools (http_send, scan, crawler) call this automatically if scope configured. "

                "**Budget impact:** LOW - Local validation only, no HTTP requests. Completes in <5ms via "
                "regex/CIDR matching. Does NOT count against request budget. Call frequently without concern. "

                "**Failure modes:** 'Scope not configured' if SCOPE_FILE not set or file missing - acceptable "
                "for development but required for production engagements. 'Invalid target format' if target "
                "string unparseable as URL/domain/IP. 'Validation error' if scope file has syntax errors. "
                "Returns in_scope=false for out-of-scope targets (NOT an error, expected behavior). "

                "**Risk level:** SAFE - Read-only validation, no network activity or target interaction. "
                "Critical safety mechanism that PREVENTS unauthorized testing. Should never be bypassed or "
                "disabled in production. "

                "**Returns:** Validation result with in_scope (boolean), reason (explanation), target (normalized), "
                "matched_rule (allowlist entry that authorized target, if in_scope=true). Use in_scope field to "
                "decide whether to proceed with testing. If in_scope=false, log reason and skip target - do NOT "
                "ask user to expand scope without documented change request approval."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target": {
                        "type": "string",
                        "description": "Target to validate (URL, domain, or IP address)",
                    }
                },
                "required": ["target"],
            },
        ),
        Tool(
            name="scope_get_allowlist",
            description=(
                "Get the current allowlist of permitted targets from engagement scope configuration. Returns "
                "complete list of authorized domains (with wildcards), IP ranges (CIDR notation), specific "
                "ports, and services. Essential reference for understanding testing boundaries and investigating "
                "scope validation failures. "

                "**When to use:** Phase 1 (Recon) at engagement start to understand authorized targets. Also "
                "use when scope_validate_target() rejects a target to verify the rejection is correct. Helpful "
                "for planning reconnaissance strategy (which subdomains to enumerate, which IP ranges to scan). "
                "Reference during assessment when discovering redirects or new infrastructure to confirm scope. "

                "**Dependencies:** Requires SCOPE_FILE environment variable with engagement scope YAML/JSON. "
                "No follow-up tools required - returns reference data only. Use scope_validate_target() to "
                "test specific targets against this allowlist. Use with wm_add_asset() to populate world model "
                "with in-scope targets. "

                "**Budget impact:** LOW - Local file read and JSON serialization, no HTTP requests. Completes "
                "in <50ms. Does NOT count against request budget. Allowlist cached after first load. "

                "**Failure modes:** 'Scope not configured' if SCOPE_FILE not set or missing (acceptable for "
                "dev, required for production). 'Parse error' if scope file has invalid YAML/JSON syntax. "
                "Returns empty allowlist if file exists but has no permitted_targets section (misconfiguration). "

                "**Risk level:** SAFE - Read-only query of configuration file, no network activity or target "
                "interaction. Exposes authorized targets only (no sensitive data). "

                "**Returns:** Allowlist object with: domains (list with wildcard support like *.example.com), "
                "ip_ranges (CIDR notation like 192.168.1.0/24), ports (specific ports like [80, 443, 8080]), "
                "services (service names like ['http', 'https', 'ssh']), excluded_targets (explicit exclusions "
                "within scope). Use to understand testing boundaries, verify subdomain_enum() results are in "
                "scope, and plan port scanning strategy (scan only allowed ports)."
            ),
            inputSchema={
                "type": "object",
                "properties": {},
                "required": [],
            },
        ),
        Tool(
            name="scope_get_constraints",
            description=(
                "Get the engagement constraints including rate limits (max RPS), budget limits (max total "
                "requests), timeouts, testing policies (allowed times, attack intensities), and safety rules. "
                "Returns the governance framework that shapes testing strategy and tool selection. Essential "
                "for understanding engagement boundaries beyond just target allowlist. "

                "**When to use:** Phase 1 (Recon) at engagement start to understand operational constraints. "
                "Review before planning testing strategy to align with rate limits and budget. Reference when "
                "choosing between tools (e.g., nuclei with all templates vs targeted templates based on budget). "
                "Check allowed_testing_times before running intensive scans that might disrupt production. "

                "**Dependencies:** Requires SCOPE_FILE with constraints section defining max_requests, "
                "max_requests_per_target, rate_limit_per_second, timeout_ms, allowed_hours, attack_intensity, "
                "safety_checks. Follow with scope_check_budget() to see current consumption against these limits. "
                "Use constraints to configure tool parameters (e.g., set nuclei thread count based on rate limit). "

                "**Budget impact:** LOW - Local file read, no HTTP requests. Completes in <50ms. Does NOT "
                "count against request budget. Constraints cached after first load. "

                "**Failure modes:** 'Scope not configured' if SCOPE_FILE not set (returns empty constraints, "
                "tools use defaults). 'Parse error' if constraints section has invalid format. Missing fields "
                "use sensible defaults (max_requests=10000, rate_limit=10/sec, timeout=30000ms). "

                "**Risk level:** SAFE - Read-only query of configuration, no network activity or target "
                "interaction. Exposes operational limits only (no credentials or sensitive data). "

                "**Returns:** Constraints object with: max_requests (total budget), max_requests_per_target "
                "(per-domain limit), rate_limit_per_second (max RPS), timeout_ms (default request timeout), "
                "allowed_testing_times (e.g., 'business_hours_only', 'maintenance_window'), attack_intensity "
                "(e.g., 'passive', 'active', 'aggressive'), safety_checks (enabled validations), concurrent_limit "
                "(max parallel requests). Use to configure testing approach - 'passive' intensity means use "
                "recon tools only, skip active exploitation."
            ),
            inputSchema={
                "type": "object",
                "properties": {},
                "required": [],
            },
        ),
        Tool(
            name="scope_check_budget",
            description=(
                "Check current budget status including total requests sent, remaining requests available, "
                "per-target limits, and rate limit status. Essential for budget-aware testing strategy - "
                "helps decide between comprehensive vs targeted testing based on remaining capacity. Returns "
                "real-time view of constraint enforcement without consuming budget. "

                "**When to use:** Phase 1-4 (All phases) periodically to monitor budget consumption. Call "
                "every 20-30 tool invocations, especially BEFORE expensive operations like recon_pipeline_run() "
                "(500-2000 requests), nuclei_scan_template() (100-1000 requests), fuzz_parameter() (200-500 "
                "requests), or large http_send_batch() calls. Use to make strategic decisions about testing "
                "depth and prioritization. "

                "**Dependencies:** Requires scope configuration via SCOPE_FILE with constraints section defining "
                "max_requests, max_requests_per_target, rate_limit_per_second. Use scope_get_constraints() "
                "first to understand overall budget allocation. Follow with budget-appropriate tool selection "
                "(see autopentest://budget-optimization resource for strategies). Compare with http_get_stats() "
                "for HTTP-specific metrics. "

                "**Budget impact:** LOW - Zero requests, local query only. Returns cached budget state from "
                "tracker. Completes in <10ms. Does NOT count against max_requests budget. Call as frequently "
                "as needed for monitoring. "

                "**Failure modes:** 'Scope not configured' if SCOPE_FILE not set (returns empty budget status). "
                "Returns 0 remaining if budget exhausted (expected, not an error - stop testing). Per-target "
                "limits may differ from global limit (check both fields). Budget resets on server restart "
                "(not persistent across sessions unless using external tracking). "

                "**Risk level:** SAFE - Read-only query of configuration and tracking state, no target interaction "
                "or network requests. Pure monitoring tool with zero security risk. "

                "**Returns:** Budget status object with: max_requests (configured limit), requests_used "
                "(consumed so far), remaining_requests (available capacity), per_target_stats (request counts "
                "per domain), rate_limit_status (current RPS and limit), per_identity_stats (if identity_id "
                "provided). Use remaining_requests to decide testing strategy: >500 = comprehensive (use all "
                "tools), 100-500 = targeted (prioritize coverage_next priority>70), <100 = critical only "
                "(validation + evidence), <20 = stop testing."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "identity_id": {
                        "type": "string",
                        "description": "Optional identity ID for per-identity budget status",
                    }
                },
                "required": [],
            },
        ),
        Tool(
            name="scope_record_request",
            description=(
                "Record a request for budget tracking and enforcement. Increments request counters for global "
                "budget, per-target limits, and per-identity quotas. Returns success or error if budget exceeded. "
                "Called automatically by http_send() and other tools - rarely needs manual invocation. Provides "
                "audit trail and enforces max_requests constraints. "

                "**When to use:** Phase 3-4 (Assessment/Exploitation) - usually NOT called directly. Tools like "
                "http_send(), scan(), nuclei_scan_template() call this automatically to track their requests. "
                "Only call manually if implementing custom HTTP client or recording requests made by external "
                "tools (e.g., sqlmap, ffuf) for accurate budget tracking. "

                "**Dependencies:** Requires scope configuration with max_requests and max_requests_per_target "
                "constraints. Called before making actual HTTP request to enforce budget. If returns error, "
                "abort the request and call scope_check_budget() to see remaining capacity. Follow with the "
                "actual HTTP request only if this returns success. "

                "**Budget impact:** LOW - Local counter increment, no HTTP requests. Completes in <5ms. "
                "Paradoxically, this tool that TRACKS budget does not CONSUME budget itself (otherwise infinite "
                "loop). Updates in-memory counters and optional persistent storage. "

                "**Failure modes:** 'Budget exceeded' error if max_requests reached - expected failure that "
                "signals end of testing capacity. Returns success=false with remaining=0. 'Per-target limit "
                "exceeded' if one domain hit its quota while global budget remains - switch to different target "
                "or use different domain. 'Scope not configured' allows recording but doesn't enforce limits "
                "(unlimited mode for development). "

                "**Risk level:** SAFE - Local accounting only, no network activity or target interaction. "
                "Critical safety mechanism that ENFORCES budget constraints and prevents over-testing. Maintains "
                "audit trail of request volume for compliance reporting. "

                "**Returns:** Recording result with success (boolean), recorded (boolean), remaining_requests "
                "(global capacity left), per_target_remaining (target-specific capacity), budget_status (full "
                "status object). If success=false, stop testing and use scope_check_budget() to assess options. "
                "If success=true, proceed with actual request and consider recording result in wm_store() for "
                "audit trail."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target": {
                        "type": "string",
                        "description": "Target of the request for per-target tracking",
                    },
                    "identity_id": {
                        "type": "string",
                        "description": "Optional identity ID for the request",
                    },
                },
                "required": [],
            },
        ),
        Tool(
            name="scope_get_identities",
            description=(
                "Get available credentials/identities configured for authenticated testing. Returns test "
                "accounts with different privilege levels (admin, user, readonly), authentication types "
                "(bearer tokens, cookies, basic auth), and expected access scopes. Essential for authorization "
                "testing, IDOR detection, and privilege escalation checks. Credentials stored securely in "
                "scope configuration, not in code. "

                "**When to use:** Phase 2-3 (Mapping/Assessment) before authenticated testing operations. "
                "Call before crawler_start() with identity_id to crawl as authenticated user. Use before "
                "auth_diff_test() to get identity_ids for comparison testing. Reference when running "
                "validate_cross_identity() to test across privilege levels. Essential for discovering "
                "privileged endpoints that require authentication. "

                "**Dependencies:** Requires SCOPE_FILE with identities section defining test accounts with "
                "auth credentials, scopes, and expected_access flags. Follow with credentials_add() if you "
                "discover new credentials during testing. Use identity_ids returned here with tools that "
                "support identity_id parameter (crawler_start, http_send, auth_diff_test). "

                "**Budget impact:** LOW - Local query, no HTTP requests. Completes in <10ms. Does NOT "
                "count against request budget. Returns metadata about identities, not raw credentials "
                "(credentials accessed internally when identity_id used). "

                "**Failure modes:** 'Scope not configured' or 'No identities defined' returns empty list "
                "(still valid for unauthenticated testing). 'Expired credentials' warning if tokens have "
                "expiration metadata and are expired (use credentials_add to refresh). Missing identities "
                "section in scope file is acceptable - not all engagements have test accounts. "

                "**Risk level:** SAFE - Returns identity metadata only (IDs, types, scopes), not actual "
                "credentials (tokens, passwords). Credentials stored securely in scope file and accessed "
                "internally when identity_id used. No network activity or target interaction. "

                "**Returns:** Array of identity objects with: identity_id (use with other tools), auth_type "
                "(bearer/basic/cookie/api_key), scope (admin/user/readonly/etc), expected_access (domains/"
                "endpoints this identity should access), description (role explanation), metadata (custom "
                "fields). Use identity_ids with crawler_start(identity_id=...) for authenticated crawling, "
                "auth_diff_test(identity_ids=[...]) for authz testing, and validate_cross_identity() for "
                "IDOR validation. Empty array indicates unauthenticated testing only."
            ),
            inputSchema={
                "type": "object",
                "properties": {},
                "required": [],
            },
        ),
        Tool(
            name="scope_get_rules",
            description=(
                "Get the current scope's avoid_rules and focus_rules. Avoid rules block specific "
                "methods, headers, parameters, or paths. Focus rules restrict testing to only matching "
                "requests. Rules support types: path, subdomain, domain, method, header, parameter. "

                "**When to use:** Phase 1-4 to understand fine-grained scope restrictions beyond "
                "domain/IP allowlist. Check before testing specific HTTP methods or parameters. "

                "**Dependencies:** Requires load_assessment() first. Use with scope_validate_target() "
                "for full request validation including rules. "

                "**Budget impact:** LOW - local query, no HTTP requests. "

                "**Risk level:** SAFE - read-only query of scope configuration. "

                "**Returns:** JSON with avoid_rules and focus_rules arrays. Each rule has: pattern "
                "(match string), rule_type (path/method/header/parameter/subdomain/domain), "
                "description (optional explanation)."
            ),
            inputSchema={
                "type": "object",
                "properties": {},
                "required": [],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_scope_tool(
    name: str,
    arguments: dict,
    mcp_service,
) -> List[TextContent]:
    """Dispatch a scope tool call to the appropriate handler.

    Now uses per-assessment scope via mcp_service.scope_provider.

    Parameters
    ----------
    name : str
        Tool name (one of the six scope_* tools).
    arguments : dict
        Arguments supplied by the caller.
    mcp_service :
        The MCP service instance - provides scope_provider and current_assessment_id.
    """
    # Check if assessment is selected
    if not mcp_service.current_assessment_id:
        return _error_content(
            "No assessment selected. Use load_assessment() first to select an assessment."
        )

    # Check if scope provider is available
    if not mcp_service.scope_provider:
        return _error_content(
            "Scope provider not initialized. Database connection may have failed."
        )

    assessment_id = mcp_service.current_assessment_id

    if name == "scope_validate_target":
        return await _handle_validate_target(arguments, assessment_id, mcp_service)
    elif name == "scope_get_allowlist":
        return await _handle_get_allowlist(assessment_id, mcp_service)
    elif name == "scope_get_constraints":
        return await _handle_get_constraints(assessment_id, mcp_service)
    elif name == "scope_check_budget":
        return await _handle_check_budget(arguments, assessment_id, mcp_service)
    elif name == "scope_record_request":
        return await _handle_record_request(arguments, assessment_id, mcp_service)
    elif name == "scope_get_identities":
        return await _handle_get_identities(assessment_id, mcp_service)
    elif name == "scope_get_rules":
        return await _handle_get_rules(assessment_id, mcp_service)

    return _error_content(f"Unknown scope tool: {name}")


# ---------------------------------------------------------------------------
# Individual handlers (now async and use per-assessment scope)
# ---------------------------------------------------------------------------

async def _handle_validate_target(
    arguments: dict,
    assessment_id: int,
    mcp_service,
) -> List[TextContent]:
    """Validate if a target is within the engagement scope."""
    target = arguments.get("target")
    if not isinstance(target, str) or not target:
        return _error_content("target parameter is required and must be a string")

    # Get assessment-specific validator
    validator = await mcp_service.scope_provider.get_validator(assessment_id)
    if not validator:
        return _error_content(
            f"No scope configured for assessment {assessment_id}. "
            "Configure scope using save_scope_to_db() or create ./scope/engagement.yaml"
        )

    result: ValidationResult = validator.validate_target(target)
    return _json_content(asdict(result))


async def _handle_get_allowlist(
    assessment_id: int,
    mcp_service,
) -> List[TextContent]:
    """Return the current allowlist (and denylist) for the engagement."""
    scope = await mcp_service.scope_provider.get_scope(assessment_id)
    if not scope:
        return _error_content(
            f"No scope configured for assessment {assessment_id}"
        )

    data: Dict[str, Any] = {
        "assessment_id": assessment_id,
        "engagement_id": scope.engagement.id,
        "allowlist": scope.allowlist.model_dump(exclude_none=True),
    }
    if scope.denylist is not None:
        data["denylist"] = scope.denylist.model_dump(exclude_none=True)

    return _json_content(data)


async def _handle_get_constraints(
    assessment_id: int,
    mcp_service,
) -> List[TextContent]:
    """Return engagement constraints, actions, and approval policy."""
    scope = await mcp_service.scope_provider.get_scope(assessment_id)
    if not scope:
        return _error_content(
            f"No scope configured for assessment {assessment_id}"
        )

    data: Dict[str, Any] = {
        "assessment_id": assessment_id,
        "engagement_id": scope.engagement.id,
        "constraints": scope.constraints.model_dump(),
    }
    if scope.actions is not None:
        data["actions"] = scope.actions.model_dump()
    data["approval_policy"] = scope.approval_policy.model_dump()

    return _json_content(data)


async def _handle_check_budget(
    arguments: dict,
    assessment_id: int,
    mcp_service,
) -> List[TextContent]:
    """Return the current budget/rate-limit status."""
    scope = await mcp_service.scope_provider.get_scope(assessment_id)
    if not scope:
        return _error_content(
            f"No scope configured for assessment {assessment_id}"
        )

    budget_tracker = await mcp_service.scope_provider.get_budget_tracker(assessment_id)
    if not budget_tracker:
        return _error_content(
            f"Failed to get budget tracker for assessment {assessment_id}"
        )

    identity_id = arguments.get("identity_id")
    if identity_id is not None and not isinstance(identity_id, str):
        identity_id = None

    status: BudgetStatus = budget_tracker.get_status(identity_id)

    data: Dict[str, Any] = {
        "assessment_id": assessment_id,
        "engagement_id": scope.engagement.id,
        "total_requests": status.total_requests,
        "max_total_requests": status.max_total_requests,
        "remaining_requests": status.remaining_requests,
        "requests_by_target": status.requests_by_target,
        "rate_limit_status": asdict(status.rate_limit_status),
        "budget_exhausted": status.budget_exhausted,
        "duration_exceeded": budget_tracker.is_duration_exceeded(),
        "elapsed_hours": round(budget_tracker.get_elapsed_hours() * 100) / 100,
        "max_hours": scope.constraints.budget.max_scan_duration_hours,
    }

    return _json_content(data)


async def _handle_record_request(
    arguments: dict,
    assessment_id: int,
    mcp_service,
) -> List[TextContent]:
    """Record a request and return updated budget info."""
    validator = await mcp_service.scope_provider.get_validator(assessment_id)
    if not validator:
        return _error_content(
            f"No scope configured for assessment {assessment_id}"
        )

    budget_tracker = await mcp_service.scope_provider.get_budget_tracker(assessment_id)
    if not budget_tracker:
        return _error_content(
            f"Failed to get budget tracker for assessment {assessment_id}"
        )

    target = arguments.get("target")
    if target is not None and not isinstance(target, str):
        target = None

    identity_id = arguments.get("identity_id")
    if identity_id is not None and not isinstance(identity_id, str):
        identity_id = None

    # Validate target if provided
    if target:
        validation = validator.validate_target(target)
        if not validation.valid:
            return _error_content(f"Target out of scope: {validation.reason}")

    try:
        await budget_tracker.record_request(target, identity_id)
    except BudgetExceededError as exc:
        return _error_content(str(exc))

    status: BudgetStatus = budget_tracker.get_status()

    return _json_content({
        "success": True,
        "assessment_id": assessment_id,
        "total_requests": status.total_requests,
        "remaining_requests": status.remaining_requests,
    })


async def _handle_get_identities(
    assessment_id: int,
    mcp_service,
) -> List[TextContent]:
    """Return available credentials with a has_credentials flag."""
    scope = await mcp_service.scope_provider.get_scope(assessment_id)
    if not scope:
        return _error_content(
            f"No scope configured for assessment {assessment_id}"
        )

    credentials_list: List[Dict[str, Any]] = []
    for cred in scope.credentials or []:
        credentials_list.append({
            "id": cred.id,
            "type": cred.type,
            "scope": cred.scope,
            "has_credentials": _check_credential_env_vars(cred),
        })

    return _json_content({
        "assessment_id": assessment_id,
        "engagement_id": scope.engagement.id,
        "credentials": credentials_list,
    })


async def _handle_get_rules(
    assessment_id: int,
    mcp_service,
) -> List[TextContent]:
    """Return the current scope's avoid_rules and focus_rules."""
    scope = await mcp_service.scope_provider.get_scope(assessment_id)
    if not scope:
        return _error_content(
            f"No scope configured for assessment {assessment_id}"
        )

    avoid = [r.model_dump(exclude_none=True) for r in (scope.avoid_rules or [])]
    focus = [r.model_dump(exclude_none=True) for r in (scope.focus_rules or [])]

    return _json_content({
        "assessment_id": assessment_id,
        "engagement_id": scope.engagement.id,
        "avoid_rules": avoid,
        "focus_rules": focus,
        "total_avoid": len(avoid),
        "total_focus": len(focus),
    })


def _check_credential_env_vars(cred) -> bool:
    """Check whether the environment variables for a credential are set.

    Mirrors the TypeScript ``checkCredentialEnvVars`` logic -- checks that
    the relevant env vars exist without exposing their values.
    """
    if cred.type == "basic":
        return bool(
            cred.username_env
            and os.environ.get(cred.username_env)
            and cred.password_env
            and os.environ.get(cred.password_env)
        )
    if cred.type == "bearer":
        return bool(cred.token_env and os.environ.get(cred.token_env))
    if cred.type == "api_key":
        return bool(cred.api_key_env and os.environ.get(cred.api_key_env))
    return False
