"""
Scope Guard Tools - Validate targets, manage allowlists, track budgets.

Ports the 6 tools from the scope-guard-mcp TypeScript server to Python,
following the same pattern as tools_assessment.py.
"""

import json
import logging
import os
from dataclasses import asdict
from typing import Any, Dict, List

from mcp.types import Tool, TextContent

from lib.scope_types import (
    EngagementScope,
    ValidationResult,
    BudgetStatus,
    ScopeValidationError,
    BudgetExceededError,
)
from lib.scope_loader import load_scope_from_env
from lib.scope_validator import TargetValidator
from lib.budget_tracker import BudgetTracker

logger = logging.getLogger("autopentest-mcp")

# ---------------------------------------------------------------------------
# Module-level lazy state
# ---------------------------------------------------------------------------
_scope_state: Dict[str, Any] = {
    "scope": None,
    "validator": None,
    "budget_tracker": None,
    "init_error": None,
}


def _ensure_initialized() -> None:
    """Lazily initialise scope, validator and budget tracker on first call.

    If loading fails the error is captured in ``_scope_state["init_error"]``
    so every handler can return a friendly message instead of crashing.
    """
    if _scope_state["scope"] is not None or _scope_state["init_error"] is not None:
        return

    try:
        scope: EngagementScope = load_scope_from_env()
        _scope_state["scope"] = scope
        _scope_state["validator"] = TargetValidator(scope)
        _scope_state["budget_tracker"] = BudgetTracker(scope.constraints)
        logger.info(
            "Scope guard initialized for engagement: %s",
            scope.engagement.id,
        )
    except ScopeValidationError as exc:
        msg = f"Scope configuration error: {exc}"
        if exc.errors:
            msg += "\n  - " + "\n  - ".join(exc.errors)
        _scope_state["init_error"] = msg
        logger.error(msg)
    except FileNotFoundError as exc:
        _scope_state["init_error"] = (
            f"Scope file not found. Set the SCOPE_FILE environment variable "
            f"to the path of your engagement scope YAML/JSON file. ({exc})"
        )
        logger.error(_scope_state["init_error"])
    except Exception as exc:  # noqa: BLE001
        _scope_state["init_error"] = f"Failed to initialize scope guard: {exc}"
        logger.error(_scope_state["init_error"])


def _error_content(message: str) -> List[TextContent]:
    """Return a single TextContent list wrapping a JSON error object."""
    return [TextContent(type="text", text=json.dumps({"error": message}, indent=2))]


def _json_content(data: Any) -> List[TextContent]:
    """Return a single TextContent list with *data* serialised as JSON."""
    return [TextContent(type="text", text=json.dumps(data, indent=2, default=str))]


# ---------------------------------------------------------------------------
# Tool definitions
# ---------------------------------------------------------------------------

def get_scope_tools() -> List[Tool]:
    """Return the six scope-guard tools."""
    return [
        Tool(
            name="scope_validate_target",
            description=(
                "Validate if a target (URL, domain, or IP) is within the "
                "engagement scope. Returns validation result with reason."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target": {
                        "type": "string",
                        "description": "Target to validate (URL, domain, or IP address)",
                    }
                },
                "required": ["target"],
            },
        ),
        Tool(
            name="scope_get_allowlist",
            description=(
                "Get the current allowlist of permitted targets including "
                "domains, IP ranges, ports, and services."
            ),
            inputSchema={
                "type": "object",
                "properties": {},
                "required": [],
            },
        ),
        Tool(
            name="scope_get_constraints",
            description=(
                "Get the engagement constraints including rate limits, budget, "
                "timeouts, and policies."
            ),
            inputSchema={
                "type": "object",
                "properties": {},
                "required": [],
            },
        ),
        Tool(
            name="scope_check_budget",
            description=(
                "Check current budget status including total requests, "
                "remaining requests, and rate limit status."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "identity_id": {
                        "type": "string",
                        "description": "Optional identity ID for per-identity budget status",
                    }
                },
                "required": [],
            },
        ),
        Tool(
            name="scope_record_request",
            description=(
                "Record a request for budget tracking. Returns success or "
                "error if budget exceeded."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "target": {
                        "type": "string",
                        "description": "Target of the request for per-target tracking",
                    },
                    "identity_id": {
                        "type": "string",
                        "description": "Optional identity ID for the request",
                    },
                },
                "required": [],
            },
        ),
        Tool(
            name="scope_get_identities",
            description="Get available credentials/identities for authenticated testing.",
            inputSchema={
                "type": "object",
                "properties": {},
                "required": [],
            },
        ),
    ]


# ---------------------------------------------------------------------------
# Tool handler dispatch
# ---------------------------------------------------------------------------

async def handle_scope_tool(
    name: str,
    arguments: dict,
    mcp_service,
) -> List[TextContent]:
    """Dispatch a scope tool call to the appropriate handler.

    Parameters
    ----------
    name : str
        Tool name (one of the six scope_* tools).
    arguments : dict
        Arguments supplied by the caller.
    mcp_service :
        The MCP service instance (unused by scope tools but kept for
        interface parity with other tool modules).
    """
    _ensure_initialized()

    # If initialisation failed, return the error for every call.
    if _scope_state["init_error"] is not None:
        return _error_content(_scope_state["init_error"])

    if name == "scope_validate_target":
        return _handle_validate_target(arguments)
    elif name == "scope_get_allowlist":
        return _handle_get_allowlist()
    elif name == "scope_get_constraints":
        return _handle_get_constraints()
    elif name == "scope_check_budget":
        return _handle_check_budget(arguments)
    elif name == "scope_record_request":
        return _handle_record_request(arguments)
    elif name == "scope_get_identities":
        return _handle_get_identities()

    return _error_content(f"Unknown scope tool: {name}")


# ---------------------------------------------------------------------------
# Individual handlers
# ---------------------------------------------------------------------------

def _handle_validate_target(arguments: dict) -> List[TextContent]:
    """Validate if a target is within the engagement scope."""
    target = arguments.get("target")
    if not isinstance(target, str) or not target:
        return _error_content("target parameter is required and must be a string")

    validator: TargetValidator = _scope_state["validator"]
    result: ValidationResult = validator.validate_target(target)

    return _json_content(asdict(result))


def _handle_get_allowlist() -> List[TextContent]:
    """Return the current allowlist (and denylist) for the engagement."""
    scope: EngagementScope = _scope_state["scope"]

    data: Dict[str, Any] = {
        "engagement_id": scope.engagement.id,
        "allowlist": scope.allowlist.model_dump(exclude_none=True),
    }
    if scope.denylist is not None:
        data["denylist"] = scope.denylist.model_dump(exclude_none=True)

    return _json_content(data)


def _handle_get_constraints() -> List[TextContent]:
    """Return engagement constraints, actions, and approval policy."""
    scope: EngagementScope = _scope_state["scope"]

    data: Dict[str, Any] = {
        "engagement_id": scope.engagement.id,
        "constraints": scope.constraints.model_dump(),
    }
    if scope.actions is not None:
        data["actions"] = scope.actions.model_dump()
    data["approval_policy"] = scope.approval_policy.model_dump()

    return _json_content(data)


def _handle_check_budget(arguments: dict) -> List[TextContent]:
    """Return the current budget/rate-limit status."""
    scope: EngagementScope = _scope_state["scope"]
    budget_tracker: BudgetTracker = _scope_state["budget_tracker"]

    identity_id = arguments.get("identity_id")
    if identity_id is not None and not isinstance(identity_id, str):
        identity_id = None

    status: BudgetStatus = budget_tracker.get_status(identity_id)

    data: Dict[str, Any] = {
        "engagement_id": scope.engagement.id,
        "total_requests": status.total_requests,
        "max_total_requests": status.max_total_requests,
        "remaining_requests": status.remaining_requests,
        "requests_by_target": status.requests_by_target,
        "rate_limit_status": asdict(status.rate_limit_status),
        "budget_exhausted": status.budget_exhausted,
        "duration_exceeded": budget_tracker.is_duration_exceeded(),
        "elapsed_hours": round(budget_tracker.get_elapsed_hours() * 100) / 100,
        "max_hours": scope.constraints.budget.max_scan_duration_hours,
    }

    return _json_content(data)


def _handle_record_request(arguments: dict) -> List[TextContent]:
    """Record a request and return updated budget info."""
    validator: TargetValidator = _scope_state["validator"]
    budget_tracker: BudgetTracker = _scope_state["budget_tracker"]

    target = arguments.get("target")
    if target is not None and not isinstance(target, str):
        target = None

    identity_id = arguments.get("identity_id")
    if identity_id is not None and not isinstance(identity_id, str):
        identity_id = None

    # Validate target if provided
    if target:
        validation = validator.validate_target(target)
        if not validation.valid:
            return _error_content(f"Target out of scope: {validation.reason}")

    try:
        budget_tracker.record_request(target, identity_id)
    except BudgetExceededError as exc:
        return _error_content(str(exc))

    status: BudgetStatus = budget_tracker.get_status()

    return _json_content({
        "success": True,
        "total_requests": status.total_requests,
        "remaining_requests": status.remaining_requests,
    })


def _handle_get_identities() -> List[TextContent]:
    """Return available credentials with a has_credentials flag."""
    scope: EngagementScope = _scope_state["scope"]

    credentials_list: List[Dict[str, Any]] = []
    for cred in scope.credentials or []:
        credentials_list.append({
            "id": cred.id,
            "type": cred.type,
            "scope": cred.scope,
            "has_credentials": _check_credential_env_vars(cred),
        })

    return _json_content({
        "engagement_id": scope.engagement.id,
        "credentials": credentials_list,
    })


def _check_credential_env_vars(cred) -> bool:
    """Check whether the environment variables for a credential are set.

    Mirrors the TypeScript ``checkCredentialEnvVars`` logic -- checks that
    the relevant env vars exist without exposing their values.
    """
    if cred.type == "basic":
        return bool(
            cred.username_env
            and os.environ.get(cred.username_env)
            and cred.password_env
            and os.environ.get(cred.password_env)
        )
    if cred.type == "bearer":
        return bool(cred.token_env and os.environ.get(cred.token_env))
    if cred.type == "api_key":
        return bool(cred.api_key_env and os.environ.get(cred.api_key_env))
    return False
