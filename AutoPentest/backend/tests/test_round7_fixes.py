"""
Test suite for Deep Audit Round 7 fixes.

Tests verify fixes for:
1. card_result â†’ result variable name (BLOCKER)
2. ExchangeAnalysis dataclass attribute access (HIGH)
3. http_client_factory log_http_exchange kwargs (HIGH)
4. Credential password redaction on failure (HIGH)
5. Phase 5 lifecycle - no auto-complete (MEDIUM)
6. Intermediate phases marked done on force advance (MEDIUM)
7. SQL scripts cleaned of psql meta-commands (MEDIUM)
"""

import unittest
import asyncio
import json
import re
from unittest.mock import AsyncMock, MagicMock, patch, call
from dataclasses import asdict


class TestRound7Fixes(unittest.TestCase):
    """Test all Round 7 bug fixes"""

    def setUp(self):
        """Set up test fixtures"""
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)

    def tearDown(self):
        """Clean up"""
        self.loop.close()

    # ========================================================================
    # Fix 1: card_result â†’ result variable name (BLOCKER)
    # ========================================================================

    def test_safe_add_card_uses_result_not_card_result(self):
        """Verify safe_add_card uses 'result' variable, not 'card_result'"""
        # Read the service.py file to verify variable names
        with open('/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/service.py', 'r') as f:
            content = f.read()

        # Find the safe_add_card method's wm_findings sync section
        # Should use 'result' everywhere, not 'card_result'
        pattern = r'hypothesis_id = f"auto-\{(.*?)\.get\('
        matches = re.findall(pattern, content)

        # Filter to the safe_add_card context (after line 548: result = await self.add_card)
        safe_add_card_section = content[content.find('result = await self.add_card'):content.find('result = await self.add_card') + 1500]

        # Verify 'result' is used, not 'card_result'
        self.assertIn('hypothesis_id = f"auto-{result.get', safe_add_card_section,
                     "Line 562 should use 'result', not 'card_result'")
        self.assertIn('"card_id": result.get("id")', safe_add_card_section,
                     "Line 572 should use 'result', not 'card_result'")
        self.assertNotIn('card_result.get', safe_add_card_section,
                        "'card_result' should not exist in safe_add_card wm_findings sync")

    # ========================================================================
    # Fix 2: ExchangeAnalysis dataclass attribute access (HIGH)
    # ========================================================================

    def test_batch_exchange_analysis_uses_dataclass_attrs(self):
        """Verify http_send_batch uses dataclass attributes, not .get()"""
        with open('/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/tools_http.py', 'r') as f:
            content = f.read()

        # Find the batch analysis section
        batch_section = content[content.find('if ea_result.'):content.find('if ea_result.') + 500]

        # Should use attribute access: ea_result.risk_signals, ea_result.detected_technologies
        self.assertIn('if ea_result.risk_signals or ea_result.detected_technologies:', batch_section,
                     "Should use dataclass attribute access")
        self.assertIn('from dataclasses import asdict', batch_section,
                     "Should import asdict for serialization")
        self.assertIn('asdict(ea_result)', batch_section,
                     "Should convert dataclass to dict with asdict()")
        self.assertIn('batch_findings.extend(ea_result.risk_signals)', batch_section,
                     "Should use attribute access for risk_signals")

        # Should NOT use .get() method on dataclass
        self.assertNotIn('ea_result.get("risk_signals")', batch_section,
                        "Should not use .get() on dataclass")
        self.assertNotIn('ea_result.get("tech_detected")', batch_section,
                        "Should not use old 'tech_detected' name")

    # ========================================================================
    # Fix 3: http_client_factory log_http_exchange kwargs (HIGH)
    # ========================================================================

    def test_http_client_factory_log_signature(self):
        """Verify http_client_factory passes correct kwargs to log_http_exchange"""
        with open('/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/lib/http_client_factory.py', 'r') as f:
            content = f.read()

        # Find the _log_exchange function
        log_func = content[content.find('async def _log_exchange'):content.find('async def _log_exchange') + 800]

        # Verify it decomposes dicts into individual parameters
        self.assertIn('url=request.get("url"', log_func)
        self.assertIn('method=request.get("method"', log_func)
        self.assertIn('status_code=response.get("status"', log_func)
        self.assertIn('request_headers=request.get("headers"', log_func)
        self.assertIn('response_headers=response.get("headers"', log_func)
        self.assertIn('response_body_preview=', log_func)
        self.assertIn('correlation_id=correlation_ids.get("request_id"', log_func)
        self.assertIn('timing_ms=timing.get("duration_ms"', log_func)

        # Should NOT pass dicts directly
        self.assertNotIn('request=request,', log_func)
        self.assertNotIn('response=response,', log_func)
        self.assertNotIn('correlation_ids=correlation_ids,', log_func)
        self.assertNotIn('timing=timing,', log_func)

    # ========================================================================
    # Fix 4: Credential password redaction on failure (HIGH)
    # ========================================================================

    def test_credential_failure_redacts_password(self):
        """Verify credential test failure logs use *** not plaintext password"""
        with open('/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/tools_credentials.py', 'r') as f:
            content = f.read()

        # Find the failure logging line (around line 250)
        failure_section = content[content.find('Credential test FAILED'):content.find('Credential test FAILED') + 200]

        # Verify password is redacted with ***
        self.assertIn(':*** -', failure_section,
                     "Failure log should redact password with ***")

        # Verify it does NOT log the actual password
        # The pattern should be: username:*** not username:{password}
        self.assertNotRegex(failure_section, r':\{credential_data\.get\([\'"]password',
                          "Should not log actual password on failure")

    # ========================================================================
    # Fix 5: Phase 5 lifecycle - no auto-complete (MEDIUM)
    # ========================================================================

    def test_phase6_not_auto_completed(self):
        """Verify orchestration_advance does not auto-complete phase 6 (use target_phase=7 to complete)"""
        with open('/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/tools_assessment.py', 'r') as f:
            content = f.read()

        # Find the orchestration_advance handler section
        advance_section = content[content.find('async def handle_assessment_tool'):content.find('async def handle_assessment_tool') + 5000]

        # Extract the part after "Create stub sections for skipped phases"
        if 'Create stub sections for skipped phases' in advance_section:
            after_stubs = advance_section[advance_section.find('Create stub sections for skipped phases'):]
        else:
            after_stubs = advance_section

        # Should NOT contain auto-complete logic for phase 6
        self.assertNotIn('if target_phase == 6:', after_stubs,
                        "Should not auto-complete phase 6 on advance to phase 6")
        # Complete assessment should only be called when target_phase=7
        if 'complete_assessment()' in after_stubs:
            self.assertIn('if target_phase == 7:', after_stubs,
                         "complete_assessment should only be called when target_phase=7")

    # ========================================================================
    # Fix 6: Intermediate phases marked done on force advance (MEDIUM)
    # ========================================================================

    def test_force_advance_marks_intermediate_phases_done(self):
        """Verify force advance marks all intermediate phases as done"""
        with open('/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/lib/phase_orchestrator.py', 'r') as f:
            content = f.read()

        # Find the advance() method's phase marking logic
        advance_method = content[content.find('# Perform the transition'):content.find('# Perform the transition') + 2000]

        # Should use a loop to mark phases from current to (target-1)
        self.assertIn('for phase_num in range(current_phase, target_phase):', advance_method,
                     "Should loop through all phases between current and target")
        self.assertIn('step_status="done"', advance_method,
                     "Should mark phases as done")
        self.assertIn('Skipped (force advance)', advance_method,
                     "Should mark skipped phases with appropriate message")

        # Should NOT only mark current phase
        self.assertNotRegex(advance_method, r'if current_phase >= 1 and current_phase <= 5:\s+await self\._db\.update_plan\([^)]+step_status="done"[^)]+\)\s+# Mark target',
                          "Should not only mark current phase, should mark all intermediate phases")

    # ========================================================================
    # Fix 7: SQL scripts cleaned of psql meta-commands (MEDIUM)
    # ========================================================================

    def test_activity_log_sql_no_psql_commands(self):
        """Verify SQL scripts don't contain psql-only meta-commands"""
        # Check activity_log table script
        with open('/mnt/d/testing_tool/AutoPentest/backend/scripts/create_activity_log_table.sql', 'r') as f:
            table_sql = f.read()

        # Should NOT contain psql meta-commands
        self.assertNotIn(r'\d activity_log', table_sql,
                        "Table script should not contain \\d command")
        self.assertNotIn(r'\echo', table_sql,
                        "Table script should not contain \\echo command")

        # Should NOT contain DROP TABLE (production safety)
        self.assertNotIn('DROP TABLE IF EXISTS activity_log', table_sql,
                        "Should not contain DROP TABLE for production safety")

        # Check trigger script
        with open('/mnt/d/testing_tool/AutoPentest/backend/scripts/create_activity_notify_trigger.sql', 'r') as f:
            trigger_sql = f.read()

        # Verification SELECT should be commented out for asyncpg compatibility
        lines = trigger_sql.split('\n')
        select_lines = [line for line in lines if 'SELECT tgname' in line]
        if select_lines:
            # If SELECT exists, it must be commented
            self.assertTrue(all(line.strip().startswith('--') for line in select_lines),
                          "Verification SELECT should be commented out")

    # ========================================================================
    # Code structure verification: wm_findings population
    # ========================================================================

    def test_wm_findings_code_structure(self):
        """Verify the wm_findings sync code has correct structure"""
        with open('/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/service.py', 'r') as f:
            content = f.read()

        # Find safe_add_card method - use a large window to capture all of it
        safe_add_card_start = content.find('async def safe_add_card(')
        safe_add_card_end = content.find('async def ', safe_add_card_start + 100)
        if safe_add_card_end == -1:
            safe_add_card_section = content[safe_add_card_start:]
        else:
            safe_add_card_section = content[safe_add_card_start:safe_add_card_end]

        # Verify the variable assignment exists
        self.assertIn('result = await self.add_card(', safe_add_card_section,
                     "Should assign result from add_card")

        # Check that all references use 'result' not 'card_result'
        # Count occurrences in the full method
        result_count = safe_add_card_section.count('result.get(')
        card_result_count = safe_add_card_section.count('card_result.get(')

        self.assertEqual(0, card_result_count,
                        f"Found {card_result_count} uses of 'card_result.get()' - should be 0")
        self.assertGreater(result_count, 0,
                          f"Should have uses of 'result.get()' in safe_add_card, found {result_count}")

        # Verify the exact patterns we fixed (both should exist in the full method)
        hypothesis_pattern_fixed = 'hypothesis_id = f"auto-{result.get(' in safe_add_card_section
        card_id_pattern_fixed = '"card_id": result.get("id")' in safe_add_card_section

        self.assertTrue(hypothesis_pattern_fixed,
                       "hypothesis_id should use result.get('id'), not card_result")
        self.assertTrue(card_id_pattern_fixed,
                       "metadata card_id should use result.get('id'), not card_result")


if __name__ == '__main__':
    unittest.main()
