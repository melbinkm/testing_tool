"""Tests for Wave 1 dev-beta features: Scope rules, Config validator, Login flow.

Feature #19: Method/Parameter-Level Scope Rules
Feature #23: Config JSON Schema Validation
Feature #16: Declarative Login Flow YAML Config
"""

import sys
import os
import unittest
import asyncio
from unittest.mock import AsyncMock, MagicMock, patch

# Path setup: ensure local mcp modules are importable
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'mcp', 'modules'))


# ============================================================================
# Feature #19: Scope Rules Tests
# ============================================================================

class TestScopeRule(unittest.TestCase):
    """Test ScopeRule dataclass and EngagementScope extensions."""

    def test_scope_rule_defaults(self):
        from lib.scope_types import ScopeRule
        rule = ScopeRule(pattern="GET")
        self.assertEqual(rule.pattern, "GET")
        self.assertEqual(rule.rule_type, "path")
        self.assertIsNone(rule.description)

    def test_scope_rule_method_type(self):
        from lib.scope_types import ScopeRule
        rule = ScopeRule(pattern="DELETE", rule_type="method", description="Block DELETE")
        self.assertEqual(rule.rule_type, "method")
        self.assertEqual(rule.pattern, "DELETE")
        self.assertEqual(rule.description, "Block DELETE")

    def test_engagement_scope_avoid_rules(self):
        from lib.scope_types import EngagementScope, EngagementInfo, ScopeRule
        scope = EngagementScope(
            engagement=EngagementInfo(id="test", name="test"),
            avoid_rules=[ScopeRule(pattern="DELETE", rule_type="method")],
        )
        self.assertEqual(len(scope.avoid_rules), 1)
        self.assertEqual(scope.avoid_rules[0].rule_type, "method")

    def test_engagement_scope_focus_rules(self):
        from lib.scope_types import EngagementScope, EngagementInfo, ScopeRule
        scope = EngagementScope(
            engagement=EngagementInfo(id="test", name="test"),
            focus_rules=[ScopeRule(pattern="/api/.*", rule_type="path")],
        )
        self.assertEqual(len(scope.focus_rules), 1)

    def test_engagement_scope_rules_default_none(self):
        from lib.scope_types import EngagementScope, EngagementInfo
        scope = EngagementScope(
            engagement=EngagementInfo(id="test", name="test"),
        )
        self.assertIsNone(scope.avoid_rules)
        self.assertIsNone(scope.focus_rules)


class TestScopeValidatorRequestRules(unittest.TestCase):
    """Test TargetValidator.validate_request() with method/header/parameter rules."""

    def _make_scope(self, avoid_rules=None, focus_rules=None):
        from lib.scope_types import EngagementScope, EngagementInfo, ScopeAllowlist, ScopeRule
        rules_avoid = [ScopeRule(**r) for r in (avoid_rules or [])]
        rules_focus = [ScopeRule(**r) for r in (focus_rules or [])]
        return EngagementScope(
            engagement=EngagementInfo(id="test", name="test"),
            allowlist=ScopeAllowlist(domains=["*.example.com"]),
            avoid_rules=rules_avoid or None,
            focus_rules=rules_focus or None,
        )

    def test_validate_request_no_rules(self):
        from lib.scope_validator import TargetValidator
        scope = self._make_scope()
        v = TargetValidator(scope)
        result = v.validate_request("https://api.example.com/test", method="GET")
        self.assertTrue(result.valid)

    def test_avoid_rule_blocks_method(self):
        from lib.scope_validator import TargetValidator
        scope = self._make_scope(avoid_rules=[
            {"pattern": "DELETE", "rule_type": "method"},
        ])
        v = TargetValidator(scope)
        result = v.validate_request("https://api.example.com/users", method="DELETE")
        self.assertFalse(result.valid)
        self.assertIn("avoid_rule", result.reason)

    def test_avoid_rule_allows_other_method(self):
        from lib.scope_validator import TargetValidator
        scope = self._make_scope(avoid_rules=[
            {"pattern": "DELETE", "rule_type": "method"},
        ])
        v = TargetValidator(scope)
        result = v.validate_request("https://api.example.com/users", method="GET")
        self.assertTrue(result.valid)

    def test_avoid_rule_blocks_header(self):
        from lib.scope_validator import TargetValidator
        scope = self._make_scope(avoid_rules=[
            {"pattern": "X-Custom: dangerous", "rule_type": "header"},
        ])
        v = TargetValidator(scope)
        result = v.validate_request(
            "https://api.example.com/test",
            method="GET",
            headers={"X-Custom": "dangerous-value"},
        )
        self.assertFalse(result.valid)

    def test_avoid_rule_allows_without_header(self):
        from lib.scope_validator import TargetValidator
        scope = self._make_scope(avoid_rules=[
            {"pattern": "X-Custom: dangerous", "rule_type": "header"},
        ])
        v = TargetValidator(scope)
        result = v.validate_request(
            "https://api.example.com/test",
            method="GET",
            headers={"Content-Type": "application/json"},
        )
        self.assertTrue(result.valid)

    def test_avoid_rule_blocks_parameter(self):
        from lib.scope_validator import TargetValidator
        scope = self._make_scope(avoid_rules=[
            {"pattern": "admin", "rule_type": "parameter"},
        ])
        v = TargetValidator(scope)
        result = v.validate_request(
            "https://api.example.com/test",
            params={"admin": "true"},
        )
        self.assertFalse(result.valid)

    def test_focus_rules_restrict_matching(self):
        from lib.scope_validator import TargetValidator
        scope = self._make_scope(focus_rules=[
            {"pattern": "/api/.*", "rule_type": "path"},
        ])
        v = TargetValidator(scope)
        # Matches focus rule
        result = v.validate_request("https://api.example.com/api/users")
        self.assertTrue(result.valid)

    def test_focus_rules_block_non_matching(self):
        from lib.scope_validator import TargetValidator
        scope = self._make_scope(focus_rules=[
            {"pattern": "/api/.*", "rule_type": "path"},
        ])
        v = TargetValidator(scope)
        # Does NOT match focus rule
        result = v.validate_request("https://api.example.com/admin/settings")
        self.assertFalse(result.valid)
        self.assertIn("focus_rule", result.reason)

    def test_avoid_rule_blocks_path_pattern(self):
        from lib.scope_validator import TargetValidator
        scope = self._make_scope(avoid_rules=[
            {"pattern": "/admin", "rule_type": "path"},
        ])
        v = TargetValidator(scope)
        result = v.validate_request("https://api.example.com/admin/dashboard")
        self.assertFalse(result.valid)

    def test_header_name_only_match(self):
        from lib.scope_validator import TargetValidator
        scope = self._make_scope(avoid_rules=[
            {"pattern": "authorization", "rule_type": "header"},
        ])
        v = TargetValidator(scope)
        result = v.validate_request(
            "https://api.example.com/test",
            headers={"Authorization": "Bearer token123"},
        )
        self.assertFalse(result.valid)


# ============================================================================
# Feature #19: scope_get_rules Tool Handler Tests
# ============================================================================

class TestScopeGetRulesTool(unittest.IsolatedAsyncioTestCase):
    """Test scope_get_rules tool handler."""

    async def test_scope_get_rules_returns_rules(self):
        from lib.scope_types import EngagementScope, EngagementInfo, ScopeRule
        from tools_scope import _handle_get_rules

        scope = EngagementScope(
            engagement=EngagementInfo(id="eng1", name="test"),
            avoid_rules=[ScopeRule(pattern="DELETE", rule_type="method")],
            focus_rules=[ScopeRule(pattern="/api/.*", rule_type="path")],
        )

        mock_service = MagicMock()
        mock_service.scope_provider.get_scope = AsyncMock(return_value=scope)

        result = await _handle_get_rules(1, mock_service)
        import json
        data = json.loads(result[0].text)
        self.assertEqual(data["total_avoid"], 1)
        self.assertEqual(data["total_focus"], 1)
        self.assertEqual(data["avoid_rules"][0]["pattern"], "DELETE")
        self.assertEqual(data["focus_rules"][0]["rule_type"], "path")

    async def test_scope_get_rules_empty(self):
        from lib.scope_types import EngagementScope, EngagementInfo
        from tools_scope import _handle_get_rules

        scope = EngagementScope(
            engagement=EngagementInfo(id="eng1", name="test"),
        )

        mock_service = MagicMock()
        mock_service.scope_provider.get_scope = AsyncMock(return_value=scope)

        result = await _handle_get_rules(1, mock_service)
        import json
        data = json.loads(result[0].text)
        self.assertEqual(data["total_avoid"], 0)
        self.assertEqual(data["total_focus"], 0)

    async def test_scope_get_rules_no_scope(self):
        from tools_scope import _handle_get_rules

        mock_service = MagicMock()
        mock_service.scope_provider.get_scope = AsyncMock(return_value=None)

        result = await _handle_get_rules(1, mock_service)
        import json
        data = json.loads(result[0].text)
        self.assertFalse(data["success"])


# ============================================================================
# Feature #23: Config Validator Tests
# ============================================================================

class TestConfigValidator(unittest.TestCase):
    """Test validate_scope_config()."""

    def test_valid_config(self):
        from lib.config_validator import validate_scope_config
        config = {
            "domains": ["example.com", "*.example.com"],
            "ip_ranges": ["192.168.1.0/24"],
            "ports": [80, 443, 8080],
        }
        is_valid, errors = validate_scope_config(config)
        self.assertTrue(is_valid)
        self.assertEqual(errors, [])

    def test_invalid_ports_type(self):
        from lib.config_validator import validate_scope_config
        config = {
            "ports": ["eighty"],  # Should be integers
        }
        is_valid, errors = validate_scope_config(config)
        self.assertFalse(is_valid)
        self.assertTrue(any("integer" in e.lower() for e in errors))

    def test_invalid_domains_type(self):
        from lib.config_validator import validate_scope_config
        config = {
            "domains": [123],  # Should be strings
        }
        is_valid, errors = validate_scope_config(config)
        self.assertFalse(is_valid)
        self.assertTrue(len(errors) > 0)

    def test_empty_config_valid(self):
        from lib.config_validator import validate_scope_config
        is_valid, errors = validate_scope_config({})
        self.assertTrue(is_valid)
        self.assertEqual(errors, [])

    def test_additional_properties_allowed(self):
        from lib.config_validator import validate_scope_config
        config = {
            "domains": ["example.com"],
            "custom_field": "allowed",
        }
        is_valid, errors = validate_scope_config(config)
        self.assertTrue(is_valid)

    def test_credentials_validation(self):
        from lib.config_validator import validate_scope_config
        config = {
            "credentials": [
                {"username": "admin", "password": "secret"},
            ],
        }
        is_valid, errors = validate_scope_config(config)
        self.assertTrue(is_valid)

    def test_rules_validation(self):
        from lib.config_validator import validate_scope_config
        config = {
            "rules": [
                {"type": "method", "pattern": "DELETE"},
                {"type": "path", "pattern": "/admin"},
            ],
        }
        is_valid, errors = validate_scope_config(config)
        self.assertTrue(is_valid)

    def test_multiple_errors(self):
        from lib.config_validator import validate_scope_config
        config = {
            "ports": ["not-int"],
            "domains": [42],
        }
        is_valid, errors = validate_scope_config(config)
        self.assertFalse(is_valid)
        self.assertTrue(len(errors) >= 2)


# ============================================================================
# Feature #16: Login Flow Tests
# ============================================================================

class TestLoginFlow(unittest.TestCase):
    """Test login_flow.py dataclasses and parsing."""

    def test_parse_login_flow_from_authentication(self):
        from lib.login_flow import parse_login_flow
        config = {
            "authentication": {
                "login_type": "form",
                "login_url": "https://app.example.com/login",
                "username_field": "#email",
                "password_field": "#pass",
                "steps": [
                    {"action": "navigate", "value": "https://app.example.com/login"},
                    {"action": "fill", "selector": "#email", "value": "$username"},
                    {"action": "fill", "selector": "#pass", "value": "$password"},
                    {"action": "click", "selector": "#submit"},
                    {"action": "wait", "wait_ms": 2000},
                ],
                "success_condition": "url_contains:/dashboard",
            },
        }
        flow = parse_login_flow(config)
        self.assertIsNotNone(flow)
        self.assertEqual(flow.login_type, "form")
        self.assertEqual(flow.login_url, "https://app.example.com/login")
        self.assertEqual(len(flow.steps), 5)
        self.assertEqual(flow.steps[0].action, "navigate")
        self.assertEqual(flow.steps[1].action, "fill")
        self.assertEqual(flow.steps[1].selector, "#email")
        self.assertEqual(flow.steps[1].value, "$username")
        self.assertEqual(flow.success_condition, "url_contains:/dashboard")

    def test_parse_login_flow_from_login_flow_key(self):
        from lib.login_flow import parse_login_flow
        config = {
            "login_flow": {
                "login_type": "sso",
                "login_url": "https://sso.example.com",
                "steps": [],
            },
        }
        flow = parse_login_flow(config)
        self.assertIsNotNone(flow)
        self.assertEqual(flow.login_type, "sso")

    def test_parse_login_flow_none_when_missing(self):
        from lib.login_flow import parse_login_flow
        self.assertIsNone(parse_login_flow({}))
        self.assertIsNone(parse_login_flow({"other_key": "value"}))

    def test_substitute_credentials(self):
        from lib.login_flow import substitute_credentials
        result = substitute_credentials("$username:$password", "admin", "secret123")
        self.assertEqual(result, "admin:secret123")

    def test_substitute_credentials_no_placeholders(self):
        from lib.login_flow import substitute_credentials
        result = substitute_credentials("literal_value", "admin", "secret")
        self.assertEqual(result, "literal_value")

    def test_login_step_defaults(self):
        from lib.login_flow import LoginStep
        step = LoginStep(action="click")
        self.assertEqual(step.action, "click")
        self.assertIsNone(step.selector)
        self.assertIsNone(step.value)
        self.assertEqual(step.wait_ms, 1000)

    def test_login_flow_defaults(self):
        from lib.login_flow import LoginFlow
        flow = LoginFlow(login_type="form", login_url="https://example.com/login")
        self.assertEqual(flow.steps, [])
        self.assertIsNone(flow.username_field)
        self.assertIsNone(flow.password_field)
        self.assertIsNone(flow.success_condition)

    def test_parse_login_flow_defaults_fields(self):
        from lib.login_flow import parse_login_flow
        config = {
            "authentication": {
                "login_url": "https://example.com/login",
            },
        }
        flow = parse_login_flow(config)
        self.assertIsNotNone(flow)
        self.assertEqual(flow.login_type, "form")
        self.assertEqual(flow.username_field, "#username")
        self.assertEqual(flow.password_field, "#password")


class TestBrowserLoginHandler(unittest.IsolatedAsyncioTestCase):
    """Test the browser_login tool handler."""

    async def test_browser_login_no_scope(self):
        from tools_browser import _handle_login
        mock_service = MagicMock()
        mock_service.scope_provider = None
        result = await _handle_login({}, mock_service)
        import json
        data = json.loads(result[0].text)
        self.assertFalse(data["success"])

    async def test_browser_login_no_login_flow(self):
        from lib.scope_types import EngagementScope, EngagementInfo
        from tools_browser import _handle_login

        scope = EngagementScope(
            engagement=EngagementInfo(id="test", name="test"),
        )
        mock_service = MagicMock()
        mock_service.current_assessment_id = 1
        mock_service.scope_provider.get_scope = AsyncMock(return_value=scope)

        result = await _handle_login({}, mock_service)
        import json
        data = json.loads(result[0].text)
        self.assertFalse(data["success"])
        self.assertIn("No login flow configured", data["error"])

    async def test_browser_login_no_assessment(self):
        from tools_browser import _handle_login
        mock_service = MagicMock()
        mock_service.current_assessment_id = None
        mock_service.scope_provider = MagicMock()
        result = await _handle_login({}, mock_service)
        import json
        data = json.loads(result[0].text)
        self.assertFalse(data["success"])
        self.assertIn("No assessment loaded", data["error"])


if __name__ == "__main__":
    unittest.main()
