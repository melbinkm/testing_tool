"""
Test Deep Audit Round 12 Fixes

Tests for 3 runtime data bugs:
1. batch_analysis.auto_findings_created not overwritten
2. SQL script idempotent with IF NOT EXISTS
3. _get_db raises error instead of defaulting to assessment 1
"""

import unittest
from unittest.mock import AsyncMock, MagicMock, patch
import sys
import os

# Add modules to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))


class TestRound12Fixes(unittest.IsolatedAsyncioTestCase):
    """Test Round 12 bug fixes."""

    # -------------------------------------------------------------------------
    # Fix 1A: batch_analysis.auto_findings_created preserved
    # -------------------------------------------------------------------------

    def test_batch_analysis_auto_findings_preserved(self):
        """Verify auto_findings_created is set AFTER batch_analysis dict (not overwritten)."""
        import os

        # Read the source code
        tools_http_path = os.path.join(
            os.path.dirname(__file__),
            "../mcp/modules/tools_http.py"
        )

        with open(tools_http_path, "r") as f:
            content = f.read()

        # Find the section that builds batch_analysis
        batch_analysis_start = content.find('if batch_findings:')
        self.assertNotEqual(batch_analysis_start, -1, "batch_findings block not found")

        # Extract the block (next ~200 chars should contain both operations)
        block = content[batch_analysis_start:batch_analysis_start + 600]

        # Verify the ORDER: batch_analysis dict creation comes BEFORE auto_findings_created
        dict_creation = block.find('result["batch_analysis"] = {')
        auto_findings = block.find('result["batch_analysis"]["auto_findings_created"]')

        self.assertNotEqual(dict_creation, -1, "batch_analysis dict creation not found")
        self.assertNotEqual(auto_findings, -1, "auto_findings_created not found")

        # Critical: dict creation must come BEFORE auto_findings_created assignment
        self.assertLess(dict_creation, auto_findings,
            "BUG: batch_analysis dict overwrites auto_findings_created! Dict creation must come BEFORE.")

    # -------------------------------------------------------------------------
    # Fix 1C: _get_db raises error instead of defaulting
    # -------------------------------------------------------------------------

    async def test_get_db_raises_when_no_assessment(self):
        """Verify _get_db raises ValueError when no assessment is loaded."""
        from tools_endpoint_analysis import _get_db

        # Mock service with NO current_assessment_id
        mock_service = MagicMock()
        mock_service.current_assessment_id = None

        with self.assertRaises(ValueError) as ctx:
            await _get_db(mock_service)

        self.assertIn("No assessment", str(ctx.exception))
        self.assertIn("load_assessment", str(ctx.exception))

    async def test_get_db_works_with_valid_assessment(self):
        """Verify _get_db works normally when assessment is loaded."""
        from tools_endpoint_analysis import _get_db
        from lib.world_model_db import WorldModelDatabase

        # Mock service with valid assessment_id
        mock_service = MagicMock()
        mock_service.current_assessment_id = 5

        # Mock the world model DB factory at the module level where it's imported
        mock_db = MagicMock(spec=WorldModelDatabase)

        with patch('lib.tool_helpers.get_world_model_db', new_callable=AsyncMock, return_value=mock_db):
            result = await _get_db(mock_service)

        self.assertEqual(result, mock_db)


# -------------------------------------------------------------------------
# Fix 1B: SQL script idempotence - requires PostgreSQL, skip in unit tests
# -------------------------------------------------------------------------

class TestSQLScriptIdempotence(unittest.TestCase):
    """Test SQL script can be run multiple times without error."""

    def test_sql_script_has_if_not_exists(self):
        """Verify SQL script contains IF NOT EXISTS clauses."""
        sql_path = os.path.join(
            os.path.dirname(__file__),
            "../scripts/create_activity_log_table.sql"
        )

        with open(sql_path, "r") as f:
            sql_content = f.read()

        # Verify CREATE TABLE IF NOT EXISTS
        self.assertIn("CREATE TABLE IF NOT EXISTS activity_log", sql_content)

        # Verify all 5 indexes have IF NOT EXISTS
        self.assertIn("CREATE INDEX IF NOT EXISTS idx_activity_assessment", sql_content)
        self.assertIn("CREATE INDEX IF NOT EXISTS idx_activity_type", sql_content)
        self.assertIn("CREATE INDEX IF NOT EXISTS idx_activity_timestamp", sql_content)
        self.assertIn("CREATE INDEX IF NOT EXISTS idx_activity_type_assessment", sql_content)
        self.assertIn("CREATE INDEX IF NOT EXISTS idx_activity_data_gin", sql_content)


if __name__ == "__main__":
    unittest.main()
