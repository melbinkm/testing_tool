"""Tests for D2 - User Instructions per Assessment (set_instructions tool)."""
import sys
import os
import unittest
import json
from unittest.mock import AsyncMock, MagicMock, patch

# Fix import path: local mcp/ must come before pip mcp package
sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'mcp', 'modules'))
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


def _make_mock_service(assessment_id=1):
    """Create a mock MCP service with assessment loaded."""
    svc = MagicMock()
    svc.current_assessment_id = assessment_id
    return svc


def _make_mock_db():
    """Create a mock WorldModelDatabase."""
    db = AsyncMock()
    db.store_knowledge = AsyncMock()
    return db


class TestSetInstructions(unittest.IsolatedAsyncioTestCase):
    """Test set_instructions tool handler."""

    @patch("lib.tool_helpers.get_world_model_db")
    async def test_stores_text_successfully(self, mock_get_db):
        from tools_assessment import _handle_set_instructions
        mock_db = _make_mock_db()
        mock_get_db.return_value = mock_db
        svc = _make_mock_service()

        result = await _handle_set_instructions(
            {"text": "Focus on IDOR vulnerabilities in /api/users"},
            svc
        )
        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        mock_db.store_knowledge.assert_called_once()
        call_args = mock_db.store_knowledge.call_args
        # Positional args: source_tool, category, title, content
        self.assertEqual(call_args[0][0], "set_instructions")
        self.assertEqual(call_args[0][1], "other")
        self.assertEqual(call_args[0][2], "assessment_instructions")

    @patch("lib.tool_helpers.get_world_model_db")
    async def test_rejects_empty_text(self, mock_get_db):
        from tools_assessment import _handle_set_instructions
        svc = _make_mock_service()

        result = await _handle_set_instructions({"text": "  "}, svc)
        text = result[0].text
        self.assertIn("empty", text.lower())

    @patch("lib.tool_helpers.get_world_model_db")
    async def test_returns_char_count(self, mock_get_db):
        from tools_assessment import _handle_set_instructions
        mock_db = _make_mock_db()
        mock_get_db.return_value = mock_db
        svc = _make_mock_service()

        instructions = "Test all API endpoints for broken access control"
        result = await _handle_set_instructions({"text": instructions}, svc)
        data = json.loads(result[0].text)
        self.assertEqual(data["char_count"], len(instructions))

    @patch("lib.tool_helpers.get_world_model_db")
    async def test_returns_resource_uri(self, mock_get_db):
        from tools_assessment import _handle_set_instructions
        mock_db = _make_mock_db()
        mock_get_db.return_value = mock_db
        svc = _make_mock_service()

        result = await _handle_set_instructions(
            {"text": "Focus on authentication"},
            svc
        )
        data = json.loads(result[0].text)
        self.assertEqual(data["resource_uri"], "autopentest://instructions")


class TestSetInstructionsToolRegistered(unittest.TestCase):
    """Test that set_instructions tool is properly registered."""

    def test_tool_in_assessment_tools(self):
        from tools_assessment import get_assessment_tools
        tools = get_assessment_tools()
        tool_names = [t.name for t in tools]
        self.assertIn("set_instructions", tool_names)


if __name__ == "__main__":
    unittest.main()
