"""
Tests for Code Audit Tools

Tests the 4 code audit tools:
1. code_audit_enumerate - Parse functions, create audit queue
2. code_audit_get_next - Get next unreviewed function
3. code_audit_mark_reviewed - Record LLM verdict
4. code_audit_progress - Show audit completion stats
"""
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

import unittest
from unittest.mock import MagicMock, AsyncMock, patch
from typing import Any, Dict, List


# Mock MCP types
class MockTextContent:
    def __init__(self, type: str, text: str):
        self.type = type
        self.text = text


# Import after path setup
from tools_code_audit import (
    _handle_code_audit_enumerate,
    _handle_code_audit_get_next,
    _handle_code_audit_mark_reviewed,
    _handle_code_audit_progress,
    _calculate_function_risk,
    _score_to_tier,
)


class MockMCPService:
    """Mock MCP service for testing."""
    def __init__(self, assessment_id: int = 1):
        self.current_assessment_id = assessment_id
        self.added_cards = []

    async def safe_add_card(self, **kwargs):
        """Mock safe_add_card method."""
        self.added_cards.append(kwargs)


class MockDB:
    """Mock WorldModelDatabase."""
    def __init__(self):
        self.knowledge_store = []
        self.knowledge_id_counter = 1

    async def recall_knowledge(self, category: str = None, limit: int = 1000) -> List[Dict[str, Any]]:
        """Mock recall_knowledge."""
        results = []
        for entry in self.knowledge_store:
            if category and entry.get("category") != category:
                continue
            results.append(entry)
            if len(results) >= limit:
                break
        return results

    async def store_knowledge(self, **kwargs) -> str:
        """Mock store_knowledge."""
        entry_id = f"mock-id-{self.knowledge_id_counter}"
        self.knowledge_id_counter += 1
        entry = {
            "id": entry_id,
            **kwargs
        }
        self.knowledge_store.append(entry)
        return entry_id

    async def update_knowledge(self, entry_id: str, **kwargs) -> None:
        """Mock update_knowledge."""
        for entry in self.knowledge_store:
            if entry["id"] == entry_id:
                entry.update(kwargs)
                break

    async def get_knowledge_chunks(self, parent_id: str) -> List[Dict[str, Any]]:
        """Mock get_knowledge_chunks - reassemble all chunks for a parent."""
        chunks = [
            e for e in self.knowledge_store
            if e.get("id") == parent_id or e.get("parent_id") == parent_id
        ]
        return sorted(chunks, key=lambda c: c.get("chunk_index", 0))


class MockCodeIndexer:
    """Mock CodeIndexer."""
    def enumerate_functions_with_lines(self, content: str, language: str, include_tests: bool = False) -> List[Dict[str, Any]]:
        """Mock enumerate_functions_with_lines."""
        if language == "python":
            return [
                {"name": "authenticate_user", "start_line": 10, "end_line": 30, "signature": "def authenticate_user(username, password):"},
                {"name": "execute_query", "start_line": 35, "end_line": 50, "signature": "def execute_query(sql, params):"},
                {"name": "upload_file", "start_line": 55, "end_line": 75, "signature": "def upload_file(file_path):"},
            ]
        elif language == "javascript":
            return [
                {"name": "handleLogin", "start_line": 5, "end_line": 20, "signature": "function handleLogin(req, res) {"},
                {"name": "processPayment", "start_line": 25, "end_line": 45, "signature": "const processPayment = (amount) => {"},
            ]
        else:
            return []

    def extract_function_at_line(self, content: str, language: str, line_number: int) -> Dict[str, Any]:
        """Mock extract_function_at_line."""
        return {
            "function_name": "authenticate_user",
            "start_line": 10,
            "end_line": 30,
            "code": "def authenticate_user(username, password):\n    # Authenticate user\n    return True"
        }


class MockSASTRunner:
    """Mock SASTRunner."""
    repo_base_dir = "/workspace/repos"

    async def _exec(self, cmd: str, args: List[str], timeout: int = 10) -> Dict[str, Any]:
        """Mock _exec method."""
        if cmd == "cat":
            return {
                "exit_code": 0,
                "stdout": "def authenticate_user(username, password):\n    # Authenticate user\n    return True",
                "stderr": ""
            }
        if cmd == "find":
            # Simulate repo directory discovery
            return {
                "exit_code": 0,
                "stdout": "/workspace/repos/1\n/workspace/repos/1/my-repo",
                "stderr": ""
            }
        return {"exit_code": 1, "stdout": "", "stderr": "Unknown command"}


class TestCodeAudit(unittest.IsolatedAsyncioTestCase):
    """Tests for code audit tools."""

    def setUp(self):
        """Set up test fixtures."""
        self.mock_service = MockMCPService()
        self.mock_db = MockDB()
        self.mock_indexer = MockCodeIndexer()
        self.mock_sast_runner = MockSASTRunner()

    # Test 1: Function enumeration (Python)
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    @patch('tools_code_audit.get_sast_runner')
    @patch('tools_code_audit.get_code_indexer')
    async def test_enumerate_functions_python(self, mock_get_indexer, mock_get_runner, mock_get_db):
        """Test enumerate extracts Python functions correctly."""
        mock_get_db.return_value = self.mock_db
        mock_get_runner.return_value = self.mock_sast_runner
        mock_get_indexer.return_value = self.mock_indexer

        # Add source file to knowledge store
        await self.mock_db.store_knowledge(
            title="auth/login.py",
            content="def authenticate_user(username, password):\n    pass",
            category="source_code",
            metadata={"language": "python", "priority_score": 80}
        )

        # Enumerate
        result = await _handle_code_audit_enumerate({}, self.mock_service)

        # Verify functions queued
        queue_items = await self.mock_db.recall_knowledge(category="code_audit_queue")
        self.assertEqual(len(queue_items), 3)  # 3 Python functions
        self.assertEqual(queue_items[0]["metadata"]["function_name"], "authenticate_user")
        self.assertIn("critical", [q["metadata"]["risk_tier"] for q in queue_items])

    # Test 2: Function enumeration (JavaScript)
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    @patch('tools_code_audit.get_sast_runner')
    @patch('tools_code_audit.get_code_indexer')
    async def test_enumerate_functions_javascript(self, mock_get_indexer, mock_get_runner, mock_get_db):
        """Test enumerate extracts JavaScript functions correctly."""
        mock_get_db.return_value = self.mock_db
        mock_get_runner.return_value = self.mock_sast_runner
        mock_get_indexer.return_value = self.mock_indexer

        # Add source file
        await self.mock_db.store_knowledge(
            title="routes/payment.js",
            content="function handleLogin(req, res) {}",
            category="source_code",
            metadata={"language": "javascript", "priority_score": 70}
        )

        # Enumerate
        result = await _handle_code_audit_enumerate({}, self.mock_service)

        # Verify
        queue_items = await self.mock_db.recall_knowledge(category="code_audit_queue")
        self.assertEqual(len(queue_items), 2)  # 2 JS functions
        self.assertIn("handleLogin", [q["metadata"]["function_name"] for q in queue_items])

    # Test 3: Empty file handling
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    @patch('tools_code_audit.get_sast_runner')
    @patch('tools_code_audit.get_code_indexer')
    async def test_enumerate_functions_empty(self, mock_get_indexer, mock_get_runner, mock_get_db):
        """Test enumerate handles empty files correctly."""
        mock_get_db.return_value = self.mock_db
        mock_get_runner.return_value = self.mock_sast_runner
        mock_get_indexer.return_value = self.mock_indexer

        # Add empty source file
        await self.mock_db.store_knowledge(
            title="empty.py",
            content="",
            category="source_code",
            metadata={"language": "python", "priority_score": 50}
        )

        # Enumerate
        result = await _handle_code_audit_enumerate({}, self.mock_service)

        # Verify no functions queued
        queue_items = await self.mock_db.recall_knowledge(category="code_audit_queue")
        self.assertEqual(len(queue_items), 0)

    # Test 4: Enumerate handler stores queue items correctly
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    @patch('tools_code_audit.get_sast_runner')
    @patch('tools_code_audit.get_code_indexer')
    async def test_enumerate_basic(self, mock_get_indexer, mock_get_runner, mock_get_db):
        """Test enumerate handler stores queue items with correct metadata."""
        mock_get_db.return_value = self.mock_db
        mock_get_runner.return_value = self.mock_sast_runner
        mock_get_indexer.return_value = self.mock_indexer

        # Add source file
        await self.mock_db.store_knowledge(
            title="auth/login.py",
            content="def authenticate_user(username, password):\n    pass",
            category="source_code",
            metadata={"language": "python", "priority_score": 80}
        )

        # Enumerate with max_functions=1
        result = await _handle_code_audit_enumerate({"max_functions": 1}, self.mock_service)

        # Verify
        queue_items = await self.mock_db.recall_knowledge(category="code_audit_queue")
        self.assertEqual(len(queue_items), 1)
        self.assertEqual(queue_items[0]["category"], "code_audit_queue")
        self.assertFalse(queue_items[0]["metadata"]["reviewed"])
        self.assertIsNotNone(queue_items[0]["metadata"]["risk_score"])

    # Test 5: SAST overlap detection
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    @patch('tools_code_audit.get_sast_runner')
    @patch('tools_code_audit.get_code_indexer')
    async def test_enumerate_sast_overlap(self, mock_get_indexer, mock_get_runner, mock_get_db):
        """Test enumerate auto-marks functions covered by SAST."""
        mock_get_db.return_value = self.mock_db
        mock_get_runner.return_value = self.mock_sast_runner
        mock_get_indexer.return_value = self.mock_indexer

        # Add source file
        await self.mock_db.store_knowledge(
            title="auth/login.py",
            content="def authenticate_user(username, password):\n    pass",
            category="source_code",
            metadata={"language": "python", "priority_score": 80}
        )

        # Add SAST finding at line 15 (within authenticate_user function 10-30)
        await self.mock_db.store_knowledge(
            title="auth/login.py",
            content="SQL injection detected",
            category="sast_scan_result",
            metadata={"line": 15}
        )

        # Enumerate
        result = await _handle_code_audit_enumerate({}, self.mock_service)

        # Verify auto-marked as reviewed
        queue_items = await self.mock_db.recall_knowledge(category="code_audit_queue")
        covered_funcs = [q for q in queue_items if q["metadata"]["function_name"] == "authenticate_user"]
        self.assertTrue(covered_funcs[0]["metadata"]["reviewed"])
        self.assertEqual(covered_funcs[0]["metadata"]["verdict"], "covered_by_sast")

    # Test 6: Get next returns highest-risk function
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    @patch('tools_code_audit.get_sast_runner')
    @patch('tools_code_audit.get_code_indexer')
    async def test_get_next_returns_function(self, mock_get_indexer, mock_get_runner, mock_get_db):
        """Test get_next returns highest-risk unreviewed function."""
        mock_get_db.return_value = self.mock_db
        mock_get_runner.return_value = self.mock_sast_runner
        mock_get_indexer.return_value = self.mock_indexer

        # Add queue items with different risk scores
        await self.mock_db.store_knowledge(
            title="low_risk.py::helper",
            content="def helper():",
            category="code_audit_queue",
            target="low_risk.py",
            metadata={
                "file": "low_risk.py",
                "function_name": "helper",
                "start_line": 1,
                "end_line": 5,
                "language": "python",
                "risk_score": 30,
                "risk_tier": "low",
                "reviewed": False,
                "verdict": None,
                "signature": "def helper():"
            }
        )

        await self.mock_db.store_knowledge(
            title="high_risk.py::authenticate_user",
            content="def authenticate_user():",
            category="code_audit_queue",
            target="high_risk.py",
            metadata={
                "file": "high_risk.py",
                "function_name": "authenticate_user",
                "start_line": 10,
                "end_line": 30,
                "language": "python",
                "risk_score": 90,
                "risk_tier": "critical",
                "reviewed": False,
                "verdict": None,
                "signature": "def authenticate_user():"
            }
        )

        # Get next
        result = await _handle_code_audit_get_next({}, self.mock_service)

        # Verify highest risk returned
        self.assertIn("authenticate_user", result[0].text)
        self.assertIn("90", result[0].text)  # risk_score

    # Test 7: Get next with tier filter
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    @patch('tools_code_audit.get_sast_runner')
    @patch('tools_code_audit.get_code_indexer')
    async def test_get_next_with_tier_filter(self, mock_get_indexer, mock_get_runner, mock_get_db):
        """Test get_next risk_tier filter works."""
        mock_get_db.return_value = self.mock_db
        mock_get_runner.return_value = self.mock_sast_runner
        mock_get_indexer.return_value = self.mock_indexer

        # Add low and high risk functions
        await self.mock_db.store_knowledge(
            title="low_risk.py::helper",
            content="def helper():",
            category="code_audit_queue",
            target="low_risk.py",
            metadata={
                "file": "low_risk.py",
                "function_name": "helper",
                "start_line": 1,
                "end_line": 5,
                "language": "python",
                "risk_score": 30,
                "risk_tier": "low",
                "reviewed": False,
                "verdict": None,
                "signature": "def helper():"
            }
        )

        # Get next with tier filter
        result = await _handle_code_audit_get_next({"risk_tier": "critical"}, self.mock_service)

        # Verify no critical tier functions (should return all_reviewed or no match)
        self.assertNotIn("helper", result[0].text)

    # Test 8: Get next when all reviewed
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    @patch('tools_code_audit.get_sast_runner')
    @patch('tools_code_audit.get_code_indexer')
    async def test_get_next_all_reviewed(self, mock_get_indexer, mock_get_runner, mock_get_db):
        """Test get_next returns all_reviewed when nothing left."""
        mock_get_db.return_value = self.mock_db
        mock_get_runner.return_value = self.mock_sast_runner
        mock_get_indexer.return_value = self.mock_indexer

        # Add reviewed queue item
        await self.mock_db.store_knowledge(
            title="file.py::func",
            content="def func():",
            category="code_audit_queue",
            target="file.py",
            metadata={
                "file": "file.py",
                "function_name": "func",
                "start_line": 1,
                "end_line": 5,
                "language": "python",
                "risk_score": 50,
                "risk_tier": "medium",
                "reviewed": True,
                "verdict": "safe",
                "signature": "def func():"
            }
        )

        # Get next
        result = await _handle_code_audit_get_next({}, self.mock_service)

        # Verify all_reviewed status
        self.assertIn("All functions reviewed", result[0].text)

    # Test 9: Mark reviewed as vulnerable creates finding
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    async def test_mark_reviewed_vulnerable(self, mock_get_db):
        """Test mark_reviewed with verdict=vulnerable creates finding."""
        mock_get_db.return_value = self.mock_db

        # Add queue item
        queue_id = await self.mock_db.store_knowledge(
            title="file.py::vulnerable_func",
            content="def vulnerable_func():",
            category="code_audit_queue",
            target="file.py",
            metadata={
                "file": "file.py",
                "function_name": "vulnerable_func",
                "start_line": 10,
                "end_line": 20,
                "language": "python",
                "risk_score": 80,
                "risk_tier": "critical",
                "reviewed": False,
                "verdict": None,
                "signature": "def vulnerable_func():"
            }
        )

        # Mark as vulnerable
        result = await _handle_code_audit_mark_reviewed({
            "queue_item_id": queue_id,
            "verdict": "vulnerable",
            "vuln_class": "sql_injection",
            "severity": "high",
            "description": "Unsanitized SQL query"
        }, self.mock_service)

        # Verify finding created
        self.assertEqual(len(self.mock_service.added_cards), 1)
        self.assertEqual(self.mock_service.added_cards[0]["card_type"], "finding")
        self.assertIn("sql_injection", self.mock_service.added_cards[0]["title"])

        # Verify metadata updated
        queue_items = await self.mock_db.recall_knowledge(category="code_audit_queue")
        updated = next(q for q in queue_items if q["id"] == queue_id)
        self.assertTrue(updated["metadata"]["reviewed"])
        self.assertEqual(updated["metadata"]["verdict"], "vulnerable")

    # Test 10: Mark reviewed as safe (no finding created)
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    async def test_mark_reviewed_safe(self, mock_get_db):
        """Test mark_reviewed with verdict=safe does not create finding."""
        mock_get_db.return_value = self.mock_db

        # Add queue item
        queue_id = await self.mock_db.store_knowledge(
            title="file.py::safe_func",
            content="def safe_func():",
            category="code_audit_queue",
            target="file.py",
            metadata={
                "file": "file.py",
                "function_name": "safe_func",
                "start_line": 1,
                "end_line": 5,
                "language": "python",
                "risk_score": 40,
                "risk_tier": "medium",
                "reviewed": False,
                "verdict": None,
                "signature": "def safe_func():"
            }
        )

        # Mark as safe
        result = await _handle_code_audit_mark_reviewed({
            "queue_item_id": queue_id,
            "verdict": "safe"
        }, self.mock_service)

        # Verify no finding created
        self.assertEqual(len(self.mock_service.added_cards), 0)

        # Verify metadata updated
        queue_items = await self.mock_db.recall_knowledge(category="code_audit_queue")
        updated = next(q for q in queue_items if q["id"] == queue_id)
        self.assertTrue(updated["metadata"]["reviewed"])
        self.assertEqual(updated["metadata"]["verdict"], "safe")

    # Test 11: Mark reviewed as suspicious
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    async def test_mark_reviewed_suspicious(self, mock_get_db):
        """Test mark_reviewed with verdict=suspicious stores reason."""
        mock_get_db.return_value = self.mock_db

        # Add queue item
        queue_id = await self.mock_db.store_knowledge(
            title="file.py::suspicious_func",
            content="def suspicious_func():",
            category="code_audit_queue",
            target="file.py",
            metadata={
                "file": "file.py",
                "function_name": "suspicious_func",
                "start_line": 10,
                "end_line": 20,
                "language": "python",
                "risk_score": 60,
                "risk_tier": "high",
                "reviewed": False,
                "verdict": None,
                "signature": "def suspicious_func():"
            }
        )

        # Mark as suspicious
        result = await _handle_code_audit_mark_reviewed({
            "queue_item_id": queue_id,
            "verdict": "suspicious",
            "suspicious_reason": "Possible SQL injection, needs dynamic testing"
        }, self.mock_service)

        # Verify no finding created
        self.assertEqual(len(self.mock_service.added_cards), 0)

        # Verify reason stored
        queue_items = await self.mock_db.recall_knowledge(category="code_audit_queue")
        updated = next(q for q in queue_items if q["id"] == queue_id)
        self.assertTrue(updated["metadata"]["reviewed"])
        self.assertEqual(updated["metadata"]["verdict"], "suspicious")
        self.assertIn("SQL injection", updated["metadata"]["suspicious_reason"])

    # Test 12: Progress returns correct stats
    @patch('tools_code_audit._get_db', new_callable=AsyncMock)
    async def test_progress(self, mock_get_db):
        """Test progress returns correct counts and percentages."""
        mock_get_db.return_value = self.mock_db

        # Add queue items with different verdicts
        await self.mock_db.store_knowledge(
            title="file1.py::func1",
            content="def func1():",
            category="code_audit_queue",
            target="file1.py",
            metadata={
                "file": "file1.py",
                "function_name": "func1",
                "start_line": 1,
                "end_line": 5,
                "language": "python",
                "risk_score": 50,
                "risk_tier": "medium",
                "reviewed": True,
                "verdict": "safe",
                "signature": "def func1():"
            }
        )

        await self.mock_db.store_knowledge(
            title="file2.py::func2",
            content="def func2():",
            category="code_audit_queue",
            target="file2.py",
            metadata={
                "file": "file2.py",
                "function_name": "func2",
                "start_line": 10,
                "end_line": 20,
                "language": "python",
                "risk_score": 80,
                "risk_tier": "critical",
                "reviewed": True,
                "verdict": "vulnerable",
                "signature": "def func2():"
            }
        )

        await self.mock_db.store_knowledge(
            title="file3.py::func3",
            content="def func3():",
            category="code_audit_queue",
            target="file3.py",
            metadata={
                "file": "file3.py",
                "function_name": "func3",
                "start_line": 30,
                "end_line": 40,
                "language": "python",
                "risk_score": 60,
                "risk_tier": "high",
                "reviewed": False,
                "verdict": None,
                "signature": "def func3():"
            }
        )

        # Get progress
        result = await _handle_code_audit_progress({}, self.mock_service)

        # Verify stats
        self.assertIn("total: 3", result[0].text)
        self.assertIn("reviewed: 2", result[0].text)
        self.assertIn("unreviewed: 1", result[0].text)
        self.assertIn("completion_pct: 66.7", result[0].text)
        self.assertIn("findings_created: 1", result[0].text)


class TestHelperFunctions(unittest.TestCase):
    """Tests for helper functions."""

    def test_calculate_function_risk(self):
        """Test risk score calculation."""
        # Auth function
        score = _calculate_function_risk("authenticate_user", 50)
        self.assertGreater(score, 50)  # Base + auth bonus

        # SQL function
        score = _calculate_function_risk("execute_query", 50)
        self.assertGreater(score, 50)  # Base + SQL bonus

        # eval function (highest risk)
        score = _calculate_function_risk("eval_code", 50)
        self.assertEqual(score, 75)  # Base + eval bonus (+25)

        # Plain helper
        score = _calculate_function_risk("helper", 50)
        self.assertEqual(score, 50)  # Base only

    def test_score_to_tier(self):
        """Test risk score to tier mapping."""
        self.assertEqual(_score_to_tier(85), "critical")
        self.assertEqual(_score_to_tier(65), "high")
        self.assertEqual(_score_to_tier(45), "medium")
        self.assertEqual(_score_to_tier(25), "low")


if __name__ == '__main__':
    unittest.main()
