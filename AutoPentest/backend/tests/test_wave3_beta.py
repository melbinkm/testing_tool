"""Tests for Wave 3 dev-beta features: Dataflow tracer, Exploitation queue, SAST→DAST.

Feature #2: LLM-Based Data-Flow Source-to-Sink Tracing
Feature #3: Exploitation Queue (Code-Analysis-Derived Attack Plan)
Feature #8: Stronger SAST→DAST Connection
"""

import sys
import os
import json
import unittest
from unittest.mock import AsyncMock, MagicMock, patch

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'mcp', 'modules'))


# ============================================================================
# Feature #2: Dataflow Tracer (lib)
# ============================================================================

class TestDataflowTracer(unittest.TestCase):
    """Test dataflow_tracer.py library."""

    def test_trace_empty_findings(self):
        from lib.dataflow_tracer import trace_dataflow
        traces = trace_dataflow([])
        self.assertEqual(len(traces), 0)

    def test_trace_finding_with_source_and_sink(self):
        from lib.dataflow_tracer import trace_dataflow
        findings = [{
            "content": "cursor.execute(request.args.get('id'))",
            "metadata": {
                "file": "routes/users.py",
                "line": 42,
                "vuln_class": "sql_injection",
                "severity": "high",
            },
        }]
        traces = trace_dataflow(findings)
        self.assertEqual(len(traces), 1)
        trace = traces[0]
        self.assertIsNotNone(trace.source)
        self.assertIsNotNone(trace.sink)
        self.assertEqual(trace.source.input_type.value, "query_param")
        # "exec" matches before "cursor.execute" in _DANGEROUS_SINKS iteration order
        self.assertIn(trace.sink.function, ("exec", "execute", "cursor.execute"))

    def test_trace_verdict_vulnerable_no_sanitization(self):
        from lib.dataflow_tracer import trace_dataflow, DataFlowVerdict
        findings = [{
            "content": "os.system(request.form['cmd'])",
            "metadata": {
                "file": "api/admin.py",
                "line": 10,
                "vuln_class": "command_injection",
                "severity": "critical",
            },
        }]
        traces = trace_dataflow(findings)
        self.assertEqual(traces[0].verdict, DataFlowVerdict.VULNERABLE)
        self.assertGreaterEqual(traces[0].confidence, 0.7)

    def test_trace_verdict_safe_with_sanitization(self):
        from lib.dataflow_tracer import trace_dataflow, DataFlowVerdict
        findings = [{
            "content": "cursor.execute(parameterize(request.args['q']))",
            "metadata": {
                "file": "routes/search.py",
                "line": 20,
                "vuln_class": "sql_injection",
                "severity": "high",
            },
        }]
        traces = trace_dataflow(findings)
        self.assertEqual(traces[0].verdict, DataFlowVerdict.SAFE)

    def test_trace_needs_review_no_source(self):
        from lib.dataflow_tracer import trace_dataflow, DataFlowVerdict
        findings = [{
            "content": "eval(some_variable)",
            "metadata": {
                "file": "utils/eval.py",
                "line": 5,
                "vuln_class": "code_injection",
                "severity": "high",
            },
        }]
        traces = trace_dataflow(findings)
        self.assertEqual(traces[0].verdict, DataFlowVerdict.NEEDS_REVIEW)

    def test_trace_to_dict(self):
        from lib.dataflow_tracer import trace_dataflow
        findings = [{
            "content": "exec(request.json['code'])",
            "metadata": {
                "file": "api/exec.py",
                "line": 15,
                "vuln_class": "code_injection",
                "severity": "critical",
            },
        }]
        traces = trace_dataflow(findings)
        d = traces[0].to_dict()
        self.assertIn("trace_id", d)
        self.assertIn("source", d)
        self.assertIn("sink", d)
        self.assertIn("sanitization_chain", d)
        self.assertIn("verdict", d)
        self.assertIn("confidence", d)

    def test_trace_metadata_json_string(self):
        """Test that JSON-string metadata is properly parsed."""
        from lib.dataflow_tracer import trace_dataflow
        findings = [{
            "content": "cursor.execute(request.args.get('q'))",
            "metadata": json.dumps({
                "file": "app.py",
                "line": 10,
                "vuln_class": "sqli",
                "severity": "high",
            }),
        }]
        traces = trace_dataflow(findings)
        self.assertEqual(len(traces), 1)
        self.assertIsNotNone(traces[0].source)

    def test_dangerous_sinks_detection(self):
        from lib.dataflow_tracer import _DANGEROUS_SINKS, DangerLevel
        self.assertEqual(_DANGEROUS_SINKS["exec"], DangerLevel.CRITICAL)
        self.assertEqual(_DANGEROUS_SINKS["cursor.execute"], DangerLevel.HIGH)
        self.assertIn("subprocess", _DANGEROUS_SINKS)

    def test_sanitizer_patterns(self):
        from lib.dataflow_tracer import _SANITIZERS
        self.assertGreaterEqual(len(_SANITIZERS), 10)
        self.assertGreater(_SANITIZERS["parameterize"], 0.9)
        self.assertGreater(_SANITIZERS["bleach.clean"], 0.8)


# ============================================================================
# Feature #3: Exploitation Queue (lib)
# ============================================================================

class TestExploitationQueue(unittest.TestCase):
    """Test exploitation_queue.py library."""

    def test_empty_queue(self):
        from lib.exploitation_queue import ExploitationQueue
        q = ExploitationQueue()
        d = q.to_dict()
        self.assertEqual(d["total_entries"], 0)
        self.assertEqual(d["avg_confidence"], 0.0)

    def test_add_entry(self):
        from lib.exploitation_queue import ExploitationQueue, ExploitationQueueEntry, QueueSlotType
        q = ExploitationQueue()
        entry = ExploitationQueueEntry(
            vuln_type="sqli",
            source="routes/users.py:42",
            sink="cursor.execute",
            slot_type=QueueSlotType.INJECTION,
            confidence=0.8,
        )
        q.add_entry(entry)
        self.assertEqual(len(q.entries), 1)
        self.assertEqual(q.to_dict()["total_entries"], 1)

    def test_filter_by_vuln_type(self):
        from lib.exploitation_queue import ExploitationQueue, ExploitationQueueEntry
        q = ExploitationQueue()
        q.add_entry(ExploitationQueueEntry(vuln_type="sqli", confidence=0.8))
        q.add_entry(ExploitationQueueEntry(vuln_type="xss", confidence=0.7))
        q.add_entry(ExploitationQueueEntry(vuln_type="sqli", confidence=0.9))

        sqli = q.filter_by_vuln_type("sqli")
        self.assertEqual(len(sqli), 2)

    def test_filter_by_confidence(self):
        from lib.exploitation_queue import ExploitationQueue, ExploitationQueueEntry
        q = ExploitationQueue()
        q.add_entry(ExploitationQueueEntry(vuln_type="sqli", confidence=0.3))
        q.add_entry(ExploitationQueueEntry(vuln_type="xss", confidence=0.7))
        q.add_entry(ExploitationQueueEntry(vuln_type="ssrf", confidence=0.9))

        high = q.filter_by_confidence(0.7)
        self.assertEqual(len(high), 2)

    def test_build_queue_from_sast(self):
        from lib.exploitation_queue import build_queue_from_sast
        findings = [
            {
                "metadata": {
                    "file": "routes/users.py",
                    "line": 42,
                    "vuln_class": "sqli",
                    "severity": "high",
                },
            },
            {
                "metadata": {
                    "file": "routes/admin.py",
                    "line": 10,
                    "vuln_class": "auth_bypass",
                    "severity": "critical",
                },
            },
        ]
        queue = build_queue_from_sast(findings)
        self.assertEqual(len(queue.entries), 2)
        d = queue.to_dict()
        self.assertIn("injection", d["by_slot_type"])
        self.assertIn("auth", d["by_slot_type"])

    def test_build_queue_with_dataflow_traces(self):
        from lib.exploitation_queue import build_queue_from_sast
        findings = [{
            "metadata": {
                "file": "routes/users.py",
                "line": 42,
                "vuln_class": "sqli",
                "severity": "high",
            },
        }]
        traces = [{
            "metadata": json.dumps({
                "source": {"file": "routes/users.py", "line": 42},
                "sink": {"function": "cursor.execute"},
                "sanitization_chain": [],
                "verdict": "vulnerable",
                "confidence": 0.9,
            }),
        }]
        queue = build_queue_from_sast(findings, traces)
        self.assertEqual(len(queue.entries), 1)
        self.assertEqual(queue.entries[0].confidence, 0.9)
        self.assertEqual(queue.entries[0].verdict, "vulnerable")

    def test_witness_payloads(self):
        from lib.exploitation_queue import build_queue_from_sast
        findings = [
            {"metadata": {"file": "a.py", "line": 1, "vuln_class": "sqli", "severity": "high"}},
            {"metadata": {"file": "b.py", "line": 2, "vuln_class": "xss", "severity": "medium"}},
            {"metadata": {"file": "c.py", "line": 3, "vuln_class": "ssrf", "severity": "high"}},
        ]
        queue = build_queue_from_sast(findings)
        payloads = [e.witness_payload for e in queue.entries]
        self.assertTrue(any("OR" in p for p in payloads))  # SQLi
        self.assertTrue(any("script" in p for p in payloads))  # XSS
        self.assertTrue(any("169.254" in p for p in payloads))  # SSRF

    def test_entry_to_dict(self):
        from lib.exploitation_queue import ExploitationQueueEntry, QueueSlotType
        entry = ExploitationQueueEntry(
            vuln_type="xss",
            source="app.py:10",
            sink="innerHTML",
            slot_type=QueueSlotType.INJECTION,
            confidence=0.7,
            witness_payload="<script>alert(1)</script>",
        )
        d = entry.to_dict()
        self.assertEqual(d["vuln_type"], "xss")
        self.assertEqual(d["slot_type"], "injection")
        self.assertIn("id", d)


# ============================================================================
# Feature #2: sast_trace_dataflow tool handler
# ============================================================================

class TestSastTraceDataflowTool(unittest.IsolatedAsyncioTestCase):
    """Test sast_trace_dataflow tool handler."""

    async def test_trace_dataflow_no_findings(self):
        from tools_sast import _handle_sast_trace_dataflow

        mock_db = MagicMock()
        mock_db.query = AsyncMock(return_value=[])

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db):
            result = await _handle_sast_trace_dataflow({}, mock_service)

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["traces"], 0)

    async def test_trace_dataflow_with_findings(self):
        from tools_sast import _handle_sast_trace_dataflow

        mock_db = MagicMock()
        mock_db.query = AsyncMock(return_value=[
            {
                "content": "cursor.execute(request.args.get('id'))",
                "metadata": {
                    "file": "routes/users.py",
                    "line": 42,
                    "vuln_class": "sql_injection",
                    "severity": "high",
                },
            },
        ])
        mock_db.store_knowledge = AsyncMock(return_value={"id": "k1", "chunk_count": 1, "content_size": 100})

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db):
            result = await _handle_sast_trace_dataflow({}, mock_service)

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["traces"], 1)
        self.assertEqual(data["stored"], 1)
        self.assertIn("vulnerable", data["by_verdict"])


# ============================================================================
# Feature #3: sast_build_exploitation_queue tool handler
# ============================================================================

class TestSastBuildExploitationQueueTool(unittest.IsolatedAsyncioTestCase):
    """Test sast_build_exploitation_queue tool handler."""

    async def test_build_queue_no_findings(self):
        from tools_sast import _handle_sast_build_exploitation_queue

        mock_db = MagicMock()
        mock_db.query = AsyncMock(return_value=[])

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db):
            result = await _handle_sast_build_exploitation_queue({}, mock_service)

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["queue_size"], 0)

    async def test_build_queue_with_findings(self):
        from tools_sast import _handle_sast_build_exploitation_queue

        mock_db = MagicMock()
        # First call: sast_scan_result, second call: dataflow_trace
        mock_db.query = AsyncMock(side_effect=[
            [
                {"metadata": {"file": "a.py", "line": 1, "vuln_class": "sqli", "severity": "high"}},
                {"metadata": {"file": "b.py", "line": 5, "vuln_class": "xss", "severity": "medium"}},
            ],
            [],  # No dataflow traces
        ])
        mock_db.store_knowledge = AsyncMock(return_value={"id": "k1", "chunk_count": 1, "content_size": 100})

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db):
            result = await _handle_sast_build_exploitation_queue({}, mock_service)

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["queue_size"], 2)
        self.assertIn("injection", data["by_slot_type"])
        self.assertGreater(len(data["top_entries"]), 0)

    async def test_build_queue_with_confidence_filter(self):
        from tools_sast import _handle_sast_build_exploitation_queue

        mock_db = MagicMock()
        mock_db.query = AsyncMock(side_effect=[
            [
                {"metadata": {"file": "a.py", "line": 1, "vuln_class": "sqli", "severity": "high"}},
                {"metadata": {"file": "b.py", "line": 5, "vuln_class": "xss", "severity": "low"}},
            ],
            [],
        ])
        mock_db.store_knowledge = AsyncMock(return_value={"id": "k1", "chunk_count": 1, "content_size": 100})

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db):
            result = await _handle_sast_build_exploitation_queue(
                {"min_confidence": 0.6}, mock_service
            )

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        # High severity sqli -> confidence 0.7, low severity xss -> confidence 0.3
        # Only sqli should pass the 0.6 filter
        self.assertEqual(data["queue_size"], 1)


# ============================================================================
# Feature #8: sast_get_dast_targets tool handler
# ============================================================================

class TestSastGetDastTargetsTool(unittest.IsolatedAsyncioTestCase):
    """Test sast_get_dast_targets tool handler."""

    async def test_no_exploitation_queue(self):
        from tools_sast import _handle_sast_get_dast_targets

        mock_db = MagicMock()
        mock_db.query = AsyncMock(return_value=[])

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db):
            result = await _handle_sast_get_dast_targets({}, mock_service)

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(len(data["targets"]), 0)

    async def test_no_endpoints(self):
        from tools_sast import _handle_sast_get_dast_targets

        mock_db = MagicMock()
        mock_db.query = AsyncMock(side_effect=[
            [{
                "content": json.dumps({
                    "entries": [
                        {"vuln_type": "sqli", "source": "routes/users.py:42", "sink": "execute",
                         "confidence": 0.8, "witness_payload": "' OR 1=1 --", "slot_type": "injection"},
                    ],
                }),
            }],
            [],  # No endpoints
        ])

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db):
            result = await _handle_sast_get_dast_targets({}, mock_service)

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(len(data["targets"]), 0)

    async def test_matches_endpoints(self):
        from tools_sast import _handle_sast_get_dast_targets

        mock_db = MagicMock()
        mock_db.query = AsyncMock(side_effect=[
            [{
                "content": json.dumps({
                    "entries": [
                        {"vuln_type": "sqli", "source": "routes/users.py:42", "sink": "execute",
                         "confidence": 0.8, "witness_payload": "' OR 1=1 --", "slot_type": "injection"},
                    ],
                }),
            }],
            [
                {"id": "ep1", "path": "/api/users", "method": "POST", "parameters": [{"name": "id"}]},
                {"id": "ep2", "path": "/api/products", "method": "GET", "parameters": []},
            ],
        ])

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db):
            result = await _handle_sast_get_dast_targets({}, mock_service)

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        # "routes/users.py" should match "/api/users" via "users" segment overlap
        self.assertGreater(len(data["targets"]), 0)
        self.assertEqual(data["targets"][0]["endpoint_id"], "ep1")

    async def test_confidence_filter(self):
        from tools_sast import _handle_sast_get_dast_targets

        mock_db = MagicMock()
        mock_db.query = AsyncMock(side_effect=[
            [{
                "content": json.dumps({
                    "entries": [
                        {"vuln_type": "sqli", "source": "a.py:1", "sink": "exec",
                         "confidence": 0.2, "witness_payload": "x", "slot_type": "injection"},
                        {"vuln_type": "xss", "source": "b.py:2", "sink": "innerHTML",
                         "confidence": 0.9, "witness_payload": "y", "slot_type": "injection"},
                    ],
                }),
            }],
            [
                {"id": "ep1", "path": "/api/search", "method": "GET", "parameters": [{"name": "q"}]},
            ],
        ])

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db):
            result = await _handle_sast_get_dast_targets(
                {"min_confidence": 0.5}, mock_service
            )

        data = json.loads(result[0].text)
        # Only entry with confidence 0.9 should pass
        for target in data["targets"]:
            self.assertGreaterEqual(target["confidence"], 0.5)


# ============================================================================
# Feature #8: Coverage init sast_hints integration
# ============================================================================

class TestCoverageInitSastHints(unittest.IsolatedAsyncioTestCase):
    """Test coverage_init with sast_hints parameter."""

    async def test_coverage_init_without_sast_hints(self):
        from tools_coverage import _handle_coverage_init

        mock_db = MagicMock()
        mock_db.query = AsyncMock(return_value=[
            {"id": "ep1", "path": "/api/users", "method": "GET", "parameters": []},
        ])
        mock_db.get_by_id = AsyncMock()
        mock_db.coverage_init_rows = AsyncMock(return_value={"created": 5, "skipped_existing": 0})

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_coverage._get_db', return_value=mock_db):
            result = await _handle_coverage_init(
                {"base_url": "https://example.com"}, mock_service
            )

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["sast_boosted"], 0)

    async def test_coverage_init_with_sast_hints(self):
        from tools_coverage import _handle_coverage_init

        mock_db = MagicMock()
        mock_db.query = AsyncMock(return_value=[
            {"id": "ep1", "path": "/api/users", "method": "POST",
             "parameters": [{"name": "id"}], "url": "/api/users"},
        ])
        mock_db.get_by_id = AsyncMock()
        # Capture rows passed to coverage_init_rows
        captured_rows = []

        async def mock_init_rows(rows):
            captured_rows.extend(rows)
            return {"created": len(rows), "skipped_existing": 0}

        mock_db.coverage_init_rows = mock_init_rows

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        # Mock CoverageTracker to produce controlled rows with known vuln_classes
        mock_rows = [
            {"endpoint_id": "ep1", "vuln_class": "sqli", "parameter": "", "priority": 50,
             "tool_name": "endpoint_execute_plan", "tool_args": {}},
            {"endpoint_id": "ep1", "vuln_class": "xss", "parameter": "", "priority": 40,
             "tool_name": "endpoint_execute_plan", "tool_args": {}},
        ]

        sast_hints = [
            {"endpoint_id": "ep1", "vuln_type": "sqli", "confidence": 0.85},
        ]

        with patch('tools_coverage._get_db', return_value=mock_db), \
             patch('lib.coverage_tracker.CoverageTracker.build_matrix', return_value=mock_rows):
            result = await _handle_coverage_init(
                {"base_url": "https://example.com", "sast_hints": sast_hints},
                mock_service,
            )

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["sast_boosted"], 1)

        # Verify boosted rows have sast_priority set
        boosted = [r for r in captured_rows if r.get("sast_priority", 0) > 0]
        self.assertEqual(len(boosted), 1)
        self.assertEqual(boosted[0]["sast_priority"], 85)  # 0.85 * 100
        self.assertEqual(boosted[0]["priority"], 80)  # 50 + 30 boost


# ============================================================================
# Helper function tests
# ============================================================================

class TestMatchEntryToEndpoints(unittest.TestCase):
    """Test _match_entry_to_endpoints heuristic."""

    def test_path_segment_match(self):
        from tools_sast import _match_entry_to_endpoints
        entry = {"vuln_type": "sqli", "source": "routes/users.py:42", "sink": "execute"}
        endpoints = [
            {"id": "ep1", "path": "/api/users", "method": "GET"},
            {"id": "ep2", "path": "/api/products", "method": "GET"},
        ]
        matched = _match_entry_to_endpoints(entry, endpoints)
        self.assertTrue(any(ep["id"] == "ep1" for ep in matched))

    def test_no_match(self):
        from tools_sast import _match_entry_to_endpoints
        entry = {"vuln_type": "sqli", "source": "utils/crypto.py:5", "sink": "hash"}
        endpoints = [
            {"id": "ep1", "path": "/api/users", "method": "GET"},
        ]
        matched = _match_entry_to_endpoints(entry, endpoints)
        self.assertEqual(len(matched), 0)


class TestGuessParameter(unittest.TestCase):
    """Test _guess_parameter heuristic."""

    def test_sqli_prefers_id(self):
        from tools_sast import _guess_parameter
        entry = {"vuln_type": "sqli"}
        endpoint = {"parameters": [{"name": "name"}, {"name": "id"}, {"name": "page"}]}
        param = _guess_parameter(entry, endpoint)
        self.assertEqual(param, "id")

    def test_xss_prefers_search(self):
        from tools_sast import _guess_parameter
        entry = {"vuln_type": "xss"}
        endpoint = {"parameters": [{"name": "id"}, {"name": "search"}, {"name": "page"}]}
        param = _guess_parameter(entry, endpoint)
        self.assertEqual(param, "search")

    def test_fallback_first_param(self):
        from tools_sast import _guess_parameter
        entry = {"vuln_type": "unknown_vuln"}
        endpoint = {"parameters": [{"name": "foo"}]}
        param = _guess_parameter(entry, endpoint)
        self.assertEqual(param, "foo")

    def test_empty_params(self):
        from tools_sast import _guess_parameter
        entry = {"vuln_type": "sqli"}
        endpoint = {"parameters": []}
        param = _guess_parameter(entry, endpoint)
        self.assertEqual(param, "")


# ============================================================================
# Tool definition count
# ============================================================================

class TestToolDefinitions(unittest.TestCase):
    """Test tool definitions are correct."""

    def test_sast_tool_count(self):
        from tools_sast import get_sast_tools
        tools = get_sast_tools()
        self.assertEqual(len(tools), 18)

    def test_new_tools_present(self):
        from tools_sast import get_sast_tools
        tools = get_sast_tools()
        names = [t.name for t in tools]
        self.assertIn("sast_trace_dataflow", names)
        self.assertIn("sast_build_exploitation_queue", names)
        self.assertIn("sast_get_dast_targets", names)

    def test_coverage_init_has_sast_hints_param(self):
        from tools_coverage import get_coverage_tools
        tools = get_coverage_tools()
        init_tool = [t for t in tools if t.name == "coverage_init"][0]
        props = init_tool.inputSchema["properties"]
        self.assertIn("sast_hints", props)


if __name__ == "__main__":
    unittest.main()
