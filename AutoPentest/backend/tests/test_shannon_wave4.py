"""Tests for Shannon Wave 4 features: Git checkpoints, Exploitation decision queue."""
import sys
import types
import unittest
import json
import os
import tempfile
from unittest.mock import AsyncMock, MagicMock, patch

sys.path.insert(0, 'mcp/modules')

# Mock mcp.types to avoid import errors on system Python
mcp_mod = types.ModuleType('mcp')
mcp_types = types.ModuleType('mcp.types')
mcp_types.Tool = type('Tool', (), {'__init__': lambda s, **k: None})
mcp_types.TextContent = type('TextContent', (), {'__init__': lambda s, **k: None})
sys.modules.setdefault('mcp', mcp_mod)
sys.modules.setdefault('mcp.types', mcp_types)


class TestExploitationDecision(unittest.TestCase):
    """Test exploitation_decision.py: Decision queue and attempt tracking."""

    def test_initial_decision_should_exploit(self):
        from lib.exploitation_decision import ExploitationDecision
        d = ExploitationDecision(finding_id="f-1")
        self.assertTrue(d.should_exploit)
        self.assertFalse(d.should_retry)
        self.assertEqual(d.attempt_count, 0)

    def test_success_stops_exploitation(self):
        from lib.exploitation_decision import DecisionQueue, ExploitResult
        queue = DecisionQueue()
        d = queue.update_decision("f-1", ExploitResult.SUCCESS, "sqli")
        self.assertFalse(d.should_exploit)
        self.assertFalse(d.should_retry)
        self.assertEqual(d.attempt_count, 1)
        self.assertEqual(d.last_result, ExploitResult.SUCCESS)

    def test_blocked_by_security_stops(self):
        from lib.exploitation_decision import DecisionQueue, ExploitResult
        queue = DecisionQueue()
        d = queue.update_decision("f-1", ExploitResult.BLOCKED_BY_SECURITY)
        self.assertFalse(d.should_exploit)
        self.assertFalse(d.should_retry)

    def test_partial_allows_retry(self):
        from lib.exploitation_decision import DecisionQueue, ExploitResult
        queue = DecisionQueue()
        d = queue.update_decision("f-1", ExploitResult.PARTIAL)
        self.assertTrue(d.should_exploit)
        self.assertTrue(d.should_retry)
        self.assertEqual(d.attempt_count, 1)

    def test_failed_allows_retry(self):
        from lib.exploitation_decision import DecisionQueue, ExploitResult
        queue = DecisionQueue()
        d = queue.update_decision("f-1", ExploitResult.FAILED)
        self.assertTrue(d.should_retry)
        self.assertTrue(d.should_exploit)

    def test_max_attempts_stops_exploitation(self):
        from lib.exploitation_decision import DecisionQueue, ExploitResult, MAX_ATTEMPTS
        queue = DecisionQueue()
        for _ in range(MAX_ATTEMPTS):
            d = queue.update_decision("f-1", ExploitResult.FAILED)
        self.assertFalse(d.should_exploit)
        self.assertFalse(d.should_retry)
        self.assertEqual(d.attempt_count, MAX_ATTEMPTS)

    def test_max_attempts_is_3(self):
        from lib.exploitation_decision import MAX_ATTEMPTS
        self.assertEqual(MAX_ATTEMPTS, 3)

    def test_get_pending_and_completed(self):
        from lib.exploitation_decision import DecisionQueue, ExploitResult
        queue = DecisionQueue()
        queue.update_decision("f-1", ExploitResult.SUCCESS)
        queue.update_decision("f-2", ExploitResult.PARTIAL)
        queue.update_decision("f-3", ExploitResult.BLOCKED_BY_SECURITY)

        pending = queue.get_pending()
        completed = queue.get_completed()
        pending_ids = [d.finding_id for d in pending]
        completed_ids = [d.finding_id for d in completed]

        self.assertIn("f-2", pending_ids)
        self.assertIn("f-1", completed_ids)
        self.assertIn("f-3", completed_ids)

    def test_to_dict_and_from_dict_roundtrip(self):
        from lib.exploitation_decision import DecisionQueue, ExploitResult
        queue = DecisionQueue()
        queue.update_decision("f-1", ExploitResult.SUCCESS, "xss", "confirmed")
        queue.update_decision("f-2", ExploitResult.FAILED, "sqli")

        data = queue.to_dict()
        restored = DecisionQueue.from_dict(data)

        self.assertEqual(len(restored.decisions), 2)
        self.assertFalse(restored.decisions["f-1"].should_exploit)
        self.assertTrue(restored.decisions["f-2"].should_exploit)

    def test_decision_to_dict(self):
        from lib.exploitation_decision import ExploitationDecision, ExploitResult
        d = ExploitationDecision(
            finding_id="f-1", vuln_type="sqli",
            should_exploit=False, attempt_count=1,
            last_result=ExploitResult.SUCCESS, notes="done"
        )
        data = d.to_dict()
        self.assertEqual(data["finding_id"], "f-1")
        self.assertEqual(data["last_result"], "success")
        self.assertFalse(data["should_exploit"])

    def test_decision_from_dict_handles_unknown_result(self):
        from lib.exploitation_decision import ExploitationDecision, ExploitResult
        d = ExploitationDecision.from_dict({
            "finding_id": "f-1",
            "last_result": "unknown_value",
        })
        self.assertEqual(d.last_result, ExploitResult.NOT_ATTEMPTED)


class TestExploitationDecisionPersistence(unittest.IsolatedAsyncioTestCase):
    """Test load/save of decision queue via wm_knowledge."""

    async def test_load_empty_queue(self):
        from lib.exploitation_decision import load_decision_queue
        mock_db = AsyncMock()
        mock_db.recall_knowledge.return_value = []
        queue = await load_decision_queue(mock_db, assessment_id=1)
        self.assertEqual(len(queue.decisions), 0)

    async def test_load_saved_queue(self):
        from lib.exploitation_decision import load_decision_queue, DecisionQueue, ExploitResult
        q = DecisionQueue()
        q.update_decision("f-1", ExploitResult.SUCCESS)
        content = json.dumps(q.to_dict())

        mock_db = AsyncMock()
        mock_db.recall_knowledge.return_value = [{"content": content}]
        loaded = await load_decision_queue(mock_db, assessment_id=1)
        self.assertEqual(len(loaded.decisions), 1)
        self.assertFalse(loaded.decisions["f-1"].should_exploit)

    async def test_save_queue(self):
        from lib.exploitation_decision import save_decision_queue, DecisionQueue, ExploitResult
        q = DecisionQueue()
        q.update_decision("f-1", ExploitResult.SUCCESS)

        mock_db = AsyncMock()
        await save_decision_queue(mock_db, assessment_id=1, queue=q)
        mock_db.store_knowledge.assert_called_once()
        call_kwargs = mock_db.store_knowledge.call_args[1]
        self.assertEqual(call_kwargs["category"], "exploitation_decision")

    async def test_load_corrupted_json_returns_empty(self):
        from lib.exploitation_decision import load_decision_queue
        mock_db = AsyncMock()
        mock_db.recall_knowledge.return_value = [{"content": "not valid json{{{"}]
        queue = await load_decision_queue(mock_db, assessment_id=1)
        self.assertEqual(len(queue.decisions), 0)


class TestGitCheckpointStructures(unittest.TestCase):
    """Test git_checkpoint.py: CheckpointInfo dataclass."""

    def test_checkpoint_info_to_dict(self):
        from lib.git_checkpoint import CheckpointInfo
        cp = CheckpointInfo(
            hash="abc123", description="Phase 2 complete",
            phase=2, timestamp="2026-01-01 00:00:00", files_changed=5
        )
        d = cp.to_dict()
        self.assertEqual(d["hash"], "abc123")
        self.assertEqual(d["phase"], 2)
        self.assertEqual(d["files_changed"], 5)

    def test_checkpoint_prefix_constant(self):
        from lib.git_checkpoint import _CHECKPOINT_PREFIX
        self.assertEqual(_CHECKPOINT_PREFIX, "[phase:")


class TestGitCheckpointFunctions(unittest.IsolatedAsyncioTestCase):
    """Test git_checkpoint.py: async checkpoint operations with mocked git."""

    @patch('lib.git_checkpoint._run_git')
    async def test_ensure_git_repo_existing(self, mock_run):
        from lib.git_checkpoint import _ensure_git_repo
        with tempfile.TemporaryDirectory() as tmpdir:
            os.makedirs(os.path.join(tmpdir, ".git"))
            result = await _ensure_git_repo(tmpdir)
            self.assertTrue(result)
            mock_run.assert_not_called()

    @patch('lib.git_checkpoint._run_git')
    async def test_create_checkpoint_success(self, mock_run):
        from lib.git_checkpoint import create_checkpoint
        mock_run.side_effect = [
            (0, b"", b""),           # git add .
            (0, b"", b""),           # git commit
            (0, b"abc123\n", b""),   # git rev-parse HEAD
            (0, b"1 file changed, 2 insertions(+)\n", b""),  # git diff --stat
            (0, b"2026-01-01 00:00:00 +0000\n", b""),        # git log timestamp
        ]
        with tempfile.TemporaryDirectory() as tmpdir:
            os.makedirs(os.path.join(tmpdir, ".git"))
            result = await create_checkpoint(tmpdir, "Test checkpoint", phase=2)
            self.assertIsNotNone(result)
            self.assertEqual(result.hash, "abc123")
            self.assertEqual(result.phase, 2)
            self.assertEqual(result.description, "Test checkpoint")
            self.assertEqual(result.files_changed, 1)

    @patch('lib.git_checkpoint._run_git')
    async def test_list_checkpoints(self, mock_run):
        from lib.git_checkpoint import list_checkpoints
        mock_run.return_value = (
            0,
            b"abc123|[phase:2] Mapping complete|2026-01-01 12:00:00\ndef456|[phase:1] Recon done|2026-01-01 10:00:00\nghi789|Normal commit|2026-01-01 08:00:00\n",
            b""
        )
        with tempfile.TemporaryDirectory() as tmpdir:
            os.makedirs(os.path.join(tmpdir, ".git"))
            checkpoints = await list_checkpoints(tmpdir)
            self.assertEqual(len(checkpoints), 2)
            self.assertEqual(checkpoints[0].phase, 2)
            self.assertEqual(checkpoints[0].description, "Mapping complete")
            self.assertEqual(checkpoints[1].phase, 1)

    @patch('lib.git_checkpoint._run_git')
    async def test_rollback_to_checkpoint(self, mock_run):
        from lib.git_checkpoint import rollback_to_checkpoint
        mock_run.return_value = (0, b"", b"")
        with tempfile.TemporaryDirectory() as tmpdir:
            os.makedirs(os.path.join(tmpdir, ".git"))
            result = await rollback_to_checkpoint(tmpdir, "abc123")
            self.assertTrue(result)
            mock_run.assert_called_once()
            args = mock_run.call_args[0]
            self.assertIn("reset", args[1])
            self.assertIn("abc123", args[1])

    async def test_list_checkpoints_no_git_dir(self):
        from lib.git_checkpoint import list_checkpoints
        with tempfile.TemporaryDirectory() as tmpdir:
            result = await list_checkpoints(tmpdir)
            self.assertEqual(result, [])

    async def test_rollback_no_git_dir_returns_false(self):
        from lib.git_checkpoint import rollback_to_checkpoint
        with tempfile.TemporaryDirectory() as tmpdir:
            result = await rollback_to_checkpoint(tmpdir, "abc123")
            self.assertFalse(result)


if __name__ == '__main__':
    unittest.main()
