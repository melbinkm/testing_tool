"""Tests for Wave 4 dev-beta features: Sink hunt, Endpoint binding, Queue symmetry.

Feature #53: Pre-Recon Source-to-Sink Tracing
Feature #54: Recon-to-Code Systematic Binding
Feature #24: Queue Deliverable Symmetry Enforcement
"""

import sys
import os
import json
import unittest
from unittest.mock import AsyncMock, MagicMock, patch

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'mcp', 'modules'))


# ============================================================================
# Feature #53: Sink Hunt
# ============================================================================

class TestSinkHuntToolDefinition(unittest.TestCase):
    """Test sast_sink_hunt tool is defined."""

    def test_tool_exists(self):
        from tools_sast import get_sast_tools
        tools = get_sast_tools()
        names = [t.name for t in tools]
        self.assertIn("sast_sink_hunt", names)

    def test_tool_count(self):
        from tools_sast import get_sast_tools
        tools = get_sast_tools()
        self.assertEqual(len(tools), 18)


class TestSemgrepRuleFiles(unittest.TestCase):
    """Test semgrep rule files exist."""

    def test_injection_rules_exist(self):
        rules_dir = os.path.join(os.path.dirname(__file__), '..', 'mcp', 'modules', 'lib', 'semgrep_rules')
        self.assertTrue(os.path.exists(os.path.join(rules_dir, 'injection_sinks.yaml')))

    def test_sql_rules_exist(self):
        rules_dir = os.path.join(os.path.dirname(__file__), '..', 'mcp', 'modules', 'lib', 'semgrep_rules')
        self.assertTrue(os.path.exists(os.path.join(rules_dir, 'sql_sinks.yaml')))

    def test_ssrf_rules_exist(self):
        rules_dir = os.path.join(os.path.dirname(__file__), '..', 'mcp', 'modules', 'lib', 'semgrep_rules')
        self.assertTrue(os.path.exists(os.path.join(rules_dir, 'ssrf_sinks.yaml')))

    def test_deserialization_rules_exist(self):
        rules_dir = os.path.join(os.path.dirname(__file__), '..', 'mcp', 'modules', 'lib', 'semgrep_rules')
        self.assertTrue(os.path.exists(os.path.join(rules_dir, 'deserialization_sinks.yaml')))


class TestBuiltinSinkPatterns(unittest.TestCase):
    """Test built-in sink patterns for heuristic fallback."""

    def test_injection_patterns(self):
        from tools_sast import _BUILTIN_SINK_PATTERNS
        self.assertGreaterEqual(len(_BUILTIN_SINK_PATTERNS["injection"]), 5)

    def test_sql_patterns(self):
        from tools_sast import _BUILTIN_SINK_PATTERNS
        self.assertGreaterEqual(len(_BUILTIN_SINK_PATTERNS["sql"]), 3)

    def test_ssrf_patterns(self):
        from tools_sast import _BUILTIN_SINK_PATTERNS
        self.assertGreaterEqual(len(_BUILTIN_SINK_PATTERNS["ssrf"]), 3)

    def test_deserialization_patterns(self):
        from tools_sast import _BUILTIN_SINK_PATTERNS
        self.assertGreaterEqual(len(_BUILTIN_SINK_PATTERNS["deserialization"]), 3)


class TestSinkHuntHandler(unittest.IsolatedAsyncioTestCase):
    """Test sast_sink_hunt tool handler."""

    async def test_no_repo(self):
        from tools_sast import _handle_sast_sink_hunt

        mock_db = MagicMock()
        mock_runner = MagicMock()
        mock_runner.repo_base_dir = "/workspace/repos"
        mock_runner._exec = AsyncMock(return_value={"exit_code": 1, "stdout": ""})

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db), \
             patch('tools_sast.get_sast_runner', return_value=mock_runner):
            result = await _handle_sast_sink_hunt({}, mock_service)

        data = json.loads(result[0].text)
        self.assertFalse(data.get("success", True))

    async def test_heuristic_fallback(self):
        from tools_sast import _handle_sast_sink_hunt

        mock_db = MagicMock()
        mock_db.store_knowledge = AsyncMock(return_value={"id": "k1", "chunk_count": 1, "content_size": 100})

        mock_runner = MagicMock()
        mock_runner.repo_base_dir = "/workspace/repos"

        call_count = 0

        async def mock_exec(cmd, args, timeout=30):
            nonlocal call_count
            call_count += 1
            if cmd == "find":
                return {"exit_code": 0, "stdout": "/workspace/repos/1\n/workspace/repos/1/myrepo"}
            if cmd == "which":
                return {"exit_code": 1, "stdout": ""}  # No semgrep
            if cmd == "grep":
                return {"exit_code": 0, "stdout": "routes/users.py:42:    cursor.execute(query)\n"}
            return {"exit_code": 0, "stdout": ""}

        mock_runner._exec = mock_exec

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db), \
             patch('tools_sast.get_sast_runner', return_value=mock_runner):
            result = await _handle_sast_sink_hunt({"sink_types": ["sql"]}, mock_service)

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["detection_method"], "heuristic")
        self.assertGreater(data["total_sinks"], 0)


class TestCountByKey(unittest.TestCase):
    """Test _count_by_key helper."""

    def test_count_by_key(self):
        from tools_sast import _count_by_key
        items = [
            {"type": "a"}, {"type": "b"}, {"type": "a"}, {"type": "c"},
        ]
        counts = _count_by_key(items, "type")
        self.assertEqual(counts, {"a": 2, "b": 1, "c": 1})


# ============================================================================
# Feature #54: Endpoint Binding
# ============================================================================

class TestEndpointBindingToolDefinition(unittest.TestCase):
    """Test sast_bind_endpoints tool is defined."""

    def test_tool_exists(self):
        from tools_sast import get_sast_tools
        tools = get_sast_tools()
        names = [t.name for t in tools]
        self.assertIn("sast_bind_endpoints", names)


class TestRoutesMatch(unittest.TestCase):
    """Test _routes_match heuristic."""

    def test_exact_match(self):
        from tools_sast import _routes_match
        self.assertTrue(_routes_match("/api/users", "/api/users"))

    def test_trailing_slash(self):
        from tools_sast import _routes_match
        self.assertTrue(_routes_match("/api/users/", "/api/users"))

    def test_case_insensitive(self):
        from tools_sast import _routes_match
        self.assertTrue(_routes_match("/API/Users", "/api/users"))

    def test_param_wildcard(self):
        from tools_sast import _routes_match
        self.assertTrue(_routes_match("/users/<id>", "/users/{id}"))

    def test_suffix_match(self):
        from tools_sast import _routes_match
        self.assertTrue(_routes_match("/users", "/api/v1/users"))

    def test_no_match(self):
        from tools_sast import _routes_match
        self.assertFalse(_routes_match("/users", "/products"))


class TestBindEndpointsHandler(unittest.IsolatedAsyncioTestCase):
    """Test sast_bind_endpoints tool handler."""

    async def test_no_sink_map(self):
        from tools_sast import _handle_sast_bind_endpoints

        mock_db = MagicMock()
        mock_db.query = AsyncMock(return_value=[])

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db):
            result = await _handle_sast_bind_endpoints({}, mock_service)

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["bound"], 0)

    async def test_bind_endpoints(self):
        from tools_sast import _handle_sast_bind_endpoints

        mock_db = MagicMock()
        # First call: sink_map query, second call: endpoints query
        mock_db.query = AsyncMock(side_effect=[
            [{"content": json.dumps({"sinks": [
                {"file": "routes/users.py", "line": 42, "sink_type": "sql",
                 "function": "execute", "risk_level": "high"},
            ]})}],
            [{"id": "ep1", "path": "/api/users", "method": "POST",
              "metadata": {}, "parameters": []}],
        ])
        mock_db.update_endpoint = AsyncMock(return_value={})

        mock_runner = MagicMock()
        mock_runner.repo_base_dir = "/workspace/repos"

        async def mock_exec(cmd, args, timeout=30):
            if cmd == "find":
                return {"exit_code": 0, "stdout": "/workspace/repos/1\n/workspace/repos/1/myrepo"}
            if cmd == "grep":
                return {
                    "exit_code": 0,
                    "stdout": "/workspace/repos/1/myrepo/routes/users.py:40:@app.route('/api/users', methods=['POST'])\n",
                }
            return {"exit_code": 0, "stdout": ""}

        mock_runner._exec = mock_exec

        mock_service = MagicMock()
        mock_service.current_assessment_id = 1

        with patch('tools_sast._get_db', return_value=mock_db), \
             patch('tools_sast.get_sast_runner', return_value=mock_runner):
            result = await _handle_sast_bind_endpoints({}, mock_service)

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["bound"], 1)


# ============================================================================
# Feature #54: wm_endpoints new columns
# ============================================================================

class TestEndpointNewColumns(unittest.TestCase):
    """Test that database.py has new endpoint columns."""

    def test_schema_has_source_file(self):
        schema_path = os.path.join(os.path.dirname(__file__), '..', 'database.py')
        with open(schema_path) as f:
            content = f.read()
        self.assertIn("source_file", content)
        self.assertIn("source_line", content)
        self.assertIn("auth_requirement", content)
        self.assertIn("input_constraints", content)


# ============================================================================
# Feature #24: Queue Deliverable Symmetry Enforcement
# ============================================================================

class TestQueueSymmetryGates(unittest.IsolatedAsyncioTestCase):
    """Test phase orchestrator gate checks for exploitation queue."""

    async def test_phase4_warns_no_exploitation_queue(self):
        from lib.phase_orchestrator import PhaseOrchestrator

        mock_db = MagicMock()
        mock_db._assessment_id = 1

        # Simulate all metrics
        async def mock_fetchone(sql, params):
            if "wm_assets" in sql:
                return {"cnt": 5}
            if "wm_endpoints" in sql:
                return {"cnt": 10}
            if "wm_hypotheses" in sql and "confirmed" in sql:
                return {"cnt": 2}
            if "wm_hypotheses" in sql:
                return {"cnt": 3}
            if "wm_findings" in sql and "confirmed" in sql:
                return {"cnt": 2}
            if "wm_findings" in sql:
                return {"cnt": 5}
            if "wm_coverage_matrix" in sql:
                return {"total": 100, "tested": 30}
            if "sast_scan_result" in sql:
                return {"total": 0, "verified": 0}
            if "source_code" in sql:
                return {"cnt": 0}  # No source code indexed
            if "code_audit_queue" in sql:
                return {"total": 0, "reviewed": 0}
            if "exploitation_queue" in sql:
                return {"cnt": 0}  # No exploitation queue
            return {"cnt": 0}

        mock_db._fetchone = mock_fetchone
        mock_db.query = AsyncMock(return_value=[])
        mock_db.add_plan = AsyncMock(return_value={"id": "plan1"})
        mock_db.update_plan = AsyncMock()
        mock_db.get_by_id = AsyncMock(return_value={
            "id": "plan1", "steps": [
                {"description": "Recon", "status": "done"},
                {"description": "Mapping", "status": "done"},
                {"description": "SAST", "status": "done"},
                {"description": "Vuln Assessment", "status": "in_progress"},
            ],
        })

        orch = PhaseOrchestrator(mock_db)
        metrics = await orch.get_metrics()

        # Check gate with exploitation_queue_exists = 0
        self.assertEqual(metrics["exploitation_queue_exists"], 0)
        gate_result = orch.check_gates(4, metrics)
        # Should still pass (queue is informational, not blocking)
        # But should have warnings
        self.assertIn("warnings", gate_result)
        self.assertTrue(any("exploitation queue" in w.lower() for w in gate_result["warnings"]))

    async def test_phase4_no_warning_when_queue_exists(self):
        from lib.phase_orchestrator import PhaseOrchestrator

        mock_db = MagicMock()
        mock_db._assessment_id = 1

        async def mock_fetchone(sql, params):
            if "wm_assets" in sql:
                return {"cnt": 5}
            if "wm_endpoints" in sql:
                return {"cnt": 10}
            if "wm_hypotheses" in sql and "confirmed" in sql:
                return {"cnt": 2}
            if "wm_hypotheses" in sql:
                return {"cnt": 3}
            if "wm_findings" in sql and "confirmed" in sql:
                return {"cnt": 2}
            if "wm_findings" in sql:
                return {"cnt": 5}
            if "wm_coverage_matrix" in sql:
                return {"total": 100, "tested": 30}
            if "sast_scan_result" in sql:
                return {"total": 5, "verified": 5}
            if "source_code" in sql:
                return {"cnt": 100}
            if "code_audit_queue" in sql:
                return {"total": 10, "reviewed": 10}
            if "exploitation_queue" in sql:
                return {"cnt": 1}  # Queue exists
            return {"cnt": 0}

        mock_db._fetchone = mock_fetchone
        mock_db.query = AsyncMock(return_value=[])
        mock_db.add_plan = AsyncMock(return_value={"id": "plan1"})
        mock_db.update_plan = AsyncMock()

        orch = PhaseOrchestrator(mock_db)
        metrics = await orch.get_metrics()

        self.assertEqual(metrics["exploitation_queue_exists"], 1)
        gate_result = orch.check_gates(4, metrics)
        # No warnings when queue exists and SAST deliverable exists
        self.assertNotIn("warnings", gate_result)

    async def test_phase4_warns_no_sast_when_source_indexed(self):
        from lib.phase_orchestrator import PhaseOrchestrator

        mock_db = MagicMock()
        mock_db._assessment_id = 1

        async def mock_fetchone(sql, params):
            if "wm_assets" in sql:
                return {"cnt": 5}
            if "wm_endpoints" in sql:
                return {"cnt": 10}
            if "wm_hypotheses" in sql and "confirmed" in sql:
                return {"cnt": 2}
            if "wm_hypotheses" in sql:
                return {"cnt": 3}
            if "wm_findings" in sql and "confirmed" in sql:
                return {"cnt": 2}
            if "wm_findings" in sql:
                return {"cnt": 5}
            if "wm_coverage_matrix" in sql:
                return {"total": 100, "tested": 30}
            if "sast_scan_result" in sql:
                return {"total": 0, "verified": 0}  # No SAST scans run
            if "source_code" in sql:
                return {"cnt": 50}  # But source IS indexed
            if "code_audit_queue" in sql:
                return {"total": 0, "reviewed": 0}
            if "exploitation_queue" in sql:
                return {"cnt": 1}
            return {"cnt": 0}

        mock_db._fetchone = mock_fetchone
        mock_db.query = AsyncMock(return_value=[])
        mock_db.add_plan = AsyncMock(return_value={"id": "plan1"})
        mock_db.update_plan = AsyncMock()

        orch = PhaseOrchestrator(mock_db)
        metrics = await orch.get_metrics()

        self.assertEqual(metrics["sast_deliverable_exists"], 0)
        gate_result = orch.check_gates(4, metrics)
        self.assertIn("warnings", gate_result)
        self.assertTrue(any("sast" in w.lower() for w in gate_result["warnings"]))


class TestPhaseGateNoWarningsForOtherPhases(unittest.TestCase):
    """Test that warnings only appear for Phase 4."""

    def test_no_warnings_phase_2(self):
        from lib.phase_orchestrator import PhaseOrchestrator

        mock_db = MagicMock()
        orch = PhaseOrchestrator(mock_db)

        metrics = {
            "assets": 5, "endpoints": 10, "exploitation_queue_exists": 0,
            "sast_deliverable_exists": 0,
        }
        gate_result = orch.check_gates(2, metrics)
        self.assertNotIn("warnings", gate_result)


if __name__ == "__main__":
    unittest.main()
