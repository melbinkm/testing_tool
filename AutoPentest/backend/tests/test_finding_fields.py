"""
Test structured finding fields (CVSS, endpoints, description, attack scenario, recommendation, evidence)
Plus tests for: no duplication, confirmed status, 7-tuple risk signals
"""
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../mcp/modules')))

import json
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from schemas.card import CardCreate, CardUpdate, CardResponse


class TestFindingFieldsSchema:
    """Test that Pydantic schemas accept all 6 new fields."""

    def test_card_create_with_new_fields(self):
        """CardCreate accepts all 7 new fields (including evidence)."""
        evidence_json = json.dumps({"request": {"method": "GET"}, "response": {"status": 500}})
        card = CardCreate(
            card_type="finding",
            title="SQL Injection",
            severity="HIGH",
            cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            cvss_score=9.8,
            affected_endpoints="https://example.com/api/users, https://example.com/api/products",
            description="The application is vulnerable to SQL injection via the username parameter.",
            attack_scenario="An attacker can inject SQL payloads to extract database contents.",
            recommendation="Use parameterized queries to prevent SQL injection.",
            evidence=evidence_json,
        )

        assert card.cvss_vector == "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        assert card.cvss_score == 9.8
        assert "https://example.com/api/users" in card.affected_endpoints
        assert "SQL injection" in card.description
        assert "attacker" in card.attack_scenario
        assert "parameterized queries" in card.recommendation
        assert card.evidence == evidence_json

    def test_card_create_backwards_compatible(self):
        """CardCreate still works without new fields (backward compat)."""
        card = CardCreate(
            card_type="finding",
            title="XSS Vulnerability",
            severity="MEDIUM",
            technical_analysis="Reflected XSS in search parameter",
        )

        assert card.cvss_vector is None
        assert card.cvss_score is None
        assert card.affected_endpoints is None
        assert card.description is None
        assert card.attack_scenario is None
        assert card.recommendation is None

    def test_card_update_with_new_fields(self):
        """CardUpdate accepts all 6 new fields."""
        update = CardUpdate(
            cvss_vector="CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:L/A:N",
            cvss_score=4.6,
            affected_endpoints="https://example.com/admin",
            description="CSRF vulnerability in admin panel",
            attack_scenario="Attacker tricks admin into clicking malicious link",
            recommendation="Implement anti-CSRF tokens",
        )

        assert update.cvss_score == 4.6
        assert "CSRF" in update.description
        assert "tokens" in update.recommendation

    def test_card_response_includes_new_fields(self):
        """CardResponse returns all 6 new fields."""
        from datetime import datetime

        response = CardResponse(
            id=42,
            assessment_id=1,
            card_type="finding",
            title="IDOR Vulnerability",
            severity="HIGH",
            cvss_vector="CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
            cvss_score=6.5,
            affected_endpoints="https://example.com/api/documents/123",
            description="Users can access other users' documents by changing ID parameter",
            attack_scenario="Attacker iterates document IDs to access sensitive data",
            recommendation="Implement proper authorization checks on document access",
            created_at=datetime.now(),
            updated_at=datetime.now(),
        )

        assert response.cvss_score == 6.5
        assert "IDOR" in response.title
        assert "authorization checks" in response.recommendation


class TestRecordFindingHandler:
    """Test record_finding tool handler passes new fields correctly."""

    @pytest.mark.asyncio
    async def test_record_finding_passes_description(self):
        """Description field reaches safe_add_card (not silently dropped)."""
        from tools_pentest import _handle_record_finding

        mcp_service = MagicMock()
        mcp_service.safe_add_card = AsyncMock(return_value=MagicMock(
            ok=True,
            data={"id": 42}
        ))

        args = {
            "title": "SQL Injection",
            "severity": "high",
            "url": "https://example.com/login",
            "vuln_class": "sqli_error",
            "evidence": {
                "description": "MySQL error message confirms SQL injection"
            }
        }

        await _handle_record_finding(args, mcp_service)

        # Verify safe_add_card was called with description
        call_kwargs = mcp_service.safe_add_card.call_args[1]
        assert "description" in call_kwargs
        assert call_kwargs["description"]  # Not None or empty

    @pytest.mark.asyncio
    async def test_record_finding_computes_cvss_score(self):
        """Passing cvss_vector auto-computes cvss_score."""
        from tools_pentest import _handle_record_finding

        mcp_service = MagicMock()
        mcp_service.safe_add_card = AsyncMock(return_value=MagicMock(
            ok=True,
            data={"id": 42}
        ))

        args = {
            "title": "RCE Vulnerability",
            "severity": "critical",
            "url": "https://example.com/upload",
            "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        }

        await _handle_record_finding(args, mcp_service)

        # Verify cvss_score was computed from vector
        call_kwargs = mcp_service.safe_add_card.call_args[1]
        assert call_kwargs["cvss_vector"] == "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        assert call_kwargs["cvss_score"] is not None
        assert isinstance(call_kwargs["cvss_score"], (int, float))
        assert 9.0 <= call_kwargs["cvss_score"] <= 10.0  # Should be critical score

    @pytest.mark.asyncio
    async def test_record_finding_invalid_cvss_vector(self):
        """Invalid cvss_vector results in cvss_score=None (no crash)."""
        from tools_pentest import _handle_record_finding

        mcp_service = MagicMock()
        mcp_service.safe_add_card = AsyncMock(return_value=MagicMock(
            ok=True,
            data={"id": 42}
        ))

        args = {
            "title": "XSS",
            "severity": "medium",
            "url": "https://example.com/search",
            "cvss_vector": "INVALID_VECTOR",
        }

        await _handle_record_finding(args, mcp_service)

        # Verify invalid vector doesn't crash, sets score to None
        call_kwargs = mcp_service.safe_add_card.call_args[1]
        assert call_kwargs["cvss_vector"] == "INVALID_VECTOR"
        assert call_kwargs["cvss_score"] is None

    @pytest.mark.asyncio
    async def test_record_finding_passes_attack_scenario(self):
        """attack_scenario reaches safe_add_card."""
        from tools_pentest import _handle_record_finding

        mcp_service = MagicMock()
        mcp_service.safe_add_card = AsyncMock(return_value=MagicMock(
            ok=True,
            data={"id": 42}
        ))

        args = {
            "title": "CSRF",
            "severity": "medium",
            "url": "https://example.com/account/delete",
            "attack_scenario": "Attacker tricks user into visiting malicious page that submits form",
        }

        await _handle_record_finding(args, mcp_service)

        call_kwargs = mcp_service.safe_add_card.call_args[1]
        assert call_kwargs["attack_scenario"] == "Attacker tricks user into visiting malicious page that submits form"

    @pytest.mark.asyncio
    async def test_record_finding_defaults_affected_endpoints_to_url(self):
        """When affected_endpoints not provided, defaults to url."""
        from tools_pentest import _handle_record_finding

        mcp_service = MagicMock()
        mcp_service.safe_add_card = AsyncMock(return_value=MagicMock(
            ok=True,
            data={"id": 42}
        ))

        args = {
            "title": "Open Redirect",
            "severity": "low",
            "url": "https://example.com/redirect",
        }

        await _handle_record_finding(args, mcp_service)

        call_kwargs = mcp_service.safe_add_card.call_args[1]
        assert call_kwargs["affected_endpoints"] == "https://example.com/redirect"


class TestAutoRiskSignals:
    """Test auto_persist_risk_signals includes description and recommendation."""

    def test_risk_signal_7_tuple(self):
        """_RISK_SIGNAL_CARDS entries are 7-tuples (title, severity, vuln_class, desc, rec, cvss_vector, attack_scenario)."""
        from service import AutoPentestService

        signal_cards = AutoPentestService._RISK_SIGNAL_CARDS

        # Test a few key signal types
        assert len(signal_cards["missing_csp"]) == 7
        assert len(signal_cards["cors_wildcard"]) == 7
        assert len(signal_cards["cookie_missing_httponly"]) == 7

        # Verify structure: (title, severity, vuln_class, description, recommendation, cvss_vector, attack_scenario)
        title, severity, vuln_class, desc, rec, cvss_vector, attack_scenario = signal_cards["missing_csp"]
        assert isinstance(title, str) and "Content Security Policy" in title
        assert severity in ("low", "medium", "high", "critical", "info")
        assert isinstance(vuln_class, str)
        assert isinstance(desc, str) and len(desc) > 20
        assert isinstance(rec, str) and len(rec) > 10
        assert isinstance(cvss_vector, str)
        assert isinstance(attack_scenario, str) and len(attack_scenario) > 20

    @pytest.mark.asyncio
    async def test_risk_signal_passes_description(self):
        """auto_persist_risk_signals passes description to safe_add_card."""
        from service import AutoPentestService

        service = AutoPentestService()
        service.current_assessment_id = 1
        service.safe_add_card = AsyncMock(return_value=MagicMock(ok=True, skipped=False))

        risk_signals = [
            {
                "type": "missing_hsts",
                "severity": "medium",
                "detail": "No HSTS header found on HTTPS endpoint",
            }
        ]

        await service.auto_persist_risk_signals(risk_signals, "https://example.com")

        # Verify safe_add_card was called with description
        call_kwargs = service.safe_add_card.call_args[1]
        assert "description" in call_kwargs
        assert "Transport Security" in call_kwargs["description"] or "HTTPS" in call_kwargs["description"]
        assert len(call_kwargs["description"]) > 20

    @pytest.mark.asyncio
    async def test_risk_signal_passes_recommendation(self):
        """auto_persist_risk_signals passes recommendation to safe_add_card."""
        from service import AutoPentestService

        service = AutoPentestService()
        service.current_assessment_id = 1
        service.safe_add_card = AsyncMock(return_value=MagicMock(ok=True, skipped=False))

        risk_signals = [
            {
                "type": "cors_wildcard",
                "severity": "high",
                "detail": "Access-Control-Allow-Origin: * detected",
            }
        ]

        await service.auto_persist_risk_signals(risk_signals, "https://example.com")

        # Verify safe_add_card was called with recommendation
        call_kwargs = service.safe_add_card.call_args[1]
        assert "recommendation" in call_kwargs
        assert "CORS" in call_kwargs["recommendation"] or "origin" in call_kwargs["recommendation"].lower()
        assert len(call_kwargs["recommendation"]) > 10

    def test_wm_findings_metadata_includes_new_fields(self):
        """Verify the metadata structure includes all new fields (code inspection test)."""
        # This test verifies the code path by inspecting the safe_add_card method
        # to ensure it constructs metadata with the new fields
        from service import AutoPentestService
        import inspect

        # Get the source code of safe_add_card
        source = inspect.getsource(AutoPentestService.safe_add_card)

        # Verify metadata dict includes the new fields
        assert "cvss_vector" in source
        assert "cvss_score" in source
        assert "affected_endpoints" in source
        assert "description" in source
        assert "attack_scenario" in source
        assert "recommendation" in source

        # Verify they're in the metadata dict construction
        assert 'metadata={' in source or 'metadata = {' in source
        assert '"cvss_vector": kwargs.get("cvss_vector")' in source or \
               '"cvss_vector": kwargs.get' in source


class TestNewFeatures:
    """Tests for new features: evidence storage, no duplication, confirmed status, 7-tuple risk signals"""

    @pytest.mark.asyncio
    async def test_record_finding_stores_evidence_json(self):
        """Evidence dict should be serialized to JSON string"""
        from tools_pentest import _handle_record_finding

        mcp_service = MagicMock()
        mcp_service.safe_add_card = AsyncMock(return_value=MagicMock(ok=True, data={"id": 42}))

        evidence = {
            "request": {"method": "GET", "url": "https://example.com/api/users?id=1"},
            "response": {"status": 500, "body": "SQL error: syntax error near '1'"},
            "payload": "' OR '1'='1",
            "description": "SQL injection confirmed via error message"
        }

        await _handle_record_finding({
            "title": "SQL Injection in /api/users",
            "severity": "high",
            "url": "https://example.com/api/users",
            "vuln_class": "sqli_error",
            "parameter": "id",
            "evidence": evidence,
            "remediation": "Use parameterized queries"
        }, mcp_service)

        # Verify safe_add_card was called with evidence as JSON string
        call_kwargs = mcp_service.safe_add_card.call_args[1]
        assert "evidence" in call_kwargs
        assert isinstance(call_kwargs["evidence"], str)

        # Verify JSON is valid and contains expected data
        parsed_evidence = json.loads(call_kwargs["evidence"])
        assert parsed_evidence["request"]["method"] == "GET"
        assert parsed_evidence["response"]["status"] == 500
        assert parsed_evidence["payload"] == "' OR '1'='1"

    @pytest.mark.asyncio
    async def test_record_finding_sets_confirmed_status(self):
        """Status should be set to 'confirmed' for pentest findings"""
        from tools_pentest import _handle_record_finding

        mcp_service = MagicMock()
        mcp_service.safe_add_card = AsyncMock(return_value=MagicMock(ok=True, data={"id": 42}))

        await _handle_record_finding({
            "title": "XSS in search",
            "severity": "medium",
            "url": "https://example.com/search",
            "vuln_class": "xss_reflected",
            "parameter": "q",
            "evidence": {"payload": "<script>alert(1)</script>"},
            "remediation": "HTML encode output"
        }, mcp_service)

        call_kwargs = mcp_service.safe_add_card.call_args[1]
        assert call_kwargs["status"] == "confirmed"

    @pytest.mark.asyncio
    async def test_record_finding_no_duplicate_technical_analysis(self):
        """technical_analysis should NOT be in kwargs (removed duplication)"""
        from tools_pentest import _handle_record_finding

        mcp_service = MagicMock()
        mcp_service.safe_add_card = AsyncMock(return_value=MagicMock(ok=True, data={"id": 42}))

        await _handle_record_finding({
            "title": "IDOR in /api/invoices",
            "severity": "high",
            "url": "https://example.com/api/invoices/123",
            "vuln_class": "idor",
            "parameter": "id",
            "evidence": {"description": "Can access other user invoices"},
            "remediation": "Add authorization checks"
        }, mcp_service)

        call_kwargs = mcp_service.safe_add_card.call_args[1]
        # technical_analysis should NOT be in kwargs (removed duplication)
        assert "technical_analysis" not in call_kwargs

    def test_risk_signal_cards_7_tuple_format(self):
        """All 25 risk signal entries should have 7 elements"""
        from service import AutoPentestService

        service = AutoPentestService()

        for sig_type, card_info in service._RISK_SIGNAL_CARDS.items():
            assert len(card_info) == 7, f"{sig_type} should have 7 elements (title, severity, vuln_class, description, recommendation, cvss_vector, attack_scenario)"

            title, severity, vuln_class, description, recommendation, cvss_vector, attack_scenario = card_info

            # Verify types
            assert isinstance(title, str) and len(title) > 0, f"{sig_type} title must be non-empty string"
            assert severity in ("high", "medium", "low", "info"), f"{sig_type} severity must be valid"
            assert isinstance(description, str) and len(description) > 20, f"{sig_type} description must be substantial"
            assert isinstance(recommendation, str) and len(recommendation) > 20, f"{sig_type} recommendation must be substantial"
            assert isinstance(cvss_vector, str), f"{sig_type} cvss_vector must be string"
            assert isinstance(attack_scenario, str) and len(attack_scenario) > 20, f"{sig_type} attack_scenario must be substantial"

    def test_risk_signal_cvss_vectors_valid(self):
        """All non-info severity signals should have valid CVSS vectors"""
        from service import AutoPentestService
        from lib.risk_engine import CVSSv31

        service = AutoPentestService()

        for sig_type, card_info in service._RISK_SIGNAL_CARDS.items():
            title, severity, vuln_class, description, recommendation, cvss_vector, attack_scenario = card_info

            if cvss_vector:
                # Verify CVSS vector parses and produces a valid score
                try:
                    cvss_obj = CVSSv31(cvss_vector)
                    score = cvss_obj.base_score()
                    assert 0.0 <= score <= 10.0, f"{sig_type} CVSS score {score} out of range"
                    assert cvss_vector.startswith("CVSS:3.1/"), f"{sig_type} CVSS vector must start with CVSS:3.1/"
                except Exception as e:
                    pytest.fail(f"{sig_type} has invalid CVSS vector '{cvss_vector}': {e}")

    @pytest.mark.asyncio
    async def test_auto_persist_risk_signals_includes_cvss_and_attack_scenario(self):
        """auto_persist_risk_signals should pass cvss_vector, cvss_score, attack_scenario, status to safe_add_card"""
        from service import AutoPentestService

        service = AutoPentestService()
        service.current_assessment_id = 1
        service.safe_add_card = AsyncMock(return_value=MagicMock(ok=True, skipped=False, data={"id": 42}))

        risk_signals = [
            {
                "type": "cors_wildcard",
                "severity": "high",
                "detail": "Access-Control-Allow-Origin: * with credentials"
            }
        ]

        count = await service.auto_persist_risk_signals(risk_signals, "https://example.com/api")

        assert count == 1
        call_kwargs = service.safe_add_card.call_args[1]

        # Verify CVSS fields present
        assert "cvss_vector" in call_kwargs
        assert call_kwargs["cvss_vector"].startswith("CVSS:3.1/")

        assert "cvss_score" in call_kwargs
        assert isinstance(call_kwargs["cvss_score"], float)
        assert 0.0 <= call_kwargs["cvss_score"] <= 10.0

        # Verify attack_scenario present
        assert "attack_scenario" in call_kwargs
        assert isinstance(call_kwargs["attack_scenario"], str)
        assert len(call_kwargs["attack_scenario"]) > 50  # Should be a detailed scenario

        # Verify status is confirmed
        assert call_kwargs["status"] == "confirmed"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
