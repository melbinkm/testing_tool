"""
Tests for PayloadRegistry - Unified payload interface for all vulnerability classes.
"""

import os
import sys
import unittest

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "mcp", "modules"))

from lib.payload_registry import get_payload_registry


class TestPayloadRegistry(unittest.TestCase):
    """Test payload registry functionality."""

    def setUp(self):
        """Set up test fixtures."""
        self.registry = get_payload_registry()

    def test_get_sqli_payloads(self):
        """Test retrieving SQL injection payloads."""
        payloads = self.registry.get_payloads('sqli_error')
        self.assertGreater(len(payloads), 0)
        # Should be SQLPayload objects with payload attribute
        self.assertTrue(hasattr(payloads[0], 'payload'))

    def test_get_xss_payloads(self):
        """Test retrieving XSS payloads."""
        payloads = self.registry.get_payloads('xss_reflected')
        self.assertGreater(len(payloads), 0)

    def test_get_cmdi_payloads(self):
        """Test retrieving command injection payloads."""
        payloads = self.registry.get_payloads('command_injection')
        self.assertGreater(len(payloads), 0)

        # Verify structure
        payload_obj = payloads[0]
        self.assertTrue(hasattr(payload_obj, 'payload'))
        self.assertTrue(hasattr(payload_obj, 'technique'))
        self.assertTrue(hasattr(payload_obj, 'platform'))

    def test_get_nosql_payloads(self):
        """Test retrieving NoSQL injection payloads."""
        payloads = self.registry.get_payloads('nosql_injection')
        self.assertGreater(len(payloads), 0)

        # Check for MongoDB-specific payloads
        payload_strings = [p.payload for p in payloads]
        self.assertTrue(any('$ne' in str(p) for p in payload_strings))
        self.assertTrue(any('$gt' in str(p) for p in payload_strings))

    def test_get_xxe_payloads(self):
        """Test retrieving XXE payloads."""
        payloads = self.registry.get_payloads('xml_injection')
        self.assertGreater(len(payloads), 0)

        # Check for XXE-specific patterns
        payload_strings = [p.payload for p in payloads]
        self.assertTrue(any('<!ENTITY' in str(p) for p in payload_strings))
        self.assertTrue(any('SYSTEM' in str(p) for p in payload_strings))

    def test_get_header_injection_payloads(self):
        """Test retrieving header injection payloads."""
        payloads = self.registry.get_payloads('header_injection')
        self.assertGreater(len(payloads), 0)

        # Check for CRLF patterns
        payload_strings = [p.payload for p in payloads]
        self.assertTrue(any('\\r\\n' in str(p) or '\r\n' in str(p) for p in payload_strings))

    def test_get_jwt_payloads(self):
        """Test retrieving JWT manipulation payloads."""
        payloads = self.registry.get_payloads('jwt_manipulation')
        self.assertGreater(len(payloads), 0)

        # Check for JWT-specific patterns
        for payload in payloads:
            self.assertTrue(hasattr(payload, 'header'))
            self.assertTrue(hasattr(payload, 'payload_claims'))

    def test_get_cors_payloads(self):
        """Test retrieving CORS test payloads."""
        payloads = self.registry.get_payloads('cors_misconfig')
        self.assertGreater(len(payloads), 0)

        # Check for origin header values
        for payload in payloads:
            self.assertTrue(hasattr(payload, 'origin_header'))

    def test_get_redirect_payloads(self):
        """Test retrieving open redirect payloads."""
        payloads = self.registry.get_payloads('open_redirect')
        self.assertGreater(len(payloads), 0)

        # Check for redirect patterns
        payload_strings = [p.payload for p in payloads]
        self.assertTrue(any('evil.com' in str(p) for p in payload_strings))

    def test_get_payload_count(self):
        """Test payload count retrieval."""
        count = self.registry.get_payload_count('sqli_error')
        self.assertGreater(count, 0)

        count_xss = self.registry.get_payload_count('xss_reflected')
        self.assertGreater(count_xss, 0)

    def test_get_all_payload_counts(self):
        """Test retrieving counts for all vulnerability classes."""
        counts = self.registry.get_all_payload_counts()

        self.assertIsInstance(counts, dict)
        self.assertGreater(len(counts), 0)

        # Check some expected classes
        self.assertIn('sqli_error', counts)
        self.assertIn('xss_reflected', counts)
        self.assertIn('command_injection', counts)
        self.assertIn('nosql_injection', counts)

    def test_has_payloads(self):
        """Test checking if a class has payloads."""
        self.assertTrue(self.registry.has_payloads('sqli_error'))
        self.assertTrue(self.registry.has_payloads('command_injection'))
        self.assertTrue(self.registry.has_payloads('nosql_injection'))

        # Tool-based tests without payloads
        self.assertFalse(self.registry.has_payloads('idor'))
        self.assertFalse(self.registry.has_payloads('csrf'))

    def test_to_string_payloads_sql(self):
        """Test converting SQL payload objects to strings."""
        payloads = self.registry.get_payloads('sqli_error')
        strings = self.registry.to_string_payloads(payloads)

        self.assertEqual(len(strings), len(payloads))
        self.assertTrue(all(isinstance(s, str) for s in strings))

        # Should contain SQL injection patterns
        all_strings = ' '.join(strings)
        self.assertTrue("'" in all_strings or 'SELECT' in all_strings)

    def test_to_string_payloads_cors(self):
        """Test converting CORS payload objects to strings."""
        payloads = self.registry.get_payloads('cors_misconfig')
        strings = self.registry.to_string_payloads(payloads)

        self.assertEqual(len(strings), len(payloads))
        # CORS payloads use origin_header attribute
        self.assertTrue(all(isinstance(s, str) for s in strings))

    def test_to_string_payloads_jwt(self):
        """Test converting JWT payload objects to strings."""
        payloads = self.registry.get_payloads('jwt_manipulation')
        strings = self.registry.to_string_payloads(payloads)

        self.assertEqual(len(strings), len(payloads))
        # JWT payloads should be built into token strings
        self.assertTrue(all('.' in s or s == '' for s in strings))  # JWT format or empty

    def test_empty_payloads_for_tool_based(self):
        """Test that tool-based tests return empty payload lists."""
        # IDOR is tool-based (validate_cross_identity)
        payloads = self.registry.get_payloads('idor')
        self.assertEqual(len(payloads), 0)

        # CSRF is tool-based
        payloads = self.registry.get_payloads('csrf')
        self.assertEqual(len(payloads), 0)

        # Auth bypass is tool-based
        payloads = self.registry.get_payloads('auth_bypass')
        self.assertEqual(len(payloads), 0)

    def test_context_aware_mass_assignment(self):
        """Test context-aware payload generation for mass assignment."""
        # No context
        payloads = self.registry.get_payloads('mass_assignment')
        self.assertGreater(len(payloads), 0)

        # With user endpoint context
        context = {
            'endpoint': {'path': '/api/users/profile'}
        }
        payloads_with_context = self.registry.get_payloads('mass_assignment', context)
        self.assertGreater(len(payloads_with_context), len(payloads))

        # Should include verified/email_verified fields for user endpoints
        payload_strings = ' '.join(payloads_with_context)
        self.assertIn('verified', payload_strings)

    def test_context_aware_param_pollution(self):
        """Test context-aware payload generation for parameter pollution."""
        context = {
            'parameter': {'name': 'user_id'}
        }
        payloads = self.registry.get_payloads('param_pollution', context)

        self.assertGreater(len(payloads), 0)

        # Should include parameter name in payloads
        payload_str = ' '.join(payloads)
        self.assertIn('user_id', payload_str)

    def test_graphql_payloads(self):
        """Test GraphQL introspection payloads."""
        payloads = self.registry.get_payloads('graphql_introspection')
        self.assertGreater(len(payloads), 0)

        # Should contain __schema queries
        payload_str = ' '.join(payloads)
        self.assertIn('__schema', payload_str)
        self.assertIn('__type', payload_str)

    def test_price_manipulation_payloads(self):
        """Test price manipulation payloads."""
        payloads = self.registry.get_payloads('price_manipulation')
        self.assertGreater(len(payloads), 0)

        # Should include negative values, zero, etc.
        self.assertIn('0', payloads)
        self.assertIn('-1', payloads)

    def test_unknown_vuln_class(self):
        """Test handling of unknown vulnerability class."""
        payloads = self.registry.get_payloads('unknown_vuln_class_xyz')
        self.assertEqual(len(payloads), 0)

        count = self.registry.get_payload_count('unknown_vuln_class_xyz')
        self.assertEqual(count, 0)

        has_payloads = self.registry.has_payloads('unknown_vuln_class_xyz')
        self.assertFalse(has_payloads)

    def test_ssti_payloads(self):
        """Test SSTI payloads from existing library."""
        payloads = self.registry.get_payloads('ssti')
        self.assertGreater(len(payloads), 0)

        # Should contain template syntax
        payload_strings = [str(p.payload) if hasattr(p, 'payload') else str(p) for p in payloads]
        template_found = any('{{' in s or '${' in s for s in payload_strings)
        self.assertTrue(template_found)

    def test_ssrf_payloads(self):
        """Test SSRF payloads from existing library."""
        payloads = self.registry.get_payloads('ssrf')
        self.assertGreater(len(payloads), 0)

        # Should contain localhost/metadata URLs
        payload_strings = [str(p.payload) if hasattr(p, 'payload') else str(p) for p in payloads]
        ssrf_found = any('localhost' in s.lower() or '169.254' in s for s in payload_strings)
        self.assertTrue(ssrf_found)

    def test_path_traversal_payloads(self):
        """Test path traversal payloads from existing library."""
        payloads = self.registry.get_payloads('path_traversal')
        self.assertGreater(len(payloads), 0)

        # Should contain ../ patterns
        payload_strings = [str(p.payload) if hasattr(p, 'payload') else str(p) for p in payloads]
        traversal_found = any('../' in s or '..\\' in s for s in payload_strings)
        self.assertTrue(traversal_found)

    def test_legacy_sqli_compatibility(self):
        """Test backward compatibility with legacy 'sqli' class."""
        # Old 'sqli' class should still work
        payloads_legacy = self.registry.get_payloads('sqli')
        self.assertGreater(len(payloads_legacy), 0)

        # Should get error-based payloads
        payloads_new = self.registry.get_payloads('sqli_error')
        self.assertGreater(len(payloads_new), 0)

    def test_legacy_xss_compatibility(self):
        """Test backward compatibility with legacy 'xss' class."""
        payloads_legacy = self.registry.get_payloads('xss')
        self.assertGreater(len(payloads_legacy), 0)

        payloads_new = self.registry.get_payloads('xss_reflected')
        self.assertGreater(len(payloads_new), 0)


if __name__ == '__main__':
    unittest.main()
