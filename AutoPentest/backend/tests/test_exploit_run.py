"""Tests for exploit_run tool in tools_execution.py."""
import sys
import os
import asyncio
import unittest
import json
from unittest.mock import AsyncMock, MagicMock, patch

# Add modules to path (avoid pip mcp package shadowing)
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp'))

from tools_execution import _handle_exploit_run


def _make_mock_service():
    svc = MagicMock()
    svc.current_assessment_id = 1
    svc.config = None
    svc.activity_logger = MagicMock()
    svc.activity_logger.log = AsyncMock()
    return svc


def _parse_result(result):
    return json.loads(result[0].text)


def _make_mock_process(returncode=0, stdout=b"", stderr=b""):
    """Create a mock async subprocess process."""
    proc = AsyncMock()
    proc.returncode = returncode
    proc.communicate = AsyncMock(return_value=(stdout, stderr))
    return proc


class TestExploitRun(unittest.IsolatedAsyncioTestCase):
    @patch('asyncio.create_subprocess_exec')
    async def test_successful_execution(self, mock_create_proc):
        """Test successful Python code execution."""
        mock_service = _make_mock_service()

        write_proc = _make_mock_process(returncode=0, stdout=b"", stderr=b"")
        exec_proc = _make_mock_process(returncode=0, stdout=b"Exploit output: vulnerable\n", stderr=b"")
        cleanup_proc = _make_mock_process(returncode=0)

        mock_create_proc.side_effect = [write_proc, exec_proc, cleanup_proc]

        result = await _handle_exploit_run({
            "code": "print('Exploit output: vulnerable')",
            "timeout": 30,
        }, mock_service)

        data = _parse_result(result)
        self.assertTrue(data["success"])
        self.assertEqual(data["return_code"], 0)
        self.assertIn("vulnerable", data["stdout"])
        self.assertFalse(data["timed_out"])

    @patch('asyncio.create_subprocess_exec')
    async def test_execution_failure(self, mock_create_proc):
        """Test Python code execution failure (non-zero exit)."""
        mock_service = _make_mock_service()

        write_proc = _make_mock_process(returncode=0, stderr=b"")
        exec_proc = _make_mock_process(returncode=1, stdout=b"", stderr=b"NameError: name 'foo' is not defined\n")
        cleanup_proc = _make_mock_process(returncode=0)

        mock_create_proc.side_effect = [write_proc, exec_proc, cleanup_proc]

        result = await _handle_exploit_run({
            "code": "foo()",
            "timeout": 30,
        }, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["success"])
        self.assertEqual(data["return_code"], 1)
        self.assertIn("NameError", data["stderr"])

    @patch('asyncio.create_subprocess_exec')
    async def test_timeout_detection(self, mock_create_proc):
        """Test timeout detection (return code 124)."""
        mock_service = _make_mock_service()

        write_proc = _make_mock_process(returncode=0, stderr=b"")
        exec_proc = _make_mock_process(returncode=124, stdout=b"", stderr=b"")
        cleanup_proc = _make_mock_process(returncode=0)

        mock_create_proc.side_effect = [write_proc, exec_proc, cleanup_proc]

        result = await _handle_exploit_run({
            "code": "import time; time.sleep(999)",
            "timeout": 5,
        }, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["success"])
        self.assertTrue(data["timed_out"])

    async def test_empty_code_returns_error(self):
        """Test empty code returns error."""
        mock_service = _make_mock_service()

        result = await _handle_exploit_run({
            "code": "",
        }, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["success"])
        self.assertIn("No code", data["error"])

    @patch('asyncio.create_subprocess_exec')
    async def test_safety_blocked(self, mock_create_proc):
        """Test safety classifier blocks dangerous code."""
        mock_service = _make_mock_service()

        mock_classifier = MagicMock()
        mock_classifier.classify_command.return_value = {
            "level": "blocked",
            "reason": "Destructive command detected"
        }

        with patch('lib.safety_classifier.get_safety_classifier', return_value=mock_classifier):
            result = await _handle_exploit_run({
                "code": "import os; os.system('rm -rf /')",
                "timeout": 30,
            }, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["success"])
        self.assertIn("blocked", data["error"].lower())
        # asyncio.create_subprocess_exec should NOT have been called
        mock_create_proc.assert_not_called()

    @patch('asyncio.create_subprocess_exec')
    async def test_write_failure(self, mock_create_proc):
        """Test handling when writing code to container fails."""
        mock_service = _make_mock_service()

        write_proc = _make_mock_process(returncode=1, stderr=b"docker: Container not found")
        cleanup_proc = _make_mock_process(returncode=0)

        mock_create_proc.side_effect = [write_proc, cleanup_proc]

        result = await _handle_exploit_run({
            "code": "print('test')",
            "timeout": 30,
        }, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["success"])
        self.assertIn("Failed to write", data["error"])


if __name__ == "__main__":
    unittest.main()
