"""
Test that ALL HTTP-making tools run exchange analysis.

This test verifies that every tool that makes HTTP requests also runs
ExchangeAnalyzer to detect security issues automatically.
"""
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

import unittest
from unittest.mock import AsyncMock, MagicMock, patch, ANY
import json


class TestExchangeAnalysisCoverage(unittest.IsolatedAsyncioTestCase):
    """Verify exchange analysis runs for all HTTP-making tools."""

    async def test_recon_endpoint_runs_exchange_analysis(self):
        """Verify recon_endpoint runs exchange analysis and persists findings."""
        from tools_pentest import _handle_recon_endpoint

        # Mock HttpClient
        mock_client = AsyncMock()
        mock_client.send.return_value = {
            "status": 200,
            "statusText": "OK",
            "headers": {"content-type": "text/html"},
            "body": "<!-- password: admin123 -->",
            "timing": {"duration_ms": 100}
        }

        # Mock ExchangeAnalyzer
        mock_analyzer = MagicMock()
        mock_analysis_result = MagicMock()
        mock_analysis_result.risk_signals = [
            {"type": "sensitive_comment", "severity": "low", "details": "Found password in comment"}
        ]
        mock_analysis_result.recommended_tests = ["xss"]
        mock_analysis_result.detected_technologies = ["html"]
        mock_analyzer.analyze.return_value = mock_analysis_result

        # Mock MCP service
        mock_service = AsyncMock()
        mock_service.auto_persist_risk_signals = AsyncMock(return_value=1)

        with patch('tools_pentest._get_http_client', return_value=mock_client), \
             patch('lib.exchange_analyzer.get_exchange_analyzer', return_value=mock_analyzer):

            result = await _handle_recon_endpoint(
                {"url": "http://test.com", "method": "GET"},
                mock_service
            )

            # Verify exchange analyzer was called
            mock_analyzer.analyze.assert_called_once()
            # Check positional args (analyzer.analyze(request_dict, response_dict))
            args = mock_analyzer.analyze.call_args[0]
            self.assertEqual(args[0]["url"], "http://test.com")  # request dict
            self.assertEqual(args[1]["status"], 200)  # response dict

            # Verify findings were persisted
            mock_service.auto_persist_risk_signals.assert_called_once_with(
                mock_analysis_result.risk_signals,
                "http://test.com"
            )

            # Verify response includes exchange_analysis
            response_data = json.loads(result[0].text)
            self.assertIn("exchange_analysis", response_data)
            self.assertEqual(len(response_data["exchange_analysis"]["risk_signals"]), 1)
            self.assertEqual(response_data["exchange_analysis"]["auto_findings_created"], 1)

    async def test_inject_payload_runs_exchange_analysis(self):
        """Verify inject_payload runs exchange analysis."""
        from tools_pentest import _handle_inject_payload

        mock_client = AsyncMock()
        mock_client.send.return_value = {
            "status": 200,
            "statusText": "OK",
            "headers": {"set-cookie": "session=abc"},
            "body": "<script>alert(1)</script>",
            "timing": {"duration_ms": 50}
        }

        mock_analyzer = MagicMock()
        mock_analysis_result = MagicMock()
        mock_analysis_result.risk_signals = [
            {"type": "cookie_missing_httponly", "severity": "medium"}
        ]
        mock_analysis_result.recommended_tests = []
        mock_analysis_result.detected_technologies = []
        mock_analyzer.analyze.return_value = mock_analysis_result

        mock_service = AsyncMock()
        mock_service.auto_persist_risk_signals = AsyncMock(return_value=1)

        with patch('tools_pentest._get_http_client', return_value=mock_client), \
             patch('lib.exchange_analyzer.get_exchange_analyzer', return_value=mock_analyzer), \
             patch('tools_pentest.TestPlanExecutor._inject_payload',
                   return_value=("http://test.com?id=<script>", "", {})):

            result = await _handle_inject_payload({
                "url": "http://test.com",
                "method": "GET",
                "parameter": "id",
                "location": "query",
                "payload": "<script>alert(1)</script>"
            }, mock_service)

            # Verify analyzer called
            mock_analyzer.analyze.assert_called_once()

            # Verify response includes exchange_analysis
            response_data = json.loads(result[0].text)
            self.assertIn("exchange_analysis", response_data)
            self.assertEqual(response_data["exchange_analysis"]["auto_findings_created"], 1)

    async def test_inject_batch_runs_exchange_analysis_on_baseline(self):
        """Verify inject_batch runs exchange analysis on baseline request."""
        from tools_pentest import _handle_inject_batch

        mock_client = AsyncMock()
        # Baseline response
        baseline_response = {
            "status": 200,
            "statusText": "OK",
            "headers": {"x-powered-by": "PHP/7.4.1"},
            "body": "OK",
            "timing": {"duration_ms": 100}
        }
        # Payload responses
        payload_response = {
            "status": 200,
            "statusText": "OK",
            "headers": {},
            "body": "OK",
            "timing": {"duration_ms": 101}
        }
        mock_client.send.side_effect = [baseline_response, payload_response, payload_response]

        mock_analyzer = MagicMock()
        mock_analysis_result = MagicMock()
        mock_analysis_result.risk_signals = [
            {"type": "version_disclosure", "severity": "low"}
        ]
        mock_analysis_result.recommended_tests = []
        mock_analysis_result.detected_technologies = ["php"]
        mock_analyzer.analyze.return_value = mock_analysis_result

        mock_service = AsyncMock()
        mock_service.auto_persist_risk_signals = AsyncMock(return_value=1)

        with patch('tools_pentest._get_http_client', return_value=mock_client), \
             patch('lib.exchange_analyzer.get_exchange_analyzer', return_value=mock_analyzer), \
             patch('tools_pentest.TestPlanExecutor._inject_payload',
                   side_effect=lambda **kw: (kw["url"], kw["body"], kw["headers"])):

            result = await _handle_inject_batch({
                "url": "http://test.com",
                "method": "GET",
                "parameter": "id",
                "location": "query",
                "payloads": ["payload1", "payload2"],
                "include_baseline": True
            }, mock_service)

            # Verify analyzer called once (for baseline only)
            mock_analyzer.analyze.assert_called_once()

            # Verify response includes baseline_exchange_analysis
            response_data = json.loads(result[0].text)
            self.assertIn("baseline_exchange_analysis", response_data)
            self.assertEqual(response_data["baseline_exchange_analysis"]["auto_findings_created"], 1)

    async def test_analyze_headers_runs_exchange_analysis(self):
        """Verify analyze_headers runs exchange analysis."""
        from tools_pentest import _handle_analyze_headers

        mock_client = AsyncMock()
        mock_client.send.return_value = {
            "status": 200,
            "headers": {
                "server": "nginx/1.18.0",
                "x-frame-options": "DENY"
            },
            "body": ""
        }

        mock_analyzer = MagicMock()
        mock_analysis_result = MagicMock()
        mock_analysis_result.risk_signals = [
            {"type": "missing_csp", "severity": "medium"},
            {"type": "version_disclosure", "severity": "low"}
        ]
        mock_analysis_result.recommended_tests = []
        mock_analysis_result.detected_technologies = ["nginx"]
        mock_analyzer.analyze.return_value = mock_analysis_result

        mock_service = AsyncMock()
        mock_service.auto_persist_risk_signals = AsyncMock(return_value=2)

        with patch('tools_pentest._get_http_client', return_value=mock_client), \
             patch('lib.exchange_analyzer.get_exchange_analyzer', return_value=mock_analyzer):

            result = await _handle_analyze_headers({
                "url": "http://test.com"
            }, mock_service)

            # Verify analyzer called
            mock_analyzer.analyze.assert_called_once()

            # Verify response includes exchange_analysis
            response_data = json.loads(result[0].text)
            self.assertIn("exchange_analysis", response_data)
            self.assertEqual(response_data["exchange_analysis"]["auto_findings_created"], 2)

    async def test_auth_replay_with_identity_runs_exchange_analysis(self):
        """Verify auth_replay_with_identity runs exchange analysis."""
        from tools_auth_tester import _handle_replay_with_identity

        # Mock identity store
        mock_identity = MagicMock()
        mock_identity.type = "admin"
        mock_identity.scope = "full"
        mock_identity.should_have_access = True

        mock_store = MagicMock()
        mock_store.get_identity.return_value = mock_identity

        # Mock HttpClient
        mock_client = AsyncMock()
        mock_client.send.return_value = {
            "response": {
                "status": 200,
                "headers": {"content-type": "application/json"},
                "body": '{"success": true}'
            }
        }

        # Mock ExchangeAnalyzer
        mock_analyzer = MagicMock()
        mock_analysis_result = MagicMock()
        mock_analysis_result.risk_signals = []
        mock_analysis_result.recommended_tests = []
        mock_analysis_result.detected_technologies = []
        mock_analyzer.analyze.return_value = mock_analysis_result

        mock_service = AsyncMock()

        with patch('tools_auth_tester._get_identity_store', return_value=mock_store), \
             patch('lib.http_client_factory.create_audit_http_client', return_value=mock_client), \
             patch('lib.exchange_analyzer.get_exchange_analyzer', return_value=mock_analyzer), \
             patch('lib.identity_store.IdentityStore.build_auth_headers', return_value={"authorization": "Bearer token"}):

            result = await _handle_replay_with_identity({
                "url": "http://test.com",
                "identity_id": "admin1",
                "method": "GET"
            }, mock_service)

            # Verify analyzer called
            mock_analyzer.analyze.assert_called_once()

            # Verify response includes exchange_analysis
            response_data = json.loads(result[0].text)
            self.assertIn("exchange_analysis", response_data)

    async def test_auth_diff_test_runs_exchange_analysis(self):
        """Verify auth_diff_test runs exchange analysis on all responses."""
        from tools_auth_tester import _handle_diff_test

        # Mock identities
        mock_identity1 = MagicMock()
        mock_identity1.type = "admin"
        mock_identity2 = MagicMock()
        mock_identity2.type = "user"

        mock_store = MagicMock()
        mock_store.count = 2
        mock_store.get_identities.return_value = [mock_identity1, mock_identity2]

        # Mock HttpClient
        mock_client = AsyncMock()

        # Mock DifferentialTester
        mock_tester = MagicMock()
        mock_tester.test_endpoint = AsyncMock(return_value=[
            {
                "identity_id": "admin",
                "request": {"method": "GET", "url": "http://test.com", "headers": {}, "body": ""},
                "response": {"status_code": 200, "headers": {}, "body": "OK"}
            },
            {
                "identity_id": "user",
                "request": {"method": "GET", "url": "http://test.com", "headers": {}, "body": ""},
                "response": {"status_code": 403, "headers": {}, "body": "Forbidden"}
            }
        ])
        mock_tester.analyze_results.return_value = {"access_differences": True}

        # Mock ExchangeAnalyzer
        mock_analyzer = MagicMock()
        mock_analysis_result = MagicMock()
        mock_analysis_result.risk_signals = [
            {"type": "missing_hsts", "severity": "medium"}
        ]
        mock_analysis_result.recommended_tests = []
        mock_analysis_result.detected_technologies = []
        mock_analyzer.analyze.return_value = mock_analysis_result

        mock_service = AsyncMock()
        mock_service.auto_persist_risk_signals = AsyncMock(return_value=1)

        with patch('tools_auth_tester._get_identity_store', return_value=mock_store), \
             patch('lib.http_client_factory.create_audit_http_client', return_value=mock_client), \
             patch('lib.diff_tester.DifferentialTester', return_value=mock_tester), \
             patch('lib.exchange_analyzer.get_exchange_analyzer', return_value=mock_analyzer):

            result = await _handle_diff_test({
                "url": "http://test.com"
            }, mock_service)

            # Verify analyzer called twice (once per identity)
            self.assertEqual(mock_analyzer.analyze.call_count, 2)

            # Verify response includes exchange_analyses
            response_data = json.loads(result[0].text)
            self.assertIn("exchange_analyses", response_data)
            self.assertEqual(len(response_data["exchange_analyses"]), 2)
            self.assertEqual(response_data["auto_findings_created"], 1)


if __name__ == '__main__':
    unittest.main()
