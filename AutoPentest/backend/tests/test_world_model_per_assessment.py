"""
Tests for per-assessment world model isolation.

Verifies:
1. _resolve_db_path produces assessment-specific paths
2. get_world_model_db creates separate instances per assessment_id
3. Data isolation: assets in assessment 1 are not visible in assessment 2
4. reset_world_model_db closes and removes instances
5. Invalid assessment_id values are rejected
6. _NoAssessmentError is raised when mcp_service is missing or has no assessment
"""

from __future__ import annotations

import asyncio
import json
import os
import sys
import tempfile

import pytest

# Ensure the mcp modules directory is importable
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "mcp", "modules"))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "mcp", "modules", "lib"))


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------

@pytest.fixture(autouse=True)
def tmp_data_dir(tmp_path, monkeypatch):
    """Point WORLD_MODEL_DB to a temp directory for each test."""
    db_path = str(tmp_path / "world-model.db")
    monkeypatch.setenv("WORLD_MODEL_DB", db_path)
    # Also clear the instance cache before each test
    from world_model_db import _db_instances
    _db_instances.clear()
    yield tmp_path


# ---------------------------------------------------------------------------
# Tests for _resolve_db_path
# ---------------------------------------------------------------------------

class TestResolveDbPath:
    def test_path_from_env_ending_with_db(self, tmp_data_dir):
        from world_model_db import _resolve_db_path
        path = _resolve_db_path(42)
        assert path.endswith("world-model-42.db")
        assert str(tmp_data_dir) in path

    def test_path_from_env_as_directory(self, tmp_data_dir, monkeypatch):
        from world_model_db import _resolve_db_path
        monkeypatch.setenv("WORLD_MODEL_DB", str(tmp_data_dir))
        path = _resolve_db_path(7)
        assert path.endswith("world-model-7.db")
        assert str(tmp_data_dir) in path

    def test_different_ids_different_paths(self):
        from world_model_db import _resolve_db_path
        assert _resolve_db_path(1) != _resolve_db_path(2)


# ---------------------------------------------------------------------------
# Tests for get_world_model_db
# ---------------------------------------------------------------------------

class TestGetWorldModelDb:
    @pytest.mark.asyncio
    async def test_creates_instance(self):
        from world_model_db import get_world_model_db, _db_instances
        db = await get_world_model_db(1)
        assert db is not None
        assert 1 in _db_instances
        assert _db_instances[1] is db

    @pytest.mark.asyncio
    async def test_returns_same_instance_for_same_id(self):
        from world_model_db import get_world_model_db
        db1 = await get_world_model_db(1)
        db2 = await get_world_model_db(1)
        assert db1 is db2

    @pytest.mark.asyncio
    async def test_different_ids_get_different_instances(self):
        from world_model_db import get_world_model_db
        db1 = await get_world_model_db(1)
        db2 = await get_world_model_db(2)
        assert db1 is not db2

    @pytest.mark.asyncio
    async def test_rejects_zero(self):
        from world_model_db import get_world_model_db
        with pytest.raises(ValueError, match="positive integer"):
            await get_world_model_db(0)

    @pytest.mark.asyncio
    async def test_rejects_negative(self):
        from world_model_db import get_world_model_db
        with pytest.raises(ValueError, match="positive integer"):
            await get_world_model_db(-1)

    @pytest.mark.asyncio
    async def test_rejects_string(self):
        from world_model_db import get_world_model_db
        with pytest.raises(ValueError, match="positive integer"):
            await get_world_model_db("abc")  # type: ignore


# ---------------------------------------------------------------------------
# Tests for reset_world_model_db
# ---------------------------------------------------------------------------

class TestResetWorldModelDb:
    @pytest.mark.asyncio
    async def test_reset_specific_id(self):
        from world_model_db import get_world_model_db, reset_world_model_db, _db_instances
        await get_world_model_db(1)
        await get_world_model_db(2)
        assert 1 in _db_instances
        assert 2 in _db_instances
        await reset_world_model_db(1)
        assert 1 not in _db_instances
        assert 2 in _db_instances

    @pytest.mark.asyncio
    async def test_reset_all(self):
        from world_model_db import get_world_model_db, reset_world_model_db, _db_instances
        await get_world_model_db(1)
        await get_world_model_db(2)
        await reset_world_model_db()
        assert len(_db_instances) == 0

    @pytest.mark.asyncio
    async def test_reset_nonexistent_id_no_error(self):
        from world_model_db import reset_world_model_db
        # Should not raise
        await reset_world_model_db(999)


# ---------------------------------------------------------------------------
# Tests for data isolation between assessments
# ---------------------------------------------------------------------------

class TestDataIsolation:
    @pytest.mark.asyncio
    async def test_assets_isolated(self):
        from world_model_db import get_world_model_db
        db1 = await get_world_model_db(1)
        db2 = await get_world_model_db(2)

        # Add asset to assessment 1
        asset = await db1.add_asset(kind="domain", name="example.com")
        assert asset["name"] == "example.com"

        # Query assessment 1 - should find it
        results1 = await db1.query("assets")
        assert len(results1) == 1
        assert results1[0]["name"] == "example.com"

        # Query assessment 2 - should be empty
        results2 = await db2.query("assets")
        assert len(results2) == 0

    @pytest.mark.asyncio
    async def test_hypotheses_isolated(self):
        from world_model_db import get_world_model_db
        db1 = await get_world_model_db(1)
        db2 = await get_world_model_db(2)

        await db1.add_hypothesis(
            title="SQL Injection",
            description="Test for SQLi in login",
            severity="high",
        )

        stats1 = await db1.get_stats()
        stats2 = await db2.get_stats()
        assert stats1["hypotheses"] == 1
        assert stats2["hypotheses"] == 0

    @pytest.mark.asyncio
    async def test_db_files_are_separate(self, tmp_data_dir):
        from world_model_db import get_world_model_db
        await get_world_model_db(10)
        await get_world_model_db(20)

        assert (tmp_data_dir / "world-model-10.db").exists()
        assert (tmp_data_dir / "world-model-20.db").exists()


# ---------------------------------------------------------------------------
# Tests for _NoAssessmentError in tools_world_model
# ---------------------------------------------------------------------------

class TestNoAssessmentGuard:
    @pytest.mark.asyncio
    async def test_get_db_raises_when_no_service(self):
        # Import from the tools module path
        tools_path = os.path.join(os.path.dirname(__file__), "..", "mcp", "modules")
        if tools_path not in sys.path:
            sys.path.insert(0, tools_path)
        from tools_world_model import _get_db, _NoAssessmentError
        with pytest.raises(_NoAssessmentError):
            await _get_db(None)

    @pytest.mark.asyncio
    async def test_get_db_raises_when_no_assessment_id(self):
        from tools_world_model import _get_db, _NoAssessmentError

        class MockService:
            current_assessment_id = None

        with pytest.raises(_NoAssessmentError):
            await _get_db(MockService())

    @pytest.mark.asyncio
    async def test_get_db_succeeds_with_assessment_id(self):
        from tools_world_model import _get_db

        class MockService:
            current_assessment_id = 1

        db = await _get_db(MockService())
        assert db is not None

    @pytest.mark.asyncio
    async def test_handler_returns_error_when_no_assessment(self):
        """The handle_world_model_tool dispatcher should catch _NoAssessmentError."""
        from tools_world_model import handle_world_model_tool
        result = await handle_world_model_tool("wm_query", {"stats": True}, mcp_service=None)
        assert len(result) == 1
        data = json.loads(result[0].text)
        assert data["success"] is False
        assert "No assessment loaded" in data["error"]
