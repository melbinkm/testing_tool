"""
Tests for VulnChecklist - 42-class vulnerability test specification registry.
"""

import os
import sys
import unittest

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "mcp", "modules"))

from lib.vuln_checklist import get_vuln_checklist, VulnTestSpec


class TestVulnChecklist(unittest.TestCase):
    """Test vulnerability checklist functionality."""

    def setUp(self):
        """Set up test fixtures."""
        self.checklist = get_vuln_checklist()

    def test_checklist_initialization(self):
        """Test checklist initializes correctly."""
        self.assertIsNotNone(self.checklist)

    def test_spec_count(self):
        """Test that we have at least 42 specs."""
        specs = self.checklist.get_all_specs()
        self.assertGreaterEqual(len(specs), 42, "Should have at least 42 vulnerability specs")

    def test_all_specs_have_required_fields(self):
        """Test that all specs have required fields."""
        specs = self.checklist.get_all_specs()

        for spec in specs:
            self.assertIsInstance(spec, VulnTestSpec)
            self.assertIsNotNone(spec.id, f"Spec missing id: {spec}")
            self.assertIsNotNone(spec.name, f"Spec missing name: {spec}")
            self.assertIsNotNone(spec.category, f"Spec missing category: {spec}")
            self.assertIsNotNone(spec.description, f"Spec missing description: {spec}")
            self.assertIsNotNone(spec.tool_name, f"Spec missing tool_name: {spec}")
            self.assertIsInstance(spec.base_args, dict, f"Spec base_args not dict: {spec}")
            self.assertIsInstance(spec.severity_range, tuple, f"Spec severity_range not tuple: {spec}")
            self.assertEqual(len(spec.severity_range), 2, f"Spec severity_range wrong length: {spec}")

    def test_categories_exist(self):
        """Test that expected categories exist."""
        expected_categories = {
            'injection', 'auth', 'config', 'client_side',
            'api', 'business_logic', 'info_leak'
        }
        categories = set(self.checklist.get_categories())

        for expected in expected_categories:
            self.assertIn(expected, categories, f"Missing category: {expected}")

    def test_get_specs_by_category(self):
        """Test filtering specs by category."""
        injection_specs = self.checklist.get_specs_by_category('injection')
        self.assertGreater(len(injection_specs), 0, "Should have injection category specs")

        # Verify all returned specs are in injection category
        for spec in injection_specs:
            self.assertEqual(spec.category, 'injection')

    def test_get_spec_by_id(self):
        """Test retrieving specific spec by ID."""
        # Test SQL injection spec
        sqli_error = self.checklist.get_spec_by_id('sqli_error')
        self.assertIsNotNone(sqli_error)
        self.assertEqual(sqli_error.id, 'sqli_error')
        self.assertEqual(sqli_error.category, 'injection')

        # Test XSS spec
        xss_reflected = self.checklist.get_spec_by_id('xss_reflected')
        self.assertIsNotNone(xss_reflected)
        self.assertEqual(xss_reflected.id, 'xss_reflected')

        # Test auth spec
        idor = self.checklist.get_spec_by_id('idor')
        self.assertIsNotNone(idor)
        self.assertEqual(idor.category, 'auth')

        # Test non-existent spec
        fake = self.checklist.get_spec_by_id('fake_vuln_class')
        self.assertIsNone(fake)

    def test_applicable_specs_with_parameters(self):
        """Test applicability filtering for endpoint with parameters."""
        endpoint = {
            'method': 'GET',
            'path': '/api/users',
            'parameters': [
                {'name': 'id', 'type': 'integer'},
                {'name': 'search', 'type': 'string'}
            ],
            'requires_auth': False,
            'content_type': 'application/json'
        }

        applicable = self.checklist.get_applicable_specs(endpoint)
        spec_ids = {spec.id for spec in applicable}

        # Should include parameter-bound classes
        self.assertIn('sqli_error', spec_ids, "Should test SQL injection with parameters")
        self.assertIn('command_injection', spec_ids, "Should test command injection with parameters")

    def test_applicable_specs_without_parameters(self):
        """Test applicability filtering for endpoint without parameters."""
        endpoint = {
            'method': 'GET',
            'path': '/health',
            'parameters': [],
            'requires_auth': False,
            'content_type': 'text/plain'
        }

        applicable = self.checklist.get_applicable_specs(endpoint)
        spec_ids = {spec.id for spec in applicable}

        # Should NOT include parameter-bound classes when no parameters
        parameter_bound_classes = {'sqli_error', 'xss_reflected', 'command_injection'}
        for cls in parameter_bound_classes:
            if cls in spec_ids:
                spec = self.checklist.get_spec_by_id(cls)
                # It's ok if non-parameter-bound specs appear
                if spec.parameter_bound:
                    self.fail(f"Parameter-bound class {cls} should not apply to endpoint without parameters")

    def test_applicable_specs_with_auth(self):
        """Test applicability filtering for authenticated endpoint."""
        endpoint = {
            'method': 'GET',
            'path': '/api/users/profile',
            'parameters': [],
            'requires_auth': True,
            'content_type': 'application/json'
        }

        applicable = self.checklist.get_applicable_specs(endpoint)
        spec_ids = {spec.id for spec in applicable}

        # Should include auth-related tests
        auth_classes = {'idor', 'privilege_escalation', 'session_expiry'}
        for cls in auth_classes:
            # Note: Not all auth classes may apply, depends on predicates
            pass  # Just verify it doesn't crash

    def test_build_tool_map(self):
        """Test tool map generation for backward compatibility."""
        tool_map = self.checklist.build_tool_map()

        self.assertIsInstance(tool_map, dict)
        self.assertGreater(len(tool_map), 0, "Tool map should not be empty")

        # Check structure
        for vuln_id, config in tool_map.items():
            self.assertIn('tool_name', config, f"Missing tool_name for {vuln_id}")
            self.assertIn('base_args', config, f"Missing base_args for {vuln_id}")
            self.assertIn('parameter_bound', config, f"Missing parameter_bound for {vuln_id}")
            self.assertIsInstance(config['tool_name'], str)
            self.assertIsInstance(config['base_args'], dict)
            self.assertIsInstance(config['parameter_bound'], bool)

    def test_summary_statistics(self):
        """Test summary statistics generation."""
        summary = self.checklist.get_summary()

        self.assertIn('total_specs', summary)
        self.assertIn('categories', summary)
        self.assertIn('parameter_bound_count', summary)
        self.assertIn('requires_auth_count', summary)
        self.assertIn('severity_distribution', summary)

        self.assertGreaterEqual(summary['total_specs'], 42)
        self.assertGreater(summary['parameter_bound_count'], 0)
        self.assertGreater(summary['requires_auth_count'], 0)

    def test_spec_to_dict(self):
        """Test spec serialization to dict."""
        spec = self.checklist.get_spec_by_id('sqli_error')
        self.assertIsNotNone(spec)

        spec_dict = spec.to_dict()

        self.assertIsInstance(spec_dict, dict)
        self.assertEqual(spec_dict['id'], 'sqli_error')
        self.assertIn('name', spec_dict)
        self.assertIn('category', spec_dict)
        self.assertIn('description', spec_dict)
        self.assertIn('tool_name', spec_dict)
        self.assertIn('base_args', spec_dict)
        self.assertIn('severity_range', spec_dict)

    def test_injection_category_completeness(self):
        """Test that injection category has expected specs."""
        injection_specs = self.checklist.get_specs_by_category('injection')
        injection_ids = {spec.id for spec in injection_specs}

        expected_injection = {
            'sqli_error', 'sqli_blind_boolean', 'sqli_blind_time', 'sqli_union',
            'xss_reflected', 'xss_stored', 'xss_dom',
            'ssti', 'ssrf', 'path_traversal',
            'command_injection', 'xml_injection', 'header_injection', 'nosql_injection'
        }

        for expected in expected_injection:
            self.assertIn(expected, injection_ids, f"Missing injection spec: {expected}")

    def test_auth_category_completeness(self):
        """Test that auth category has expected specs."""
        auth_specs = self.checklist.get_specs_by_category('auth')
        auth_ids = {spec.id for spec in auth_specs}

        expected_auth = {
            'idor', 'auth_bypass', 'broken_auth', 'session_fixation',
            'session_expiry', 'jwt_manipulation', 'privilege_escalation',
            'username_enumeration'
        }

        for expected in expected_auth:
            self.assertIn(expected, auth_ids, f"Missing auth spec: {expected}")

    def test_config_category_completeness(self):
        """Test that config category has expected specs."""
        config_specs = self.checklist.get_specs_by_category('config')
        config_ids = {spec.id for spec in config_specs}

        expected_config = {
            'cors_misconfig', 'csrf', 'clickjacking', 'security_headers',
            'cookie_security', 'http_method_tampering', 'tls_config'
        }

        for expected in expected_config:
            self.assertIn(expected, config_ids, f"Missing config spec: {expected}")


if __name__ == '__main__':
    unittest.main()
