"""Tests for test_csrf and think tools in tools_pentest.py."""
import sys
import os
import asyncio
import unittest
import json
from unittest.mock import AsyncMock, MagicMock, patch

# Add modules to path (avoid pip mcp package shadowing)
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

from tools_pentest import _handle_test_csrf, _handle_think


def _make_mock_service():
    svc = MagicMock()
    svc.current_assessment_id = 1
    svc._http_client_cache = None
    svc._http_client_cache_key = None
    svc.activity_logger = MagicMock()
    svc.activity_logger.log = AsyncMock()
    return svc


def _parse_result(result):
    return json.loads(result[0].text)


class TestCSRFTool(unittest.IsolatedAsyncioTestCase):
    async def test_csrf_vulnerable_all_bypasses_succeed(self):
        """Test CSRF vulnerable when all bypass variants succeed (return 200 like baseline)."""
        mock_service = _make_mock_service()

        mock_client = AsyncMock()
        # All requests return 200 - CSRF protection missing
        mock_client.send = AsyncMock(return_value={
            "status": 200, "body": "ok", "headers": {}
        })

        with patch('tools_pentest._get_http_client', return_value=mock_client):
            result = await _handle_test_csrf({
                "url": "http://target/api/update",
                "method": "POST",
                "body": '{"csrf_token": "abc123", "name": "test"}',
                "headers": {"Content-Type": "application/json"},
                "csrf_token_name": "csrf_token",
                "csrf_token_location": "body",
            }, mock_service)

        data = _parse_result(result)
        self.assertTrue(data["csrf_vulnerable"])
        self.assertEqual(data["bypasses_found"], 5)  # All 5 bypass variants
        self.assertEqual(data["verdict"], "CSRF VULNERABLE")

    async def test_csrf_protected_rejects_all(self):
        """Test CSRF protection intact when all variants return 403."""
        mock_service = _make_mock_service()

        call_count = [0]

        async def mock_send(**kwargs):
            call_count[0] += 1
            if call_count[0] == 1:
                # Baseline returns 200
                return {"status": 200, "body": "ok", "headers": {}}
            # All bypass variants return 403
            return {"status": 403, "body": "CSRF token invalid", "headers": {}}

        mock_client = AsyncMock()
        mock_client.send = mock_send

        with patch('tools_pentest._get_http_client', return_value=mock_client):
            result = await _handle_test_csrf({
                "url": "http://target/api/update",
                "method": "POST",
                "body": "csrf_token=abc123&name=test",
                "headers": {},
            }, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["csrf_vulnerable"])
        self.assertEqual(data["bypasses_found"], 0)
        self.assertEqual(data["verdict"], "CSRF protection appears intact")

    async def test_csrf_partial_bypass(self):
        """Test partial CSRF bypass (some variants succeed, some fail)."""
        mock_service = _make_mock_service()

        call_count = [0]

        async def mock_send(**kwargs):
            call_count[0] += 1
            if call_count[0] == 1:
                return {"status": 200, "body": "ok", "headers": {}}  # Baseline
            elif call_count[0] in (2, 3):
                return {"status": 403, "body": "Forbidden", "headers": {}}  # remove_token, empty_token
            else:
                return {"status": 200, "body": "ok", "headers": {}}  # Other variants pass

        mock_client = AsyncMock()
        mock_client.send = mock_send

        with patch('tools_pentest._get_http_client', return_value=mock_client):
            result = await _handle_test_csrf({
                "url": "http://target/api/update",
                "method": "POST",
                "body": '{"csrf_token": "abc"}',
                "headers": {},
            }, mock_service)

        data = _parse_result(result)
        self.assertTrue(data["csrf_vulnerable"])
        self.assertGreater(data["bypasses_found"], 0)
        self.assertLess(data["bypasses_found"], 5)

    async def test_csrf_baseline_failure(self):
        """Test baseline failure returns error."""
        mock_service = _make_mock_service()

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(side_effect=ConnectionError("Connection refused"))

        with patch('tools_pentest._get_http_client', return_value=mock_client):
            result = await _handle_test_csrf({
                "url": "http://target/api/update",
                "method": "POST",
                "body": "test=1",
                "headers": {},
            }, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["success"])
        self.assertIn("Baseline request failed", data["error"])

    async def test_csrf_form_encoded_token_removal(self):
        """Test form-encoded CSRF token removal works correctly."""
        mock_service = _make_mock_service()

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value={
            "status": 200, "body": "ok", "headers": {}
        })

        with patch('tools_pentest._get_http_client', return_value=mock_client):
            result = await _handle_test_csrf({
                "url": "http://target/form",
                "method": "POST",
                "body": "_token=abc123&name=test&email=a@b.com",
                "headers": {"Content-Type": "application/x-www-form-urlencoded"},
                "csrf_token_name": "_token",
                "csrf_token_location": "body",
            }, mock_service)

        data = _parse_result(result)
        # Verify 5 tests were run
        self.assertEqual(len(data["tests"]), 5)

    async def test_csrf_runs_five_tests(self):
        """Test that exactly 5 bypass variants are tested."""
        mock_service = _make_mock_service()

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value={"status": 200, "body": "ok", "headers": {}})

        with patch('tools_pentest._get_http_client', return_value=mock_client):
            result = await _handle_test_csrf({
                "url": "http://target/api/test",
                "method": "POST",
                "body": "data=1",
                "headers": {},
            }, mock_service)

        data = _parse_result(result)
        test_names = [t["test"] for t in data["tests"]]
        self.assertEqual(len(test_names), 5)
        self.assertIn("remove_token", test_names)
        self.assertIn("empty_token", test_names)
        self.assertIn("content_type_switch", test_names)
        self.assertIn("remove_origin_referer", test_names)
        self.assertIn("cross_origin", test_names)


class TestThinkTool(unittest.IsolatedAsyncioTestCase):
    async def test_think_records_reasoning(self):
        """Test think tool records reasoning successfully."""
        mock_service = _make_mock_service()

        result = await _handle_think({
            "reasoning": "The login endpoint at /api/auth/login accepts POST with username and password."
        }, mock_service)

        data = _parse_result(result)
        self.assertTrue(data["success"])
        self.assertGreater(data["char_count"], 0)

    async def test_think_empty_reasoning_returns_error(self):
        """Test think tool rejects empty reasoning."""
        mock_service = _make_mock_service()

        result = await _handle_think({"reasoning": ""}, mock_service)
        data = _parse_result(result)
        self.assertFalse(data["success"])
        self.assertIn("empty", data["error"].lower())

    async def test_think_logs_to_activity_logger(self):
        """Test think tool logs to activity logger."""
        mock_service = _make_mock_service()

        result = await _handle_think({
            "reasoning": "Testing XSS in comment field"
        }, mock_service)

        mock_service.activity_logger.log.assert_called_once()
        call_kwargs = mock_service.activity_logger.log.call_args.kwargs
        self.assertEqual(call_kwargs["event_type"], "think")

    async def test_think_no_activity_logger(self):
        """Test think tool works without activity logger."""
        mock_service = _make_mock_service()
        mock_service.activity_logger = None

        result = await _handle_think({
            "reasoning": "Planning next steps"
        }, mock_service)

        data = _parse_result(result)
        self.assertTrue(data["success"])


if __name__ == "__main__":
    unittest.main()
