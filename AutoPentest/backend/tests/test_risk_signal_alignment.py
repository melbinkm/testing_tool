"""
Test Risk Signal Key Alignment (Fix 1)

Verifies that _RISK_SIGNAL_CARDS keys match ExchangeAnalyzer output
and that auto-persistence works correctly for all severity levels.
"""
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

import unittest
from unittest.mock import AsyncMock, MagicMock, patch
import re


class TestRiskSignalAlignment(unittest.IsolatedAsyncioTestCase):
    """Verify risk signal keys match between ExchangeAnalyzer and service.py"""

    def test_all_analyzer_signals_have_card_mappings(self):
        """Verify every signal type emitted by ExchangeAnalyzer has a card mapping."""
        # Extract all signal types from ExchangeAnalyzer
        analyzer_types = set()
        analyzer_path = os.path.join(os.path.dirname(__file__), '../mcp/modules/lib/exchange_analyzer.py')
        with open(analyzer_path) as f:
            content = f.read()
            for m in re.finditer(r"'type': '(\w+)'", content):
                analyzer_types.add(m.group(1))

        # Extract all keys from _RISK_SIGNAL_CARDS
        from service import AutoPentestService, SafeResult
        card_keys = set(AutoPentestService._RISK_SIGNAL_CARDS.keys())

        # Check alignment
        missing = analyzer_types - card_keys
        self.assertEqual(len(missing), 0,
            f"Missing card mappings for signal types: {missing}")

        # Verify we have all 25 signal types
        self.assertEqual(len(card_keys), 25,
            f"Expected 25 signal types, got {len(card_keys)}")

        print(f"âœ… All {len(analyzer_types)} signal types have card mappings")

    def test_no_extra_card_mappings(self):
        """Verify no extra card mappings exist that don't match analyzer output."""
        # Extract all signal types from ExchangeAnalyzer
        analyzer_types = set()
        analyzer_path = os.path.join(os.path.dirname(__file__), '../mcp/modules/lib/exchange_analyzer.py')
        with open(analyzer_path) as f:
            content = f.read()
            for m in re.finditer(r"'type': '(\w+)'", content):
                analyzer_types.add(m.group(1))

        # Extract all keys from _RISK_SIGNAL_CARDS
        from service import AutoPentestService, SafeResult
        card_keys = set(AutoPentestService._RISK_SIGNAL_CARDS.keys())

        # Check for extras
        extra = card_keys - analyzer_types
        self.assertEqual(len(extra), 0,
            f"Extra card mappings not emitted by analyzer: {extra}")

    async def test_auto_persist_high_severity(self):
        """Verify HIGH severity signals are auto-persisted."""
        from service import AutoPentestService, SafeResult, SafeResult

        # Create service
        service = AutoPentestService()
        service.current_assessment_id = 123

        # Mock safe_add_card to return SafeResult
        service.safe_add_card = AsyncMock(return_value=SafeResult(ok=True, data={"id": "finding-1"}, skipped=False))

        # Test HIGH severity signal (cors_wildcard)
        risk_signals = [
            {"type": "cors_wildcard", "severity": "high", "detail": "Wildcard CORS detected"}
        ]

        created = await service.auto_persist_risk_signals(risk_signals, "http://test.com")

        # Verify card was created
        self.assertEqual(created, 1)
        service.safe_add_card.assert_called_once()

        # Verify correct card data
        call_kwargs = service.safe_add_card.call_args[1]
        self.assertEqual(call_kwargs["title"], "Wildcard CORS Configuration")
        self.assertEqual(call_kwargs["severity"], "HIGH")  # Normalized to uppercase in service.py
        self.assertEqual(call_kwargs["card_type"], "finding")

    async def test_auto_persist_medium_severity(self):
        """Verify MEDIUM severity signals are auto-persisted."""
        from service import AutoPentestService, SafeResult

        service = AutoPentestService()
        service.current_assessment_id = 123
        service.safe_add_card = AsyncMock(return_value=SafeResult(ok=True, data={"id": "finding-2"}, skipped=False))

        # Test MEDIUM severity signal (cookie_missing_httponly)
        risk_signals = [
            {"type": "cookie_missing_httponly", "severity": "medium", "detail": "Cookie missing HttpOnly"}
        ]

        created = await service.auto_persist_risk_signals(risk_signals, "http://test.com")

        self.assertEqual(created, 1)
        service.safe_add_card.assert_called_once()

        call_kwargs = service.safe_add_card.call_args[1]
        self.assertEqual(call_kwargs["title"], "Insecure Cookie - Missing HttpOnly Flag")
        self.assertEqual(call_kwargs["severity"], "MEDIUM")  # Normalized to uppercase in service.py

    async def test_auto_persist_low_severity(self):
        """Verify LOW severity signals are NOW auto-persisted (Fix 1 change)."""
        from service import AutoPentestService, SafeResult

        service = AutoPentestService()
        service.current_assessment_id = 123
        service.safe_add_card = AsyncMock(return_value=SafeResult(ok=True, data={"id": "finding-3"}, skipped=False))

        # Test LOW severity signal (sensitive_comment)
        risk_signals = [
            {"type": "sensitive_comment", "severity": "low", "detail": "Password in comment"}
        ]

        created = await service.auto_persist_risk_signals(risk_signals, "http://test.com")

        # CRITICAL: Low severity should NOW be persisted (was filtered before Fix 1)
        self.assertEqual(created, 1, "LOW severity signals should be persisted after Fix 1")
        service.safe_add_card.assert_called_once()

        call_kwargs = service.safe_add_card.call_args[1]
        self.assertEqual(call_kwargs["title"], "Sensitive Information in HTML Comments")
        self.assertEqual(call_kwargs["severity"], "LOW")  # Normalized to uppercase in service.py

    async def test_auto_persist_info_severity_filtered(self):
        """Verify INFO severity signals are NOT auto-persisted."""
        from service import AutoPentestService, SafeResult

        service = AutoPentestService()
        service.current_assessment_id = 123
        service.safe_add_card = AsyncMock(return_value=SafeResult(ok=True, data={"id": "finding-x"}, skipped=False))

        # Test INFO severity signal (version_disclosure)
        risk_signals = [
            {"type": "version_disclosure", "severity": "info", "detail": "nginx/1.18.0"}
        ]

        created = await service.auto_persist_risk_signals(risk_signals, "http://test.com")

        # INFO severity should be filtered out
        self.assertEqual(created, 0)
        service.safe_add_card.assert_not_called()

    async def test_auto_persist_deduplicates_by_type(self):
        """Verify auto_persist deduplicates signals by type within a single call."""
        from service import AutoPentestService, SafeResult

        service = AutoPentestService()
        service.current_assessment_id = 123
        service.safe_add_card = AsyncMock(return_value=SafeResult(ok=True, data={"id": "finding-4"}, skipped=False))

        # Two signals of the same type
        risk_signals = [
            {"type": "missing_csp", "severity": "medium", "detail": "No CSP header"},
            {"type": "missing_csp", "severity": "medium", "detail": "No CSP header (duplicate)"}
        ]

        created = await service.auto_persist_risk_signals(risk_signals, "http://test.com")

        # Should only create 1 card (deduplicated)
        self.assertEqual(created, 1)
        self.assertEqual(service.safe_add_card.call_count, 1)

    async def test_auto_persist_skips_if_finding_exists(self):
        """Verify auto_persist skips creation if finding already exists."""
        from service import AutoPentestService, SafeResult

        service = AutoPentestService()
        service.current_assessment_id = 123
        # Simulate safe_add_card returning skipped result (card already exists)
        service.safe_add_card = AsyncMock(return_value=SafeResult(ok=True, skipped=True, reason="duplicate"))

        risk_signals = [
            {"type": "missing_hsts", "severity": "medium", "detail": "No HSTS"}
        ]

        created = await service.auto_persist_risk_signals(risk_signals, "http://test.com")

        # Should return 0 because card already exists (safe_add_card returned None)
        self.assertEqual(created, 0)

    async def test_auto_persist_multiple_different_types(self):
        """Verify auto_persist creates cards for multiple different signal types."""
        from service import AutoPentestService, SafeResult

        service = AutoPentestService()
        service.current_assessment_id = 123
        service.safe_add_card = AsyncMock(return_value=SafeResult(ok=True, data={"id": "finding-x"}, skipped=False))

        # 4 different signals: high, medium, low, info
        risk_signals = [
            {"type": "template_syntax", "severity": "high", "detail": "SSTI detected"},
            {"type": "missing_csrf_token", "severity": "medium", "detail": "No CSRF"},
            {"type": "cookie_missing_samesite", "severity": "low", "detail": "No SameSite"},
            {"type": "jwt_detected", "severity": "info", "detail": "JWT in auth header"}
        ]

        created = await service.auto_persist_risk_signals(risk_signals, "http://test.com")

        # Should create 3 cards (high, medium, low) but NOT info
        self.assertEqual(created, 3)
        self.assertEqual(service.safe_add_card.call_count, 3)

    def test_card_mapping_has_correct_format(self):
        """Verify all card mappings have correct format (title, severity, category, description, recommendation, cvss_vector, attack_scenario)."""
        from service import AutoPentestService, SafeResult

        for sig_type, card_info in AutoPentestService._RISK_SIGNAL_CARDS.items():
            # Verify tuple format
            self.assertIsInstance(card_info, tuple, f"Card info for {sig_type} must be tuple")
            self.assertEqual(len(card_info), 7, f"Card info for {sig_type} must have 7 elements")

            title, severity, category, description, recommendation, cvss_vector, attack_scenario = card_info

            # Verify types
            self.assertIsInstance(title, str, f"Title for {sig_type} must be string")
            self.assertIsInstance(severity, str, f"Severity for {sig_type} must be string")
            self.assertIsInstance(category, str, f"Category for {sig_type} must be string")
            self.assertIsInstance(cvss_vector, str, f"CVSS vector for {sig_type} must be string")
            self.assertIsInstance(attack_scenario, str, f"Attack scenario for {sig_type} must be string")
            self.assertIsInstance(description, str, f"Description for {sig_type} must be string")
            self.assertIsInstance(recommendation, str, f"Recommendation for {sig_type} must be string")

            # Verify severity is valid
            self.assertIn(severity, ["high", "medium", "low", "info"],
                f"Invalid severity '{severity}' for {sig_type}")

            # Verify description and recommendation are meaningful (not empty)
            self.assertGreater(len(description), 20, f"Description for {sig_type} too short")
            self.assertGreater(len(recommendation), 10, f"Recommendation for {sig_type} too short")

            # Verify title is not empty
            self.assertGreater(len(title), 0, f"Title for {sig_type} is empty")


if __name__ == '__main__':
    unittest.main()
