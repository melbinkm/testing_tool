"""
Test Wave 6 dev-beta: WebSocket, JS Instrumentation, Multi-Tab browser tools.

Tests for 8 new browser tools added to tools_browser.py:
  - browser_ws_connect, browser_ws_send, browser_ws_listen
  - browser_instrument_dom, browser_get_dom_mutations
  - browser_new_tab, browser_switch_tab
  - browser_postmessage_test
"""
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

import json
import unittest
from unittest.mock import AsyncMock, MagicMock, patch, PropertyMock


# ---------------------------------------------------------------------------
# Tool definition tests
# ---------------------------------------------------------------------------

class TestToolDefinitions(unittest.TestCase):
    """Verify tool count and new tools exist."""

    def test_tool_count(self):
        """Total browser tools should be 24."""
        from tools_browser import get_browser_tools
        tools = get_browser_tools()
        self.assertEqual(len(tools), 24)

    def test_new_ws_tools_present(self):
        """WebSocket tools should be in the list."""
        from tools_browser import get_browser_tools
        names = [t.name for t in get_browser_tools()]
        self.assertIn("browser_ws_connect", names)
        self.assertIn("browser_ws_send", names)
        self.assertIn("browser_ws_listen", names)

    def test_new_dom_tools_present(self):
        """DOM instrumentation tools should be in the list."""
        from tools_browser import get_browser_tools
        names = [t.name for t in get_browser_tools()]
        self.assertIn("browser_instrument_dom", names)
        self.assertIn("browser_get_dom_mutations", names)

    def test_new_tab_tools_present(self):
        """Multi-tab tools should be in the list."""
        from tools_browser import get_browser_tools
        names = [t.name for t in get_browser_tools()]
        self.assertIn("browser_new_tab", names)
        self.assertIn("browser_switch_tab", names)

    def test_postmessage_tool_present(self):
        """postMessage tool should be in the list."""
        from tools_browser import get_browser_tools
        names = [t.name for t in get_browser_tools()]
        self.assertIn("browser_postmessage_test", names)

    def test_ws_connect_requires_url(self):
        """browser_ws_connect should require url parameter."""
        from tools_browser import get_browser_tools
        tools = {t.name: t for t in get_browser_tools()}
        schema = tools["browser_ws_connect"].inputSchema
        self.assertIn("url", schema.get("required", []))

    def test_ws_send_requires_connection_id_and_message(self):
        """browser_ws_send should require connection_id and message."""
        from tools_browser import get_browser_tools
        tools = {t.name: t for t in get_browser_tools()}
        schema = tools["browser_ws_send"].inputSchema
        self.assertIn("connection_id", schema.get("required", []))
        self.assertIn("message", schema.get("required", []))

    def test_switch_tab_requires_tab_id(self):
        """browser_switch_tab should require tab_id."""
        from tools_browser import get_browser_tools
        tools = {t.name: t for t in get_browser_tools()}
        schema = tools["browser_switch_tab"].inputSchema
        self.assertIn("tab_id", schema.get("required", []))

    def test_postmessage_requires_origin_and_message(self):
        """browser_postmessage_test should require target_origin and message."""
        from tools_browser import get_browser_tools
        tools = {t.name: t for t in get_browser_tools()}
        schema = tools["browser_postmessage_test"].inputSchema
        self.assertIn("target_origin", schema.get("required", []))
        self.assertIn("message", schema.get("required", []))


# ---------------------------------------------------------------------------
# WebSocket handler tests
# ---------------------------------------------------------------------------

class TestWsConnectHandler(unittest.IsolatedAsyncioTestCase):
    """Test browser_ws_connect handler."""

    async def test_ws_connect_missing_url(self):
        """Should return error if url not provided."""
        from tools_browser import _handle_ws_connect
        result = await _handle_ws_connect({})
        text = result[0].text
        self.assertIn("url is required", text)

    async def test_ws_connect_success(self):
        """Should inject JS and return connection_id."""
        from tools_browser import _handle_ws_connect

        mock_page = AsyncMock()
        mock_page.evaluate = AsyncMock(side_effect=["ws_abc", "open"])

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_ws_connect({"url": "ws://example.com/ws"})

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertTrue(data["connection_id"].startswith("ws_"))
        self.assertEqual(data["url"], "ws://example.com/ws")
        self.assertEqual(data["state"], "open")


class TestWsSendHandler(unittest.IsolatedAsyncioTestCase):
    """Test browser_ws_send handler."""

    async def test_ws_send_missing_connection_id(self):
        """Should return error if connection_id not provided."""
        from tools_browser import _handle_ws_send
        result = await _handle_ws_send({"message": "hello"})
        self.assertIn("connection_id is required", result[0].text)

    async def test_ws_send_missing_message(self):
        """Should return error if message not provided."""
        from tools_browser import _handle_ws_send
        result = await _handle_ws_send({"connection_id": "ws_abc"})
        self.assertIn("message is required", result[0].text)

    async def test_ws_send_not_open(self):
        """Should return error if WebSocket not in open state."""
        from tools_browser import _handle_ws_send

        mock_page = AsyncMock()
        mock_page.evaluate = AsyncMock(return_value="closed")

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_ws_send({
                "connection_id": "ws_abc",
                "message": "hello",
            })

        self.assertIn("not open", result[0].text)

    async def test_ws_send_success(self):
        """Should send message and return sent_at."""
        from tools_browser import _handle_ws_send

        mock_page = AsyncMock()
        # First call: state check returns "open", second: send returns timestamp
        mock_page.evaluate = AsyncMock(side_effect=["open", 1707000000000])

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_ws_send({
                "connection_id": "ws_abc",
                "message": "test payload",
            })

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["message_length"], len("test payload"))
        self.assertEqual(data["sent_at"], 1707000000000)


class TestWsListenHandler(unittest.IsolatedAsyncioTestCase):
    """Test browser_ws_listen handler."""

    async def test_ws_listen_missing_connection_id(self):
        """Should return error if connection_id not provided."""
        from tools_browser import _handle_ws_listen
        result = await _handle_ws_listen({})
        self.assertIn("connection_id is required", result[0].text)

    async def test_ws_listen_returns_messages(self):
        """Should poll and return messages."""
        from tools_browser import _handle_ws_listen

        mock_messages = [
            {"data": "response1", "timestamp": 1707000000001},
            {"data": "response2", "timestamp": 1707000000002},
        ]

        mock_page = AsyncMock()
        # First evaluate: messages found, second: clear buffer, third: state
        mock_page.evaluate = AsyncMock(side_effect=[
            mock_messages,  # poll returns messages
            None,           # clear buffer
            "open",         # state check
        ])

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_ws_listen({
                "connection_id": "ws_abc",
                "timeout_ms": 1000,
            })

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["message_count"], 2)
        self.assertEqual(data["messages"][0]["data"], "response1")

    async def test_ws_listen_timeout_empty(self):
        """Should return empty list on timeout."""
        from tools_browser import _handle_ws_listen

        mock_page = AsyncMock()
        # Always returns empty messages, then final state check
        call_count = [0]
        async def mock_eval(js):
            call_count[0] += 1
            if "ws_state" in js or "__ws_state" in js:
                return "open"
            return []
        mock_page.evaluate = mock_eval

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_ws_listen({
                "connection_id": "ws_abc",
                "timeout_ms": 300,  # Short timeout for test
            })

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["message_count"], 0)


# ---------------------------------------------------------------------------
# DOM instrumentation handler tests
# ---------------------------------------------------------------------------

class TestInstrumentDomHandler(unittest.IsolatedAsyncioTestCase):
    """Test browser_instrument_dom handler."""

    async def test_instrument_dom_success(self):
        """Should install MutationObserver and return 'installed'."""
        from tools_browser import _handle_instrument_dom

        mock_page = AsyncMock()
        mock_page.evaluate = AsyncMock(return_value="installed")

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_instrument_dom({})

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["status"], "installed")

    async def test_instrument_dom_already_installed(self):
        """Should return 'already_installed' if called twice."""
        from tools_browser import _handle_instrument_dom

        mock_page = AsyncMock()
        mock_page.evaluate = AsyncMock(return_value="already_installed")

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_instrument_dom({})

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["status"], "already_installed")


class TestGetDomMutationsHandler(unittest.IsolatedAsyncioTestCase):
    """Test browser_get_dom_mutations handler."""

    async def test_get_dom_mutations_empty(self):
        """Should return empty list when no mutations."""
        from tools_browser import _handle_get_dom_mutations

        mock_page = AsyncMock()
        mock_page.evaluate = AsyncMock(return_value=[])

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_get_dom_mutations({})

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["mutation_count"], 0)
        self.assertFalse(data["cleared"])

    async def test_get_dom_mutations_with_data(self):
        """Should return mutation entries."""
        from tools_browser import _handle_get_dom_mutations

        mock_mutations = [
            {"type": "attributes", "target_tag": "DIV", "attribute": "class",
             "old_value": "foo", "new_value": "bar", "timestamp": 1707000000001},
            {"type": "childList", "target_tag": "BODY", "added_nodes": 1,
             "removed_nodes": 0, "timestamp": 1707000000002},
        ]

        mock_page = AsyncMock()
        mock_page.evaluate = AsyncMock(return_value=mock_mutations)

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_get_dom_mutations({})

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["mutation_count"], 2)
        self.assertEqual(data["mutations"][0]["type"], "attributes")
        self.assertEqual(data["mutations"][1]["type"], "childList")

    async def test_get_dom_mutations_clear(self):
        """Should clear mutations when clear=True."""
        from tools_browser import _handle_get_dom_mutations

        mock_page = AsyncMock()
        # First: return mutations, second: clear call
        mock_page.evaluate = AsyncMock(side_effect=[
            [{"type": "attributes", "target_tag": "DIV", "timestamp": 123}],
            None,  # clear call
        ])

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_get_dom_mutations({"clear": True})

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertTrue(data["cleared"])
        # Verify clear was called (second evaluate call)
        self.assertEqual(mock_page.evaluate.call_count, 2)


# ---------------------------------------------------------------------------
# Multi-tab handler tests
# ---------------------------------------------------------------------------

class TestNewTabHandler(unittest.IsolatedAsyncioTestCase):
    """Test browser_new_tab handler."""

    async def test_new_tab_no_url(self):
        """Should open blank tab when no URL provided."""
        from tools_browser import _handle_new_tab

        mock_new_page = AsyncMock()
        mock_new_page.url = "about:blank"

        mock_context = AsyncMock()
        mock_context.new_page = AsyncMock(return_value=mock_new_page)
        mock_context.pages = [MagicMock(), mock_new_page]  # existing + new

        mock_session = MagicMock()
        mock_session.session_id = "test-session"
        mock_session._context = mock_context

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_new_tab({})

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertTrue(data["tab_id"].startswith("tab_"))
        self.assertEqual(data["url"], "about:blank")
        self.assertEqual(data["total_tabs"], 2)

    async def test_new_tab_with_url(self):
        """Should navigate new tab to specified URL."""
        from tools_browser import _handle_new_tab

        mock_new_page = AsyncMock()
        mock_new_page.url = "https://example.com"
        mock_new_page.goto = AsyncMock(return_value=MagicMock(status=200))

        mock_context = AsyncMock()
        mock_context.new_page = AsyncMock(return_value=mock_new_page)
        mock_context.pages = [MagicMock(), mock_new_page]

        mock_session = MagicMock()
        mock_session.session_id = "test-session"
        mock_session._context = mock_context

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_new_tab({"url": "https://example.com"})

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["url"], "https://example.com")
        mock_new_page.goto.assert_called_once()

    async def test_new_tab_no_context(self):
        """Should return error if no browser context."""
        from tools_browser import _handle_new_tab

        mock_session = MagicMock()
        mock_session.session_id = "test-session"
        mock_session._context = None

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_new_tab({})

        self.assertIn("not available", result[0].text)


class TestSwitchTabHandler(unittest.IsolatedAsyncioTestCase):
    """Test browser_switch_tab handler."""

    async def test_switch_tab_missing_tab_id(self):
        """Should return error if tab_id not provided."""
        from tools_browser import _handle_switch_tab
        result = await _handle_switch_tab({})
        self.assertIn("tab_id is required", result[0].text)

    async def test_switch_tab_not_found(self):
        """Should return error if tab_id not in registry."""
        from tools_browser import _handle_switch_tab

        mock_session = MagicMock()
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_switch_tab({"tab_id": "nonexistent"})

        self.assertIn("Tab not found", result[0].text)

    async def test_switch_tab_success(self):
        """Should switch to tab and update session page."""
        import tools_browser
        from tools_browser import _handle_switch_tab

        mock_target_page = AsyncMock()
        mock_target_page.url = "https://example.com/tab2"
        mock_target_page.bring_to_front = AsyncMock()

        mock_context = MagicMock()
        mock_context.pages = [MagicMock(), mock_target_page]

        mock_session = MagicMock()
        mock_session.session_id = "switch-session"
        mock_session._context = mock_context

        # Register a tab for this session
        tools_browser._tab_registry["switch-session"] = {"tab_99": 1}

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_switch_tab({"tab_id": "tab_99"})

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["url"], "https://example.com/tab2")
        mock_target_page.bring_to_front.assert_called_once()
        # Verify session._page was updated
        self.assertEqual(mock_session._page, mock_target_page)

        # Cleanup
        del tools_browser._tab_registry["switch-session"]


# ---------------------------------------------------------------------------
# postMessage handler tests
# ---------------------------------------------------------------------------

class TestPostMessageHandler(unittest.IsolatedAsyncioTestCase):
    """Test browser_postmessage_test handler."""

    async def test_postmessage_missing_origin(self):
        """Should return error if target_origin not provided."""
        from tools_browser import _handle_postmessage_test
        result = await _handle_postmessage_test({"message": "test"})
        self.assertIn("target_origin is required", result[0].text)

    async def test_postmessage_missing_message(self):
        """Should return error if message not provided."""
        from tools_browser import _handle_postmessage_test
        result = await _handle_postmessage_test({"target_origin": "*"})
        self.assertIn("message is required", result[0].text)

    async def test_postmessage_wildcard_indicator(self):
        """Should flag wildcard origin as vulnerability indicator."""
        from tools_browser import _handle_postmessage_test

        mock_page = AsyncMock()
        # Calls: install listener, send message, collect responses, cleanup
        mock_page.evaluate = AsyncMock(side_effect=[
            True,   # install listener
            True,   # send message
            [],     # no responses
            None,   # cleanup
        ])

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_postmessage_test({
                "target_origin": "*",
                "message": "test",
            })

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertIn("wildcard_origin_used", data["vulnerability_indicators"])

    async def test_postmessage_sensitive_data_detected(self):
        """Should flag sensitive data in postMessage responses."""
        from tools_browser import _handle_postmessage_test

        mock_page = AsyncMock()
        mock_page.evaluate = AsyncMock(side_effect=[
            True,   # install listener
            True,   # send message
            [{"data": '{"token":"abc123"}', "origin": "https://example.com", "timestamp": 123}],
            None,   # cleanup
        ])

        mock_session = MagicMock()
        mock_session.get_page.return_value = mock_page
        mock_session.session_id = "test-session"

        with patch("tools_browser._require_active_session", return_value=mock_session):
            result = await _handle_postmessage_test({
                "target_origin": "https://example.com",
                "message": "get_token",
            })

        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertIn("sensitive_data_in_response", data["vulnerability_indicators"])
        self.assertEqual(data["response_count"], 1)


# ---------------------------------------------------------------------------
# Dispatch tests
# ---------------------------------------------------------------------------

class TestHandlerDispatch(unittest.IsolatedAsyncioTestCase):
    """Test that handler dispatch routes to correct handlers."""

    async def test_dispatch_unknown_tool(self):
        """Unknown tool should return error."""
        from tools_browser import handle_browser_tool

        mock_mcp = MagicMock()
        mock_mcp.current_assessment_id = None

        with patch("tools_browser._get_session_manager"):
            result = await handle_browser_tool("browser_nonexistent", {}, mock_mcp)

        self.assertIn("Unknown browser tool", result[0].text)

    async def test_dispatch_ws_connect(self):
        """browser_ws_connect should dispatch to _handle_ws_connect."""
        from tools_browser import handle_browser_tool

        mock_mcp = MagicMock()
        mock_mcp.current_assessment_id = None

        with patch("tools_browser._get_session_manager"), \
             patch("tools_browser._handle_ws_connect", new_callable=AsyncMock, return_value=[]) as mock_handler:
            await handle_browser_tool("browser_ws_connect", {"url": "ws://x"}, mock_mcp)
            mock_handler.assert_called_once_with({"url": "ws://x"})

    async def test_dispatch_instrument_dom(self):
        """browser_instrument_dom should dispatch to _handle_instrument_dom."""
        from tools_browser import handle_browser_tool

        mock_mcp = MagicMock()
        mock_mcp.current_assessment_id = None

        with patch("tools_browser._get_session_manager"), \
             patch("tools_browser._handle_instrument_dom", new_callable=AsyncMock, return_value=[]) as mock_handler:
            await handle_browser_tool("browser_instrument_dom", {}, mock_mcp)
            mock_handler.assert_called_once_with({})

    async def test_dispatch_new_tab(self):
        """browser_new_tab should dispatch to _handle_new_tab."""
        from tools_browser import handle_browser_tool

        mock_mcp = MagicMock()
        mock_mcp.current_assessment_id = None

        with patch("tools_browser._get_session_manager"), \
             patch("tools_browser._handle_new_tab", new_callable=AsyncMock, return_value=[]) as mock_handler:
            await handle_browser_tool("browser_new_tab", {}, mock_mcp)
            mock_handler.assert_called_once_with({})

    async def test_dispatch_postmessage(self):
        """browser_postmessage_test should dispatch to _handle_postmessage_test."""
        from tools_browser import handle_browser_tool

        mock_mcp = MagicMock()
        mock_mcp.current_assessment_id = None

        with patch("tools_browser._get_session_manager"), \
             patch("tools_browser._handle_postmessage_test", new_callable=AsyncMock, return_value=[]) as mock_handler:
            await handle_browser_tool("browser_postmessage_test", {"target_origin": "*", "message": "x"}, mock_mcp)
            mock_handler.assert_called_once_with({"target_origin": "*", "message": "x"})


if __name__ == '__main__':
    unittest.main()
