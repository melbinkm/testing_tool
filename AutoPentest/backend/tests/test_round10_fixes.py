"""
Test suite for Deep Audit Round 10 bug fixes.

Verifies 7 critical/high/medium bugs fixed:
1. db.search() → db.query() in tools_sequences.py
2. IdentityStore.add_identity() method added
3. mcp_service.session → mcp_service.http_client
4. Credential API response format (.get("credentials", []))
5. where_parts[:-0] → where_parts in LIKE fallback
6. JSONB path operator fix in scope_loader_db
7. date_trunc interval default fix
"""

import unittest
import asyncio
from pathlib import Path


class TestRound10SourceVerification(unittest.TestCase):
    """Verify all 7 fixes are present in source code."""

    def test_fix1_db_query_not_search(self):
        """Bug 1: db.search() should be db.query()"""
        path = Path(__file__).parent.parent / "mcp" / "modules" / "tools_sequences.py"
        content = path.read_text()

        # Should contain db.query("identities", limit=100)
        self.assertIn('db.query("identities", limit=100)', content)

        # Should NOT contain db.search("identities"
        self.assertNotIn('db.search("identities"', content)

    def test_fix2_add_identity_method_exists(self):
        """Bug 2: IdentityStore should have add_identity() method"""
        path = Path(__file__).parent.parent / "mcp" / "modules" / "lib" / "identity_store.py"
        content = path.read_text()

        # Should define the add_identity method
        self.assertIn("def add_identity(self, identity: Identity)", content)
        self.assertIn("self._identities[identity.id] = identity", content)

    def test_fix3_http_client_not_session(self):
        """Bug 3: mcp_service.http_client not .session"""
        path = Path(__file__).parent.parent / "mcp" / "modules" / "tools_sequences.py"
        content = path.read_text()

        # Should contain mcp_service.http_client
        self.assertIn("mcp_service.http_client", content)

        # Should NOT contain mcp_service.session (at least in credential lookup context)
        lines = content.split('\n')
        for i, line in enumerate(lines):
            if 'mcp_service.session' in line and i > 700:  # Around line 732
                self.fail(f"Found mcp_service.session on line {i+1} (should be http_client)")

    def test_fix4_credential_api_response_parsing(self):
        """Bug 4: Should use .get("credentials", [])"""
        path = Path(__file__).parent.parent / "mcp" / "modules" / "tools_sequences.py"
        content = path.read_text()

        # Should contain resp.json().get("credentials", [])
        self.assertIn('resp.json().get("credentials", [])', content)

    def test_fix5_like_fallback_where_parts(self):
        """Bug 5: where_parts not where_parts[:-0]"""
        path = Path(__file__).parent.parent / "mcp" / "modules" / "lib" / "world_model_db.py"
        content = path.read_text()

        # Should NOT contain where_parts[:-0]
        self.assertNotIn("where_parts[:-0]", content)

        # Should contain the correct _like_search call
        self.assertIn("_like_search(query, where_parts, params[:-1]", content)

    def test_fix6_jsonb_path_operator(self):
        """Bug 6: JSONB path should use -> then ->>"""
        path = Path(__file__).parent.parent / "mcp" / "modules" / "lib" / "scope_loader_db.py"
        content = path.read_text()

        # Should contain scope_data->'engagement'->>'id'
        self.assertIn("scope_data->'engagement'->>'id'", content)

        # Should NOT contain scope_data->>'engagement'->>'id'
        self.assertNotIn("scope_data->>'engagement'->>'id'", content)

    def test_fix7_date_trunc_interval_default(self):
        """Bug 7: date_trunc interval default should be 'hour' not '1 hour'"""
        path = Path(__file__).parent.parent / "api" / "activity_log.py"
        content = path.read_text()

        # Should contain Query("hour"
        self.assertIn('Query("hour"', content)

        # Should NOT contain Query("1 hour"
        self.assertNotIn('Query("1 hour"', content)


class TestIdentityStoreAddIdentity(unittest.TestCase):
    """Test the new add_identity() method."""

    def test_add_identity_method_works(self):
        """Verify add_identity() correctly adds identities to store"""
        import sys
        sys.path.insert(0, str(Path(__file__).parent.parent / "mcp" / "modules"))
        from lib.identity_store import IdentityStore, Identity

        store = IdentityStore()
        identity = Identity(
            id="test-user-1",
            type="bearer",
            scope="https://api.example.com",
            auth_header="Bearer test-token-123",
            cookies={"session": "abc123"},
            should_have_access=True,
            description="Test user"
        )

        # Add identity
        store.add_identity(identity)

        # Verify it was added
        retrieved = store.get_identity("test-user-1")
        self.assertIsNotNone(retrieved)
        self.assertEqual(retrieved.id, "test-user-1")
        self.assertEqual(retrieved.type, "bearer")
        self.assertEqual(retrieved.auth_header, "Bearer test-token-123")

    def test_add_identity_overwrites_existing(self):
        """Verify add_identity() overwrites if ID already exists"""
        import sys
        sys.path.insert(0, str(Path(__file__).parent.parent / "mcp" / "modules"))
        from lib.identity_store import IdentityStore, Identity

        store = IdentityStore()

        # Add first identity
        identity1 = Identity(
            id="user-1",
            type="bearer",
            scope="scope1",
            auth_header="Bearer token1",
            cookies={},
            should_have_access=True,
            description="First"
        )
        store.add_identity(identity1)

        # Add second identity with same ID
        identity2 = Identity(
            id="user-1",
            type="basic",
            scope="scope2",
            auth_header="Basic creds",
            cookies={},
            should_have_access=False,
            description="Second"
        )
        store.add_identity(identity2)

        # Verify second overwrote first
        retrieved = store.get_identity("user-1")
        self.assertEqual(retrieved.type, "basic")
        self.assertEqual(retrieved.description, "Second")


class TestIdentityStoreLoadsFromQuery(unittest.IsolatedAsyncioTestCase):
    """Test that _get_identity_store uses db.query() not db.search()"""

    async def test_identity_store_uses_query_method(self):
        """Verify _get_identity_store calls db.query() not db.search()"""
        # This is implicitly tested by Fix 1 source verification
        # Here we just verify the method signature exists
        import sys
        sys.path.insert(0, str(Path(__file__).parent.parent / "mcp" / "modules"))
        from lib.world_model_db import WorldModelDatabase

        # Verify query() method exists
        self.assertTrue(hasattr(WorldModelDatabase, 'query'))

        # Verify search() does NOT exist
        self.assertFalse(hasattr(WorldModelDatabase, 'search'))


class TestCredentialReuseUsesHttpClient(unittest.TestCase):
    """Test that sequence_credential_reuse uses http_client not session"""

    def test_http_client_attribute_check(self):
        """Verify the code checks for http_client attribute"""
        path = Path(__file__).parent.parent / "mcp" / "modules" / "tools_sequences.py"
        content = path.read_text()

        # Find the credential lookup section
        lines = content.split('\n')
        found_http_client_check = False

        for i in range(len(lines) - 1):
            if 'mcp_service.http_client' in lines[i]:
                # Check next line has the .get() call
                if 'await mcp_service.http_client.get' in lines[i+1]:
                    found_http_client_check = True
                    break

        self.assertTrue(found_http_client_check,
                       "Did not find mcp_service.http_client check followed by .get() call")


class TestCredentialApiResponseParsing(unittest.TestCase):
    """Test that credential API response is parsed correctly"""

    def test_credentials_list_extraction(self):
        """Verify .get("credentials", []) extracts the list correctly"""
        # Mock API response structure
        mock_response = {
            "credentials": [
                {"id": "cred-1", "name": "admin", "type": "bearer", "token": "abc123"},
                {"id": "cred-2", "name": "user", "type": "basic", "username": "user", "password": "pass"}
            ],
            "total": 2,
            "by_type": {"bearer": 1, "basic": 1}
        }

        # Verify extraction works
        creds = mock_response.get("credentials", [])
        self.assertEqual(len(creds), 2)
        self.assertEqual(creds[0]["id"], "cred-1")

        # Verify wrong approach would fail
        wrong_creds = list(mock_response)  # Iterating dict directly
        self.assertEqual(wrong_creds, ["credentials", "total", "by_type"])


class TestLikeFallbackParams(unittest.TestCase):
    """Test that LIKE fallback passes params correctly"""

    def test_where_parts_passed_correctly(self):
        """Verify where_parts is passed without [:-0] slicing"""
        path = Path(__file__).parent.parent / "mcp" / "modules" / "lib" / "world_model_db.py"
        content = path.read_text()

        # Find the _like_search call
        lines = content.split('\n')
        like_search_line = None

        for i, line in enumerate(lines):
            if '_like_search(query,' in line:
                like_search_line = line
                break

        self.assertIsNotNone(like_search_line, "Could not find _like_search call")

        # Verify it's "where_parts," not "where_parts[:-0],"
        self.assertIn("where_parts,", like_search_line)
        self.assertNotIn("where_parts[:-0]", like_search_line)

    def test_list_slicing_behavior(self):
        """Verify [:-0] behavior vs no slicing"""
        test_list = ["a", "b", "c", "d"]

        # [:-0] returns empty list (not full list as I initially thought!)
        self.assertEqual(test_list[:-0], [])

        # [:-1] removes last element (as intended for params)
        self.assertEqual(test_list[:-1], ["a", "b", "c"])

        # No slicing also returns full list (correct fix)
        self.assertEqual(test_list, ["a", "b", "c", "d"])


class TestJsonbPathOperator(unittest.TestCase):
    """Test JSONB path operator fix"""

    def test_jsonb_extraction_syntax(self):
        """Verify -> used for intermediate traversal, ->> for final extraction"""
        path = Path(__file__).parent.parent / "mcp" / "modules" / "lib" / "scope_loader_db.py"
        content = path.read_text()

        # Should have the correct pattern: ->'engagement'->>'id'
        self.assertIn("->'engagement'->>'id'", content)


class TestDateTruncInterval(unittest.TestCase):
    """Test date_trunc interval default fix"""

    def test_interval_default_is_valid_keyword(self):
        """Verify interval default is 'hour' not '1 hour'"""
        path = Path(__file__).parent.parent / "api" / "activity_log.py"
        content = path.read_text()

        # Find the Query parameter definition
        lines = content.split('\n')
        query_line = None

        for line in lines:
            if 'interval:' in line and 'Query(' in line:
                query_line = line
                break

        self.assertIsNotNone(query_line, "Could not find interval Query parameter")

        # Verify it uses "hour" not "1 hour"
        self.assertIn('Query("hour"', query_line)


def run_async_tests():
    """Helper to run async tests with proper event loop"""
    suite = unittest.TestLoader().loadTestsFromTestCase(TestIdentityStoreLoadsFromQuery)
    runner = unittest.TextTestRunner(verbosity=2)
    return runner.run(suite)


if __name__ == "__main__":
    # Run all tests
    unittest.main(verbosity=2)
