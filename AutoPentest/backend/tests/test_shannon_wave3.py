"""Tests for Shannon Wave 3 features: VulnChecklist, PoC generator, Audit log, Dataflow tracer."""
import sys
import types
import unittest
import json
import re
from unittest.mock import AsyncMock, MagicMock, patch

sys.path.insert(0, 'mcp/modules')

# Mock mcp.types to avoid import errors on system Python
mcp_mod = types.ModuleType('mcp')
mcp_types = types.ModuleType('mcp.types')
mcp_types.Tool = type('Tool', (), {'__init__': lambda s, **k: None})
mcp_types.TextContent = type('TextContent', (), {'__init__': lambda s, **k: None})
sys.modules.setdefault('mcp', mcp_mod)
sys.modules.setdefault('mcp.types', mcp_types)


class TestVulnChecklistInit(unittest.TestCase):
    """Test vuln_checklist.py: VulnChecklist initialization and spec registry."""

    def test_has_at_least_42_specs(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        self.assertGreaterEqual(cl.get_spec_count(), 42)

    def test_all_specs_have_required_fields(self):
        from lib.vuln_checklist import VulnChecklist, VulnTestSpec
        cl = VulnChecklist()
        for spec in cl.get_all_specs():
            self.assertIsInstance(spec, VulnTestSpec)
            self.assertTrue(spec.id)
            self.assertTrue(spec.name)
            self.assertTrue(spec.category)
            self.assertTrue(spec.tool_name)
            self.assertIsInstance(spec.severity_range, tuple)
            self.assertEqual(len(spec.severity_range), 2)

    def test_get_spec_by_id(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        sqli = cl.get_spec_by_id("sqli_error")
        self.assertIsNotNone(sqli)
        self.assertEqual(sqli.category, "injection")

    def test_get_spec_by_id_returns_none_for_unknown(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        self.assertIsNone(cl.get_spec_by_id("nonexistent"))

    def test_categories_include_all_expected(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        categories = cl.get_categories()
        for expected in ["injection", "auth", "config", "info_leak"]:
            self.assertIn(expected, categories)

    def test_get_specs_by_category(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        injection_specs = cl.get_specs_by_category("injection")
        self.assertGreater(len(injection_specs), 0)
        for spec in injection_specs:
            self.assertEqual(spec.category, "injection")


class TestVulnChecklistApplicability(unittest.TestCase):
    """Test applicability predicates on endpoints."""

    def test_sqli_applicable_to_endpoint_with_params(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        endpoint = {"method": "GET", "parameters": [{"name": "id", "type": "string"}]}
        applicable = cl.get_applicable_specs(endpoint)
        ids = [s.id for s in applicable]
        self.assertIn("sqli_error", ids)

    def test_xss_reflected_needs_html_and_params(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        # JSON endpoint should skip HTML-only specs
        endpoint = {"method": "GET", "parameters": [{"name": "q"}], "content_type": "application/json"}
        applicable = cl.get_applicable_specs(endpoint)
        ids = [s.id for s in applicable]
        self.assertNotIn("xss_reflected", ids)

    def test_html_endpoint_gets_xss_specs(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        endpoint = {"method": "GET", "parameters": [{"name": "q"}], "content_type": "text/html"}
        applicable = cl.get_applicable_specs(endpoint)
        ids = [s.id for s in applicable]
        self.assertIn("xss_reflected", ids)

    def test_csrf_applicable_to_state_changing(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        endpoint = {"method": "POST", "parameters": []}
        applicable = cl.get_applicable_specs(endpoint)
        ids = [s.id for s in applicable]
        self.assertIn("csrf", ids)

    def test_csrf_not_applicable_to_get(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        endpoint = {"method": "GET", "parameters": []}
        applicable = cl.get_applicable_specs(endpoint)
        ids = [s.id for s in applicable]
        self.assertNotIn("csrf", ids)

    def test_nosql_detection_patterns(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        nosql = cl.get_spec_by_id("nosql_injection")
        self.assertIsNotNone(nosql)
        patterns = nosql.detection_patterns
        matched = any(re.search(p, "MongoError: query failed") for p in patterns)
        self.assertTrue(matched, "MongoError pattern should match")

    def test_modern_xss_patterns(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        xss = cl.get_spec_by_id("xss_reflected")
        patterns = xss.detection_patterns
        matched = any(re.search(p, '<svg onload=alert(1)>') for p in patterns)
        self.assertTrue(matched, "<svg onload> should be detected as XSS")


class TestVulnChecklistToolMap(unittest.TestCase):
    """Test tool_map backward compatibility."""

    def test_build_tool_map(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        tool_map = cl.build_tool_map()
        self.assertIsInstance(tool_map, dict)
        self.assertGreaterEqual(len(tool_map), 42)
        for spec_id, config in tool_map.items():
            self.assertIn("tool_name", config)
            self.assertIn("base_args", config)
            self.assertIn("parameter_bound", config)

    def test_summary_statistics(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        summary = cl.get_summary()
        self.assertIn("total_specs", summary)
        self.assertIn("categories", summary)
        self.assertGreaterEqual(summary["total_specs"], 42)

    def test_to_dict_serialization(self):
        from lib.vuln_checklist import VulnChecklist
        cl = VulnChecklist()
        spec = cl.get_spec_by_id("sqli_error")
        d = spec.to_dict()
        self.assertEqual(d["id"], "sqli_error")
        self.assertEqual(d["category"], "injection")
        self.assertIn("references", d)

    def test_singleton_instance(self):
        from lib.vuln_checklist import get_vuln_checklist
        c1 = get_vuln_checklist()
        c2 = get_vuln_checklist()
        self.assertIs(c1, c2)


class TestPoCGenerator(unittest.TestCase):
    """Test poc_generator.py: PoC generation for various vulnerability types."""

    def setUp(self):
        from lib.poc_generator import PoCGenerator
        self.gen = PoCGenerator()

    def test_sqli_poc(self):
        result = self.gen.generate({
            "vuln_type": "sqli",
            "url": "http://target.com/api/users",
            "parameter": "id",
            "payload": "' OR 1=1 --",
        })
        self.assertEqual(result["poc_type"], "sqli")
        self.assertIn("python", result["language"])
        self.assertIn("curl", result["curl_command"])
        self.assertIn("script", result)

    def test_xss_poc(self):
        result = self.gen.generate({
            "vuln_type": "xss",
            "url": "http://target.com/search",
            "parameter": "q",
            "payload": "<script>alert(1)</script>",
        })
        self.assertEqual(result["poc_type"], "xss")
        self.assertIn("browser_url", result)

    def test_idor_poc(self):
        result = self.gen.generate({
            "vuln_type": "idor",
            "url": "http://target.com/api/users/1",
            "method": "GET",
        })
        self.assertEqual(result["poc_type"], "idor")

    def test_jwt_manipulation_poc(self):
        result = self.gen.generate({
            "vuln_type": "jwt_manipulation",
            "url": "http://target.com/api/admin",
        })
        self.assertEqual(result["poc_type"], "jwt_manipulation")
        # The curl command uses a base64-encoded JWT header with alg:none,
        # not the literal text "alg:none". eyJhbGciOiJub25l decodes to {"alg":"none"...
        self.assertIn("eyJhbGciOiJub25l", result["curl_command"])

    def test_auth_bypass_poc(self):
        result = self.gen.generate({
            "vuln_type": "auth_bypass",
            "url": "http://target.com/admin",
        })
        self.assertEqual(result["poc_type"], "auth_bypass")

    def test_csrf_poc(self):
        result = self.gen.generate({
            "vuln_type": "csrf",
            "url": "http://target.com/api/action",
            "method": "POST",
            "payload": "action=delete&id=1",
        })
        self.assertEqual(result["poc_type"], "csrf")
        self.assertEqual(result["language"], "html")
        self.assertIn("form", result["script"].lower())

    def test_ssti_poc(self):
        result = self.gen.generate({
            "vuln_type": "ssti",
            "url": "http://target.com/render",
            "parameter": "name",
        })
        self.assertEqual(result["poc_type"], "ssti")

    def test_clickjacking_poc(self):
        result = self.gen.generate({
            "vuln_type": "clickjacking",
            "url": "http://target.com/settings",
        })
        self.assertEqual(result["poc_type"], "clickjacking")
        self.assertEqual(result["language"], "html")
        self.assertIn("iframe", result["script"])

    def test_race_condition_poc(self):
        result = self.gen.generate({
            "vuln_type": "race_condition",
            "url": "http://target.com/api/transfer",
            "method": "POST",
        })
        self.assertEqual(result["poc_type"], "race_condition")
        self.assertIn("bash_script", result)

    def test_generic_poc_for_unknown_type(self):
        result = self.gen.generate({
            "vuln_type": "some_unknown_type",
            "url": "http://target.com/endpoint",
        })
        self.assertEqual(result["poc_type"], "generic")

    def test_auto_detect_sqli_from_title(self):
        result = self.gen.generate({
            "title": "SQL Injection in /api/users",
            "url": "http://target.com/api/users",
        })
        self.assertEqual(result["poc_type"], "sqli")

    def test_ssrf_poc(self):
        result = self.gen.generate({
            "vuln_type": "ssrf",
            "url": "http://target.com/fetch",
            "parameter": "url",
        })
        self.assertEqual(result["poc_type"], "ssrf")
        self.assertIn("127.0.0.1", result["script"])

    def test_deserialization_poc(self):
        result = self.gen.generate({
            "vuln_type": "insecure_deserialization",
            "url": "http://target.com/api/data",
            "parameter": "data",
        })
        self.assertEqual(result["poc_type"], "insecure_deserialization")

    def test_all_poc_types_have_safety_level(self):
        """Every PoC must specify a safety_level."""
        types_to_test = ["sqli", "xss", "idor", "ssrf", "lfi", "cmdi",
                         "jwt_manipulation", "auth_bypass", "csrf", "ssti",
                         "clickjacking", "race_condition", "generic"]
        for vt in types_to_test:
            result = self.gen.generate({"vuln_type": vt, "url": "http://t.com/x"})
            self.assertIn("safety_level", result, f"Missing safety_level for {vt}")
            self.assertIn(result["safety_level"], ("safe", "caution"), f"Bad safety_level for {vt}")


class TestActivityLogger(unittest.IsolatedAsyncioTestCase):
    """Test activity_logger.py: structured logging to DB and files."""

    async def test_log_tool_execution(self):
        from lib.activity_logger import ActivityLogger
        mock_pool = MagicMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__ = AsyncMock(return_value=mock_conn)
        mock_pool.acquire.return_value.__aexit__ = AsyncMock(return_value=False)

        logger = ActivityLogger(assessment_id=1, db_pool=mock_pool)
        await logger.log_tool_execution("inject_payload", {"url": "http://t.com"}, "completed")
        mock_conn.execute.assert_called_once()
        args = mock_conn.execute.call_args[0]
        self.assertIn("INSERT INTO activity_log", args[0])

    async def test_log_phase_transition(self):
        from lib.activity_logger import ActivityLogger
        mock_pool = MagicMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__ = AsyncMock(return_value=mock_conn)
        mock_pool.acquire.return_value.__aexit__ = AsyncMock(return_value=False)

        logger = ActivityLogger(assessment_id=1, db_pool=mock_pool)
        await logger.log_phase_transition(from_phase=1, to_phase=2, reason="gate passed")
        mock_conn.execute.assert_called_once()

    async def test_log_finding_created(self):
        from lib.activity_logger import ActivityLogger
        mock_pool = MagicMock()
        mock_conn = AsyncMock()
        mock_pool.acquire.return_value.__aenter__ = AsyncMock(return_value=mock_conn)
        mock_pool.acquire.return_value.__aexit__ = AsyncMock(return_value=False)

        logger = ActivityLogger(assessment_id=1, db_pool=mock_pool)
        await logger.log_finding_created(42, "XSS in /search", "high", "tool", "inject_payload")
        args = mock_conn.execute.call_args[0]
        self.assertIn("finding_created", args[2])

    async def test_log_db_failure_does_not_raise(self):
        from lib.activity_logger import ActivityLogger
        mock_pool = MagicMock()
        mock_conn = AsyncMock()
        mock_conn.execute.side_effect = Exception("DB down")
        mock_pool.acquire.return_value.__aenter__ = AsyncMock(return_value=mock_conn)
        mock_pool.acquire.return_value.__aexit__ = AsyncMock(return_value=False)

        logger = ActivityLogger(assessment_id=1, db_pool=mock_pool)
        # Should not raise even though DB is down
        await logger.log_tool_execution("test", {}, "completed")


class TestDataflowTracer(unittest.TestCase):
    """Test dataflow_tracer.py: source-to-sink tracing."""

    def test_trace_finds_source_and_sink(self):
        from lib.dataflow_tracer import trace_dataflow, DataFlowVerdict
        findings = [{
            "content": "user_input = request.args.get('id'); cursor.execute(f'SELECT * FROM users WHERE id={user_input}')",
            "metadata": {"file": "app.py", "line": 10, "vuln_class": "sql_injection"},
        }]
        traces = trace_dataflow(findings)
        self.assertEqual(len(traces), 1)
        trace = traces[0]
        self.assertIsNotNone(trace.source)
        self.assertIsNotNone(trace.sink)
        self.assertEqual(trace.verdict, DataFlowVerdict.VULNERABLE)

    def test_trace_with_sanitization_is_safe(self):
        from lib.dataflow_tracer import trace_dataflow, DataFlowVerdict
        findings = [{
            "content": "user_input = request.args.get('id'); safe = parameterize(user_input); cursor.execute(safe)",
            "metadata": {"file": "app.py", "line": 10, "vuln_class": "sql_injection"},
        }]
        traces = trace_dataflow(findings)
        self.assertEqual(len(traces), 1)
        self.assertEqual(traces[0].verdict, DataFlowVerdict.SAFE)

    def test_trace_no_source_needs_review(self):
        from lib.dataflow_tracer import trace_dataflow, DataFlowVerdict
        findings = [{
            "content": "cursor.execute('DROP TABLE users')",
            "metadata": {"file": "app.py", "line": 5, "vuln_class": "sql_injection"},
        }]
        traces = trace_dataflow(findings)
        self.assertEqual(len(traces), 1)
        self.assertEqual(traces[0].verdict, DataFlowVerdict.NEEDS_REVIEW)

    def test_trace_to_dict_serialization(self):
        from lib.dataflow_tracer import trace_dataflow
        findings = [{
            "content": "val = request.form['name']; eval(val)",
            "metadata": {"file": "app.py", "line": 1, "vuln_class": "code_injection"},
        }]
        traces = trace_dataflow(findings)
        d = traces[0].to_dict()
        self.assertIn("trace_id", d)
        self.assertIn("source", d)
        self.assertIn("sink", d)
        self.assertIn("verdict", d)

    def test_empty_findings_returns_empty(self):
        from lib.dataflow_tracer import trace_dataflow
        traces = trace_dataflow([])
        self.assertEqual(traces, [])

    def test_source_detection_patterns(self):
        from lib.dataflow_tracer import _SOURCE_PATTERNS, InputType
        self.assertEqual(_SOURCE_PATTERNS["request.args"], InputType.QUERY_PARAM)
        self.assertEqual(_SOURCE_PATTERNS["request.form"], InputType.FORM_FIELD)
        self.assertEqual(_SOURCE_PATTERNS["req.body"], InputType.JSON_BODY)

    def test_dangerous_sinks_include_critical(self):
        from lib.dataflow_tracer import _DANGEROUS_SINKS, DangerLevel
        self.assertEqual(_DANGEROUS_SINKS["exec"], DangerLevel.CRITICAL)
        self.assertEqual(_DANGEROUS_SINKS["eval"], DangerLevel.CRITICAL)
        self.assertEqual(_DANGEROUS_SINKS["cursor.execute"], DangerLevel.HIGH)

    def test_metadata_as_json_string(self):
        from lib.dataflow_tracer import trace_dataflow
        findings = [{
            "content": "data = request.json['payload']; eval(data)",
            "metadata": '{"file": "api.py", "line": 5, "vuln_class": "injection"}',
        }]
        traces = trace_dataflow(findings)
        self.assertEqual(len(traces), 1)
        self.assertIsNotNone(traces[0].source)

    def test_weak_sanitization_still_vulnerable(self):
        from lib.dataflow_tracer import trace_dataflow, DataFlowVerdict
        findings = [{
            "content": "data = request.args.get('q'); filtered = filter(data); eval(filtered)",
            "metadata": {"file": "app.py", "line": 1, "vuln_class": "injection"},
        }]
        traces = trace_dataflow(findings)
        # filter has effectiveness 0.5 which is < 0.6, so verdict is VULNERABLE
        self.assertEqual(traces[0].verdict, DataFlowVerdict.VULNERABLE)


if __name__ == '__main__':
    unittest.main()
