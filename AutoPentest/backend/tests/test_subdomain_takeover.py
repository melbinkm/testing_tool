"""
Tests for check_subdomain_takeover tool.

5 tests validating subdomain takeover detection with CNAME resolution
and fingerprint matching.
"""

import sys
import os
import json
import unittest
from unittest.mock import AsyncMock, MagicMock, patch

# Add modules to path (avoid pip mcp package shadowing)
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

from tools_scanning import (
    get_scanning_tools,
    handle_scanning_tool,
    TAKEOVER_FINGERPRINTS,
    _handle_check_subdomain_takeover,
)


class TestSubdomainTakeover(unittest.IsolatedAsyncioTestCase):
    """Test suite for subdomain takeover detection."""

    def setUp(self):
        self.mcp_service = MagicMock()
        self.mcp_service.current_assessment_id = 1
        self.mcp_service.scope_provider = MagicMock()
        self.mcp_service.current_container = "kali"

    def test_tool_definition_exists(self):
        """Test that check_subdomain_takeover tool is defined."""
        tools = get_scanning_tools()
        tool_names = [t.name for t in tools]
        self.assertIn("check_subdomain_takeover", tool_names)

    def test_fingerprint_database_populated(self):
        """Test that fingerprint database has known providers."""
        self.assertGreater(len(TAKEOVER_FINGERPRINTS), 10)
        self.assertIn("github.io", TAKEOVER_FINGERPRINTS)
        self.assertIn("herokuapp.com", TAKEOVER_FINGERPRINTS)
        self.assertIn("s3.amazonaws.com", TAKEOVER_FINGERPRINTS)

        # Each fingerprint should have (provider_name, fingerprint_string)
        for domain, (provider, fingerprint) in TAKEOVER_FINGERPRINTS.items():
            self.assertIsInstance(provider, str)
            self.assertIsInstance(fingerprint, str)
            self.assertTrue(len(fingerprint) > 0)

    async def test_no_subdomains_returns_error(self):
        """Test that empty subdomains list returns error."""
        result = await _handle_check_subdomain_takeover({}, self.mcp_service)
        data = json.loads(result[0].text)
        self.assertFalse(data["success"])
        self.assertIn("No subdomains", data["error"])

    @patch("httpx.AsyncClient")
    async def test_vulnerable_subdomain_detected(self, mock_async_client_cls):
        """Test detection of vulnerable subdomain with CNAME to unclaimed resource."""
        # Mock the container command for CNAME resolution
        self.mcp_service.execute_container_command = AsyncMock(return_value={
            "stdout": "example.github.io.\n",
            "success": True,
        })

        # Mock HTTP response with GitHub Pages fingerprint
        mock_response = MagicMock()
        mock_response.text = "<html>There isn't a GitHub Pages site here.</html>"
        mock_response.status_code = 404

        mock_client = AsyncMock()
        mock_client.get = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock(return_value=False)
        mock_async_client_cls.return_value = mock_client

        result = await _handle_check_subdomain_takeover(
            {"subdomains": ["blog.example.com"]},
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        self.assertEqual(data["total_checked"], 1)
        self.assertEqual(data["vulnerable_count"], 1)
        self.assertTrue(data["results"][0]["takeover_possible"])
        self.assertEqual(data["results"][0]["provider"], "GitHub Pages")
        self.assertEqual(data["results"][0]["confidence"], "high")

    @patch("httpx.AsyncClient")
    async def test_safe_subdomain_not_flagged(self, mock_async_client_cls):
        """Test that a subdomain not matching any fingerprint is not flagged."""
        # Mock CNAME that doesn't match any fingerprint
        self.mcp_service.execute_container_command = AsyncMock(return_value={
            "stdout": "cdn.cloudflare.com.\n",
            "success": True,
        })

        result = await _handle_check_subdomain_takeover(
            {"subdomains": ["www.example.com"]},
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        self.assertEqual(data["total_checked"], 1)
        self.assertEqual(data["vulnerable_count"], 0)
        self.assertFalse(data["results"][0]["takeover_possible"])
        self.assertEqual(data["results"][0]["confidence"], "none")

    async def test_cname_resolution_error_handled(self):
        """Test graceful handling when CNAME resolution fails."""
        # Mock container command that raises
        self.mcp_service.execute_container_command = AsyncMock(
            side_effect=Exception("dig timeout")
        )

        result = await _handle_check_subdomain_takeover(
            {"subdomains": ["broken.example.com"]},
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        self.assertEqual(data["total_checked"], 1)
        self.assertEqual(data["vulnerable_count"], 0)
        self.assertIn("cname_error", data["results"][0])


if __name__ == "__main__":
    unittest.main()
