"""
Test Deep Audit Round 9 Fixes

Tests for 6 bugs:
1. lib.credentials_store phantom import - tools_sequences.py:717
2. Endpoint analysis HTTP client cache invalidation - tools_endpoint_analysis.py:688
3. IdentityStore empty on every call - tools_sequences.py:58
4. ReproRunner/ControlRunner bypass audited HTTP client - tools_validator.py:33-48
5. test_credential uses raw httpx - tools_auth_tester.py:524
6. activity_logger None leaks into closure - http_client_factory.py:49
"""

import unittest
from unittest.mock import AsyncMock, MagicMock, patch
import sys
import os

# Add backend to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))


class TestRound9Fixes(unittest.IsolatedAsyncioTestCase):
    """Test Round 9 bug fixes."""

    # -------------------------------------------------------------------------
    # Fix 1: Credential lookup from backend API (not phantom module)
    # -------------------------------------------------------------------------

    async def test_credential_lookup_from_backend_api(self):
        """Verify credential_reuse uses backend API instead of phantom credentials_store module."""
        from tools_sequences import _handle_credential_reuse

        # Mock MCP service with backend API
        mcp_service = MagicMock()
        mcp_service.current_assessment_id = "test-assessment"
        mcp_service.backend_url = "http://backend:8000"

        # Mock session.get to return credential from API
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "credentials": [
                {
                    "id": "cred-123",
                    "name": "test-cred",
                    "type": "bearer",
                    "token": "test-token-value",
                    "username": None,
                    "password": None,
                }
            ]
        }

        mock_http_client = AsyncMock()
        mock_http_client.get = AsyncMock(return_value=mock_response)
        mcp_service.http_client = mock_http_client

        # Mock HTTP client and scope
        with patch("tools_sequences._get_http_client") as mock_http, \
             patch("tools_sequences._get_db") as mock_db, \
             patch("lib.scope_loader.load_scope_from_env") as mock_scope:

            mock_http.return_value = AsyncMock()
            mock_http.return_value.send = AsyncMock(return_value={"success": False, "error": "test"})
            mock_db.side_effect = Exception("No DB needed for this test")
            mock_scope.return_value = None

            # Mock CredentialReuseTester
            with patch("lib.sequence_runner.CredentialReuseTester") as MockTester:
                mock_tester = AsyncMock()
                mock_tester.test_credential_reuse = AsyncMock(return_value={
                    "endpoints_tested": 1,
                    "successful_auth": [],
                })
                MockTester.return_value = mock_tester

                # Call handler
                arguments = {
                    "credential_id": "cred-123",
                    "target_endpoints": ["http://target.com/api"],
                    "method": "GET",
                }

                result = await _handle_credential_reuse(arguments, mcp_service)

                # Verify backend API was called
                mock_http_client.get.assert_called_once()
                call_url = mock_http_client.get.call_args[0][0]
                self.assertIn("/credentials", call_url)

                # Verify credential was passed to tester
                MockTester.assert_called_once()
                mock_tester.test_credential_reuse.assert_called_once()

                # Extract credential passed to tester
                call_args = mock_tester.test_credential_reuse.call_args
                credential = call_args.kwargs.get("credential") or call_args.args[0]

                self.assertIsNotNone(credential)
                self.assertEqual(credential.get("type"), "bearer")
                self.assertEqual(credential.get("value"), "test-token-value")

    # -------------------------------------------------------------------------
    # Fix 2: Endpoint analysis client cache invalidation
    # -------------------------------------------------------------------------

    async def test_endpoint_analysis_client_cache_invalidation(self):
        """Verify endpoint analysis HTTP client is invalidated on assessment change."""
        from tools_endpoint_analysis import _get_http_client

        # Create mock service with assessment 1
        mcp_service = MagicMock()
        mcp_service.current_assessment_id = "assessment-1"
        mcp_service.scope_provider = MagicMock()
        mcp_service.activity_logger = None

        # Get first client
        client1 = _get_http_client(mcp_service)
        self.assertIsNotNone(client1)

        # Verify cache attributes exist
        self.assertTrue(hasattr(mcp_service, "_endpoint_analysis_http_client"))
        self.assertTrue(hasattr(mcp_service, "_endpoint_analysis_cache_key"))
        self.assertEqual(mcp_service._endpoint_analysis_cache_key, "assessment-1")

        # Get again with same assessment - should be cached
        client2 = _get_http_client(mcp_service)
        self.assertIs(client1, client2, "Should return cached client for same assessment")

        # Change assessment
        mcp_service.current_assessment_id = "assessment-2"

        # Get new client - should create new instance
        client3 = _get_http_client(mcp_service)
        self.assertIsNot(client1, client3, "Should create new client for different assessment")
        self.assertEqual(mcp_service._endpoint_analysis_cache_key, "assessment-2")

    # -------------------------------------------------------------------------
    # Fix 3: IdentityStore populated from world model
    # -------------------------------------------------------------------------

    async def test_identity_store_populated_from_world_model(self):
        """Verify _get_identity_store() loads identities from world model."""
        from tools_sequences import _get_identity_store

        # Mock MCP service
        mcp_service = MagicMock()
        mcp_service.current_assessment_id = "test-assessment"

        # Mock world model DB with identities
        mock_db = AsyncMock()
        mock_db.query = AsyncMock(return_value=[
            {
                "id": "identity-1",
                "auth_type": "bearer",
                "scope": "user",
                "description": "Test User 1",
                "metadata": {
                    "auth_header": "Bearer token123",
                    "cookies": None,
                    "should_have_access": True,
                },
            },
            {
                "id": "identity-2",
                "auth_type": "basic",
                "scope": "admin",
                "description": "Admin User",
                "metadata": {
                    "auth_header": "Basic YWRtaW46cGFzcw==",
                    "should_have_access": True,
                },
            },
        ])

        with patch("lib.world_model_db.get_world_model_db", return_value=mock_db):
            # Call the function
            store = await _get_identity_store(mcp_service)

            # Verify store is not None
            self.assertIsNotNone(store)

            # Verify world model was queried
            mock_db.query.assert_called_once_with("identities", limit=100)

            # Verify store has identities (check the internal structure)
            # IdentityStore may have different APIs, but should have loaded data
            self.assertTrue(hasattr(store, "_identities") or hasattr(store, "identities"))

    # -------------------------------------------------------------------------
    # Fix 4: Validator runners use audited HTTP client
    # -------------------------------------------------------------------------

    async def test_repro_runner_uses_audited_client(self):
        """Verify ReproRunner receives audited HTTP client."""
        from tools_validator import _get_repro_runner

        # Mock MCP service
        mcp_service = MagicMock()
        mcp_service.current_assessment_id = "test-assessment"
        mcp_service.scope_provider = MagicMock()
        mcp_service.activity_logger = None

        # Reset global state
        import tools_validator as validator_module
        validator_module._repro_runner = None
        validator_module._repro_runner_key = None

        with patch("lib.repro_runner.ReproRunner") as MockRunner, \
             patch("lib.http_client_factory.create_audit_http_client") as mock_factory:

            mock_client = MagicMock()
            mock_factory.return_value = mock_client

            mock_runner_instance = MagicMock()
            MockRunner.return_value = mock_runner_instance

            # Get runner
            runner = _get_repro_runner(mcp_service)

            # Verify factory was called
            mock_factory.assert_called_once_with(mcp_service)

            # Verify ReproRunner was initialized with http_client
            MockRunner.assert_called_once()
            call_kwargs = MockRunner.call_args.kwargs
            self.assertIn("http_client", call_kwargs)
            self.assertIs(call_kwargs["http_client"], mock_client)

    async def test_control_runner_uses_audited_client(self):
        """Verify ControlRunner receives audited HTTP client."""
        from tools_validator import _get_control_runner

        # Mock MCP service
        mcp_service = MagicMock()
        mcp_service.current_assessment_id = "test-assessment"
        mcp_service.scope_provider = MagicMock()
        mcp_service.activity_logger = None

        # Reset global state
        import tools_validator as validator_module
        validator_module._control_runner = None
        validator_module._control_runner_key = None

        with patch("lib.control_runner.ControlRunner") as MockRunner, \
             patch("lib.http_client_factory.create_audit_http_client") as mock_factory:

            mock_client = MagicMock()
            mock_factory.return_value = mock_client

            mock_runner_instance = MagicMock()
            MockRunner.return_value = mock_runner_instance

            # Get runner
            runner = _get_control_runner(mcp_service)

            # Verify factory was called
            mock_factory.assert_called_once_with(mcp_service)

            # Verify ControlRunner was initialized with http_client
            MockRunner.assert_called_once()
            call_kwargs = MockRunner.call_args.kwargs
            self.assertIn("http_client", call_kwargs)
            self.assertIs(call_kwargs["http_client"], mock_client)

    async def test_validator_runner_cache_invalidation(self):
        """Verify validator runners are recreated on assessment change."""
        from tools_validator import _get_repro_runner, _get_control_runner

        # Reset global state
        import tools_validator as validator_module
        validator_module._repro_runner = None
        validator_module._repro_runner_key = None
        validator_module._control_runner = None
        validator_module._control_runner_key = None

        # Mock MCP service with assessment 1
        mcp_service = MagicMock()
        mcp_service.current_assessment_id = "assessment-1"
        mcp_service.scope_provider = MagicMock()
        mcp_service.activity_logger = None

        with patch("lib.repro_runner.ReproRunner") as MockReproRunner, \
             patch("lib.control_runner.ControlRunner") as MockControlRunner, \
             patch("lib.http_client_factory.create_audit_http_client"):

            MockReproRunner.return_value = MagicMock(name="ReproRunner1")
            MockControlRunner.return_value = MagicMock(name="ControlRunner1")

            # Get runners for assessment 1
            repro1 = _get_repro_runner(mcp_service)
            control1 = _get_control_runner(mcp_service)

            # Change assessment
            mcp_service.current_assessment_id = "assessment-2"
            MockReproRunner.return_value = MagicMock(name="ReproRunner2")
            MockControlRunner.return_value = MagicMock(name="ControlRunner2")

            # Get runners for assessment 2
            repro2 = _get_repro_runner(mcp_service)
            control2 = _get_control_runner(mcp_service)

            # Verify new instances created
            self.assertIsNot(repro1, repro2, "ReproRunner should be recreated for new assessment")
            self.assertIsNot(control1, control2, "ControlRunner should be recreated for new assessment")

    # -------------------------------------------------------------------------
    # Fix 5: test_credential accepts optional http_client
    # -------------------------------------------------------------------------

    async def test_test_credential_accepts_http_client(self):
        """Verify test_credential() can accept and use an audited HTTP client."""
        from tools_auth_tester import test_credential

        # Create mock audited client
        mock_client = AsyncMock()
        mock_response = {
            "status": 200,
            "headers": {"set-cookie": "session=abc123"},
            "body": "Welcome, admin!",
        }
        mock_client.send = AsyncMock(return_value=mock_response)

        # Call test_credential with http_client
        result = await test_credential(
            target_url="http://testapp.com",
            username="admin",
            password="password",
            method="form",
            login_path="/login",
            http_client=mock_client,
        )

        # Verify audited client was used
        mock_client.send.assert_called_once()
        # send() is called with a dict as first positional arg
        call_args = mock_client.send.call_args.args
        self.assertEqual(len(call_args), 1)
        request_dict = call_args[0]
        self.assertEqual(request_dict.get("method"), "POST")
        self.assertIn("/login", request_dict.get("url", ""))

        # Verify result structure
        self.assertIsInstance(result, dict)
        self.assertIn("valid", result)

    # -------------------------------------------------------------------------
    # Fix 6: activity_logger None guard
    # -------------------------------------------------------------------------

    async def test_activity_logger_none_guard(self):
        """Verify http_client_factory properly guards against activity_logger=None."""
        from lib.http_client_factory import create_audit_http_client

        # Create service with activity_logger = None
        mcp_service = MagicMock()
        mcp_service.current_assessment_id = "test"
        mcp_service.scope_provider = MagicMock()
        mcp_service.activity_logger = None  # Explicitly None

        # Create client - should not crash
        client = create_audit_http_client(mcp_service)

        # Verify client was created
        self.assertIsNotNone(client)

        # Verify exchange_logger was NOT created (since activity_logger is None)
        # The factory should check both hasattr and is not None
        # This is validated by ensuring the client creation doesn't crash

    # -------------------------------------------------------------------------
    # Source code verification tests
    # -------------------------------------------------------------------------

    def test_source_fix1_backend_api_lookup(self):
        """Verify Fix 1: Credential lookup uses backend API."""
        with open("/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/tools_sequences.py", "r") as f:
            content = f.read()

        # Should NOT import credentials_store
        self.assertNotIn("from lib.credentials_store import", content,
                        "Should not import phantom credentials_store module")

        # Should use backend API (updated to http_client in Round 10)
        self.assertIn("mcp_service.http_client.get", content,
                     "Should use mcp_service.http_client.get for credential lookup")

    def test_source_fix2_cache_key_check(self):
        """Verify Fix 2: Endpoint analysis client has cache key check."""
        with open("/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/tools_endpoint_analysis.py", "r") as f:
            content = f.read()

        # Should have cache_key variable
        self.assertIn("cache_key = mcp_service.current_assessment_id", content,
                     "Should define cache_key from current_assessment_id")

        # Should check _endpoint_analysis_cache_key
        self.assertIn("_endpoint_analysis_cache_key", content,
                     "Should have cache key attribute")

    def test_source_fix3_identity_store_async(self):
        """Verify Fix 3: _get_identity_store is async and loads from DB."""
        with open("/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/tools_sequences.py", "r") as f:
            content = f.read()

        # Should be async function
        self.assertIn("async def _get_identity_store", content,
                     "_get_identity_store should be async function")

        # Should call world model DB
        self.assertIn("get_world_model_db", content,
                     "Should import and use get_world_model_db")

        # Should query identities (updated to query in Round 10)
        self.assertIn('query("identities"', content,
                     "Should query identities table")

    def test_source_fix4_validator_http_client(self):
        """Verify Fix 4: Validator runners receive http_client parameter."""
        with open("/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/tools_validator.py", "r") as f:
            content = f.read()

        # Should import create_audit_http_client
        self.assertIn("from lib.http_client_factory import create_audit_http_client", content,
                     "Should import create_audit_http_client")

        # Should have cache keys
        self.assertIn("_repro_runner_key", content,
                     "Should have _repro_runner_key for cache invalidation")
        self.assertIn("_control_runner_key", content,
                     "Should have _control_runner_key for cache invalidation")

        # Should pass http_client to runners
        self.assertIn("http_client=", content,
                     "Should pass http_client parameter to runners")

    def test_source_fix5_test_credential_param(self):
        """Verify Fix 5: test_credential accepts http_client parameter."""
        with open("/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/tools_auth_tester.py", "r") as f:
            content = f.read()

        # Should have http_client parameter in function signature
        self.assertIn("http_client: Any = None", content,
                     "test_credential should have optional http_client parameter with type hint")

    def test_source_fix6_activity_logger_guard(self):
        """Verify Fix 6: activity_logger None check is proper."""
        with open("/mnt/d/testing_tool/AutoPentest/backend/mcp/modules/lib/http_client_factory.py", "r") as f:
            content = f.read()

        # Should use getattr with None default
        self.assertIn('getattr(mcp_service, "activity_logger", None)', content,
                     "Should use getattr for activity_logger check")

        # Should check is not None
        self.assertIn("is not None", content,
                     "Should explicitly check is not None")


if __name__ == "__main__":
    unittest.main()
