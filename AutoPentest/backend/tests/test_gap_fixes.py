"""
Test suite for Deep Audit Round 5 - Assessment Workflow Gap Fixes

Tests the 6 critical gaps fixed:
- Gap 1: Audit trail holes in sequences/auth tools
- Gap 5: http_send_batch skips exchange analysis
- Gap 4: 21/42 vuln classes have no payloads (4 testable classes fixed)
- Gap 6: No coverage completeness check
- Gap 3: No checklist enforcement

Total: 20 tests across 4 batches
"""

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

import unittest
import json
from unittest.mock import Mock, AsyncMock, patch, MagicMock


# ============================================================================
# BATCH 1: Audit Trail Completeness (6 tests)
# ============================================================================

class TestAuditTrailCompleteness(unittest.TestCase):
    """Test that all HTTP traffic gets logged to audit trail."""

    def test_sequences_http_client_has_exchange_logger(self):
        """Verify sequence tools use audited HttpClient from factory."""
        from tools_sequences import _get_http_client
        from lib.http_client import HttpClient

        # Create mock mcp_service with activity_logger
        mock_mcp = Mock()
        mock_mcp.activity_logger = Mock()
        mock_mcp.activity_logger.log_http_exchange = AsyncMock()
        mock_mcp.scope_provider = None
        mock_mcp.current_assessment_id = 1

        client = _get_http_client(mock_mcp)
        self.assertIsInstance(client, HttpClient)
        # Verify exchange_logger is wired (not None)
        self.assertIsNotNone(client._exchange_logger)

    @patch('lib.http_client_factory.create_audit_http_client')
    async def test_auth_replay_uses_audited_client(self, mock_factory):
        """Verify auth_replay_with_identity uses audited HttpClient."""
        from tools_auth_tester import _handle_replay_with_identity

        # Mock HttpClient.send() to return success
        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value={
            "success": True,
            "response": {
                "status": 200,
                "headers": {},
                "body": "OK"
            }
        })
        mock_factory.return_value = mock_client

        # Mock identity store
        mock_identity = Mock()
        mock_identity.type = "bearer"
        mock_identity.scope = "user"
        mock_identity.should_have_access = True

        with patch('mcp.modules.tools_auth_tester._get_identity_store') as mock_store_fn:
            mock_store = Mock()
            mock_store.get_identity.return_value = mock_identity
            mock_store_fn.return_value = mock_store

            with patch('mcp.modules.tools_auth_tester.IdentityStore') as mock_is:
                mock_is.build_auth_headers.return_value = {"Authorization": "Bearer token"}

                result = await _handle_replay_with_identity(
                    {"url": "http://test.com", "identity_id": "test_id"},
                    mcp_service=Mock()
                )

        # Verify client.send was called (not raw httpx)
        mock_client.send.assert_called_once()
        self.assertEqual(len(result), 1)
        data = json.loads(result[0].text)
        self.assertTrue(data["success"])

    @patch('lib.http_client_factory.create_audit_http_client')
    async def test_auth_diff_test_uses_audited_client(self, mock_factory):
        """Verify auth_diff_test passes audited HttpClient to DifferentialTester."""
        from tools_auth_tester import _handle_diff_test

        mock_client = AsyncMock()
        mock_factory.return_value = mock_client

        # Mock identity store with 2 identities
        mock_identity1 = Mock()
        mock_identity1.type = "bearer"
        mock_identity1.scope = "admin"
        mock_identity1.should_have_access = True

        mock_identity2 = Mock()
        mock_identity2.type = "bearer"
        mock_identity2.scope = "user"
        mock_identity2.should_have_access = False

        with patch('mcp.modules.tools_auth_tester._get_identity_store') as mock_store_fn:
            mock_store = Mock()
            mock_store.count = 2
            mock_store.get_identities.return_value = [mock_identity1, mock_identity2]
            mock_store_fn.return_value = mock_store

            with patch('mcp.modules.tools_auth_tester.DifferentialTester') as MockTester:
                mock_tester_instance = AsyncMock()
                mock_tester_instance.test_endpoint = AsyncMock(return_value={})
                mock_tester_instance.analyze_results = Mock(return_value={})
                MockTester.return_value = mock_tester_instance

                result = await _handle_diff_test(
                    {"url": "http://test.com"},
                    mcp_service=Mock()
                )

        # Verify DifferentialTester was instantiated with http_client
        MockTester.assert_called_once()
        call_kwargs = MockTester.call_args.kwargs
        self.assertIn("http_client", call_kwargs)
        self.assertEqual(call_kwargs["http_client"], mock_client)

    async def test_http_client_logs_timeout_to_exchange_logger(self):
        """Verify timeout exceptions are logged before re-raising."""
        from lib.http_client import HttpClient, RequestTimeoutError
        import httpx

        # Create HttpClient with mock exchange_logger
        mock_logger = AsyncMock()
        client = HttpClient(
            config={
                "engagement_id": "test",
                "proxy_url": None,
                "max_rps": 10,
                "max_concurrent": 5,
                "default_timeout": 100,  # Very short timeout
                "max_total_requests": 100,
            },
            exchange_logger=mock_logger
        )

        # Mock httpx to raise TimeoutException
        with patch('httpx.AsyncClient.request', side_effect=httpx.TimeoutException("timeout")):
            with self.assertRaises(RequestTimeoutError):
                await client.send({
                    "method": "GET",
                    "url": "http://test.com",
                    "timeout": 100
                })

        # Verify exchange_logger was called with timeout details
        mock_logger.assert_called_once()
        call_args = mock_logger.call_args.kwargs
        self.assertEqual(call_args["response"]["body"], "TIMEOUT")
        self.assertEqual(call_args["response"]["status"], 0)

    def test_activity_bridge_forwards_http_exchange(self):
        """Verify http_exchange activity type maps to EventType.HTTP_EXCHANGE."""
        from websocket.activity_bridge import ActivityBridge
        from websocket.events import EventType

        bridge = ActivityBridge("postgres://test", Mock())
        event_type = bridge._translate_activity_type("http_exchange")
        self.assertEqual(event_type, EventType.HTTP_EXCHANGE)

    def test_activity_bridge_forwards_coverage_updated(self):
        """Verify coverage_updated activity type maps to EventType.COVERAGE_UPDATED."""
        from websocket.activity_bridge import ActivityBridge
        from websocket.events import EventType

        bridge = ActivityBridge("postgres://test", Mock())
        event_type = bridge._translate_activity_type("coverage_updated")
        self.assertEqual(event_type, EventType.COVERAGE_UPDATED)


# ============================================================================
# BATCH 2: Exchange Analysis on Batch Requests (3 tests)
# ============================================================================

class TestBatchExchangeAnalysis(unittest.TestCase):
    """Test that http_send_batch runs exchange analysis on responses."""

    async def test_batch_runs_exchange_analysis_by_default(self):
        """Verify analysis runs on successful batch responses."""
        from tools_http import _handle_http_send_batch

        # Mock HttpClient.send_batch
        mock_client = AsyncMock()
        mock_client.send_batch = AsyncMock(return_value={
            "results": [
                {
                    "success": True,
                    "response": {
                        "status": 200,
                        "headers": {"Content-Type": "text/html"},
                        "body": "<html>test</html>"
                    }
                }
            ]
        })

        # Mock ExchangeAnalyzer
        mock_ea = Mock()
        mock_ea.analyze = Mock(return_value={
            "risk_signals": [{"type": "info_leak", "severity": "low"}],
            "tech_detected": ["apache"]
        })

        with patch('mcp.modules.tools_http._get_http_client', return_value=mock_client):
            with patch('mcp.modules.tools_http.get_exchange_analyzer', return_value=mock_ea):
                result = await _handle_http_send_batch(
                    {"requests": [{"method": "GET", "url": "http://test.com"}]},
                    mcp_service=Mock()
                )

        data = json.loads(result[0].text)
        # Verify analysis was added
        self.assertIn("exchange_analysis", data["results"][0])
        self.assertIn("batch_analysis", data)
        self.assertEqual(data["batch_analysis"]["total_findings"], 1)

    async def test_batch_skips_analysis_when_false(self):
        """Verify analyze=False skips exchange analysis."""
        from tools_http import _handle_http_send_batch

        mock_client = AsyncMock()
        mock_client.send_batch = AsyncMock(return_value={
            "results": [
                {
                    "success": True,
                    "response": {"status": 200, "headers": {}, "body": "OK"}
                }
            ]
        })

        with patch('mcp.modules.tools_http._get_http_client', return_value=mock_client):
            with patch('mcp.modules.tools_http.get_exchange_analyzer') as mock_ea_fn:
                result = await _handle_http_send_batch(
                    {"requests": [{"method": "GET", "url": "http://test.com"}], "analyze": False},
                    mcp_service=Mock()
                )

        data = json.loads(result[0].text)
        # Verify analyzer was never called
        mock_ea_fn.assert_not_called()
        self.assertNotIn("exchange_analysis", data["results"][0])

    async def test_batch_analysis_handles_mixed_success_failure(self):
        """Verify only successful responses are analyzed."""
        from tools_http import _handle_http_send_batch

        mock_client = AsyncMock()
        mock_client.send_batch = AsyncMock(return_value={
            "results": [
                {"success": True, "response": {"status": 200, "headers": {}, "body": "OK"}},
                {"success": False, "error": "timeout"},
                {"success": True, "response": {"status": 404, "headers": {}, "body": "Not Found"}},
            ]
        })

        mock_ea = Mock()
        mock_ea.analyze = Mock(return_value={"risk_signals": [], "tech_detected": []})

        with patch('mcp.modules.tools_http._get_http_client', return_value=mock_client):
            with patch('mcp.modules.tools_http.get_exchange_analyzer', return_value=mock_ea):
                result = await _handle_http_send_batch(
                    {"requests": [
                        {"method": "GET", "url": "http://test1.com"},
                        {"method": "GET", "url": "http://test2.com"},
                        {"method": "GET", "url": "http://test3.com"}
                    ]},
                    mcp_service=Mock()
                )

        # Verify analyzer called exactly twice (2 successful responses)
        self.assertEqual(mock_ea.analyze.call_count, 2)


# ============================================================================
# BATCH 3: Payload Gaps for Testable Vuln Classes (4 tests)
# ============================================================================

class TestPayloadGaps(unittest.TestCase):
    """Test that 4 empty-but-testable vuln classes now have payloads."""

    def test_ldap_injection_has_payloads(self):
        """Verify ldap_injection returns payloads."""
        from lib.payload_registry import get_payload_registry

        registry = get_payload_registry()
        payloads = registry.get_payloads("ldap_injection")
        self.assertGreater(len(payloads), 5)
        # Verify common LDAP injection patterns present
        self.assertIn("*", payloads)
        self.assertIn("*)*", payloads)

    def test_username_enumeration_has_payloads(self):
        """Verify username_enumeration returns test usernames."""
        from lib.payload_registry import get_payload_registry

        registry = get_payload_registry()
        payloads = registry.get_payloads("username_enumeration")
        self.assertGreater(len(payloads), 5)
        # Verify common usernames present
        self.assertIn("admin", payloads)
        self.assertIn("root", payloads)

    def test_http_method_tampering_has_payloads(self):
        """Verify http_method_tampering returns HTTP methods."""
        from lib.payload_registry import get_payload_registry

        registry = get_payload_registry()
        payloads = registry.get_payloads("http_method_tampering")
        self.assertGreaterEqual(len(payloads), 9)
        # Verify standard methods present
        self.assertIn("TRACE", payloads)
        self.assertIn("DELETE", payloads)
        self.assertIn("PROPFIND", payloads)  # WebDAV

    def test_rate_limit_bypass_has_payloads(self):
        """Verify rate_limit_bypass returns IP spoofing header values."""
        from lib.payload_registry import get_payload_registry

        registry = get_payload_registry()
        payloads = registry.get_payloads("rate_limit_bypass")
        self.assertGreaterEqual(len(payloads), 5)
        # Verify common IP values present
        self.assertIn("127.0.0.1", payloads)
        self.assertIn("10.0.0.1", payloads)


# ============================================================================
# BATCH 4: Coverage Completeness + Checklist Enforcement (7 tests)
# ============================================================================

class TestCoverageCompleteness(unittest.TestCase):
    """Test endpoint completeness and checklist compliance in testing_status."""

    async def test_testing_status_includes_endpoint_completeness(self):
        """Verify testing_status returns endpoint completeness metrics."""
        from tools_testing_engine import _handle_testing_status
        from lib.world_model_db import MockPool

        # Create mock MCP service
        mock_mcp = Mock()
        mock_mcp.current_assessment_id = 1
        mock_mcp.current_base_url = "http://test.com"

        # Create mock DB with 10 endpoints, 7 in matrix
        mock_pool = MockPool()
        await mock_pool._execute(
            "INSERT INTO wm_endpoints (id, assessment_id, method, path) VALUES "
            "($1, $2, $3, $4)", (1, 1, "GET", "/api/users"))
        await mock_pool._execute(
            "INSERT INTO wm_endpoints (id, assessment_id, method, path) VALUES "
            "($1, $2, $3, $4)", (2, 1, "POST", "/api/login"))
        await mock_pool._execute(
            "INSERT INTO wm_endpoints (id, assessment_id, method, path) VALUES "
            "($1, $2, $3, $4)", (3, 1, "GET", "/admin"))

        # Add coverage for 2 endpoints only
        await mock_pool._execute(
            "INSERT INTO wm_coverage_matrix (id, assessment_id, endpoint_id, vuln_class, status, priority) VALUES "
            "($1, $2, $3, $4, $5, $6)", (1, 1, 1, "sqli", "pending", 80))
        await mock_pool._execute(
            "INSERT INTO wm_coverage_matrix (id, assessment_id, endpoint_id, vuln_class, status, priority) VALUES "
            "($1, $2, $3, $4, $5, $6)", (2, 1, 2, "xss", "pending", 70))

        from lib.world_model_db import set_shared_pool
        set_shared_pool(mock_pool)

        with patch('mcp.modules.tools_testing_engine.get_orchestrator') as mock_orch_fn:
            mock_orch = Mock()
            mock_orch.get_status.return_value = {"state": "testing", "progress": {}}
            mock_orch.update_progress = Mock()
            mock_orch_fn.return_value = mock_orch

            result = await _handle_testing_status({}, mock_mcp)

        data = json.loads(result[0].text)
        self.assertIn("endpoint_completeness", data)
        completeness = data["endpoint_completeness"]
        self.assertEqual(completeness["total_known_endpoints"], 3)
        self.assertEqual(completeness["endpoints_in_matrix"], 2)
        self.assertEqual(completeness["uncovered_endpoints"], 1)
        self.assertAlmostEqual(completeness["coverage_percentage"], 66.7, places=1)

    async def test_testing_status_completeness_all_covered(self):
        """Verify 100% coverage shows 'All endpoints covered'."""
        from tools_testing_engine import _handle_testing_status
        from lib.world_model_db import MockPool

        mock_mcp = Mock()
        mock_mcp.current_assessment_id = 1
        mock_mcp.current_base_url = "http://test.com"

        mock_pool = MockPool()
        await mock_pool._execute(
            "INSERT INTO wm_endpoints (id, assessment_id, method, path) VALUES "
            "($1, $2, $3, $4)", (1, 1, "GET", "/api/test"))
        await mock_pool._execute(
            "INSERT INTO wm_coverage_matrix (id, assessment_id, endpoint_id, vuln_class, status, priority) VALUES "
            "($1, $2, $3, $4, $5, $6)", (1, 1, 1, "sqli", "pending", 80))

        from lib.world_model_db import set_shared_pool
        set_shared_pool(mock_pool)

        with patch('mcp.modules.tools_testing_engine.get_orchestrator') as mock_orch_fn:
            mock_orch = Mock()
            mock_orch.get_status.return_value = {"state": "testing", "progress": {}}
            mock_orch.update_progress = Mock()
            mock_orch_fn.return_value = mock_orch

            result = await _handle_testing_status({}, mock_mcp)

        data = json.loads(result[0].text)
        self.assertEqual(data["endpoint_completeness"]["coverage_percentage"], 100.0)
        self.assertIn("All endpoints covered", data["endpoint_completeness"]["recommendation"])

    async def test_testing_status_includes_checklist_compliance(self):
        """Verify testing_status returns checklist compliance metrics."""
        from tools_testing_engine import _handle_testing_status
        from lib.world_model_db import MockPool

        mock_mcp = Mock()
        mock_mcp.current_assessment_id = 1
        mock_mcp.current_base_url = "http://test.com"

        # Create matrix with 5 tested vuln classes out of 42 total
        mock_pool = MockPool()
        for i, vuln_class in enumerate(["sqli", "xss", "idor", "csrf", "ssrf"]):
            await mock_pool._execute(
                "INSERT INTO wm_coverage_matrix (id, assessment_id, endpoint_id, vuln_class, status, priority) VALUES "
                "($1, $2, $3, $4, $5, $6)", (i+1, 1, 1, vuln_class, "tested", 80))

        from lib.world_model_db import set_shared_pool
        set_shared_pool(mock_pool)

        with patch('mcp.modules.tools_testing_engine.get_orchestrator') as mock_orch_fn:
            mock_orch = Mock()
            mock_orch.get_status.return_value = {"state": "testing", "progress": {}}
            mock_orch.update_progress = Mock()
            mock_orch_fn.return_value = mock_orch

            result = await _handle_testing_status({}, mock_mcp)

        data = json.loads(result[0].text)
        self.assertIn("checklist_compliance", data)
        compliance = data["checklist_compliance"]
        self.assertTrue(compliance["matrix_built"])
        self.assertGreater(compliance["total_vuln_classes"], 40)  # ~42 specs
        self.assertEqual(compliance["classes_with_test_activity"], 5)
        self.assertLess(compliance["compliance_percentage"], 20)  # 5/42 â‰ˆ 12%

    async def test_testing_status_warns_when_matrix_not_built(self):
        """Verify warning when coverage matrix is empty."""
        from tools_testing_engine import _handle_testing_status
        from lib.world_model_db import MockPool

        mock_mcp = Mock()
        mock_mcp.current_assessment_id = 1
        mock_mcp.current_base_url = "http://test.com"

        # Empty matrix
        mock_pool = MockPool()
        from lib.world_model_db import set_shared_pool
        set_shared_pool(mock_pool)

        result = await _handle_testing_status({}, mock_mcp)

        data = json.loads(result[0].text)
        self.assertIn("checklist_compliance", data)
        compliance = data["checklist_compliance"]
        self.assertFalse(compliance["matrix_built"])
        self.assertIn("COVERAGE MATRIX NOT BUILT", compliance["warning"])

    async def test_testing_status_compliance_no_db(self):
        """Verify graceful fallback when DB unavailable."""
        from tools_testing_engine import _handle_testing_status

        mock_mcp = Mock()
        mock_mcp.current_assessment_id = 1
        mock_mcp.current_base_url = "http://test.com"

        # Force DB error by not setting shared pool
        from lib.world_model_db import set_shared_pool
        set_shared_pool(None)

        with patch('mcp.modules.tools_testing_engine.get_orchestrator') as mock_orch_fn:
            mock_orch = Mock()
            mock_orch.get_status.return_value = {"state": "init", "progress": {}}
            mock_orch.update_progress = Mock()
            mock_orch_fn.return_value = mock_orch

            result = await _handle_testing_status({}, mock_mcp)

        data = json.loads(result[0].text)
        # Should have error keys instead of crashing
        self.assertIn("endpoint_completeness", data)
        self.assertIn("checklist_compliance", data)

    async def test_completeness_with_uncovered_details(self):
        """Verify uncovered_details includes method and path."""
        from tools_testing_engine import _handle_testing_status
        from lib.world_model_db import MockPool

        mock_mcp = Mock()
        mock_mcp.current_assessment_id = 1
        mock_mcp.current_base_url = "http://test.com"

        mock_pool = MockPool()
        await mock_pool._execute(
            "INSERT INTO wm_endpoints (id, assessment_id, method, path) VALUES "
            "($1, $2, $3, $4)", (1, 1, "DELETE", "/api/admin/users"))

        from lib.world_model_db import set_shared_pool
        set_shared_pool(mock_pool)

        with patch('mcp.modules.tools_testing_engine.get_orchestrator') as mock_orch_fn:
            mock_orch = Mock()
            mock_orch.get_status.return_value = {"state": "testing", "progress": {}}
            mock_orch.update_progress = Mock()
            mock_orch_fn.return_value = mock_orch

            result = await _handle_testing_status({}, mock_mcp)

        data = json.loads(result[0].text)
        uncovered = data["endpoint_completeness"]["uncovered_details"]
        self.assertEqual(len(uncovered), 1)
        self.assertEqual(uncovered[0]["method"], "DELETE")
        self.assertEqual(uncovered[0]["path"], "/api/admin/users")

    async def test_compliance_tracks_tested_classes(self):
        """Verify compliance correctly subtracts tested from total."""
        from tools_testing_engine import _handle_testing_status
        from lib.world_model_db import MockPool

        mock_mcp = Mock()
        mock_mcp.current_assessment_id = 1
        mock_mcp.current_base_url = "http://test.com"

        mock_pool = MockPool()
        # Add 3 tested vuln classes
        for i, vc in enumerate(["sqli", "xss", "idor"]):
            await mock_pool._execute(
                "INSERT INTO wm_coverage_matrix (id, assessment_id, endpoint_id, vuln_class, status, priority) VALUES "
                "($1, $2, $3, $4, $5, $6)", (i+1, 1, 1, vc, "tested", 80))

        from lib.world_model_db import set_shared_pool
        set_shared_pool(mock_pool)

        with patch('mcp.modules.tools_testing_engine.get_orchestrator') as mock_orch_fn:
            mock_orch = Mock()
            mock_orch.get_status.return_value = {"state": "testing", "progress": {}}
            mock_orch.update_progress = Mock()
            mock_orch_fn.return_value = mock_orch

            result = await _handle_testing_status({}, mock_mcp)

        data = json.loads(result[0].text)
        compliance = data["checklist_compliance"]
        self.assertEqual(compliance["classes_with_test_activity"], 3)
        # Untested should NOT include sqli, xss, idor
        untested = compliance["untested_vuln_classes"]
        self.assertNotIn("sqli", untested)
        self.assertNotIn("xss", untested)
        self.assertNotIn("idor", untested)


if __name__ == '__main__':
    # Run async tests properly
    import asyncio

    def run_async_tests():
        loader = unittest.TestLoader()
        suite = loader.loadTestsFromModule(__import__(__name__))

        # Wrap async test methods
        for test_group in suite:
            for test_case in test_group:
                test_method = getattr(test_case, test_case._testMethodName)
                if asyncio.iscoroutinefunction(test_method):
                    def make_wrapper(coro):
                        def wrapper(self):
                            loop = asyncio.new_event_loop()
                            asyncio.set_event_loop(loop)
                            try:
                                return loop.run_until_complete(coro(self))
                            finally:
                                loop.close()
                        return wrapper
                    setattr(test_case, test_case._testMethodName, make_wrapper(test_method))

        runner = unittest.TextTestRunner(verbosity=2)
        result = runner.run(suite)
        return result.wasSuccessful()

    success = run_async_tests()
    exit(0 if success else 1)
