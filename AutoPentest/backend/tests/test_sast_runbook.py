"""
Tests for SAST Integration into Autonomous Runbook

Tests function extraction, SAST verification workflow, and runbook integration.
"""

import sys
import os
import json
from pathlib import Path
from typing import Dict, Any

# Add modules to path
sys.path.insert(0, str(Path(__file__).parent.parent / "mcp" / "modules"))

import pytest

from lib.code_indexer import CodeIndexer
from lib.world_model_db import WorldModelDatabase


# ========== Test 1: Python Function Extraction ==========

def test_extract_function_python():
    """Test Python function extraction by indentation."""
    content = """import os

def helper_function():
    return 42

def vulnerable_function(user_input):
    query = "SELECT * FROM users WHERE id = " + user_input
    execute(query)
    return "done"

def another_function():
    pass
"""

    # Mock DB and create indexer
    class MockDB:
        pass

    indexer = CodeIndexer(MockDB())

    # Extract function at line 7 (inside vulnerable_function)
    result = indexer.extract_function_at_line(content, "python", 7)

    assert result["function_name"] == "vulnerable_function"
    assert result["start_line"] == 6
    # end_line includes blank line before next function
    assert result["end_line"] == 10
    assert "def vulnerable_function" in result["code"]
    assert "user_input" in result["code"]
    assert "return \"done\"" in result["code"]


# ========== Test 2: JavaScript Function Extraction ==========

def test_extract_function_javascript():
    """Test JavaScript function extraction by braces."""
    content = """const express = require('express');

function validateInput(input) {
    return true;
}

function vulnerableHandler(req, res) {
    const query = `SELECT * FROM users WHERE id = ${req.params.id}`;
    db.execute(query);
    res.send("OK");
}

module.exports = vulnerableHandler;
"""

    class MockDB:
        pass

    indexer = CodeIndexer(MockDB())

    # Extract function at line 8 (inside vulnerableHandler)
    result = indexer.extract_function_at_line(content, "javascript", 8)

    assert result["function_name"] == "vulnerableHandler"
    assert "function vulnerableHandler" in result["code"]
    assert "req.params.id" in result["code"]


# ========== Test 3: Fallback Context Window ==========

def test_extract_function_fallback():
    """Test fallback context window when no function found."""
    content = """line 1
line 2
line 3
line 4
line 5
TARGET LINE
line 7
line 8
line 9
line 10
"""

    class MockDB:
        pass

    indexer = CodeIndexer(MockDB())

    # Extract with unknown language (fallback to context window)
    result = indexer.extract_function_at_line(content, "unknown", 6)

    assert result["function_name"] is None
    assert "TARGET LINE" in result["code"]
    # Should include Â±15 lines context
    assert result["start_line"] >= 1
    assert result["end_line"] <= 10


# ========== Test 4: sast_get_next_unverified Returns Function ==========

@pytest.mark.asyncio
async def test_sast_get_next_unverified_returns_function():
    """Test sast_get_next_unverified returns function code + local paths."""
    from unittest.mock import AsyncMock, MagicMock, patch
    from tools_sast import _handle_sast_get_next_unverified

    # Mock DB with one unverified knowledge entry
    class MockDB:
        _assessment_id = 1

        async def query(self, table, filters=None, limit=None):
            if table == "knowledge" and filters and filters.get("category") == "sast_scan_result":
                return [
                    {
                        "id": "k1",
                        "content": json.dumps({
                            "title": "SQL Injection in auth.py",
                            "message": "Potential SQL injection vulnerability",
                        }),
                        "metadata": {
                            "verified": False,
                            "file": "src/auth.py",
                            "line": 42,
                            "vuln_class": "sql_injection",
                            "severity": "high",
                            "rule_id": "python.sql.sql-injection",
                            "remediation": "Use parameterized queries",
                        },
                    }
                ]
            return []

    # Mock MCP service
    class MockMCPService:
        current_assessment_id = 1
        activity_logger = None

    # Mock SAST runner
    mock_runner = MagicMock()
    mock_runner.repo_base_dir = "/tmp/sast_repos"
    mock_runner._exec = AsyncMock()

    # Mock find command to return repo directory
    async def mock_exec(cmd, args, timeout=None):
        if cmd == "find":
            return {
                "exit_code": 0,
                "stdout": "/tmp/sast_repos/1\n/tmp/sast_repos/1/my-app",
                "stderr": "",
            }
        elif cmd == "cat":
            return {
                "exit_code": 0,
                "stdout": """def authenticate(username, password):
    query = "SELECT * FROM users WHERE username = '" + username + "'"
    return db.execute(query)
""",
                "stderr": "",
            }
        return {"exit_code": 1, "stdout": "", "stderr": "Unknown command"}

    mock_runner._exec = mock_exec

    # Mock code indexer
    mock_indexer = MagicMock()
    mock_indexer._detect_language = MagicMock(return_value="python")
    mock_indexer.extract_function_at_line = MagicMock(return_value={
        "function_name": "authenticate",
        "code": "def authenticate(username, password):\n    query = \"SELECT * FROM users WHERE username = '\" + username + \"'\"\n    return db.execute(query)",
        "start_line": 1,
        "end_line": 3,
    })

    # Patch dependencies
    with patch("tools_sast._get_db", return_value=MockDB()):
        with patch("tools_sast.get_sast_runner", return_value=mock_runner):
            with patch("tools_sast.get_code_indexer", return_value=mock_indexer):
                result = await _handle_sast_get_next_unverified({}, MockMCPService())

    # Verify result
    result_data = json.loads(result[0].text)
    assert result_data["finding_id"] == "k1"
    assert result_data["function_name"] == "authenticate"
    assert "def authenticate" in result_data["function_code"]
    assert result_data["severity"] == "high"
    assert result_data["vuln_class"] == "sql_injection"
    assert "/mnt/d/testing_tool/AutoPentest/sast_repos/1/my-app/src/auth.py" in result_data["local_file_path"]
    assert result_data["total_remaining"] == 1


# ========== Test 5: sast_get_next_unverified All Done ==========

@pytest.mark.asyncio
async def test_sast_get_next_unverified_all_done():
    """Test sast_get_next_unverified returns 'all_verified' when no unverified remain."""
    from unittest.mock import patch
    from tools_sast import _handle_sast_get_next_unverified

    # Mock DB with all verified entries
    class MockDB:
        _assessment_id = 1

        async def query(self, table, filters=None, limit=None):
            if table == "knowledge" and filters and filters.get("category") == "sast_scan_result":
                return [
                    {"id": "k1", "metadata": {"verified": True}},
                    {"id": "k2", "metadata": {"verified": True}},
                    {"id": "k3", "metadata": {"verified": True}},
                ]
            return []

    # Mock MCP service
    class MockMCPService:
        current_assessment_id = 1
        activity_logger = None

    # Patch dependencies
    with patch("tools_sast._get_db", return_value=MockDB()):
        result = await _handle_sast_get_next_unverified({}, MockMCPService())

    # Verify result
    result_data = json.loads(result[0].text)
    assert result_data["status"] == "all_verified"
    assert result_data["total_verified"] == 3
    assert "All SAST scan results have been verified" in result_data["message"]


# ========== Test 6: sast_mark_verified Exploitable ==========

@pytest.mark.asyncio
async def test_sast_mark_verified_exploitable():
    """Test sast_mark_verified creates finding with severity + remediation when exploitable."""
    from unittest.mock import AsyncMock, MagicMock, patch
    from tools_sast import _handle_sast_mark_verified

    # Mock SafeResult
    class SafeResult:
        def __init__(self, ok, data):
            self.ok = ok
            self.data = data

    # Mock DB (Fix 4c: add_finding removed)
    class MockDB:
        _assessment_id = 1
        update_knowledge_called = False

        async def query(self, table, filters=None, limit=None):
            if table == "knowledge" and filters and filters.get("id") == "k1":
                return [
                    {
                        "id": "k1",
                        "content": json.dumps({
                            "title": "SQL Injection in auth.py",
                            "message": "Potential SQL injection vulnerability",
                            "code_snippet": "query = \"SELECT * FROM users WHERE username = '\" + username + \"'\"",
                        }),
                        "metadata": {
                            "verified": False,
                            "file": "src/auth.py",
                            "line": 42,
                            "vuln_class": "sql_injection",
                            "severity": "high",
                        },
                    }
                ]
            return []

        async def update_knowledge(self, knowledge_id, metadata=None, tags=None):
            self.update_knowledge_called = True
            assert metadata["verified"] is True
            assert metadata["exploitable"] is True
            assert metadata["false_positive"] is False
            return {"id": knowledge_id, "metadata": metadata}

    # Mock MCP service
    class MockMCPService:
        current_assessment_id = 1
        activity_logger = None

        async def safe_add_card(self, **kwargs):
            assert kwargs["severity"] == "HIGH"  # Not "INFO"
            assert kwargs["card_type"] == "finding"
            assert kwargs["status"] == "confirmed"
            return SafeResult(ok=True, data={"id": "card-1"})

    mock_db = MockDB()

    # Patch dependencies
    with patch("tools_sast._get_db", return_value=mock_db):
        result = await _handle_sast_mark_verified(
            {
                "finding_id": "k1",
                "exploitable": True,
                "false_positive": False,
                "remediation": "Use parameterized queries",
            },
            MockMCPService(),
        )

    # Verify update_knowledge was called
    assert mock_db.update_knowledge_called, "update_knowledge should have been called"

    # Verify result (Fix 4c: add_finding removed, only safe_add_card creates findings now)
    result_data = json.loads(result[0].text)
    assert result_data["success"] is True
    assert result_data["card_id"] == "card-1"
    assert result_data["finding_id"] == "card-1"  # finding_id is same as card_id
    assert result_data["action"] == "finding_recorded"


# ========== Test 7: sast_mark_verified Informational ==========

@pytest.mark.asyncio
async def test_sast_mark_verified_informational():
    """Test sast_mark_verified creates info finding when not exploitable."""
    from unittest.mock import patch
    from tools_sast import _handle_sast_mark_verified

    # Mock SafeResult
    class SafeResult:
        def __init__(self, ok, data):
            self.ok = ok
            self.data = data

    # Mock DB
    class MockDB:
        _assessment_id = 1

        async def query(self, table, filters=None, limit=None):
            if table == "knowledge":
                return [
                    {
                        "id": "k2",
                        "content": json.dumps({
                            "message": "Hardcoded password in config",
                        }),
                        "metadata": {
                            "verified": False,
                            "file": "config.py",
                            "line": 10,
                            "vuln_class": "hardcoded_secret",
                            "severity": "medium",
                        },
                    }
                ]
            return []

        async def update_knowledge(self, knowledge_id, metadata=None, tags=None):
            return {"id": knowledge_id, "metadata": metadata}

        async def add_finding(self, **kwargs):
            # Verify severity is downgraded to info
            assert kwargs["severity"] == "info"
            return {"id": "f2"}

    # Mock MCP service
    class MockMCPService:
        current_assessment_id = 1
        activity_logger = None

        async def safe_add_card(self, **kwargs):
            # Verify severity is INFO when not exploitable
            assert kwargs["severity"] == "INFO"
            assert "could not be demonstrated dynamically" in kwargs["description"]
            return SafeResult(ok=True, data={"id": "card-2"})

    # Patch dependencies
    with patch("tools_sast._get_db", return_value=MockDB()):
        result = await _handle_sast_mark_verified(
            {
                "finding_id": "k2",
                "exploitable": False,
                "false_positive": False,
                "notes": "Tried to exploit but couldn't reproduce",
            },
            MockMCPService(),
        )

    # Verify result
    result_data = json.loads(result[0].text)
    assert result_data["success"] is True
    assert result_data["card_id"] == "card-2"


# ========== Test 8: sast_mark_verified False Positive ==========

@pytest.mark.asyncio
async def test_sast_mark_verified_false_positive():
    """Test sast_mark_verified doesn't create finding for false positives."""
    from unittest.mock import patch
    from tools_sast import _handle_sast_mark_verified

    # Mock DB
    class MockDB:
        _assessment_id = 1
        add_finding_called = False

        async def query(self, table, filters=None, limit=None):
            if table == "knowledge":
                return [
                    {
                        "id": "k3",
                        "content": json.dumps({"message": "False positive alert"}),
                        "metadata": {
                            "verified": False,
                            "file": "test.py",
                            "line": 5,
                            "vuln_class": "sql_injection",
                            "severity": "high",
                        },
                    }
                ]
            return []

        async def update_knowledge(self, knowledge_id, metadata=None, tags=None):
            assert metadata["false_positive"] is True
            return {"id": knowledge_id, "metadata": metadata}

        async def add_finding(self, **kwargs):
            # This should NOT be called
            self.add_finding_called = True

    # Mock MCP service
    class MockMCPService:
        current_assessment_id = 1
        activity_logger = None
        safe_add_card_called = False

        async def safe_add_card(self, **kwargs):
            # This should NOT be called for false positives
            self.safe_add_card_called = True

    mock_db = MockDB()
    mock_mcp = MockMCPService()

    # Patch dependencies
    with patch("tools_sast._get_db", return_value=mock_db):
        result = await _handle_sast_mark_verified(
            {
                "finding_id": "k3",
                "exploitable": False,
                "false_positive": True,
                "notes": "This is a false positive - input is sanitized earlier",
            },
            mock_mcp,
        )

    # Verify NO finding or card was created
    assert not mock_db.add_finding_called, "add_finding should NOT be called for false positives"
    assert not mock_mcp.safe_add_card_called, "safe_add_card should NOT be called for false positives"

    # Verify result
    result_data = json.loads(result[0].text)
    assert result_data["success"] is True
    assert result_data["action"] == "marked_false_positive"
    assert result_data["finding_id"] == "k3"


# ========== Test 9: Scan Stores Results in Knowledge ==========

@pytest.mark.asyncio
async def test_scan_stores_results_in_knowledge():
    """Test Semgrep handler stores findings in wm_knowledge."""
    from unittest.mock import AsyncMock, MagicMock, patch
    from tools_sast import _handle_sast_scan_semgrep

    # Mock DB to track store_knowledge calls (Fix 4a: add_finding removed)
    class MockDB:
        _assessment_id = 1
        store_knowledge_calls = []

        async def store_knowledge(self, title, content, category, source_tool, metadata, tags):
            self.store_knowledge_calls.append({
                "title": title,
                "category": category,
                "source_tool": source_tool,
                "metadata": metadata,
                "tags": tags,
            })

    # Mock SAST runner
    mock_runner = MagicMock()
    mock_runner.repo_base_dir = "/tmp/sast_repos"
    mock_runner._exec = AsyncMock()

    # Mock find command
    async def mock_exec(cmd, args, timeout=None):
        if cmd == "find":
            return {
                "exit_code": 0,
                "stdout": "/tmp/sast_repos/1\n/tmp/sast_repos/1/my-app",
                "stderr": "",
            }
        return {"exit_code": 1, "stdout": "", "stderr": ""}

    mock_runner._exec = mock_exec

    # Mock run_semgrep to return 2 findings (1 high, 1 medium)
    mock_runner.run_semgrep = AsyncMock(return_value={
        "success": True,
        "findings": [
            {
                "title": "SQL Injection",
                "message": "SQL injection vulnerability",
                "severity": "high",
                "vuln_class": "sql_injection",
                "file": "auth.py",
                "line": 42,
                "rule_id": "python.sql.sql-injection",
                "language": "python",
                "confidence": 0.9,
            },
            {
                "title": "XSS",
                "message": "Cross-site scripting vulnerability",
                "severity": "medium",
                "vuln_class": "xss_reflected",
                "file": "views.py",
                "line": 100,
                "rule_id": "python.xss.xss-reflected",
                "language": "python",
                "confidence": 0.7,
            },
        ],
        "findings_count": 2,
    })

    # Mock MCP service
    class MockMCPService:
        current_assessment_id = 1
        activity_logger = None

    mock_db = MockDB()

    # Patch dependencies
    with patch("tools_sast._get_db", return_value=mock_db):
        with patch("tools_sast.get_sast_runner", return_value=mock_runner):
            result = await _handle_sast_scan_semgrep({}, MockMCPService())

    # Verify store_knowledge was called twice
    assert len(mock_db.store_knowledge_calls) == 2, f"Expected 2 store_knowledge calls, got {len(mock_db.store_knowledge_calls)}"

    # Verify first finding
    call1 = mock_db.store_knowledge_calls[0]
    assert call1["category"] == "sast_scan_result"
    assert call1["source_tool"] == "sast_semgrep"
    assert call1["metadata"]["verified"] is False
    assert call1["metadata"]["vuln_class"] == "sql_injection"
    assert call1["metadata"]["severity"] == "high"
    assert call1["tags"] == ["python", "sql_injection"]

    # Verify second finding
    call2 = mock_db.store_knowledge_calls[1]
    assert call2["metadata"]["vuln_class"] == "xss_reflected"
    assert call2["tags"] == ["python", "xss_reflected"]

    # Fix 4a: add_finding removed - all findings go to wm_knowledge, not wm_findings
    # The safe_add_card + wm_finding sync happens later via sast_mark_verified


# ========== Test 10: sast_all_verified Repeat Condition ==========

@pytest.mark.asyncio
async def test_sast_all_verified_repeat_condition():
    """Test sast_all_verified repeats when unverified exist, advances when done."""
    from tools_auto_run import _check_repeat_condition

    # Mock DB with unverified results
    class MockDB:
        def __init__(self, verified=False):
            self._assessment_id = 1
            self._verified = verified

        async def query(self, table, filters=None, limit=None, update=None):
            if table == "knowledge" and filters and filters.get("category") == "sast_scan_result":
                if self._verified:
                    return [
                        {"id": "1", "metadata": {"verified": True}},
                        {"id": "2", "metadata": {"verified": True}},
                    ]
                else:
                    return [
                        {"id": "1", "metadata": {"verified": False}},
                        {"id": "2", "metadata": {"verified": False}},
                    ]
            return []

    class MockMCPService:
        activity_logger = None

    # Should repeat when unverified exist
    db = MockDB(verified=False)
    mcp_service = MockMCPService()

    should_repeat = await _check_repeat_condition(
        {"sast_all_verified": True},
        mcp_service,
        db
    )
    assert should_repeat is True

    # Test with all verified
    db_verified = MockDB(verified=True)
    should_repeat = await _check_repeat_condition(
        {"sast_all_verified": True},
        mcp_service,
        db_verified
    )
    assert should_repeat is False


# ========== Test 11: Runbook Has SAST Steps ==========

def test_runbook_has_sast_steps():
    """Verify RUNBOOK_STEPS contains all SAST steps in dedicated Phase 3."""
    from tools_auto_run import RUNBOOK_STEPS

    phase_3_steps = RUNBOOK_STEPS[3]
    phase_5_steps = RUNBOOK_STEPS[5]

    # Phase 3 (SAST) should have: clone (3.1), index (3.2), semgrep (3.3), bandit (3.4), gitleaks (3.5), verify (3.6), gate check (3.7), advance (3.8)
    phase_3_ids = [s["id"] for s in phase_3_steps]
    assert "3.1" in phase_3_ids  # clone
    assert "3.2" in phase_3_ids  # index
    assert "3.3" in phase_3_ids  # semgrep
    assert "3.4" in phase_3_ids  # bandit
    assert "3.5" in phase_3_ids  # gitleaks
    assert "3.6" in phase_3_ids  # get_next_unverified (repeatable)
    assert "3.7" in phase_3_ids  # orchestration_status (gate check)
    assert "3.8" in phase_3_ids  # advance

    # Verify tools are correct
    phase_3_tools = {s["id"]: s["tool"] for s in phase_3_steps}
    assert phase_3_tools["3.1"] == "sast_clone_repo"
    assert phase_3_tools["3.2"] == "sast_index_repo"
    assert phase_3_tools["3.3"] == "sast_scan_semgrep"
    assert phase_3_tools["3.4"] == "sast_scan_bandit"
    assert phase_3_tools["3.5"] == "sast_scan_gitleaks"
    assert phase_3_tools["3.6"] == "sast_get_next_unverified"
    assert phase_3_tools["3.7"] == "orchestration_status"
    assert phase_3_tools["3.8"] == "orchestration_advance"

    # Phase 5 should have sast_correlate as first step (5.1)
    phase_5_ids = [s["id"] for s in phase_5_steps]
    assert "5.1" in phase_5_ids  # correlate
    phase_5_tools = {s["id"]: s["tool"] for s in phase_5_steps}
    assert phase_5_tools["5.1"] == "sast_correlate"


# ========== Test 12: Runbook Step Count ==========

def test_runbook_step_count():
    """Verify total step count is 40 in 6-phase structure."""
    from tools_auto_run import RUNBOOK_STEPS

    total_steps = sum(len(steps) for steps in RUNBOOK_STEPS.values())
    assert total_steps == 40, f"Expected 40 steps, got {total_steps}"

    # Verify phase counts (6-phase structure)
    assert len(RUNBOOK_STEPS) == 6, f"Expected 6 phases, got {len(RUNBOOK_STEPS)}"
    assert len(RUNBOOK_STEPS[1]) == 7  # Phase 1: Reconnaissance
    assert len(RUNBOOK_STEPS[2]) == 6  # Phase 2: Mapping (SAST steps moved to Phase 3)
    assert len(RUNBOOK_STEPS[3]) == 8  # Phase 3: SAST Code Review (new phase)
    assert len(RUNBOOK_STEPS[4]) == 8  # Phase 4: Vulnerability Assessment (was Phase 3)
    assert len(RUNBOOK_STEPS[5]) == 8  # Phase 5: Exploitation (was Phase 4)
    assert len(RUNBOOK_STEPS[6]) == 3  # Phase 6: Reporting (was Phase 5)
