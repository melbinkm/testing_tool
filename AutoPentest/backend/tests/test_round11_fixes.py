"""
Test Round 11 Fixes - Deep Audit Assessment 4 vs 10 Gap Analysis

Tests for:
- Part 1: Auto-persist risk signals as findings
- Part 2: Activity feed type translation
- Part 3: Phase progress gates and notes
- Part 4: New vuln classes (weak_password_policy, input_validation)
"""

import unittest
import sys
import os

# Add mcp/modules to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))


# Part 3: Phase progress tests (no async needed, just data validation)

class TestPhaseProgressGates(unittest.TestCase):
    """Test phase gate conditions."""

    def test_phase3_gates_lowered(self):
        """Test that Phase 3 gates have been lowered to 5 endpoints and 1 finding."""
        from lib.phase_orchestrator import PHASES

        phase3 = PHASES[2]  # 0-indexed
        self.assertEqual(phase3["phase"], 3)
        self.assertEqual(phase3["gates"]["min_endpoints"], 5)
        self.assertEqual(phase3["gates"]["min_findings"], 1)
        self.assertNotIn("min_hypotheses", phase3["gates"])


# Part 4: New vuln classes tests

class TestNewVulnClasses(unittest.TestCase):
    """Test new vulnerability classes (weak_password_policy, input_validation)."""

    def test_weak_password_policy_spec_exists(self):
        """Test that weak_password_policy vuln spec exists in checklist."""
        from lib.vuln_checklist import get_vuln_checklist

        checklist = get_vuln_checklist()
        spec = checklist.get_spec_by_id('weak_password_policy')

        self.assertIsNotNone(spec)
        self.assertEqual(spec.name, 'Weak Password Policy')
        self.assertEqual(spec.category, 'auth')
        self.assertIn('medium', spec.severity_range)

    def test_input_validation_spec_exists(self):
        """Test that input_validation vuln spec exists in checklist."""
        from lib.vuln_checklist import get_vuln_checklist

        checklist = get_vuln_checklist()
        spec = checklist.get_spec_by_id('input_validation')

        self.assertIsNotNone(spec)
        self.assertEqual(spec.name, 'Insufficient Input Validation')
        self.assertEqual(spec.category, 'config')

    def test_weak_password_payloads_exist(self):
        """Test that weak password payloads are available."""
        from lib.payload_registry import get_payload_registry

        registry = get_payload_registry()
        payloads = registry.get_payloads('weak_password_policy')

        self.assertGreater(len(payloads), 0)
        self.assertIn('password', payloads)  # Should include common weak passwords
        self.assertIn('12345678', payloads)

    def test_input_validation_payloads_exist(self):
        """Test that input validation payloads are available."""
        from lib.payload_registry import get_payload_registry

        registry = get_payload_registry()
        payloads = registry.get_payloads('input_validation', context={'parameter': {'type': 'string'}})

        self.assertGreater(len(payloads), 0)
        # Should include various validation-breaking inputs
        long_string = next((p for p in payloads if len(str(p)) > 1000), None)
        self.assertIsNotNone(long_string, "Should include very long string")

    def test_input_validation_payloads_context_aware(self):
        """Test that input validation payloads adapt to parameter type."""
        from lib.payload_registry import get_payload_registry

        registry = get_payload_registry()

        # Number type should include numeric edge cases
        num_payloads = registry.get_payloads('input_validation',
                                             context={'parameter': {'type': 'integer'}})
        has_nan = any('NaN' in str(p) for p in num_payloads)
        self.assertTrue(has_nan, "Integer type should include NaN payload")

        # Email type should include invalid email formats
        email_payloads = registry.get_payloads('input_validation',
                                               context={'parameter': {'type': 'email'}})
        has_invalid_email = any('@example.com' == str(p) for p in email_payloads)
        self.assertTrue(has_invalid_email, "Email type should include invalid email")

    def test_payload_counts_updated(self):
        """Test that payload counts reflect new vuln classes."""
        from lib.payload_registry import get_payload_registry

        registry = get_payload_registry()
        counts = registry.get_all_payload_counts()

        self.assertIn('weak_password_policy', counts)
        self.assertIn('input_validation', counts)
        self.assertGreater(counts['weak_password_policy'], 0)
        self.assertGreater(counts['input_validation'], 0)


# Part 2: Activity log type translation tests

class TestActivityLogTypeTranslation(unittest.TestCase):
    """Test activity log type translation mapping."""

    def test_translate_type_maps_tool_execution(self):
        """Test that tool_execution/* types are translated correctly."""
        from api.activity_log import _translate_type

        self.assertEqual(_translate_type("tool_execution/started"), "tool_started")
        self.assertEqual(_translate_type("tool_execution/completed"), "tool_completed")
        self.assertEqual(_translate_type("tool_execution/failed"), "tool_failed")

    def test_translate_type_handles_unmapped(self):
        """Test that unmapped types pass through unchanged."""
        from api.activity_log import _translate_type

        self.assertEqual(_translate_type("custom_event"), "custom_event")
        self.assertEqual(_translate_type("unknown"), "unknown")

    def test_translate_type_maps_phase_transition(self):
        """Test that phase_transition is mapped to phase_changed."""
        from api.activity_log import _translate_type

        self.assertEqual(_translate_type("phase_transition"), "phase_changed")


# Part 1: Risk signal mapping tests

class TestRiskSignalMapping(unittest.TestCase):
    """Test risk signal to card mapping."""

    def test_risk_signal_cards_mapping_exists(self):
        """Test that the risk signal card mapping exists in AutoPentestService."""
        from service import AutoPentestService

        self.assertTrue(hasattr(AutoPentestService, '_RISK_SIGNAL_CARDS'))
        self.assertIsInstance(AutoPentestService._RISK_SIGNAL_CARDS, dict)

    def test_risk_signal_cards_have_required_fields(self):
        """Test that each risk signal card mapping has title, severity, and class."""
        from service import AutoPentestService

        for sig_type, card_info in AutoPentestService._RISK_SIGNAL_CARDS.items():
            self.assertEqual(len(card_info), 3, f"Signal {sig_type} should have 3 fields")
            title, severity, vuln_class = card_info
            self.assertIsInstance(title, str)
            self.assertIn(severity, ['low', 'medium', 'high', 'critical', 'info'])
            self.assertIsInstance(vuln_class, str)

    def test_high_severity_signals_mapped(self):
        """Test that high-severity signals are included in mapping."""
        from service import AutoPentestService

        mapping = AutoPentestService._RISK_SIGNAL_CARDS

        # Critical signals
        self.assertIn('cors_wildcard', mapping)
        self.assertEqual(mapping['cors_wildcard'][1], 'high')

        self.assertIn('template_injection', mapping)
        self.assertEqual(mapping['template_injection'][1], 'high')

    def test_medium_severity_signals_mapped(self):
        """Test that medium-severity signals are included in mapping."""
        from service import AutoPentestService

        mapping = AutoPentestService._RISK_SIGNAL_CARDS

        self.assertIn('missing_hsts', mapping)
        self.assertEqual(mapping['missing_hsts'][1], 'medium')

        self.assertIn('csrf_no_token', mapping)
        self.assertEqual(mapping['csrf_no_token'][1], 'medium')


if __name__ == '__main__':
    unittest.main()
