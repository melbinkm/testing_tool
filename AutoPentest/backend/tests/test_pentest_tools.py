"""
Tests for LLM-in-the-loop pentest tools

16 tests validating the 8 new pentest tools that expose raw HTTP traffic
and attack surface data to the LLM for manual security testing.
"""

import sys
import os
import json
import unittest
from unittest.mock import AsyncMock, MagicMock, patch

# Add modules to path (avoid pip mcp package shadowing)
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

from tools_pentest import (
    get_pentest_tools,
    handle_pentest_tool,
    _truncate_body,
    _compute_baseline_diff,
    _parse_security_headers,
)


class TestPentestTools(unittest.IsolatedAsyncioTestCase):
    """Test suite for pentest tools."""

    def setUp(self):
        """Set up test fixtures."""
        # Mock MCP service
        self.mcp_service = MagicMock()
        self.mcp_service.current_assessment_id = 1
        self.mcp_service.scope_provider = MagicMock()
        self.mcp_service.activity_logger = None

        # Mock HTTP client
        self.http_client = MagicMock()
        self.http_client.send = AsyncMock()
        self.http_client.get_stats = MagicMock(return_value={
            "total_requests": 42,
            "max_total_requests": 10000,
        })

        # Mock world model DB
        self.db_mock = AsyncMock()

    def test_tool_definitions(self):
        """Test that all 8 tools are defined correctly."""
        tools = get_pentest_tools()
        self.assertEqual(len(tools), 8)

        tool_names = [t.name for t in tools]
        expected_names = [
            "recon_endpoint",
            "get_test_payloads",
            "inject_payload",
            "inject_batch",
            "analyze_headers",
            "discover_attack_surface",
            "record_finding",
            "get_test_progress",
        ]
        self.assertEqual(tool_names, expected_names)

    # ========== Test 1-2: recon_endpoint ==========

    async def test_recon_endpoint_returns_full_body(self):
        """Test recon_endpoint returns full response body (not truncated to 500)."""
        # Setup
        large_body = "A" * 6000  # 6KB body
        self.http_client.send.return_value = {
            "status": 200,
            "statusText": "OK",
            "headers": {"content-type": "text/html"},
            "body": large_body,
            "timing": {"duration_ms": 145},
        }

        # Patch _get_http_client
        with patch('tools_pentest._get_http_client', return_value=self.http_client):
            result = await handle_pentest_tool(
                "recon_endpoint",
                {"url": "https://example.com", "max_response_body": 8192},
                self.mcp_service
            )

        # Verify
        data = json.loads(result[0].text)
        self.assertEqual(len(data["response"]["body"]), 6000)
        self.assertFalse(data["metadata"]["body_truncated"])

    async def test_recon_endpoint_max_body_limit(self):
        """Test recon_endpoint respects max_response_body parameter."""
        # Setup
        large_body = "B" * 10000
        self.http_client.send.return_value = {
            "status": 200,
            "statusText": "OK",
            "headers": {"content-type": "application/json"},
            "body": large_body,
            "timing": {"duration_ms": 200},
        }

        with patch('tools_pentest._get_http_client', return_value=self.http_client):
            result = await handle_pentest_tool(
                "recon_endpoint",
                {"url": "https://example.com", "max_response_body": 2048},
                self.mcp_service
            )

        data = json.loads(result[0].text)
        self.assertEqual(len(data["response"]["body"]), 2048)
        self.assertTrue(data["metadata"]["body_truncated"])
        self.assertEqual(data["metadata"]["body_length"], 10000)

    # ========== Test 3-6: get_test_payloads ==========

    async def test_get_payloads_sqli(self):
        """Test get_test_payloads returns non-empty payload list for sqli_error."""
        result = await handle_pentest_tool(
            "get_test_payloads",
            {"vuln_class": "sqli_error", "limit": 10},
            self.mcp_service
        )

        data = json.loads(result[0].text)
        self.assertEqual(data["vuln_class"], "sqli_error")
        self.assertGreater(data["total_available"], 0)
        self.assertGreater(len(data["payloads"]), 0)
        self.assertLessEqual(len(data["payloads"]), 10)

        # Verify payload structure
        payload = data["payloads"][0]
        self.assertIn("index", payload)
        self.assertIn("value", payload)
        self.assertIsInstance(payload["value"], str)

    async def test_get_payloads_unknown_class(self):
        """Test get_test_payloads returns empty list for unknown vuln class."""
        result = await handle_pentest_tool(
            "get_test_payloads",
            {"vuln_class": "nonexistent_vuln_class", "limit": 10},
            self.mcp_service
        )

        data = json.loads(result[0].text)
        self.assertEqual(data["total_available"], 0)
        self.assertEqual(len(data["payloads"]), 0)

    async def test_get_payloads_limit(self):
        """Test get_test_payloads respects limit parameter."""
        result = await handle_pentest_tool(
            "get_test_payloads",
            {"vuln_class": "xss_reflected", "limit": 5},
            self.mcp_service
        )

        data = json.loads(result[0].text)
        self.assertLessEqual(len(data["payloads"]), 5)

    async def test_get_payloads_lists_classes(self):
        """Test get_test_payloads includes available_classes list."""
        result = await handle_pentest_tool(
            "get_test_payloads",
            {"vuln_class": "sqli_error"},
            self.mcp_service
        )

        data = json.loads(result[0].text)
        self.assertIn("available_classes", data)
        self.assertIsInstance(data["available_classes"], list)
        self.assertGreater(len(data["available_classes"]), 40)  # Should have 46 classes

    # ========== Test 7-9: inject_payload ==========

    async def test_inject_payload_query(self):
        """Test inject_payload injects into query parameter correctly."""
        self.http_client.send.return_value = {
            "status": 200,
            "statusText": "OK",
            "headers": {},
            "body": "Response body",
            "timing": {"duration_ms": 100},
        }

        with patch('tools_pentest._get_http_client', return_value=self.http_client):
            result = await handle_pentest_tool(
                "inject_payload",
                {
                    "url": "https://example.com/search",
                    "parameter": "q",
                    "location": "query",
                    "payload": "' OR '1'='1",
                },
                self.mcp_service
            )

        data = json.loads(result[0].text)
        # Verify payload injected into URL
        self.assertIn("q=%27+OR+%271%27%3D%271", data["request"]["url"])
        self.assertEqual(data["injection"]["parameter"], "q")
        self.assertEqual(data["injection"]["payload"], "' OR '1'='1")

    async def test_inject_payload_body_json(self):
        """Test inject_payload injects into JSON body."""
        self.http_client.send.return_value = {
            "status": 200,
            "statusText": "OK",
            "headers": {},
            "body": "OK",
            "timing": {"duration_ms": 120},
        }

        with patch('tools_pentest._get_http_client', return_value=self.http_client):
            result = await handle_pentest_tool(
                "inject_payload",
                {
                    "url": "https://example.com/api/users",
                    "method": "POST",
                    "parameter": "username",
                    "location": "body",
                    "payload": "<script>alert(1)</script>",
                    "body": '{"username": "test"}',
                },
                self.mcp_service
            )

        data = json.loads(result[0].text)
        # Verify payload in JSON body
        body = json.loads(data["request"]["body"])
        self.assertEqual(body["username"], "<script>alert(1)</script>")

    async def test_inject_payload_reflection_check(self):
        """Test inject_payload correctly detects payload reflection."""
        # Test with reflected payload
        self.http_client.send.return_value = {
            "status": 200,
            "statusText": "OK",
            "headers": {},
            "body": "Search results for: <script>alert(1)</script>",
            "timing": {"duration_ms": 90},
        }

        with patch('tools_pentest._get_http_client', return_value=self.http_client):
            result = await handle_pentest_tool(
                "inject_payload",
                {
                    "url": "https://example.com/search",
                    "parameter": "q",
                    "location": "query",
                    "payload": "<script>alert(1)</script>",
                },
                self.mcp_service
            )

        data = json.loads(result[0].text)
        self.assertTrue(data["injection"]["payload_reflected_in_body"])

    # ========== Test 10-12: inject_batch ==========

    async def test_inject_batch_baseline(self):
        """Test inject_batch sends baseline request when include_baseline=true."""
        # Mock baseline response
        baseline_resp = {
            "status": 200,
            "statusText": "OK",
            "headers": {},
            "body": "Normal response",
            "timing": {"duration_ms": 100},
        }

        # Mock payload responses
        self.http_client.send.side_effect = [
            baseline_resp,  # Baseline
            {**baseline_resp, "body": "Response 1"},  # Payload 1
            {**baseline_resp, "body": "Response 2"},  # Payload 2
        ]

        with patch('tools_pentest._get_http_client', return_value=self.http_client):
            result = await handle_pentest_tool(
                "inject_batch",
                {
                    "url": "https://example.com/search",
                    "parameter": "q",
                    "location": "query",
                    "payloads": ["payload1", "payload2"],
                    "include_baseline": True,
                },
                self.mcp_service
            )

        data = json.loads(result[0].text)
        self.assertIsNotNone(data["baseline"])
        self.assertEqual(data["baseline"]["status"], 200)
        self.assertEqual(len(data["results"]), 2)

    async def test_inject_batch_diff_detection(self):
        """Test inject_batch detects status changes and timing anomalies."""
        baseline_resp = {
            "status": 200,
            "statusText": "OK",
            "headers": {},
            "body": "A" * 1000,
            "timing": {"duration_ms": 100},
        }

        # Payload 1: status change
        # Payload 2: timing anomaly
        # Payload 3: normal
        self.http_client.send.side_effect = [
            baseline_resp,
            {"status": 500, "statusText": "Error", "headers": {}, "body": "Error", "timing": {"duration_ms": 95}},
            {"status": 200, "statusText": "OK", "headers": {}, "body": "B" * 1000, "timing": {"duration_ms": 250}},
            baseline_resp,
        ]

        with patch('tools_pentest._get_http_client', return_value=self.http_client):
            result = await handle_pentest_tool(
                "inject_batch",
                {
                    "url": "https://example.com/api",
                    "parameter": "id",
                    "location": "query",
                    "payloads": ["payload1", "payload2", "payload3"],
                    "include_baseline": True,
                },
                self.mcp_service
            )

        data = json.loads(result[0].text)
        summary = data["summary"]
        self.assertEqual(summary["status_changes"], 1)  # Payload 1
        self.assertEqual(summary["timing_anomalies"], 1)  # Payload 2 (250ms / 100ms = 2.5x)

    async def test_inject_batch_max_size(self):
        """Test inject_batch caps payloads at max_batch_size."""
        baseline_resp = {
            "status": 200,
            "statusText": "OK",
            "headers": {},
            "body": "OK",
            "timing": {"duration_ms": 100},
        }

        # 101 responses: 1 baseline + 100 payloads (capped from 150)
        self.http_client.send.return_value = baseline_resp

        with patch('tools_pentest._get_http_client', return_value=self.http_client):
            result = await handle_pentest_tool(
                "inject_batch",
                {
                    "url": "https://example.com/api",
                    "parameter": "id",
                    "location": "query",
                    "payloads": [f"payload{i}" for i in range(150)],
                    "include_baseline": True,
                    "max_batch_size": 100,
                },
                self.mcp_service
            )

        data = json.loads(result[0].text)
        self.assertEqual(len(data["results"]), 100)

    # ========== Test 13-14: analyze_headers ==========

    async def test_analyze_headers_missing_csp(self):
        """Test analyze_headers detects missing CSP header."""
        self.http_client.send.return_value = {
            "status": 200,
            "statusText": "OK",
            "headers": {
                "server": "nginx/1.18",
                "x-powered-by": "Express",
            },
            "body": "",
            "timing": {"duration_ms": 50},
        }

        with patch('tools_pentest._get_http_client', return_value=self.http_client):
            result = await handle_pentest_tool(
                "analyze_headers",
                {"url": "https://example.com"},
                self.mcp_service
            )

        data = json.loads(result[0].text)
        self.assertIn("content-security-policy", data["security_headers_missing"])
        self.assertIn("strict-transport-security", data["security_headers_missing"])
        self.assertEqual(data["server_info"]["server"], "nginx/1.18")

    async def test_analyze_headers_cookies(self):
        """Test analyze_headers correctly parses cookie flags."""
        self.http_client.send.return_value = {
            "status": 200,
            "statusText": "OK",
            "headers": {
                "set-cookie": "session=abc123; HttpOnly; Secure; SameSite=Strict",
            },
            "body": "",
            "timing": {"duration_ms": 45},
        }

        with patch('tools_pentest._get_http_client', return_value=self.http_client):
            result = await handle_pentest_tool(
                "analyze_headers",
                {"url": "https://example.com"},
                self.mcp_service
            )

        data = json.loads(result[0].text)
        self.assertEqual(len(data["cookies"]), 1)

        cookie = data["cookies"][0]
        self.assertEqual(cookie["name"], "session")
        self.assertTrue(cookie["httpOnly"])
        self.assertTrue(cookie["secure"])
        self.assertEqual(cookie["sameSite"], "Strict")

    # ========== Test 15: record_finding ==========

    async def test_record_finding_calls_safe_add_card(self):
        """Test record_finding calls safe_add_card with correct arguments."""
        # Mock safe_add_card
        mock_result = MagicMock()
        mock_result.ok = True
        mock_result.data = {"id": "card-123"}
        self.mcp_service.safe_add_card = AsyncMock(return_value=mock_result)

        # Mock DB for coverage update
        with patch('tools_pentest._get_db', return_value=self.db_mock):
            self.db_mock.query = AsyncMock(return_value=[
                {"id": "ep-1", "url": "https://example.com/api/users"}
            ])

            result = await handle_pentest_tool(
                "record_finding",
                {
                    "title": "SQL Injection in /api/users",
                    "severity": "high",
                    "url": "https://example.com/api/users",
                    "vuln_class": "sqli_error",
                    "parameter": "id",
                    "evidence": {
                        "payload": "' OR '1'='1",
                        "description": "Error-based SQLi confirmed",
                    },
                },
                self.mcp_service
            )

        # Verify safe_add_card called
        self.mcp_service.safe_add_card.assert_called_once()
        call_args = self.mcp_service.safe_add_card.call_args
        self.assertEqual(call_args.kwargs["card_type"], "finding")
        self.assertEqual(call_args.kwargs["title"], "SQL Injection in /api/users")
        self.assertEqual(call_args.kwargs["severity"], "high")

        # Verify response
        data = json.loads(result[0].text)
        self.assertTrue(data["success"])
        self.assertEqual(data["card_id"], "card-123")

    # ========== Test 16: get_test_progress ==========

    async def test_get_test_progress_aggregation(self):
        """Test get_test_progress correctly aggregates data from DB."""
        # Mock DB queries
        with patch('tools_pentest._get_db', return_value=self.db_mock):
            self.db_mock.query = AsyncMock(side_effect=[
                # endpoints query
                [
                    {"id": "ep-1", "url": "https://example.com/api/users", "method": "GET"},
                    {"id": "ep-2", "url": "https://example.com/api/posts", "method": "GET"},
                ],
                # coverage_matrix query
                [
                    {"endpoint_id": "ep-1", "vuln_class": "sqli_error", "status": "vulnerable"},
                    {"endpoint_id": "ep-1", "vuln_class": "xss_reflected", "status": "passed"},
                    {"endpoint_id": "ep-2", "vuln_class": "sqli_error", "status": "pending"},
                ],
                # findings query
                [
                    {"url": "https://example.com/api/users", "severity": "high"},
                ],
            ])

            # Patch HTTP client for budget
            with patch('tools_pentest._get_http_client', return_value=self.http_client):
                result = await handle_pentest_tool(
                    "get_test_progress",
                    {},
                    self.mcp_service
                )

        data = json.loads(result[0].text)
        self.assertEqual(data["total_endpoints"], 2)
        self.assertEqual(data["tested_endpoints"], 1)  # Only ep-1 has non-pending tests
        self.assertGreater(data["coverage_pct"], 0)
        self.assertEqual(data["findings"]["total"], 1)
        self.assertEqual(data["findings"]["high"], 1)
        self.assertEqual(data["budget"]["used"], 42)

    # ========== Helper function tests ==========

    def test_truncate_body(self):
        """Test _truncate_body helper function."""
        # No truncation
        result = _truncate_body("short", 100)
        self.assertEqual(result["body"], "short")
        self.assertFalse(result["truncated"])
        self.assertEqual(result["full_length"], 5)

        # Truncation
        result = _truncate_body("A" * 1000, 500)
        self.assertEqual(len(result["body"]), 500)
        self.assertTrue(result["truncated"])
        self.assertEqual(result["full_length"], 1000)

    def test_compute_baseline_diff(self):
        """Test _compute_baseline_diff helper function."""
        baseline = {
            "status": 200,
            "body": "A" * 1000,
            "timing_ms": 100,
        }

        # Status changed
        response = {
            "status": 500,
            "body": "B" * 1000,
            "timing_ms": 100,
        }
        diff = _compute_baseline_diff(baseline, response)
        self.assertTrue(diff["status_changed"])
        self.assertEqual(diff["body_length_diff_pct"], 0.0)
        self.assertEqual(diff["timing_ratio"], 1.0)

        # Timing anomaly
        response = {
            "status": 200,
            "body": "A" * 500,
            "timing_ms": 250,
        }
        diff = _compute_baseline_diff(baseline, response)
        self.assertFalse(diff["status_changed"])
        self.assertEqual(diff["body_length_diff_pct"], 50.0)
        self.assertEqual(diff["timing_ratio"], 2.5)

    def test_parse_security_headers(self):
        """Test _parse_security_headers helper function."""
        headers = {
            "Strict-Transport-Security": "max-age=31536000",
            "Server": "nginx/1.18",
            "Access-Control-Allow-Origin": "*",
            "Set-Cookie": "session=xyz; HttpOnly; Secure",
        }

        result = _parse_security_headers(headers)

        self.assertIn("strict-transport-security", result["security_headers_present"])
        self.assertIn("content-security-policy", result["security_headers_missing"])
        self.assertEqual(result["server_info"]["server"], "nginx/1.18")
        self.assertEqual(result["cors_headers"]["access-control-allow-origin"], "*")
        self.assertEqual(len(result["cookies"]), 1)
        self.assertTrue(result["cookies"][0]["httpOnly"])


if __name__ == "__main__":
    unittest.main()
