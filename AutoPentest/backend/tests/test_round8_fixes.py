"""
Tests for Deep Audit Round 8 fixes.

Verifies 4 critical bugs discovered during verification of Assessment 4 vs 6 gap fixes:
1. Severity case mismatch preventing wm_findings sync
2. Wrong identity_store import preventing auth testing
3. Non-existent get_scope() breaking scope validation
4. Missing complete_assessment() exposure blocking phase 5 completion
"""

import unittest
from unittest.mock import AsyncMock, MagicMock, patch
import sys
import os

# Add mcp/modules directory to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "mcp", "modules"))


class TestRound8Fixes(unittest.IsolatedAsyncioTestCase):
    """Test Round 8 bug fixes."""

    async def test_fix1_severity_lowercased_for_wm_findings(self):
        """
        Fix 1: Verify severity is lowercased before passing to add_finding().

        Bug: safe_add_card() passes UPPERCASE severity (e.g. "HIGH"), but
        world_model_db.py:825 validates against lowercase-only HYPOTHESIS_SEVERITIES.

        Fix: service.py:566 now calls .lower() on severity.
        """
        # Direct test: Read service.py line 566 and verify .lower() is present
        import os
        service_path = os.path.join(
            os.path.dirname(__file__),
            "..", "mcp", "modules", "service.py"
        )

        with open(service_path, 'r') as f:
            content = f.read()

        # Find the specific line where severity is passed to add_finding
        # Should contain: severity=kwargs.get("severity", "MEDIUM").lower(),
        self.assertIn(
            'severity=kwargs.get("severity", "MEDIUM").lower()',
            content,
            "service.py should call .lower() on severity before passing to add_finding()"
        )

        # Verify that the UPPERCASE default is lowercased
        from lib.world_model_db import WorldModelDatabase
        mock_db = AsyncMock(spec=WorldModelDatabase)
        mock_db.add_finding = AsyncMock()

        # Simulate the code path
        kwargs = {"severity": "HIGH", "status": "confirmed"}
        title = "Test XSS"

        # This simulates what service.py:563-576 does
        hypothesis_id = "auto-test"
        await mock_db.add_finding(
            hypothesis_id=hypothesis_id,
            title=title,
            severity=kwargs.get("severity", "MEDIUM").lower(),  # This is the fix
            confidence=0.8,
            evidence_ids=[],
            remediation=kwargs.get("remediation"),
            metadata={}
        )

        # Verify lowercase was used
        call_kwargs = mock_db.add_finding.call_args.kwargs
        self.assertEqual(call_kwargs['severity'], 'high')

    async def test_fix2_identity_store_import_correct(self):
        """
        Fix 2: Verify import path is lib.identity_store, not lib.auth_identity_store.

        Bug: tools_sequences.py:61 imported from non-existent lib.auth_identity_store.

        Fix: Changed to lib.identity_store.
        """
        # This test verifies the import doesn't raise an exception
        try:
            from lib.identity_store import IdentityStore
            identity_store = IdentityStore()
            self.assertIsNotNone(identity_store)
        except ImportError as e:
            self.fail(f"Identity store import failed: {e}")

        # Verify the helper function in tools_sequences works
        import tools_sequences

        # Mock MCP service (required after Round 9 changes)
        mock_service = MagicMock()
        mock_service.current_assessment_id = "test-assessment"

        # Mock world model DB
        with patch("lib.world_model_db.get_world_model_db") as mock_db_factory:
            mock_db = AsyncMock()
            mock_db.query = AsyncMock(return_value=[])
            mock_db_factory.return_value = mock_db

            identity_store = await tools_sequences._get_identity_store(mock_service)
            self.assertIsNotNone(identity_store)

    def test_fix3_scope_loader_uses_load_scope_from_env(self):
        """
        Fix 3: Verify scope_loader imports use load_scope_from_env, not get_scope.

        Bug: 5 locations imported non-existent get_scope() function.

        Fix: Changed to load_scope_from_env() in tools_sequences.py (4 places) and
        tools_browser.py (1 place).
        """
        # Verify the correct function exists and can be imported
        try:
            from lib.scope_loader import load_scope_from_env
            self.assertTrue(callable(load_scope_from_env))
        except ImportError as e:
            self.fail(f"load_scope_from_env import failed: {e}")

        # Verify get_scope does NOT exist (it was the bug)
        from lib import scope_loader
        self.assertFalse(hasattr(scope_loader, 'get_scope'))

        # Verify the actual functions that DO exist
        self.assertTrue(hasattr(scope_loader, 'load_scope_from_env'))
        self.assertTrue(hasattr(scope_loader, 'load_scope'))
        self.assertTrue(hasattr(scope_loader, 'validate_scope'))
        self.assertTrue(hasattr(scope_loader, 'normalize_scope'))

    async def test_fix4_complete_assessment_exposed_via_target_phase_7(self):
        """
        Fix 4: Verify target_phase=7 triggers complete_assessment().

        Bug: PhaseOrchestrator.complete_assessment() existed but wasn't exposed via MCP.

        Fix: orchestration_advance now accepts target_phase=7 to complete phase 6 (the final phase).
        """
        from tools_assessment import _handle_orchestration_advance
        from service import AutoPentestService
        from lib.phase_orchestrator import PhaseOrchestrator

        # Mock the service
        mock_service = MagicMock(spec=AutoPentestService)
        mock_service.current_assessment_id = "test-assessment-456"
        mock_service.activity_logger = MagicMock()
        mock_service.update_section = AsyncMock()

        # Mock the orchestrator
        mock_orchestrator = AsyncMock(spec=PhaseOrchestrator)
        mock_orchestrator.complete_assessment = AsyncMock(return_value={
            "success": True,
            "message": "Assessment completed",
            "phase": 6,
            "status": "done"
        })

        # Mock dependencies
        mock_db = AsyncMock()

        with patch('lib.world_model_db.get_world_model_db', return_value=mock_db):
            with patch('lib.phase_orchestrator.PhaseOrchestrator', return_value=mock_orchestrator):
                # Call with target_phase=7 (marks phase 6 as complete)
                result = await _handle_orchestration_advance(
                    arguments={"target_phase": 7, "force": False},
                    mcp_service=mock_service
                )

        # Verify complete_assessment was called
        self.assertTrue(mock_orchestrator.complete_assessment.called)

        # Verify response indicates success
        self.assertEqual(len(result), 1)
        import json
        response_data = json.loads(result[0].text)
        self.assertTrue(response_data['success'])
        self.assertEqual(response_data['message'], 'Assessment completed')

    async def test_fix1_all_severities_lowercased(self):
        """
        Comprehensive test: Verify all valid severities are lowercased.
        """
        from lib.world_model_db import WorldModelDatabase

        # Test all standard severities
        test_cases = [
            ("CRITICAL", "critical"),
            ("HIGH", "high"),
            ("MEDIUM", "medium"),
            ("LOW", "low"),
            ("INFO", "info"),
        ]

        for input_severity, expected_severity in test_cases:
            mock_db = AsyncMock(spec=WorldModelDatabase)
            mock_db.add_finding = AsyncMock()

            # Simulate the service.py:566 code path directly
            kwargs = {"severity": input_severity}
            await mock_db.add_finding(
                hypothesis_id=f"test-{input_severity}",
                title=f"Test {input_severity}",
                severity=kwargs.get("severity", "MEDIUM").lower(),  # The fix
                confidence=0.8,
                evidence_ids=[],
                remediation=None,
                metadata={}
            )

            # Verify lowercase conversion
            call_kwargs = mock_db.add_finding.call_args.kwargs
            self.assertEqual(
                call_kwargs['severity'],
                expected_severity,
                f"Failed for severity {input_severity}: got {call_kwargs['severity']}"
            )

    async def test_fix4_normal_phase_transitions_still_work(self):
        """
        Verify normal phase transitions (1-6) still work after Fix 4.
        """
        from tools_assessment import _handle_orchestration_advance
        from service import AutoPentestService
        from lib.phase_orchestrator import PhaseOrchestrator

        mock_service = MagicMock(spec=AutoPentestService)
        mock_service.current_assessment_id = "test-assessment-789"
        mock_service.activity_logger = MagicMock()
        mock_service.update_section = AsyncMock()

        mock_orchestrator = AsyncMock(spec=PhaseOrchestrator)
        mock_orchestrator.advance = AsyncMock(return_value={
            "success": True,
            "new_phase": 3,
            "message": "Advanced to Phase 3"
        })

        mock_db = AsyncMock()

        with patch('lib.world_model_db.get_world_model_db', return_value=mock_db):
            with patch('lib.phase_orchestrator.PhaseOrchestrator', return_value=mock_orchestrator):
                # Call with normal target_phase=3
                result = await _handle_orchestration_advance(
                    arguments={"target_phase": 3, "force": False},
                    mcp_service=mock_service
                )

        # Verify advance was called (not complete_assessment)
        self.assertTrue(mock_orchestrator.advance.called)
        self.assertFalse(mock_orchestrator.complete_assessment.called)

        # Verify correct response
        import json
        response_data = json.loads(result[0].text)
        self.assertTrue(response_data['success'])
        self.assertEqual(response_data['new_phase'], 3)

    def test_fix3_sequence_tools_scope_import(self):
        """
        Verify all 4 sequence tool handlers can import scope_loader correctly.
        """
        # Read tools_sequences.py and verify no "get_scope" references
        sequences_path = os.path.join(
            os.path.dirname(__file__),
            "..", "mcp", "modules", "tools_sequences.py"
        )

        with open(sequences_path, 'r') as f:
            content = f.read()

        # Should NOT contain the broken import
        self.assertNotIn('from lib.scope_loader import get_scope', content)

        # Should contain the correct import
        self.assertIn('from lib.scope_loader import load_scope_from_env', content)

        # Verify it's used in the right places (4 occurrences)
        count = content.count('scope = load_scope_from_env()')
        self.assertEqual(count, 4, f"Expected 4 uses of load_scope_from_env(), found {count}")

    def test_fix3_browser_tools_scope_import(self):
        """
        Verify browser tools use correct scope_loader import.
        """
        browser_path = os.path.join(
            os.path.dirname(__file__),
            "..", "mcp", "modules", "tools_browser.py"
        )

        with open(browser_path, 'r') as f:
            content = f.read()

        # Should NOT contain the broken import
        self.assertNotIn('from lib.scope_loader import get_scope', content)

        # Should contain the correct import
        self.assertIn('from lib.scope_loader import load_scope_from_env', content)

        # Should have at least 1 usage
        self.assertIn('scope = load_scope_from_env()', content)


if __name__ == '__main__':
    unittest.main()
