"""
Tests for Testing Engine - Test orchestrator and MCP tools.
"""

import os
import sys
import unittest
from unittest.mock import Mock, AsyncMock, patch
import json

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "mcp", "modules"))

from lib.test_orchestrator import (
    TestOrchestrator, OrchestratorState, ContinueDecision, CellTestingState
)


class TestTestOrchestrator(unittest.TestCase):
    """Test test orchestrator functionality."""

    def setUp(self):
        """Set up test fixtures."""
        self.orchestrator = TestOrchestrator(
            assessment_id=1,
            base_url="http://test.example.com"
        )

    def test_initial_state(self):
        """Test orchestrator initializes in INIT state."""
        self.assertEqual(self.orchestrator.state, OrchestratorState.INIT)
        self.assertEqual(self.orchestrator.assessment_id, 1)
        self.assertEqual(self.orchestrator.base_url, "http://test.example.com")
        self.assertEqual(len(self.orchestrator.crawl_history), 0)

    def test_state_transition(self):
        """Test state transitions."""
        self.orchestrator.transition_to(OrchestratorState.CRAWL)
        self.assertEqual(self.orchestrator.state, OrchestratorState.CRAWL)

        self.orchestrator.transition_to(OrchestratorState.TEST)
        self.assertEqual(self.orchestrator.state, OrchestratorState.TEST)

    def test_record_crawl(self):
        """Test crawl recording."""
        self.orchestrator.record_crawl(
            crawl_id="crawl-123",
            endpoint_count=25,
            identity_id=None,
            trigger="initial"
        )

        self.assertEqual(len(self.orchestrator.crawl_history), 1)
        crawl = self.orchestrator.crawl_history[0]
        self.assertEqual(crawl.crawl_id, "crawl-123")
        self.assertEqual(crawl.endpoint_count, 25)
        self.assertEqual(crawl.trigger, "initial")

    def test_record_auth_change(self):
        """Test auth change recording and re-crawl scheduling."""
        result = self.orchestrator.record_auth_change(
            identity_id="user-123",
            change_type="new_credential",
            details={"username": "admin"}
        )

        self.assertEqual(result['status'], 'recorded')
        self.assertTrue(result['recrawl_scheduled'])
        self.assertEqual(len(self.orchestrator.pending_recrawls), 1)
        self.assertEqual(len(self.orchestrator.auth_changes), 1)

        # Check pending re-crawl
        recrawl = self.orchestrator.pending_recrawls[0]
        self.assertEqual(recrawl['identity_id'], "user-123")
        self.assertIn('new_credential', recrawl['reason'])

    def test_get_next_actions_init_state(self):
        """Test next actions in INIT state."""
        self.orchestrator.transition_to(OrchestratorState.INIT)
        actions = self.orchestrator.get_next_actions(limit=5)

        self.assertGreater(len(actions), 0)
        self.assertEqual(actions[0]['action'], 'initial_crawl')
        self.assertEqual(actions[0]['tool'], 'crawler_start')
        self.assertEqual(actions[0]['priority'], 'critical')

    def test_get_next_actions_pending_recrawl(self):
        """Test that pending re-crawls are prioritized."""
        # Schedule a re-crawl
        self.orchestrator.record_auth_change(
            identity_id="admin-user",
            change_type="privilege_escalation",
            details={}
        )

        actions = self.orchestrator.get_next_actions(limit=5)

        # First action should be the re-crawl
        self.assertEqual(actions[0]['action'], 'recrawl')
        self.assertEqual(actions[0]['tool'], 'crawler_start')
        self.assertEqual(actions[0]['args']['identity_id'], 'admin-user')

    def test_should_continue_hardcoded_not_exhausted(self):
        """Test should_continue when hardcoded payloads not exhausted."""
        decision = self.orchestrator.should_continue_testing(
            vuln_spec_id='sqli_error',
            endpoint_id='endpoint-1',
            parameter='id',
            results_so_far=[]
        )

        self.assertTrue(decision.should_continue)
        self.assertEqual(decision.recommendation, 'continue_hardcoded')
        self.assertEqual(decision.next_payload_type, 'hardcoded')
        self.assertGreater(decision.confidence, 0.8)

    def test_should_continue_vulnerability_confirmed(self):
        """Test should_continue when vulnerability is confirmed."""
        # Record that hardcoded payloads were tried
        self.orchestrator.record_test_attempt(
            vuln_spec_id='xss_reflected',
            endpoint_id='endpoint-1',
            parameter='search',
            payload_type='hardcoded'
        )

        # Provide results with confirmed vulnerability
        results = [
            {'status': 'vulnerable', 'confidence': 0.95}
        ]

        decision = self.orchestrator.should_continue_testing(
            vuln_spec_id='xss_reflected',
            endpoint_id='endpoint-1',
            parameter='search',
            results_so_far=results
        )

        self.assertFalse(decision.should_continue)
        self.assertEqual(decision.recommendation, 'move_to_next')
        self.assertEqual(decision.confidence, 1.0)

    def test_should_continue_suspicious_no_llm(self):
        """Test should_continue with suspicious signals but no LLM payloads tried."""
        # Record that hardcoded payloads were tried
        self.orchestrator.record_test_attempt(
            vuln_spec_id='sqli_error',
            endpoint_id='endpoint-2',
            parameter='user_id',
            payload_type='hardcoded'
        )

        # Provide suspicious results
        results = [
            {'status': 'suspicious', 'confidence': 0.5, 'signal': 'timing_anomaly'}
        ]

        decision = self.orchestrator.should_continue_testing(
            vuln_spec_id='sqli_error',
            endpoint_id='endpoint-2',
            parameter='user_id',
            results_so_far=results
        )

        self.assertTrue(decision.should_continue)
        self.assertEqual(decision.recommendation, 'generate_llm_payloads')
        self.assertEqual(decision.next_payload_type, 'llm_generated')

    def test_should_continue_llm_tried_still_suspicious(self):
        """Test should_continue when LLM payloads tried but still suspicious."""
        # Record both hardcoded and LLM attempts
        self.orchestrator.record_test_attempt(
            vuln_spec_id='ssti',
            endpoint_id='endpoint-3',
            parameter='template',
            payload_type='hardcoded'
        )
        self.orchestrator.record_test_attempt(
            vuln_spec_id='ssti',
            endpoint_id='endpoint-3',
            parameter='template',
            payload_type='llm_generated'
        )

        # Still suspicious but not confirmed
        results = [
            {'status': 'suspicious', 'confidence': 0.4}
        ]

        decision = self.orchestrator.should_continue_testing(
            vuln_spec_id='ssti',
            endpoint_id='endpoint-3',
            parameter='template',
            results_so_far=results
        )

        self.assertFalse(decision.should_continue)
        self.assertEqual(decision.recommendation, 'log_suspicious')

    def test_should_continue_all_clean(self):
        """Test should_continue when all tests are clean."""
        # Record that hardcoded payloads were tried
        self.orchestrator.record_test_attempt(
            vuln_spec_id='cors_misconfig',
            endpoint_id='endpoint-4',
            parameter=None,
            payload_type='hardcoded'
        )

        # All clean results
        results = [
            {'status': 'clean', 'confidence': 0.0}
        ]

        decision = self.orchestrator.should_continue_testing(
            vuln_spec_id='cors_misconfig',
            endpoint_id='endpoint-4',
            parameter=None,
            results_so_far=results
        )

        self.assertFalse(decision.should_continue)
        self.assertEqual(decision.recommendation, 'move_to_next')

    def test_update_progress(self):
        """Test progress tracking."""
        progress_data = {
            'total_cells': 1000,
            'tested_cells': 250,
            'confirmed_vulns': 5,
            'suspicious_cells': 12,
            'categories': [
                {'category': 'injection', 'coverage_percent': 100},
                {'category': 'auth', 'coverage_percent': 50}
            ]
        }

        self.orchestrator.update_progress(progress_data)

        self.assertEqual(self.orchestrator.progress.total_cells, 1000)
        self.assertEqual(self.orchestrator.progress.tested_cells, 250)
        self.assertEqual(self.orchestrator.progress.confirmed_vulns, 5)
        self.assertEqual(self.orchestrator.progress.suspicious_cells, 12)
        self.assertIn('injection', self.orchestrator.progress.categories_complete)
        self.assertNotIn('auth', self.orchestrator.progress.categories_complete)

    def test_get_status(self):
        """Test comprehensive status reporting."""
        # Add some test data
        self.orchestrator.record_crawl("crawl-1", 30, None, "initial")
        self.orchestrator.update_progress({
            'total_cells': 500,
            'tested_cells': 100,
            'confirmed_vulns': 3,
            'suspicious_cells': 5
        })

        status = self.orchestrator.get_status()

        self.assertEqual(status['state'], 'init')
        self.assertEqual(status['crawl_count'], 1)
        self.assertEqual(status['progress']['total_cells'], 500)
        self.assertEqual(status['progress']['tested_cells'], 100)
        self.assertEqual(status['progress']['confirmed_vulns'], 3)
        self.assertIn('last_crawl', status)
        self.assertEqual(status['last_crawl']['crawl_id'], 'crawl-1')

    def test_is_complete_not_enough_coverage(self):
        """Test completion check with insufficient coverage."""
        self.orchestrator.update_progress({
            'total_cells': 1000,
            'tested_cells': 500,  # Only 50%
            'confirmed_vulns': 10
        })

        self.assertFalse(self.orchestrator.is_complete())

    def test_is_complete_high_coverage(self):
        """Test completion check with 100% coverage (default threshold)."""
        self.orchestrator.update_progress({
            'total_cells': 1000,
            'tested_cells': 1000,  # 100%
            'confirmed_vulns': 15
        })

        # No pending re-crawls
        self.assertTrue(self.orchestrator.is_complete())

    def test_is_complete_pending_recrawls(self):
        """Test completion check blocked by pending re-crawls."""
        self.orchestrator.update_progress({
            'total_cells': 1000,
            'tested_cells': 1000,  # 100%
            'confirmed_vulns': 15
        })

        # Add pending re-crawl
        self.orchestrator.record_auth_change("user-1", "new_credential", {})

        # Should NOT be complete due to pending re-crawl
        self.assertFalse(self.orchestrator.is_complete())

    def test_mark_complete(self):
        """Test marking orchestrator as complete."""
        self.orchestrator.update_progress({
            'total_cells': 100,
            'tested_cells': 98,
            'confirmed_vulns': 5
        })

        self.orchestrator.mark_complete()

        self.assertEqual(self.orchestrator.state, OrchestratorState.COMPLETE)
        self.assertTrue(self.orchestrator.is_complete())

    def test_record_test_attempt(self):
        """Test recording test attempts."""
        self.orchestrator.record_test_attempt(
            vuln_spec_id='jwt_manipulation',
            endpoint_id='endpoint-5',
            parameter=None,
            payload_type='hardcoded'
        )

        cell_id = 'endpoint-5:jwt_manipulation'
        self.assertEqual(self.orchestrator.cell_attempts.get(cell_id), 1)
        self.assertIn('hardcoded', self.orchestrator.cell_payloads_tried[cell_id])

        # Record another attempt
        self.orchestrator.record_test_attempt(
            vuln_spec_id='jwt_manipulation',
            endpoint_id='endpoint-5',
            parameter=None,
            payload_type='llm_generated'
        )

        self.assertEqual(self.orchestrator.cell_attempts.get(cell_id), 2)
        self.assertIn('llm_generated', self.orchestrator.cell_payloads_tried[cell_id])

    def test_multiple_crawls(self):
        """Test tracking multiple crawls."""
        self.orchestrator.record_crawl("crawl-1", 20, None, "initial")
        self.orchestrator.record_crawl("crawl-2", 30, "user-1", "auth_change")
        self.orchestrator.record_crawl("crawl-3", 35, "admin-1", "auth_change")

        self.assertEqual(len(self.orchestrator.crawl_history), 3)
        self.assertEqual(self.orchestrator.crawl_history[0].crawl_id, "crawl-1")
        self.assertEqual(self.orchestrator.crawl_history[1].identity_id, "user-1")
        self.assertEqual(self.orchestrator.crawl_history[2].endpoint_count, 35)

    def test_get_cell_testing_state_initial(self):
        """Test get_cell_testing_state with empty state returns zeros."""
        state = self.orchestrator.get_cell_testing_state(
            vuln_spec_id='sqli_error',
            endpoint_id='endpoint-1',
            parameter='id',
            results_so_far=[]
        )

        self.assertEqual(state.vuln_spec_id, 'sqli_error')
        self.assertEqual(state.endpoint_id, 'endpoint-1')
        self.assertEqual(state.parameter, 'id')
        self.assertEqual(state.attempt_count, 0)
        self.assertEqual(state.max_attempts, 5)
        self.assertEqual(state.payload_types_tried, [])
        self.assertEqual(state.suspicious_signal_count, 0)
        self.assertEqual(state.suspicious_signals, [])
        self.assertFalse(state.vulnerability_confirmed)
        self.assertFalse(state.max_attempts_reached)
        self.assertGreater(state.available_payload_count, 0)  # sqli_error has payloads
        self.assertEqual(state.results_summary, {"clean": 0, "suspicious": 0, "vulnerable": 0})

    def test_get_cell_testing_state_with_attempts(self):
        """Test get_cell_testing_state reflects record_test_attempt calls."""
        # Record attempts
        self.orchestrator.record_test_attempt('xss_reflected', 'endpoint-2', 'search', 'hardcoded')
        self.orchestrator.record_test_attempt('xss_reflected', 'endpoint-2', 'search', 'hardcoded')

        state = self.orchestrator.get_cell_testing_state(
            vuln_spec_id='xss_reflected',
            endpoint_id='endpoint-2',
            parameter='search',
            results_so_far=[]
        )

        self.assertEqual(state.attempt_count, 2)
        self.assertEqual(state.payload_types_tried, ['hardcoded'])
        self.assertFalse(state.max_attempts_reached)

    def test_get_cell_testing_state_with_results(self):
        """Test get_cell_testing_state parses results_summary correctly."""
        results = [
            {'status': 'clean', 'confidence': 0.0},
            {'status': 'clean', 'confidence': 0.0},
            {'status': 'suspicious', 'confidence': 0.5, 'signal': 'timing_anomaly'},
            {'status': 'suspicious', 'confidence': 0.6, 'signal': 'error_pattern'},
            {'status': 'vulnerable', 'confidence': 0.95}
        ]

        state = self.orchestrator.get_cell_testing_state(
            vuln_spec_id='sqli_blind_time',
            endpoint_id='endpoint-3',
            parameter='user_id',
            results_so_far=results
        )

        self.assertEqual(state.results_summary['clean'], 2)
        self.assertEqual(state.results_summary['suspicious'], 2)
        self.assertEqual(state.results_summary['vulnerable'], 1)
        self.assertTrue(state.vulnerability_confirmed)
        self.assertEqual(state.suspicious_signal_count, 2)

    def test_get_cell_testing_state_max_attempts(self):
        """Test get_cell_testing_state with 5 attempts sets max_attempts_reached."""
        # Record 5 attempts
        for _ in range(5):
            self.orchestrator.record_test_attempt('ssti', 'endpoint-4', 'template', 'hardcoded')

        state = self.orchestrator.get_cell_testing_state(
            vuln_spec_id='ssti',
            endpoint_id='endpoint-4',
            parameter='template',
            results_so_far=[]
        )

        self.assertEqual(state.attempt_count, 5)
        self.assertTrue(state.max_attempts_reached)

    def test_get_cell_testing_state_unknown_vuln_class(self):
        """Test get_cell_testing_state returns available_payload_count=0 for unknown vuln class."""
        state = self.orchestrator.get_cell_testing_state(
            vuln_spec_id='nonexistent_vuln_class_xyz',
            endpoint_id='endpoint-5',
            parameter=None,
            results_so_far=[]
        )

        self.assertEqual(state.available_payload_count, 0)


class TestTestingEngineHandlers(unittest.IsolatedAsyncioTestCase):
    """Test testing engine MCP tool handlers."""

    async def test_should_continue_returns_data_not_decisions(self):
        """Verify testing_should_continue returns data fields, not recommendation/confidence."""
        from tools_testing_engine import _handle_should_continue

        # Mock MCP service
        mcp_service = Mock()
        mcp_service.current_assessment_id = 1
        mcp_service.current_base_url = "http://test.example.com"

        args = {
            'vuln_spec_id': 'sqli_error',
            'endpoint_id': 'endpoint-1',
            'parameter': 'id',
            'results_so_far': []
        }

        # Call handler
        result = await _handle_should_continue(args, mcp_service)

        # Parse response
        self.assertEqual(len(result), 1)
        data = json.loads(result[0].text)

        # Verify data fields are present
        self.assertIn('cell_id', data)
        self.assertIn('vuln_spec_id', data)
        self.assertIn('endpoint_id', data)
        self.assertIn('parameter', data)
        self.assertIn('attempt_count', data)
        self.assertIn('max_attempts', data)
        self.assertIn('payload_types_tried', data)
        self.assertIn('suspicious_signal_count', data)
        self.assertIn('suspicious_signals', data)
        self.assertIn('vulnerability_confirmed', data)
        self.assertIn('max_attempts_reached', data)
        self.assertIn('available_payload_count', data)
        self.assertIn('results_summary', data)

        # Verify decision fields are NOT present
        self.assertNotIn('recommendation', data)
        self.assertNotIn('confidence', data)
        self.assertNotIn('next_payload_type', data)
        self.assertNotIn('should_continue', data)
        self.assertNotIn('reasoning', data)
        self.assertNotIn('payload_generation_context', data)

    async def test_testing_next_returns_data_not_tool_hints(self):
        """Verify testing_next returns cell metadata, not tool_call_hint or strategy."""
        from tools_testing_engine import _handle_testing_next

        # Mock MCP service
        mcp_service = Mock()
        mcp_service.current_assessment_id = 1
        mcp_service.current_base_url = "http://test.example.com"

        # Mock database
        with patch('lib.world_model_db.get_world_model_db') as mock_get_db:
            mock_db = AsyncMock()
            mock_db._assessment_id = 1

            # Mock _fetchall for coverage cells query
            mock_db._fetchall = AsyncMock()
            mock_db._fetchall.side_effect = [
                # First call: cells query
                [
                    {
                        'id': 'cell-1',
                        'endpoint_id': 'ep-1',
                        'endpoint_url': 'http://test.example.com/api/users',
                        'endpoint_method': 'GET',
                        'vuln_class': 'sqli_error',
                        'parameter': 'id',
                        'priority': 80
                    }
                ],
                # Second call: coverage summary query
                [
                    {'status': 'pending', 'cnt': 10},
                    {'status': 'tested', 'cnt': 5}
                ]
            ]
            mock_get_db.return_value = mock_db

            args = {'limit': 5}

            # Call handler
            result = await _handle_testing_next(args, mcp_service)

            # Parse response
            self.assertEqual(len(result), 1)
            data = json.loads(result[0].text)

            # Verify coverage summary is present
            self.assertIn('coverage_summary', data)
            self.assertIn('total_cells', data['coverage_summary'])
            self.assertIn('tested_cells', data['coverage_summary'])
            self.assertIn('pending_cells', data['coverage_summary'])
            self.assertIn('coverage_pct', data['coverage_summary'])

            # Verify cells have data fields
            self.assertIn('cells', data)
            if data['cells']:
                cell = data['cells'][0]
                self.assertIn('cell_id', cell)
                self.assertIn('endpoint_id', cell)
                self.assertIn('endpoint_url', cell)
                self.assertIn('endpoint_method', cell)
                self.assertIn('vuln_spec_id', cell)
                self.assertIn('parameter', cell)
                self.assertIn('payload_count', cell)
                self.assertIn('priority', cell)

                # Verify decision fields are NOT present
                self.assertNotIn('tool_call_hint', cell)
                self.assertNotIn('payloads', cell)  # No payload preview
                self.assertNotIn('tool_name', cell)
                self.assertNotIn('base_args', cell)

            # Verify strategy is NOT present at top level
            self.assertNotIn('strategy', data)


if __name__ == '__main__':
    unittest.main()
