"""Tests for http_race tool."""
import sys
import os
import asyncio
import unittest
import json
from unittest.mock import AsyncMock, MagicMock, patch

# Add modules to path (avoid pip mcp package shadowing)
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

from tools_http import _handle_http_race


def _make_mock_service():
    svc = MagicMock()
    svc.current_assessment_id = 1
    svc._http_client_cache = None
    svc._http_client_cache_key = None
    return svc


def _parse_result(result):
    return json.loads(result[0].text)


class TestHttpRace(unittest.IsolatedAsyncioTestCase):
    async def test_single_request_duplicated(self):
        """Test single request gets duplicated to concurrency count."""
        mock_service = _make_mock_service()

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value={
            "status": 200, "body": "ok", "headers": {}, "timing": {"duration_ms": 10}
        })

        with patch('tools_http._get_http_client', return_value=mock_client):
            result = await _handle_http_race({
                "requests": [{"method": "POST", "url": "http://target/api/transfer"}],
                "concurrency": 5,
            }, mock_service)

        data = _parse_result(result)
        self.assertEqual(data["total_requests"], 5)
        self.assertEqual(len(data["results"]), 5)
        self.assertEqual(data["verdict"], "No race condition detected")

    async def test_multiple_requests_sent(self):
        """Test multiple distinct requests sent concurrently."""
        mock_service = _make_mock_service()

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value={
            "status": 200, "body": "ok", "headers": {}, "timing": {"duration_ms": 10}
        })

        with patch('tools_http._get_http_client', return_value=mock_client):
            result = await _handle_http_race({
                "requests": [
                    {"method": "POST", "url": "http://target/api/transfer", "body": "amount=100"},
                    {"method": "POST", "url": "http://target/api/transfer", "body": "amount=200"},
                    {"method": "POST", "url": "http://target/api/transfer", "body": "amount=300"},
                ],
            }, mock_service)

        data = _parse_result(result)
        self.assertEqual(data["total_requests"], 3)

    async def test_race_detected_different_status_codes(self):
        """Test race condition detected when different status codes returned."""
        mock_service = _make_mock_service()

        call_count = [0]

        async def mock_send(**kwargs):
            call_count[0] += 1
            if call_count[0] <= 3:
                return {"status": 200, "body": "success", "headers": {}, "timing": {"duration_ms": 10}}
            else:
                return {"status": 409, "body": "conflict", "headers": {}, "timing": {"duration_ms": 15}}

        mock_client = AsyncMock()
        mock_client.send = mock_send

        with patch('tools_http._get_http_client', return_value=mock_client):
            result = await _handle_http_race({
                "requests": [{"method": "POST", "url": "http://target/api/redeem"}],
                "concurrency": 6,
            }, mock_service)

        data = _parse_result(result)
        self.assertEqual(data["verdict"], "RACE CONDITION DETECTED")
        self.assertIn("multiple_status_codes", data["race_indicators"])

    async def test_race_detected_different_body_hashes(self):
        """Test race condition detected when different response bodies."""
        mock_service = _make_mock_service()

        call_count = [0]

        async def mock_send(**kwargs):
            call_count[0] += 1
            body = f"response_{call_count[0]}" if call_count[0] <= 2 else "response_same"
            return {"status": 200, "body": body, "headers": {}, "timing": {"duration_ms": 10}}

        mock_client = AsyncMock()
        mock_client.send = mock_send

        with patch('tools_http._get_http_client', return_value=mock_client):
            result = await _handle_http_race({
                "requests": [{"method": "POST", "url": "http://target/api/vote"}],
                "concurrency": 4,
            }, mock_service)

        data = _parse_result(result)
        self.assertEqual(data["verdict"], "RACE CONDITION DETECTED")
        self.assertIn("multiple_response_bodies", data["race_indicators"])

    async def test_no_race_identical_responses(self):
        """Test no race detected when all responses identical."""
        mock_service = _make_mock_service()

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value={
            "status": 200, "body": "same_body", "headers": {}, "timing": {"duration_ms": 10}
        })

        with patch('tools_http._get_http_client', return_value=mock_client):
            result = await _handle_http_race({
                "requests": [{"method": "POST", "url": "http://target/api/test"}],
                "concurrency": 5,
            }, mock_service)

        data = _parse_result(result)
        self.assertEqual(data["verdict"], "No race condition detected")
        self.assertEqual(data["race_indicators"], {})

    async def test_error_handling_when_requests_fail(self):
        """Test error handling when some requests fail."""
        mock_service = _make_mock_service()

        call_count = [0]

        async def mock_send(**kwargs):
            call_count[0] += 1
            if call_count[0] == 2:
                raise ConnectionError("Connection reset")
            return {"status": 200, "body": "ok", "headers": {}, "timing": {"duration_ms": 10}}

        mock_client = AsyncMock()
        mock_client.send = mock_send

        with patch('tools_http._get_http_client', return_value=mock_client):
            result = await _handle_http_race({
                "requests": [{"method": "POST", "url": "http://target/api/test"}],
                "concurrency": 3,
            }, mock_service)

        data = _parse_result(result)
        self.assertEqual(data["error_count"], 1)
        self.assertEqual(data["total_requests"], 3)

    async def test_empty_requests_returns_error(self):
        """Test empty requests list returns error."""
        mock_service = _make_mock_service()

        result = await _handle_http_race({"requests": []}, mock_service)
        data = _parse_result(result)
        self.assertFalse(data["success"])
        self.assertIn("No requests", data["error"])

    async def test_sync_method_last_byte(self):
        """Test last_byte sync method works (or falls back gracefully)."""
        mock_service = _make_mock_service()

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value={
            "status": 200, "body": "ok", "headers": {}, "timing": {"duration_ms": 10}
        })

        with patch('tools_http._get_http_client', return_value=mock_client):
            result = await _handle_http_race({
                "requests": [{"method": "POST", "url": "http://target/api/test"}],
                "concurrency": 3,
                "sync_method": "last_byte",
            }, mock_service)

        data = _parse_result(result)
        self.assertEqual(data["total_requests"], 3)
        self.assertEqual(data["sync_method"], "last_byte")


if __name__ == "__main__":
    unittest.main()
