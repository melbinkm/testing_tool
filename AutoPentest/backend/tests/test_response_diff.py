"""
Tests for response_diff tool (Differential Response Oracle).

6 tests validating deep differential analysis between responses
from multiple identities for IDOR and authorization bypass detection.
"""

import sys
import os
import json
import unittest
from unittest.mock import AsyncMock, MagicMock, patch

# Add modules to path (avoid pip mcp package shadowing)
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

from tools_auth_tester import (
    get_auth_tester_tools,
    handle_auth_tester_tool,
    _handle_response_diff,
)


class TestResponseDiff(unittest.IsolatedAsyncioTestCase):
    """Test suite for response_diff tool."""

    def setUp(self):
        self.mcp_service = MagicMock()
        self.mcp_service.current_assessment_id = 1
        self.mcp_service.scope_provider = MagicMock()
        self.mcp_service.activity_logger = None

    def test_tool_definition_exists(self):
        """Test that response_diff tool is defined."""
        tools = get_auth_tester_tools()
        tool_names = [t.name for t in tools]
        self.assertIn("response_diff", tool_names)

        # Check required fields
        rd_tool = [t for t in tools if t.name == "response_diff"][0]
        required = rd_tool.inputSchema.get("required", [])
        self.assertIn("url", required)
        self.assertIn("identity_ids", required)

    async def test_requires_at_least_two_identities(self):
        """Test that fewer than 2 identity_ids returns error."""
        result = await handle_auth_tester_tool(
            "response_diff",
            {"url": "http://example.com/api", "identity_ids": ["id1"]},
            self.mcp_service,
        )
        data = json.loads(result[0].text)
        self.assertFalse(data["success"])
        self.assertIn("At least 2", data["error"])

    @patch("lib.http_client.HttpClient")
    @patch("lib.tool_helpers._get_db")
    async def test_detects_status_code_difference(self, mock_get_db, mock_http_cls):
        """Test that different status codes between identities are detected."""
        # Mock DB with two identities
        mock_db = AsyncMock()
        mock_db.assessment_id = 1

        # First identity gets 200, second gets 403
        call_count = [0]
        async def mock_query(sql, params):
            call_count[0] += 1
            if "wm_identities" in sql:
                return [{"id": params[0], "metadata": json.dumps({"token": "tok_" + params[0]})}]
            return []
        mock_db.query = mock_query
        mock_get_db.return_value = mock_db

        # Mock HTTP client
        responses = [
            {"status": 200, "headers": {}, "body": '{"user": "admin"}'},
            {"status": 403, "headers": {}, "body": '{"error": "forbidden"}'},
        ]
        resp_idx = [0]
        async def mock_send(request=None):
            idx = resp_idx[0]
            resp_idx[0] += 1
            return responses[idx] if idx < len(responses) else responses[0]

        mock_client = MagicMock()
        mock_client.send = mock_send
        mock_http_cls.return_value = mock_client

        result = await _handle_response_diff(
            {
                "url": "http://example.com/api/users",
                "identity_ids": ["admin", "user1"],
            },
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        self.assertEqual(data["identities_tested"], 2)
        self.assertTrue(data["data_leakage_detected"])
        self.assertIn("POTENTIAL DATA LEAKAGE", data["verdict"])
        self.assertNotEqual(data["diffs"]["status_diff"], "identical")

    @patch("lib.http_client.HttpClient")
    @patch("lib.tool_helpers._get_db")
    async def test_detects_json_field_differences(self, mock_get_db, mock_http_cls):
        """Test that different JSON fields between identities are detected."""
        mock_db = AsyncMock()
        mock_db.assessment_id = 1

        async def mock_query(sql, params):
            if "wm_identities" in sql:
                return [{"id": params[0], "metadata": json.dumps({"token": "tok_" + params[0]})}]
            return []
        mock_db.query = mock_query
        mock_get_db.return_value = mock_db

        # Both get 200 but different JSON bodies
        responses = [
            {"status": 200, "headers": {"content-type": "application/json"},
             "body": json.dumps({"name": "Admin", "role": "admin", "ssn": "123-45-6789"})},
            {"status": 200, "headers": {"content-type": "application/json"},
             "body": json.dumps({"name": "User1", "role": "user"})},
        ]
        resp_idx = [0]
        async def mock_send(request=None):
            idx = resp_idx[0]
            resp_idx[0] += 1
            return responses[idx] if idx < len(responses) else responses[0]

        mock_client = MagicMock()
        mock_client.send = mock_send
        mock_http_cls.return_value = mock_client

        result = await _handle_response_diff(
            {
                "url": "http://example.com/api/profile",
                "identity_ids": ["admin", "user1"],
            },
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        self.assertTrue(data["data_leakage_detected"])
        diffs = data["diffs"]
        # "role" values differ, "ssn" present for admin but not user1
        self.assertTrue(
            diffs.get("body_field_diffs") or diffs.get("extra_fields"),
            "Should detect field differences or extra fields"
        )

    @patch("lib.http_client.HttpClient")
    @patch("lib.tool_helpers._get_db")
    async def test_identical_responses_no_leakage(self, mock_get_db, mock_http_cls):
        """Test that identical responses report no leakage."""
        mock_db = AsyncMock()
        mock_db.assessment_id = 1

        async def mock_query(sql, params):
            if "wm_identities" in sql:
                return [{"id": params[0], "metadata": json.dumps({"token": "tok"})}]
            return []
        mock_db.query = mock_query
        mock_get_db.return_value = mock_db

        # Identical responses
        async def mock_send(request=None):
            return {"status": 200, "headers": {}, "body": '{"public": true}'}

        mock_client = MagicMock()
        mock_client.send = mock_send
        mock_http_cls.return_value = mock_client

        result = await _handle_response_diff(
            {
                "url": "http://example.com/api/public",
                "identity_ids": ["user1", "user2"],
            },
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        self.assertFalse(data["data_leakage_detected"])
        self.assertIn("No significant differences", data["verdict"])

    @patch("lib.http_client.HttpClient")
    @patch("lib.tool_helpers._get_db")
    async def test_timing_ratio_computed(self, mock_get_db, mock_http_cls):
        """Test that timing ratio is computed for responses."""
        mock_db = AsyncMock()
        mock_db.assessment_id = 1

        async def mock_query(sql, params):
            if "wm_identities" in sql:
                return [{"id": params[0], "metadata": "{}"}]
            return []
        mock_db.query = mock_query
        mock_get_db.return_value = mock_db

        async def mock_send(request=None):
            return {"status": 200, "headers": {}, "body": "ok"}

        mock_client = MagicMock()
        mock_client.send = mock_send
        mock_http_cls.return_value = mock_client

        result = await _handle_response_diff(
            {
                "url": "http://example.com/api",
                "identity_ids": ["id1", "id2"],
            },
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        self.assertIn("timing_ratio", data["diffs"])
        self.assertIsInstance(data["diffs"]["timing_ratio"], float)


if __name__ == "__main__":
    unittest.main()
