"""
Test phase-filtered tool visibility for Gap 2 fix.

Tests that tools are correctly filtered by phase to reduce decision paralysis.
"""
import unittest
import sys
from pathlib import Path

# Add modules path
sys.path.insert(0, str(Path(__file__).parent.parent / "mcp" / "modules"))

from lib.tool_metadata import (
    CORE_TOOLS,
    PHASE_TOOL_SETS,
    TOOL_METADATA,
    get_visible_tools_for_phase,
)


class TestPhaseToolFiltering(unittest.TestCase):
    """Test phase-filtered tool visibility."""

    def test_core_tools_in_every_phase(self):
        """CORE_TOOLS should appear in every phase (1-6)."""
        for phase in range(1, 7):
            visible = get_visible_tools_for_phase(phase)
            for core_tool in CORE_TOOLS:
                self.assertIn(
                    core_tool,
                    visible,
                    f"Core tool '{core_tool}' missing from phase {phase}",
                )

    def test_phase_1_has_recon_tools(self):
        """Phase 1 (Recon) should include reconnaissance tools."""
        visible = get_visible_tools_for_phase(1)
        recon_tools = ["scan", "subdomain_enum", "recon_pipeline_run"]
        for tool in recon_tools:
            self.assertIn(tool, visible, f"Recon tool '{tool}' missing from phase 1")

    def test_phase_1_excludes_assessment_tools(self):
        """Phase 1 should NOT include assessment/testing tools."""
        visible = get_visible_tools_for_phase(1)
        excluded_tools = [
            "inject_payload",
            "testing_next",
            "endpoint_execute_plan",
            "validate_repro",
        ]
        for tool in excluded_tools:
            self.assertNotIn(
                tool, visible, f"Assessment tool '{tool}' should not be in phase 1"
            )

    def test_phase_3_has_sast_tools(self):
        """Phase 3 (SAST Code Review) should include SAST tools."""
        visible = get_visible_tools_for_phase(3)
        sast_tools = [
            "sast_clone_repo",
            "sast_index_repo",
            "sast_scan_semgrep",
            "sast_scan_bandit",
            "sast_scan_gitleaks",
            "sast_get_next_unverified",
            "sast_mark_verified",
        ]
        for tool in sast_tools:
            self.assertIn(tool, visible, f"SAST tool '{tool}' missing from phase 3")

    def test_phase_4_has_all_pentest_tools(self):
        """Phase 4 (Vulnerability Assessment) should include all 8 LLM-in-the-loop pentest tools."""
        visible = get_visible_tools_for_phase(4)
        pentest_tools = [
            "recon_endpoint",
            "get_test_payloads",
            "inject_payload",
            "inject_batch",
            "analyze_headers",
            "discover_attack_surface",
            "record_finding",
            "get_test_progress",
        ]
        for tool in pentest_tools:
            self.assertIn(tool, visible, f"Pentest tool '{tool}' missing from phase 4")

    def test_phase_4_has_testing_engine(self):
        """Phase 4 (Vulnerability Assessment) should include automated testing engine tools."""
        visible = get_visible_tools_for_phase(4)
        testing_tools = [
            "testing_build_matrix",
            "testing_next",
            "testing_should_continue",
            "testing_status",
        ]
        for tool in testing_tools:
            self.assertIn(
                tool, visible, f"Testing engine tool '{tool}' missing from phase 4"
            )

    def test_fuzzer_hidden_all_phases(self):
        """Fuzzer tools should be hidden in all phases (deprecated)."""
        fuzzer_tools = ["fuzz_endpoint", "fuzz_parameter", "fuzz_list_payloads"]
        for phase in range(1, 7):
            visible = get_visible_tools_for_phase(phase)
            for tool in fuzzer_tools:
                self.assertNotIn(
                    tool,
                    visible,
                    f"Deprecated fuzzer tool '{tool}' should not be in phase {phase}",
                )

    def test_invalid_phase_returns_all(self):
        """Phase 0 or invalid should return all tools."""
        all_tools = set(TOOL_METADATA.keys())
        for phase in [0, -1, 99]:
            visible = get_visible_tools_for_phase(phase)
            self.assertEqual(
                visible,
                all_tools,
                f"Phase {phase} should return all {len(all_tools)} tools",
            )

    def test_phase_6_has_reporting_tools(self):
        """Phase 6 (Reporting) should include evidence and reporting tools."""
        visible = get_visible_tools_for_phase(6)
        reporting_tools = [
            "evidence_export",
            "evidence_generate_report",
            "risk_assess",
            "coverage_report",
        ]
        for tool in reporting_tools:
            self.assertIn(
                tool, visible, f"Reporting tool '{tool}' missing from phase 6"
            )

    def test_no_duplicate_core_tools(self):
        """CORE_TOOLS should not unnecessarily duplicate phase-specific tools."""
        # Check that CORE_TOOLS don't appear in PHASE_TOOL_SETS
        # (some overlap is OK, e.g., recon_endpoint in both phase 1 and 3)
        all_phase_tools = set()
        for phase_tools in PHASE_TOOL_SETS.values():
            all_phase_tools.update(phase_tools)

        core_only_tools = CORE_TOOLS - all_phase_tools
        # Core tools that aren't in any phase set should be truly cross-phase
        # Note: wm_store and wm_recall are now in Phase 3 (SAST) for code search
        expected_core_only = {
            "load_assessment",
            "update_phase",
            "orchestration_status",
            "orchestration_advance",
            "orchestration_auto_run",
            "scope_validate_target",
            "scope_get_allowlist",
            "scope_get_constraints",
            "scope_check_budget",
            "wm_query",
            "add_card",
            "list_cards",
            "http_get_stats",
            "credentials_add",
            "credentials_list",
        }
        self.assertEqual(
            core_only_tools,
            expected_core_only,
            "Core-only tools should be truly cross-phase utilities",
        )

    def test_all_tools_appear_somewhere(self):
        """Every registered tool should appear in CORE or at least 1 phase (except deprecated fuzzer)."""
        all_tools = set(TOOL_METADATA.keys())
        deprecated_fuzzer = {"fuzz_endpoint", "fuzz_parameter", "fuzz_list_payloads"}
        all_registered_tools = CORE_TOOLS.copy()
        for phase_tools in PHASE_TOOL_SETS.values():
            all_registered_tools.update(phase_tools)

        missing_tools = all_tools - all_registered_tools - deprecated_fuzzer
        self.assertEqual(
            set(),
            missing_tools,
            f"Tools not assigned to any phase or CORE: {missing_tools}",
        )

    def test_phase_tool_counts(self):
        """Verify expected tool counts per phase match plan."""
        # Actual counts determined by implementation
        expected_counts = {
            1: 32,  # Core (17) + 15 recon tools
            2: 49,  # Core (17) + 32 mapping tools (SAST tools moved to phase 3)
            3: 31,  # Core (17) + 14 SAST tools (new phase, includes wm_store/wm_recall)
            4: 61,  # Core (17) + 44 assessment tools (pentest + testing engine)
            5: 36,  # Core (17) + 19 exploitation tools (includes sast_correlate)
            6: 31,  # Core (17) + 14 reporting tools (includes sast_get_progress)
        }
        core_count = len(CORE_TOOLS)
        for phase, expected_total in expected_counts.items():
            visible = get_visible_tools_for_phase(phase)
            actual_count = len(visible)
            # Allow Â±2 tolerance for minor variations
            self.assertAlmostEqual(
                actual_count,
                expected_total,
                delta=2,
                msg=f"Phase {phase}: expected ~{expected_total} tools, got {actual_count} (CORE: {core_count})",
            )


if __name__ == "__main__":
    unittest.main()
