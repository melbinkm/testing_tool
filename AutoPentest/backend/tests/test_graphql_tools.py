"""Tests for GraphQL security testing tools."""
import sys
import os
import asyncio
import unittest
import json
from unittest.mock import AsyncMock, MagicMock, patch

# Add modules to path (avoid pip mcp package shadowing)
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

from tools_graphql import (
    handle_graphql_tool, get_graphql_tools,
    _handle_graphql_introspect,
    _handle_graphql_query, _handle_graphql_fuzz_schema,
    _handle_graphql_alias_idor, _handle_graphql_batch,
    SENSITIVE_FIELD_PATTERNS, INTROSPECTION_QUERY,
)


def _make_mock_service():
    svc = MagicMock()
    svc.current_assessment_id = 1
    svc._http_client_cache = None
    svc._http_client_cache_key = None
    return svc


def _parse_result(result):
    """Parse the JSON from a TextContent result list."""
    return json.loads(result[0].text)


class TestGraphQLIntrospect(unittest.IsolatedAsyncioTestCase):
    async def test_introspect_success(self):
        """Test successful introspection returns types, mutations, sensitive fields."""
        mock_service = _make_mock_service()

        introspection_response = {
            "data": {
                "__schema": {
                    "types": [
                        {"name": "User", "kind": "OBJECT", "fields": [
                            {"name": "id", "type": {"name": "ID", "kind": "SCALAR", "ofType": None}, "args": []},
                            {"name": "email", "type": {"name": "String", "kind": "SCALAR", "ofType": None}, "args": []},
                            {"name": "passwordHash", "type": {"name": "String", "kind": "SCALAR", "ofType": None}, "args": []},
                        ]},
                        {"name": "Post", "kind": "OBJECT", "fields": [
                            {"name": "title", "type": {"name": "String", "kind": "SCALAR", "ofType": None}, "args": []},
                        ]},
                        {"name": "__Schema", "kind": "OBJECT", "fields": []},
                    ],
                    "queryType": {"name": "Query"},
                    "mutationType": {"name": "Mutation"},
                    "subscriptionType": None,
                }
            }
        }

        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = introspection_response

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value=mock_resp)

        with patch('tools_graphql._get_http_client', return_value=mock_client):
            result = await _handle_graphql_introspect({"url": "http://target/graphql"}, mock_service)

        data = _parse_result(result)
        self.assertTrue(data["introspection_enabled"])
        self.assertEqual(data["type_count"], 2)  # User and Post (excludes __Schema)
        self.assertIn("User", data["types"])
        self.assertIn("Post", data["types"])
        self.assertNotIn("__Schema", data["types"])
        self.assertIn("User.email", data["sensitive_fields"])
        self.assertIn("User.passwordHash", data["sensitive_fields"])

    async def test_introspect_disabled_non_200(self):
        """Test introspection disabled returns correct message on non-200."""
        mock_service = _make_mock_service()

        mock_resp = MagicMock()
        mock_resp.status_code = 403

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value=mock_resp)

        with patch('tools_graphql._get_http_client', return_value=mock_client):
            result = await _handle_graphql_introspect({"url": "http://target/graphql"}, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["introspection_enabled"])
        self.assertEqual(data["status_code"], 403)

    async def test_introspect_disabled_errors(self):
        """Test introspection disabled with errors in response."""
        mock_service = _make_mock_service()

        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {
            "errors": [{"message": "Introspection is not allowed"}]
        }

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value=mock_resp)

        with patch('tools_graphql._get_http_client', return_value=mock_client):
            result = await _handle_graphql_introspect({"url": "http://target/graphql"}, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["introspection_enabled"])
        self.assertIn("Introspection is not allowed", data["errors"])


class TestGraphQLQuery(unittest.IsolatedAsyncioTestCase):
    async def test_query_sends_correct_payload(self):
        """Test graphql_query sends query/variables/operationName correctly."""
        mock_service = _make_mock_service()

        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {"data": {"user": {"name": "Alice"}}}
        mock_resp.headers = {"content-type": "application/json"}

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value=mock_resp)

        args = {
            "url": "http://target/graphql",
            "query": "query GetUser($id: ID!) { user(id: $id) { name } }",
            "variables": {"id": "1"},
            "operation_name": "GetUser",
        }

        with patch('tools_graphql._get_http_client', return_value=mock_client):
            result = await _handle_graphql_query(args, mock_service)

        # Verify send was called with correct payload
        call_kwargs = mock_client.send.call_args
        self.assertEqual(call_kwargs.args[0], "POST")

        data = _parse_result(result)
        self.assertEqual(data["status_code"], 200)
        self.assertEqual(data["data"]["user"]["name"], "Alice")
        self.assertFalse(data["has_errors"])


    async def test_query_identity_id_sets_auth_header(self):
        """Test graphql_query resolves identity_id to Authorization header."""
        mock_service = _make_mock_service()

        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {"data": {"me": {"name": "Alice"}}}
        mock_resp.headers = {"content-type": "application/json"}

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value=mock_resp)

        mock_db = MagicMock()
        mock_db.assessment_id = 1
        mock_db.query = AsyncMock(return_value=[
            {"metadata": {"token": "secret-jwt-token-123"}}
        ])

        args = {
            "url": "http://target/graphql",
            "query": "{ me { name } }",
            "identity_id": "user-abc",
        }

        with patch('tools_graphql._get_http_client', return_value=mock_client), \
             patch('tools_graphql._get_db', new_callable=AsyncMock, return_value=mock_db):
            result = await _handle_graphql_query(args, mock_service)

        # Verify the Authorization header was set
        call_kwargs = mock_client.send.call_args
        headers_sent = call_kwargs.kwargs.get("headers") or call_kwargs[1].get("headers", {})
        self.assertEqual(headers_sent.get("Authorization"), "Bearer secret-jwt-token-123")

        data = _parse_result(result)
        self.assertEqual(data["status_code"], 200)

    async def test_query_identity_id_access_token_fallback(self):
        """Test graphql_query uses access_token when token is absent."""
        mock_service = _make_mock_service()

        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {"data": {"me": {"name": "Bob"}}}
        mock_resp.headers = {"content-type": "application/json"}

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value=mock_resp)

        mock_db = MagicMock()
        mock_db.assessment_id = 1
        mock_db.query = AsyncMock(return_value=[
            {"metadata": {"access_token": "oauth-token-456"}}
        ])

        args = {
            "url": "http://target/graphql",
            "query": "{ me { name } }",
            "identity_id": "user-xyz",
        }

        with patch('tools_graphql._get_http_client', return_value=mock_client), \
             patch('tools_graphql._get_db', new_callable=AsyncMock, return_value=mock_db):
            result = await _handle_graphql_query(args, mock_service)

        call_kwargs = mock_client.send.call_args
        headers_sent = call_kwargs.kwargs.get("headers") or call_kwargs[1].get("headers", {})
        self.assertEqual(headers_sent.get("Authorization"), "Bearer oauth-token-456")


class TestGraphQLFuzzSchema(unittest.IsolatedAsyncioTestCase):
    async def test_fuzz_schema_parses_suggestions(self):
        """Test fuzz_schema parses 'Did you mean' suggestions from errors."""
        mock_service = _make_mock_service()

        call_count = [0]

        async def mock_send(*args, **kwargs):
            call_count[0] += 1
            resp = MagicMock()
            resp.status_code = 200
            if call_count[0] == 1:
                # __typename probe
                resp.json.return_value = {"data": {"__typename": "Query"}}
            else:
                # Field probes with suggestions
                resp.json.return_value = {
                    "errors": [{"message": 'Cannot query field "user" on type "Query". Did you mean "users" or "userById"?'}]
                }
            return resp

        mock_client = AsyncMock()
        mock_client.send = mock_send

        with patch('tools_graphql._get_http_client', return_value=mock_client):
            result = await _handle_graphql_fuzz_schema(
                {"url": "http://target/graphql", "max_requests": 5}, mock_service
            )

        data = _parse_result(result)
        self.assertTrue(data["introspection_disabled"])
        self.assertIn("query_root", data["discovered"])
        self.assertEqual(data["discovered"]["query_root"], "Query")
        self.assertIn("users", data["field_suggestions"])
        self.assertIn("userById", data["field_suggestions"])


class TestGraphQLAliasIDOR(unittest.IsolatedAsyncioTestCase):
    async def test_alias_idor_builds_correct_query(self):
        """Test alias IDOR builds correct aliased query from template."""
        mock_service = _make_mock_service()

        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {
            "data": {
                "a0": {"email": "user1@test.com"},
                "a1": {"email": "user2@test.com"},
                "a2": None,
            },
            "errors": []
        }

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value=mock_resp)

        args = {
            "url": "http://target/graphql",
            "query_template": 'user(id:"{id}"){email}',
            "ids": ["1", "2", "3"],
        }

        with patch('tools_graphql._get_http_client', return_value=mock_client):
            result = await _handle_graphql_alias_idor(args, mock_service)

        data = _parse_result(result)
        self.assertEqual(data["total_ids_tested"], 3)
        self.assertEqual(len(data["accessible_ids"]), 2)
        self.assertEqual(len(data["inaccessible_ids"]), 1)
        self.assertTrue(data["idor_indicators"])

    async def test_alias_idor_identity_id_sets_auth_header(self):
        """Test alias IDOR resolves identity_id to Authorization header."""
        mock_service = _make_mock_service()

        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {
            "data": {"a0": {"email": "user1@test.com"}},
            "errors": []
        }

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value=mock_resp)

        mock_db = MagicMock()
        mock_db.assessment_id = 1
        mock_db.query = AsyncMock(return_value=[
            {"metadata": json.dumps({"token": "idor-test-token"})}
        ])

        args = {
            "url": "http://target/graphql",
            "query_template": 'user(id:"{id}"){email}',
            "ids": ["1"],
            "identity_id": "attacker-id",
        }

        with patch('tools_graphql._get_http_client', return_value=mock_client), \
             patch('tools_graphql._get_db', new_callable=AsyncMock, return_value=mock_db):
            result = await _handle_graphql_alias_idor(args, mock_service)

        call_kwargs = mock_client.send.call_args
        headers_sent = call_kwargs.kwargs.get("headers") or call_kwargs[1].get("headers", {})
        self.assertEqual(headers_sent.get("Authorization"), "Bearer idor-test-token")

        data = _parse_result(result)
        self.assertEqual(data["total_ids_tested"], 1)

    async def test_alias_idor_no_idor(self):
        """Test alias IDOR detects no IDOR when only 1 ID accessible."""
        mock_service = _make_mock_service()

        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {
            "data": {"a0": {"email": "me@test.com"}, "a1": None},
            "errors": []
        }

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value=mock_resp)

        args = {
            "url": "http://target/graphql",
            "query_template": 'user(id:"{id}"){email}',
            "ids": ["1", "2"],
        }

        with patch('tools_graphql._get_http_client', return_value=mock_client):
            result = await _handle_graphql_alias_idor(args, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["idor_indicators"])


class TestGraphQLBatch(unittest.IsolatedAsyncioTestCase):
    async def test_batch_supported(self):
        """Test batch detection when server returns array."""
        mock_service = _make_mock_service()

        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = [
            {"data": {"user": {"name": "Alice"}}},
            {"data": {"user": {"name": "Bob"}}},
        ]

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value=mock_resp)

        args = {
            "url": "http://target/graphql",
            "queries": [
                {"query": "{ user(id:1) { name } }"},
                {"query": "{ user(id:2) { name } }"},
            ]
        }

        with patch('tools_graphql._get_http_client', return_value=mock_client):
            result = await _handle_graphql_batch(args, mock_service)

        data = _parse_result(result)
        self.assertTrue(data["batch_supported"])
        self.assertEqual(data["query_count"], 2)
        self.assertEqual(data["response_count"], 2)

    async def test_batch_not_supported(self):
        """Test batch detection when server returns non-array."""
        mock_service = _make_mock_service()

        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {"errors": [{"message": "Batching not supported"}]}

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(return_value=mock_resp)

        args = {
            "url": "http://target/graphql",
            "queries": [{"query": "{ user { name } }"}]
        }

        with patch('tools_graphql._get_http_client', return_value=mock_client):
            result = await _handle_graphql_batch(args, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["batch_supported"])


class TestGraphQLErrorHandling(unittest.IsolatedAsyncioTestCase):
    async def test_network_error_returns_error_content(self):
        """Test network failure returns error content."""
        mock_service = _make_mock_service()

        mock_client = AsyncMock()
        mock_client.send = AsyncMock(side_effect=ConnectionError("Connection refused"))

        with patch('tools_graphql._get_http_client', return_value=mock_client):
            result = await _handle_graphql_introspect({"url": "http://target/graphql"}, mock_service)

        data = _parse_result(result)
        self.assertFalse(data["success"])
        self.assertIn("Connection refused", data["error"])

    async def test_unknown_tool_name(self):
        """Test unknown tool name returns error."""
        mock_service = _make_mock_service()
        result = await handle_graphql_tool("graphql_unknown", {}, mock_service)
        data = _parse_result(result)
        self.assertIn("Unknown graphql tool", data["error"])


class TestGraphQLToolDefinitions(unittest.TestCase):
    def test_sensitive_field_patterns(self):
        """Test SENSITIVE_FIELD_PATTERNS contains expected patterns."""
        self.assertIn("password", SENSITIVE_FIELD_PATTERNS)
        self.assertIn("email", SENSITIVE_FIELD_PATTERNS)
        self.assertIn("token", SENSITIVE_FIELD_PATTERNS)
        self.assertIn("secret", SENSITIVE_FIELD_PATTERNS)
        self.assertIn("admin", SENSITIVE_FIELD_PATTERNS)

    def test_tool_count(self):
        """Test get_graphql_tools returns 5 tools."""
        tools = get_graphql_tools()
        self.assertEqual(len(tools), 5)

    def test_introspection_query_not_empty(self):
        """Test INTROSPECTION_QUERY is a non-empty string."""
        self.assertIn("__schema", INTROSPECTION_QUERY)
        self.assertIn("types", INTROSPECTION_QUERY)


if __name__ == "__main__":
    unittest.main()
