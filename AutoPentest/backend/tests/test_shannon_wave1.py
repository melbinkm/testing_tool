"""Tests for Shannon Wave 1 features: Error codes, DB schema, Config validator, Login flow."""
import sys
import types
import unittest
import inspect

sys.path.insert(0, 'mcp/modules')

# Mock mcp.types to avoid import errors on system Python
mcp_mod = types.ModuleType('mcp')
mcp_types = types.ModuleType('mcp.types')
mcp_types.Tool = type('Tool', (), {'__init__': lambda s, **k: None})
mcp_types.TextContent = type('TextContent', (), {'__init__': lambda s, **k: None})
sys.modules.setdefault('mcp', mcp_mod)
sys.modules.setdefault('mcp.types', mcp_types)


class TestErrorCodes(unittest.TestCase):
    """Test error_codes.py: ErrorCode enum, ErrorType enum, PentestError."""

    def test_all_12_error_codes_exist(self):
        from lib.error_codes import ErrorCode
        expected = [
            'CONFIG_NOT_FOUND', 'CONFIG_VALIDATION_FAILED', 'AGENT_EXECUTION_FAILED',
            'OUTPUT_VALIDATION_FAILED', 'API_RATE_LIMITED', 'SPENDING_CAP_REACHED',
            'GIT_CHECKPOINT_FAILED', 'GIT_ROLLBACK_FAILED', 'SCOPE_VIOLATION',
            'BUDGET_EXCEEDED', 'TOOL_EXECUTION_FAILED', 'DELIVERABLE_NOT_FOUND',
        ]
        actual = [c.value for c in ErrorCode]
        for code in expected:
            self.assertIn(code, actual, f"Missing ErrorCode: {code}")

    def test_all_9_error_types_exist(self):
        from lib.error_codes import ErrorType
        expected = ['config', 'network', 'tool', 'prompt', 'filesystem',
                    'validation', 'billing', 'scope', 'unknown']
        actual = [t.value for t in ErrorType]
        for et in expected:
            self.assertIn(et, actual, f"Missing ErrorType: {et}")

    def test_pentest_error_scope_violation(self):
        from lib.error_codes import PentestError, ErrorCode, ErrorType
        e = PentestError.scope_violation("out of scope")
        self.assertEqual(e.code, ErrorCode.SCOPE_VIOLATION)
        self.assertFalse(e.retryable)
        self.assertEqual(e.error_type, ErrorType.scope)
        self.assertEqual(e.message, "out of scope")

    def test_pentest_error_budget_exceeded(self):
        from lib.error_codes import PentestError, ErrorCode, ErrorType
        e = PentestError.budget_exceeded("over budget")
        self.assertEqual(e.code, ErrorCode.BUDGET_EXCEEDED)
        self.assertFalse(e.retryable)
        self.assertEqual(e.error_type, ErrorType.billing)

    def test_pentest_error_tool_execution_failed(self):
        from lib.error_codes import PentestError, ErrorCode, ErrorType
        e = PentestError.tool_execution_failed("tool broke")
        self.assertEqual(e.code, ErrorCode.TOOL_EXECUTION_FAILED)
        self.assertTrue(e.retryable)
        self.assertEqual(e.error_type, ErrorType.tool)

    def test_pentest_error_config_not_found(self):
        from lib.error_codes import PentestError, ErrorCode, ErrorType
        e = PentestError.config_not_found("missing config")
        self.assertEqual(e.code, ErrorCode.CONFIG_NOT_FOUND)
        self.assertFalse(e.retryable)
        self.assertEqual(e.error_type, ErrorType.config)

    def test_pentest_error_is_exception(self):
        from lib.error_codes import PentestError
        with self.assertRaises(PentestError):
            raise PentestError.scope_violation("test")

    def test_pentest_error_inherits_from_exception(self):
        from lib.error_codes import PentestError
        self.assertTrue(issubclass(PentestError, Exception))


class TestDBSchemaFields(unittest.IsolatedAsyncioTestCase):
    """Test that proof_level and verdict are accepted by add_finding."""

    async def test_proof_level_in_add_finding_signature(self):
        from lib.world_model_db import WorldModelDatabase
        sig = inspect.signature(WorldModelDatabase.add_finding)
        self.assertIn('proof_level', sig.parameters)

    async def test_verdict_in_add_finding_signature(self):
        from lib.world_model_db import WorldModelDatabase
        sig = inspect.signature(WorldModelDatabase.add_finding)
        self.assertIn('verdict', sig.parameters)

    async def test_evidence_ids_in_add_finding_signature(self):
        from lib.world_model_db import WorldModelDatabase
        sig = inspect.signature(WorldModelDatabase.add_finding)
        self.assertIn('evidence_ids', sig.parameters)


class TestConfigValidator(unittest.TestCase):
    """Test config_validator.py: JSON Schema validation."""

    def test_valid_config_passes(self):
        from lib.config_validator import validate_scope_config
        config = {"domains": ["example.com"], "ports": [80, 443]}
        valid, errors = validate_scope_config(config)
        self.assertTrue(valid)
        self.assertEqual(errors, [])

    def test_invalid_ports_returns_errors(self):
        from lib.config_validator import validate_scope_config
        config = {"ports": ["not-an-int"]}
        valid, errors = validate_scope_config(config)
        self.assertFalse(valid)
        self.assertTrue(len(errors) > 0)

    def test_empty_config_is_valid(self):
        from lib.config_validator import validate_scope_config
        valid, errors = validate_scope_config({})
        self.assertTrue(valid)
        self.assertEqual(errors, [])

    def test_invalid_domains_type(self):
        from lib.config_validator import validate_scope_config
        config = {"domains": "not-an-array"}
        valid, errors = validate_scope_config(config)
        self.assertFalse(valid)

    def test_valid_credentials_config(self):
        from lib.config_validator import validate_scope_config
        config = {"credentials": [{"username": "admin", "password": "pass"}]}
        valid, errors = validate_scope_config(config)
        self.assertTrue(valid)

    def test_schema_constant_exists(self):
        from lib.config_validator import SCOPE_SCHEMA
        self.assertIsInstance(SCOPE_SCHEMA, dict)
        self.assertIn("properties", SCOPE_SCHEMA)


class TestLoginFlow(unittest.TestCase):
    """Test login_flow.py: LoginFlow parsing and credential substitution."""

    def test_parse_form_login_flow(self):
        from lib.login_flow import parse_login_flow, LoginFlow
        config = {"authentication": {"login_type": "form", "login_url": "/login", "steps": []}}
        flow = parse_login_flow(config)
        self.assertIsNotNone(flow)
        self.assertIsInstance(flow, LoginFlow)
        self.assertEqual(flow.login_type, "form")
        self.assertEqual(flow.login_url, "/login")

    def test_parse_sso_login_flow(self):
        from lib.login_flow import parse_login_flow
        config = {"authentication": {"login_type": "sso", "login_url": "/sso/login"}}
        flow = parse_login_flow(config)
        self.assertIsNotNone(flow)
        self.assertEqual(flow.login_type, "sso")

    def test_credential_substitution(self):
        from lib.login_flow import substitute_credentials
        result = substitute_credentials("user=$username&pass=$password", "admin", "secret")
        self.assertEqual(result, "user=admin&pass=secret")

    def test_no_auth_returns_none(self):
        from lib.login_flow import parse_login_flow
        self.assertIsNone(parse_login_flow({}))

    def test_login_flow_with_steps(self):
        from lib.login_flow import parse_login_flow, LoginStep
        config = {"authentication": {
            "login_type": "form",
            "login_url": "/login",
            "steps": [{"action": "navigate", "value": "/login"}]
        }}
        flow = parse_login_flow(config)
        self.assertEqual(len(flow.steps), 1)
        self.assertIsInstance(flow.steps[0], LoginStep)
        self.assertEqual(flow.steps[0].action, "navigate")

    def test_login_flow_key_alias(self):
        from lib.login_flow import parse_login_flow
        config = {"login_flow": {"login_type": "api", "login_url": "/api/auth"}}
        flow = parse_login_flow(config)
        self.assertIsNotNone(flow)
        self.assertEqual(flow.login_type, "api")

    def test_substitute_no_placeholders(self):
        from lib.login_flow import substitute_credentials
        result = substitute_credentials("plain_text", "user", "pass")
        self.assertEqual(result, "plain_text")


if __name__ == '__main__':
    unittest.main()
