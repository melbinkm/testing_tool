"""
Tests for the Knowledge Store with RAG.

Verifies:
1. store_knowledge with content below/above chunk threshold
2. recall_knowledge with FTS5 full-text search
3. Chunk reassembly via get_knowledge_chunks
4. delete_knowledge cascading to chunks
5. knowledge_stats returns correct counts
6. Assessment isolation for knowledge entries
7. wm_store and wm_recall MCP tool handlers
8. capture_knowledge safe helper
9. Embedder fallback when sentence-transformers unavailable
"""

from __future__ import annotations

import asyncio
import json
import os
import sys

import pytest
import pytest_asyncio

# Ensure the mcp modules directory is importable
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "mcp", "modules"))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "mcp", "modules", "lib"))


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------

@pytest.fixture(autouse=True)
def tmp_data_dir(tmp_path, monkeypatch):
    """Point WORLD_MODEL_DB to a temp directory for each test."""
    db_path = str(tmp_path / "world-model.db")
    monkeypatch.setenv("WORLD_MODEL_DB", db_path)
    from world_model_db import _db_instances
    _db_instances.clear()
    yield tmp_path


@pytest_asyncio.fixture
async def db(tmp_data_dir):
    """Return an initialized WorldModelDatabase for assessment 1."""
    from world_model_db import get_world_model_db
    return await get_world_model_db(1)


class MockService:
    """Minimal mock for mcp_service with assessment_id."""
    def __init__(self, assessment_id=1):
        self.current_assessment_id = assessment_id


# ---------------------------------------------------------------------------
# Tests for store_knowledge
# ---------------------------------------------------------------------------

class TestStoreKnowledge:
    @pytest.mark.asyncio
    async def test_store_small_content(self, db):
        result = await db.store_knowledge(
            source_tool="scan",
            category="scan_output",
            title="nmap scan on 10.0.0.1",
            content="PORT   STATE SERVICE\n80/tcp open  http\n443/tcp open https\n",
            target="10.0.0.1",
            tags=["nmap", "scan"],
        )
        assert result["id"]
        assert result["chunk_count"] == 1
        assert result["content_size"] > 0

    @pytest.mark.asyncio
    async def test_store_large_content_chunked(self, db):
        """Content larger than CHUNK_SIZE should be split into multiple chunks."""
        from world_model_db import CHUNK_SIZE
        large_content = "A" * (CHUNK_SIZE + 1000)
        result = await db.store_knowledge(
            source_tool="execute",
            category="command_output",
            title="large output",
            content=large_content,
        )
        assert result["chunk_count"] >= 2
        assert result["content_size"] == len(large_content)

    @pytest.mark.asyncio
    async def test_store_validates_category(self, db):
        with pytest.raises(ValueError, match="Invalid category"):
            await db.store_knowledge(
                source_tool="test",
                category="invalid_category",
                title="test",
                content="test content",
            )

    @pytest.mark.asyncio
    async def test_store_validates_title(self, db):
        with pytest.raises(ValueError, match="title is required"):
            await db.store_knowledge(
                source_tool="test",
                category="other",
                title="",
                content="test content",
            )

    @pytest.mark.asyncio
    async def test_store_validates_content(self, db):
        with pytest.raises(ValueError, match="content is required"):
            await db.store_knowledge(
                source_tool="test",
                category="other",
                title="test",
                content="",
            )

    @pytest.mark.asyncio
    async def test_store_with_metadata_and_tags(self, db):
        result = await db.store_knowledge(
            source_tool="scan",
            category="scan_output",
            title="test with meta",
            content="some scan output content here",
            metadata={"command": "nmap -sV 10.0.0.1", "exit_code": 0},
            tags=["nmap", "scan"],
        )
        assert result["id"]
        # Verify we can retrieve it and metadata is preserved
        chunks = await db.get_knowledge_chunks(result["id"])
        assert len(chunks) == 1
        assert chunks[0]["metadata"]["command"] == "nmap -sV 10.0.0.1"
        assert "nmap" in chunks[0]["tags"]


# ---------------------------------------------------------------------------
# Tests for recall_knowledge (FTS5 search)
# ---------------------------------------------------------------------------

class TestRecallKnowledge:
    @pytest.mark.asyncio
    async def test_recall_by_keyword(self, db):
        await db.store_knowledge(
            source_tool="scan",
            category="scan_output",
            title="nmap scan on webserver",
            content="PORT 80/tcp open http Apache httpd 2.4.49",
            target="10.0.0.1",
        )
        await db.store_knowledge(
            source_tool="scan",
            category="scan_output",
            title="nmap scan on database",
            content="PORT 3306/tcp open mysql MariaDB 10.5",
            target="10.0.0.2",
        )

        results = await db.recall_knowledge(query="Apache")
        assert len(results) >= 1
        assert any("Apache" in r.get("content", "") for r in results)

    @pytest.mark.asyncio
    async def test_recall_browse_mode(self, db):
        """No query = browse mode, should return recent entries."""
        await db.store_knowledge(
            source_tool="scan", category="scan_output",
            title="entry 1", content="first entry content here",
        )
        await db.store_knowledge(
            source_tool="execute", category="command_output",
            title="entry 2", content="second entry content here",
        )

        results = await db.recall_knowledge()
        assert len(results) == 2

    @pytest.mark.asyncio
    async def test_recall_filter_by_category(self, db):
        await db.store_knowledge(
            source_tool="scan", category="scan_output",
            title="scan entry", content="scan data here with enough length",
        )
        await db.store_knowledge(
            source_tool="execute", category="command_output",
            title="command entry", content="command data here with enough length",
        )

        results = await db.recall_knowledge(category="scan_output")
        assert len(results) == 1
        assert results[0]["category"] == "scan_output"

    @pytest.mark.asyncio
    async def test_recall_filter_by_target(self, db):
        await db.store_knowledge(
            source_tool="scan", category="scan_output",
            title="scan 1", content="target A data content here",
            target="10.0.0.1",
        )
        await db.store_knowledge(
            source_tool="scan", category="scan_output",
            title="scan 2", content="target B data content here",
            target="10.0.0.2",
        )

        results = await db.recall_knowledge(target="10.0.0.1")
        assert len(results) == 1
        assert results[0]["target"] == "10.0.0.1"

    @pytest.mark.asyncio
    async def test_recall_filter_by_source_tool(self, db):
        await db.store_knowledge(
            source_tool="scan", category="scan_output",
            title="scan", content="scan output data with content",
        )
        await db.store_knowledge(
            source_tool="execute", category="command_output",
            title="exec", content="command output data with content",
        )

        results = await db.recall_knowledge(source_tool="execute")
        assert len(results) == 1
        assert results[0]["source_tool"] == "execute"

    @pytest.mark.asyncio
    async def test_recall_limit_and_offset(self, db):
        for i in range(5):
            await db.store_knowledge(
                source_tool="test", category="other",
                title=f"entry {i}", content=f"content for entry number {i} here",
            )

        results = await db.recall_knowledge(limit=2)
        assert len(results) == 2

        results_offset = await db.recall_knowledge(limit=2, offset=2)
        assert len(results_offset) == 2

    @pytest.mark.asyncio
    async def test_recall_without_content(self, db):
        await db.store_knowledge(
            source_tool="test", category="other",
            title="test entry", content="some content that should be excluded",
        )

        results = await db.recall_knowledge(include_content=False)
        assert len(results) == 1
        assert "content" not in results[0]


# ---------------------------------------------------------------------------
# Tests for chunk operations
# ---------------------------------------------------------------------------

class TestChunkOperations:
    @pytest.mark.asyncio
    async def test_get_chunks_single(self, db):
        result = await db.store_knowledge(
            source_tool="test", category="other",
            title="single chunk", content="short content here",
        )
        chunks = await db.get_knowledge_chunks(result["id"])
        assert len(chunks) == 1
        assert chunks[0]["chunk_index"] == 0
        assert chunks[0]["parent_id"] is None

    @pytest.mark.asyncio
    async def test_get_chunks_reassembly(self, db):
        from world_model_db import CHUNK_SIZE
        original = ("Line of content\n" * 5000)  # Ensure > CHUNK_SIZE
        if len(original) <= CHUNK_SIZE:
            original = "X" * (CHUNK_SIZE + 100)

        result = await db.store_knowledge(
            source_tool="test", category="other",
            title="multi chunk", content=original,
        )
        assert result["chunk_count"] >= 2

        chunks = await db.get_knowledge_chunks(result["id"])
        reassembled = "".join(c["content"] for c in chunks)
        assert reassembled == original


# ---------------------------------------------------------------------------
# Tests for delete_knowledge
# ---------------------------------------------------------------------------

class TestDeleteKnowledge:
    @pytest.mark.asyncio
    async def test_delete_single_chunk(self, db):
        result = await db.store_knowledge(
            source_tool="test", category="other",
            title="to delete", content="content to delete entry",
        )
        assert await db.delete_knowledge(result["id"])

        chunks = await db.get_knowledge_chunks(result["id"])
        assert len(chunks) == 0

    @pytest.mark.asyncio
    async def test_delete_cascades_to_chunks(self, db):
        from world_model_db import CHUNK_SIZE
        large = "Y" * (CHUNK_SIZE + 500)
        result = await db.store_knowledge(
            source_tool="test", category="other",
            title="multi to delete", content=large,
        )
        assert result["chunk_count"] >= 2

        assert await db.delete_knowledge(result["id"])
        chunks = await db.get_knowledge_chunks(result["id"])
        assert len(chunks) == 0


# ---------------------------------------------------------------------------
# Tests for knowledge_stats
# ---------------------------------------------------------------------------

class TestKnowledgeStats:
    @pytest.mark.asyncio
    async def test_empty_stats(self, db):
        stats = await db.knowledge_stats()
        assert stats["total_entries"] == 0
        assert stats["total_size_bytes"] == 0
        assert stats["by_category"] == {}
        assert stats["by_source_tool"] == {}

    @pytest.mark.asyncio
    async def test_stats_after_inserts(self, db):
        await db.store_knowledge(
            source_tool="scan", category="scan_output",
            title="scan 1", content="scan output content data",
        )
        await db.store_knowledge(
            source_tool="scan", category="scan_output",
            title="scan 2", content="more scan output data here",
        )
        await db.store_knowledge(
            source_tool="execute", category="command_output",
            title="cmd 1", content="command output data content",
        )

        stats = await db.knowledge_stats()
        assert stats["total_entries"] == 3
        assert stats["by_category"]["scan_output"] == 2
        assert stats["by_category"]["command_output"] == 1
        assert stats["by_source_tool"]["scan"] == 2
        assert stats["by_source_tool"]["execute"] == 1


# ---------------------------------------------------------------------------
# Tests for assessment isolation
# ---------------------------------------------------------------------------

class TestKnowledgeIsolation:
    @pytest.mark.asyncio
    async def test_knowledge_isolated_between_assessments(self):
        from world_model_db import get_world_model_db
        db1 = await get_world_model_db(1)
        db2 = await get_world_model_db(2)

        await db1.store_knowledge(
            source_tool="scan", category="scan_output",
            title="assessment 1 scan", content="scan output for assessment one",
        )

        results1 = await db1.recall_knowledge()
        results2 = await db2.recall_knowledge()
        assert len(results1) == 1
        assert len(results2) == 0


# ---------------------------------------------------------------------------
# Tests for wm_store and wm_recall MCP tools
# ---------------------------------------------------------------------------

class TestWmStoreRecallTools:
    @pytest.mark.asyncio
    async def test_wm_store_success(self):
        from tools_world_model import handle_world_model_tool
        result = await handle_world_model_tool(
            "wm_store",
            {
                "source_tool": "manual",
                "category": "other",
                "title": "test knowledge",
                "content": "This is test knowledge content for the store.",
            },
            mcp_service=MockService(),
        )
        assert len(result) == 1
        data = json.loads(result[0].text)
        assert data["success"] is True
        assert data["id"]
        assert data["chunk_count"] == 1

    @pytest.mark.asyncio
    async def test_wm_store_missing_fields(self):
        from tools_world_model import handle_world_model_tool
        result = await handle_world_model_tool(
            "wm_store",
            {"source_tool": "manual"},  # Missing required fields
            mcp_service=MockService(),
        )
        data = json.loads(result[0].text)
        assert data["success"] is False

    @pytest.mark.asyncio
    async def test_wm_recall_query(self):
        from tools_world_model import handle_world_model_tool

        svc = MockService()

        # Store something first
        await handle_world_model_tool(
            "wm_store",
            {
                "source_tool": "scan",
                "category": "scan_output",
                "title": "Apache web server scan",
                "content": "Apache httpd 2.4.49 running on port 80",
            },
            mcp_service=svc,
        )

        # Recall it
        result = await handle_world_model_tool(
            "wm_recall",
            {"query": "Apache"},
            mcp_service=svc,
        )
        data = json.loads(result[0].text)
        assert data["success"] is True
        assert data["count"] >= 1

    @pytest.mark.asyncio
    async def test_wm_recall_stats(self):
        from tools_world_model import handle_world_model_tool

        svc = MockService(assessment_id=500)  # Unique ID to avoid cross-test contamination
        await handle_world_model_tool(
            "wm_store",
            {
                "source_tool": "test",
                "category": "other",
                "title": "stats test entry",
                "content": "content for statistics test entry here",
            },
            mcp_service=svc,
        )

        result = await handle_world_model_tool(
            "wm_recall",
            {"stats": True},
            mcp_service=svc,
        )
        data = json.loads(result[0].text)
        assert data["success"] is True
        assert data["stats"]["total_entries"] == 1

    @pytest.mark.asyncio
    async def test_wm_recall_by_id(self):
        from tools_world_model import handle_world_model_tool

        svc = MockService()

        # Store
        store_result = await handle_world_model_tool(
            "wm_store",
            {
                "source_tool": "test",
                "category": "other",
                "title": "id lookup test",
                "content": "content for ID lookup test entry",
            },
            mcp_service=svc,
        )
        store_data = json.loads(store_result[0].text)
        knowledge_id = store_data["id"]

        # Recall by ID
        result = await handle_world_model_tool(
            "wm_recall",
            {"id": knowledge_id},
            mcp_service=svc,
        )
        data = json.loads(result[0].text)
        assert data["success"] is True
        assert data["entry"]["id"] == knowledge_id

    @pytest.mark.asyncio
    async def test_wm_recall_no_assessment(self):
        from tools_world_model import handle_world_model_tool
        result = await handle_world_model_tool(
            "wm_recall",
            {"stats": True},
            mcp_service=None,
        )
        data = json.loads(result[0].text)
        assert data["success"] is False
        assert "No assessment loaded" in data["error"]


# ---------------------------------------------------------------------------
# Tests for capture_knowledge helper
# ---------------------------------------------------------------------------

class TestCaptureKnowledge:
    @pytest.mark.asyncio
    async def test_capture_success(self):
        from knowledge_capture import capture_knowledge
        kid = await capture_knowledge(
            mcp_service=MockService(),
            source_tool="test",
            category="other",
            title="captured entry",
            content="This is captured content for the knowledge store that exceeds fifty characters easily.",
        )
        assert kid is not None

    @pytest.mark.asyncio
    async def test_capture_skips_no_assessment(self):
        from knowledge_capture import capture_knowledge
        kid = await capture_knowledge(
            mcp_service=None,
            source_tool="test",
            category="other",
            title="should skip",
            content="This should be skipped because no assessment.",
        )
        assert kid is None

    @pytest.mark.asyncio
    async def test_capture_skips_short_content(self):
        from knowledge_capture import capture_knowledge
        kid = await capture_knowledge(
            mcp_service=MockService(),
            source_tool="test",
            category="other",
            title="short",
            content="hi",  # Too short
        )
        assert kid is None

    @pytest.mark.asyncio
    async def test_capture_never_raises(self):
        from knowledge_capture import capture_knowledge
        # Even with invalid category, should not raise
        kid = await capture_knowledge(
            mcp_service=MockService(),
            source_tool="test",
            category="INVALID_CATEGORY",  # Will fail validation
            title="bad entry",
            content="content that should cause internal error but not raise",
        )
        assert kid is None  # Failed gracefully


# ---------------------------------------------------------------------------
# Tests for Embedder fallback
# ---------------------------------------------------------------------------

class TestEmbedder:
    def test_embedder_singleton(self):
        from embedder import get_embedder
        e1 = get_embedder()
        e2 = get_embedder()
        assert e1 is e2

    def test_embedder_cosine_similarity(self):
        import struct
        from embedder import Embedder

        # Create two identical vectors
        vec = [0.1, 0.2, 0.3, 0.4]
        a = struct.pack(f"{len(vec)}f", *vec)
        b = struct.pack(f"{len(vec)}f", *vec)
        sim = Embedder.cosine_similarity(a, b)
        assert abs(sim - 1.0) < 0.001

    def test_embedder_cosine_orthogonal(self):
        import struct
        from embedder import Embedder

        # Two orthogonal vectors
        a = struct.pack("4f", 1.0, 0.0, 0.0, 0.0)
        b = struct.pack("4f", 0.0, 1.0, 0.0, 0.0)
        sim = Embedder.cosine_similarity(a, b)
        assert abs(sim) < 0.001


# ---------------------------------------------------------------------------
# Tests for chunking edge cases
# ---------------------------------------------------------------------------

class TestChunking:
    def test_chunk_content_small(self):
        from world_model_db import WorldModelDatabase
        db_inst = WorldModelDatabase.__new__(WorldModelDatabase)
        chunks = db_inst._chunk_content("small content")
        assert len(chunks) == 1
        assert chunks[0] == "small content"

    def test_chunk_content_at_newlines(self):
        from world_model_db import WorldModelDatabase, CHUNK_SIZE
        db_inst = WorldModelDatabase.__new__(WorldModelDatabase)

        # Create content with newlines that exceeds chunk size
        line = "A" * 100 + "\n"
        num_lines = (CHUNK_SIZE // len(line)) + 10
        content = line * num_lines

        chunks = db_inst._chunk_content(content)
        assert len(chunks) >= 2
        # Reassemble should match original
        assert "".join(chunks) == content

    def test_chunk_content_no_newlines(self):
        from world_model_db import WorldModelDatabase, CHUNK_SIZE
        db_inst = WorldModelDatabase.__new__(WorldModelDatabase)

        # Content without any newlines
        content = "B" * (CHUNK_SIZE + 500)
        chunks = db_inst._chunk_content(content)
        assert len(chunks) >= 2
        assert "".join(chunks) == content


# ---------------------------------------------------------------------------
# Test tool count
# ---------------------------------------------------------------------------

class TestToolCount:
    def test_world_model_tools_count(self):
        from tools_world_model import get_world_model_tools
        tools = get_world_model_tools()
        assert len(tools) == 11  # 9 original + 2 new (wm_store, wm_recall)

    def test_wm_store_in_tools(self):
        from tools_world_model import get_world_model_tools
        tools = get_world_model_tools()
        names = [t.name for t in tools]
        assert "wm_store" in names
        assert "wm_recall" in names
