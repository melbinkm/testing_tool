"""
Tests for Zen-Ai-Pentest adapted features:
- Risk Engine (CVSS v3.1, Business Impact, EPSS, Risk Scorer)
- Safety Classifier
- SARIF Formatter
- SQL Payloads
- PoC Generator
- Plans (world_model_db)
"""

from __future__ import annotations

import asyncio
import json
import os
import sys
import tempfile
import unittest

# Add the MCP modules directory to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "mcp", "modules"))


# ============================================================================
# Risk Engine Tests
# ============================================================================

class TestCVSSv31(unittest.TestCase):
    """Test CVSS v3.1 score calculation."""

    def test_critical_score(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
        self.assertEqual(c.base_score(), 9.8)
        self.assertEqual(c.severity(), "critical")

    def test_high_score(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H")
        score = c.base_score()
        self.assertGreaterEqual(score, 7.0)
        self.assertLessEqual(score, 8.9)

    def test_low_score(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:P/AC:H/PR:H/UI:R/S:U/C:L/I:N/A:N")
        score = c.base_score()
        self.assertGreater(score, 0.0)
        self.assertLess(score, 4.0)

    def test_no_impact_zero(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N")
        self.assertEqual(c.base_score(), 0.0)
        self.assertEqual(c.severity(), "none")

    def test_scope_changed(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H")
        self.assertEqual(c.base_score(), 10.0)

    def test_to_dict(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
        d = c.to_dict()
        self.assertIn("vector", d)
        self.assertIn("base_score", d)
        self.assertIn("severity", d)
        self.assertIn("metrics", d)

    def test_missing_metric_raises(self):
        from lib.risk_engine import CVSSv31
        with self.assertRaises(ValueError):
            CVSSv31("CVSS:3.1/AV:N/AC:L")

    def test_raw_vector_without_prefix(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
        self.assertEqual(c.base_score(), 9.8)


class TestBusinessImpact(unittest.TestCase):
    """Test business impact calculation."""

    def test_high_impact(self):
        from lib.risk_engine import BusinessImpact
        bi = BusinessImpact()
        result = bi.calculate(
            asset_type="database",
            data_classification="restricted",
            compliance_frameworks=["pci-dss", "hipaa"],
            user_base="large",
        )
        self.assertGreater(result["overall"], 0.7)
        self.assertIn("financial", result)
        self.assertIn("factors", result)

    def test_low_impact(self):
        from lib.risk_engine import BusinessImpact
        bi = BusinessImpact()
        result = bi.calculate(
            asset_type="iot",
            data_classification="public",
            user_base="internal",
        )
        self.assertLess(result["overall"], 0.4)

    def test_default_values(self):
        from lib.risk_engine import BusinessImpact
        bi = BusinessImpact()
        result = bi.calculate()
        self.assertIn("overall", result)
        self.assertGreater(result["overall"], 0.0)


class TestRiskScorer(unittest.TestCase):
    """Test unified risk scoring."""

    def test_critical_risk(self):
        from lib.risk_engine import RiskScorer
        scorer = RiskScorer()
        result = scorer.score(cvss_score=9.8, confidence=0.95, business_impact=0.9, epss_score=0.7)
        self.assertEqual(result["risk_level"], "critical")
        self.assertEqual(result["priority"], 1)

    def test_low_risk(self):
        from lib.risk_engine import RiskScorer
        scorer = RiskScorer()
        result = scorer.score(cvss_score=2.0, confidence=0.3, business_impact=0.1, epss_score=0.05)
        self.assertIn(result["risk_level"], ("low", "medium"))

    def test_components_in_result(self):
        from lib.risk_engine import RiskScorer
        scorer = RiskScorer()
        result = scorer.score(cvss_score=5.0, confidence=0.5)
        self.assertIn("components", result)
        self.assertIn("recommendation", result)


class TestEPSS(unittest.TestCase):
    """Test EPSS estimation."""

    def test_high_cvss(self):
        from lib.risk_engine import calculate_epss
        epss = calculate_epss(cvss_score=9.8)
        self.assertGreater(epss, 0.5)

    def test_low_cvss(self):
        from lib.risk_engine import calculate_epss
        epss = calculate_epss(cvss_score=2.0)
        self.assertLess(epss, 0.2)

    def test_zero(self):
        from lib.risk_engine import calculate_epss
        epss = calculate_epss()
        self.assertEqual(epss, 0.0)


# ============================================================================
# Safety Classifier Tests
# ============================================================================

class TestSafetyClassifier(unittest.TestCase):
    """Test safety classification."""

    def test_safe_command(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("nmap -sV 10.0.0.1")
        self.assertEqual(result["level"], "safe")

    def test_blocked_command(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("rm -rf /")
        self.assertEqual(result["level"], "blocked")

    def test_dangerous_command(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("hashcat -m 0 hashes.txt wordlist.txt")
        self.assertEqual(result["level"], "dangerous")

    def test_caution_command(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("sqlmap -u http://target/page?id=1")
        self.assertEqual(result["level"], "caution")

    def test_blocked_payload(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_payload("'; DROP DATABASE production;--")
        self.assertEqual(result["level"], "blocked")

    def test_safe_payload(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_payload("hello world")
        self.assertEqual(result["level"], "safe")

    def test_dangerous_payload(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_payload("'; DROP TABLE users;--")
        self.assertEqual(result["level"], "dangerous")

    def test_empty_command(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("")
        self.assertEqual(result["level"], "safe")

    def test_url_safe(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_url("http://example.com/api/test")
        self.assertEqual(result["level"], "safe")

    def test_url_metadata(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_url("http://169.254.169.254/latest/meta-data/")
        self.assertEqual(result["level"], "caution")

    def test_shutdown_blocked(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("shutdown -h now")
        self.assertEqual(result["level"], "blocked")

    def test_singleton(self):
        from lib.safety_classifier import get_safety_classifier
        c1 = get_safety_classifier()
        c2 = get_safety_classifier()
        self.assertIs(c1, c2)


# ============================================================================
# SARIF Formatter Tests
# ============================================================================

class TestSARIFFormatter(unittest.TestCase):
    """Test SARIF 2.1.0 output formatting."""

    def test_empty_findings(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        result = f.format_findings([])
        self.assertEqual(result["version"], "2.1.0")
        self.assertEqual(len(result["runs"]), 1)
        self.assertEqual(len(result["runs"][0]["results"]), 0)

    def test_single_finding(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        finding = {
            "title": "SQL Injection in login",
            "severity": "high",
            "description": "The login parameter is vulnerable to SQL injection",
            "url": "http://example.com/login",
            "vuln_type": "sqli",
            "confidence": 0.9,
            "remediation": "Use parameterized queries",
        }
        result = f.format_findings([finding])
        self.assertEqual(result["version"], "2.1.0")
        self.assertEqual(len(result["runs"][0]["results"]), 1)
        r = result["runs"][0]["results"][0]
        self.assertEqual(r["level"], "error")  # high -> error
        self.assertIn("SQL Injection", r["message"]["text"])

    def test_severity_mapping(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        self.assertEqual(f._severity_to_sarif_level("critical"), "error")
        self.assertEqual(f._severity_to_sarif_level("high"), "error")
        self.assertEqual(f._severity_to_sarif_level("medium"), "warning")
        self.assertEqual(f._severity_to_sarif_level("low"), "note")
        self.assertEqual(f._severity_to_sarif_level("info"), "note")

    def test_rules_generated(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        result = f.format_findings([
            {"title": "XSS", "severity": "medium", "vuln_type": "xss"},
            {"title": "SQLi", "severity": "high", "vuln_type": "sqli"},
        ])
        rules = result["runs"][0]["tool"]["driver"]["rules"]
        self.assertEqual(len(rules), 2)

    def test_valid_json(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        result = f.format_findings([{"title": "Test", "severity": "low"}])
        # Should be valid JSON
        json_str = json.dumps(result)
        parsed = json.loads(json_str)
        self.assertEqual(parsed["version"], "2.1.0")

    def test_schema_url(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        result = f.format_findings([])
        self.assertIn("sarif-schema-2.1.0", result["$schema"])


# ============================================================================
# SQL Payloads Tests
# ============================================================================

class TestSQLPayloads(unittest.TestCase):
    """Test DB-specific SQL payloads."""

    def test_mysql_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("mysql")
        self.assertGreater(len(payloads), 10)
        for p in payloads:
            self.assertEqual(p.db_type, "mysql")
            self.assertIn(p.technique, ["union", "error_based", "blind_boolean", "blind_time", "stacked"])

    def test_postgresql_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("postgresql")
        self.assertGreater(len(payloads), 10)

    def test_mssql_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("mssql")
        self.assertGreater(len(payloads), 10)

    def test_oracle_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("oracle")
        self.assertGreater(len(payloads), 8)

    def test_sqlite_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("sqlite")
        self.assertGreater(len(payloads), 8)

    def test_generic_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("generic")
        self.assertGreater(len(payloads), 10)

    def test_technique_filter(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("mysql", technique="union")
        for p in payloads:
            self.assertEqual(p.technique, "union")

    def test_waf_bypass(self):
        from lib.sql_payloads import get_waf_bypass_payloads
        payloads = get_waf_bypass_payloads("mysql")
        self.assertGreater(len(payloads), 0)
        for p in payloads:
            self.assertTrue(p.waf_bypass)

    def test_all_db_types(self):
        from lib.sql_payloads import get_all_db_types
        types = get_all_db_types()
        self.assertIn("mysql", types)
        self.assertIn("postgresql", types)
        self.assertIn("mssql", types)
        self.assertIn("oracle", types)
        self.assertIn("sqlite", types)
        self.assertIn("generic", types)

    def test_all_techniques(self):
        from lib.sql_payloads import get_all_techniques
        techniques = get_all_techniques()
        self.assertIn("union", techniques)
        self.assertIn("blind_time", techniques)

    def test_all_payloads_flat(self):
        from lib.sql_payloads import get_all_payloads_flat
        all_payloads = get_all_payloads_flat()
        self.assertGreater(len(all_payloads), 50)


# ============================================================================
# PoC Generator Tests
# ============================================================================

class TestPoCGenerator(unittest.TestCase):
    """Test PoC script generation."""

    def test_sqli_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "sqli",
            "url": "http://target.com/login",
            "method": "POST",
            "parameter": "username",
            "payload": "' OR 1=1-- -",
            "title": "SQL Injection in login",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "sqli")
        self.assertIn("curl", poc["curl_command"])
        self.assertIn("import requests", poc["script"])
        self.assertEqual(poc["safety_level"], "caution")

    def test_xss_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "xss",
            "url": "http://target.com/search",
            "parameter": "q",
            "payload": "<script>alert(1)</script>",
            "title": "Reflected XSS",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "xss")
        self.assertIn("browser_url", poc)

    def test_idor_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "idor",
            "url": "http://target.com/api/users/1",
            "title": "IDOR on user endpoint",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "idor")

    def test_generic_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "title": "Some custom finding",
            "url": "http://target.com/api/test",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "generic")

    def test_auto_detect_sqli(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "title": "SQL Injection in search parameter",
            "url": "http://target.com/search",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "sqli")

    def test_auto_detect_xss(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "title": "Reflected Cross-Site Scripting",
            "url": "http://target.com/search",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "xss")

    def test_ssrf_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "ssrf",
            "url": "http://target.com/fetch",
            "parameter": "url",
            "title": "SSRF via URL parameter",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "ssrf")

    def test_lfi_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "lfi",
            "url": "http://target.com/view",
            "parameter": "file",
            "title": "LFI in file parameter",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "lfi")

    def test_cmdi_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "cmdi",
            "url": "http://target.com/ping",
            "parameter": "host",
            "title": "Command injection in ping",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "cmdi")


# ============================================================================
# World Model Plans Tests
# ============================================================================

class TestWorldModelPlans(unittest.TestCase):
    """Test plans table in WorldModelDatabase."""

    def setUp(self):
        self.tmp = tempfile.mktemp(suffix=".db")

    def tearDown(self):
        try:
            os.unlink(self.tmp)
        except FileNotFoundError:
            pass

    def _run(self, coro):
        return asyncio.get_event_loop().run_until_complete(coro)

    def test_add_plan(self):
        from lib.world_model_db import WorldModelDatabase
        db = WorldModelDatabase(db_path=self.tmp)
        self._run(db.init())
        plan = self._run(db.add_plan(
            title="Test Plan",
            goal="Test SQL injection",
            steps=[
                {"description": "Identify DB type"},
                {"description": "Test union injection"},
            ],
        ))
        self.assertIn("id", plan)
        self.assertEqual(plan["title"], "Test Plan")
        self.assertEqual(len(plan["steps"]), 2)
        self.assertEqual(plan["steps"][0]["status"], "pending")
        self.assertEqual(plan["status"], "active")
        self._run(db.close())

    def test_update_plan_step(self):
        from lib.world_model_db import WorldModelDatabase
        db = WorldModelDatabase(db_path=self.tmp)
        self._run(db.init())
        plan = self._run(db.add_plan(
            title="Test",
            goal="Test",
            steps=[{"description": "Step 1"}, {"description": "Step 2"}],
        ))
        updated = self._run(db.update_plan(
            plan_id=plan["id"],
            step_index=0,
            step_status="done",
            step_result="MySQL detected",
        ))
        self.assertEqual(updated["steps"][0]["status"], "done")
        self.assertEqual(updated["steps"][0]["result"], "MySQL detected")
        self.assertEqual(updated["steps"][1]["status"], "pending")
        self._run(db.close())

    def test_update_plan_reflection(self):
        from lib.world_model_db import WorldModelDatabase
        db = WorldModelDatabase(db_path=self.tmp)
        self._run(db.init())
        plan = self._run(db.add_plan(
            title="Test",
            goal="Test",
            steps=[{"description": "Step 1"}],
        ))
        updated = self._run(db.update_plan(
            plan_id=plan["id"],
            reflection="Union injection failed, blind confirmed",
            status="completed",
        ))
        self.assertEqual(updated["reflection"], "Union injection failed, blind confirmed")
        self.assertEqual(updated["status"], "completed")
        self._run(db.close())

    def test_query_plans(self):
        from lib.world_model_db import WorldModelDatabase
        db = WorldModelDatabase(db_path=self.tmp)
        self._run(db.init())
        self._run(db.add_plan(
            title="Plan A",
            goal="Goal A",
            steps=[{"description": "Step"}],
        ))
        self._run(db.add_plan(
            title="Plan B",
            goal="Goal B",
            steps=[{"description": "Step"}],
        ))
        plans = self._run(db.query(table="plans"))
        self.assertEqual(len(plans), 2)
        self._run(db.close())

    def test_plan_not_found(self):
        from lib.world_model_db import WorldModelDatabase
        db = WorldModelDatabase(db_path=self.tmp)
        self._run(db.init())
        with self.assertRaises(ValueError):
            self._run(db.update_plan(plan_id="nonexistent"))
        self._run(db.close())

    def test_step_index_out_of_range(self):
        from lib.world_model_db import WorldModelDatabase
        db = WorldModelDatabase(db_path=self.tmp)
        self._run(db.init())
        plan = self._run(db.add_plan(
            title="Test",
            goal="Test",
            steps=[{"description": "Step 1"}],
        ))
        with self.assertRaises(ValueError):
            self._run(db.update_plan(
                plan_id=plan["id"],
                step_index=5,
                step_status="done",
            ))
        self._run(db.close())

    def test_invalid_plan_status(self):
        from lib.world_model_db import WorldModelDatabase
        db = WorldModelDatabase(db_path=self.tmp)
        self._run(db.init())
        plan = self._run(db.add_plan(
            title="Test",
            goal="Test",
            steps=[{"description": "Step 1"}],
        ))
        with self.assertRaises(ValueError):
            self._run(db.update_plan(
                plan_id=plan["id"],
                status="invalid",
            ))
        self._run(db.close())


# ============================================================================
# Integration: Payload Generator with sqli_db
# ============================================================================

class TestPayloadGeneratorSQLiDB(unittest.TestCase):
    """Test sqli_db integration in PayloadGenerator."""

    def test_sqli_db_type(self):
        from lib.payload_generator import PayloadGenerator
        gen = PayloadGenerator()
        types = gen.get_payload_types()
        self.assertIn("sqli_db", types)

    def test_sqli_db_payloads(self):
        from lib.payload_generator import PayloadGenerator
        gen = PayloadGenerator()
        payloads = gen.get_payloads_by_type("sqli_db")
        self.assertGreater(len(payloads), 50)
        self.assertEqual(payloads[0]["type"], "sqli_db")

    def test_get_db_payloads_mysql(self):
        from lib.payload_generator import PayloadGenerator
        gen = PayloadGenerator()
        payloads = gen.get_db_payloads(db_type="mysql")
        self.assertGreater(len(payloads), 10)
        for p in payloads:
            self.assertEqual(p["db_type"], "mysql")

    def test_get_db_payloads_with_technique(self):
        from lib.payload_generator import PayloadGenerator
        gen = PayloadGenerator()
        payloads = gen.get_db_payloads(db_type="mysql", technique="union")
        for p in payloads:
            self.assertEqual(p["technique"], "union")

    def test_description_includes_sqli_db(self):
        from lib.payload_generator import PayloadGenerator
        gen = PayloadGenerator()
        descs = gen.get_payload_type_descriptions()
        self.assertIn("sqli_db", descs)
        self.assertIn("DB-specific", descs["sqli_db"])


if __name__ == "__main__":
    unittest.main()
