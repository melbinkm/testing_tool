"""
Tests for Zen-Ai-Pentest adapted features:
- Risk Engine (CVSS v3.1, Business Impact, EPSS, Risk Scorer)
- Safety Classifier
- SARIF Formatter
- SQL Payloads
- PoC Generator
- Plans (world_model_db)
"""

from __future__ import annotations

import asyncio
import json
import os
import sys
import unittest

# Add the MCP modules directory to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "mcp", "modules"))


# ============================================================================
# Risk Engine Tests
# ============================================================================

class TestCVSSv31(unittest.TestCase):
    """Test CVSS v3.1 score calculation."""

    def test_critical_score(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
        self.assertEqual(c.base_score(), 9.8)
        self.assertEqual(c.severity(), "critical")

    def test_high_score(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H")
        score = c.base_score()
        self.assertGreaterEqual(score, 7.0)
        self.assertLessEqual(score, 8.9)

    def test_low_score(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:P/AC:H/PR:H/UI:R/S:U/C:L/I:N/A:N")
        score = c.base_score()
        self.assertGreater(score, 0.0)
        self.assertLess(score, 4.0)

    def test_no_impact_zero(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:N")
        self.assertEqual(c.base_score(), 0.0)
        self.assertEqual(c.severity(), "none")

    def test_scope_changed(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H")
        self.assertEqual(c.base_score(), 10.0)

    def test_to_dict(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
        d = c.to_dict()
        self.assertIn("vector", d)
        self.assertIn("base_score", d)
        self.assertIn("severity", d)
        self.assertIn("metrics", d)

    def test_missing_metric_raises(self):
        from lib.risk_engine import CVSSv31
        with self.assertRaises(ValueError):
            CVSSv31("CVSS:3.1/AV:N/AC:L")

    def test_raw_vector_without_prefix(self):
        from lib.risk_engine import CVSSv31
        c = CVSSv31("AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
        self.assertEqual(c.base_score(), 9.8)


class TestBusinessImpact(unittest.TestCase):
    """Test business impact calculation."""

    def test_high_impact(self):
        from lib.risk_engine import BusinessImpact
        bi = BusinessImpact()
        result = bi.calculate(
            asset_type="database",
            data_classification="restricted",
            compliance_frameworks=["pci-dss", "hipaa"],
            user_base="large",
        )
        self.assertGreater(result["overall"], 0.7)
        self.assertIn("financial", result)
        self.assertIn("factors", result)

    def test_low_impact(self):
        from lib.risk_engine import BusinessImpact
        bi = BusinessImpact()
        result = bi.calculate(
            asset_type="iot",
            data_classification="public",
            user_base="internal",
        )
        self.assertLess(result["overall"], 0.4)

    def test_default_values(self):
        from lib.risk_engine import BusinessImpact
        bi = BusinessImpact()
        result = bi.calculate()
        self.assertIn("overall", result)
        self.assertGreater(result["overall"], 0.0)


class TestRiskScorer(unittest.TestCase):
    """Test unified risk scoring."""

    def test_critical_risk(self):
        from lib.risk_engine import RiskScorer
        scorer = RiskScorer()
        result = scorer.score(cvss_score=9.8, confidence=0.95, business_impact=0.9, epss_score=0.7)
        self.assertEqual(result["risk_level"], "critical")
        self.assertEqual(result["priority"], 1)

    def test_low_risk(self):
        from lib.risk_engine import RiskScorer
        scorer = RiskScorer()
        result = scorer.score(cvss_score=2.0, confidence=0.3, business_impact=0.1, epss_score=0.05)
        self.assertIn(result["risk_level"], ("low", "medium"))

    def test_components_in_result(self):
        from lib.risk_engine import RiskScorer
        scorer = RiskScorer()
        result = scorer.score(cvss_score=5.0, confidence=0.5)
        self.assertIn("components", result)
        self.assertIn("recommendation", result)


class TestEPSS(unittest.TestCase):
    """Test EPSS estimation."""

    def test_high_cvss(self):
        from lib.risk_engine import calculate_epss
        epss = calculate_epss(cvss_score=9.8)
        self.assertGreater(epss, 0.5)

    def test_low_cvss(self):
        from lib.risk_engine import calculate_epss
        epss = calculate_epss(cvss_score=2.0)
        self.assertLess(epss, 0.2)

    def test_zero(self):
        from lib.risk_engine import calculate_epss
        epss = calculate_epss()
        self.assertEqual(epss, 0.0)


# ============================================================================
# Safety Classifier Tests
# ============================================================================

class TestSafetyClassifier(unittest.TestCase):
    """Test safety classification."""

    def test_safe_command(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("nmap -sV 10.0.0.1")
        self.assertEqual(result["level"], "safe")

    def test_blocked_command(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("rm -rf /")
        self.assertEqual(result["level"], "blocked")

    def test_dangerous_command(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("hashcat -m 0 hashes.txt wordlist.txt")
        self.assertEqual(result["level"], "dangerous")

    def test_caution_command(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("sqlmap -u http://target/page?id=1")
        self.assertEqual(result["level"], "caution")

    def test_blocked_payload(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_payload("'; DROP DATABASE production;--")
        self.assertEqual(result["level"], "blocked")

    def test_safe_payload(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_payload("hello world")
        self.assertEqual(result["level"], "safe")

    def test_dangerous_payload(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_payload("'; DROP TABLE users;--")
        self.assertEqual(result["level"], "dangerous")

    def test_empty_command(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("")
        self.assertEqual(result["level"], "safe")

    def test_url_safe(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_url("http://example.com/api/test")
        self.assertEqual(result["level"], "safe")

    def test_url_metadata(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_url("http://169.254.169.254/latest/meta-data/")
        self.assertEqual(result["level"], "caution")

    def test_shutdown_blocked(self):
        from lib.safety_classifier import SafetyClassifier
        c = SafetyClassifier()
        result = c.classify_command("shutdown -h now")
        self.assertEqual(result["level"], "blocked")

    def test_singleton(self):
        from lib.safety_classifier import get_safety_classifier
        c1 = get_safety_classifier()
        c2 = get_safety_classifier()
        self.assertIs(c1, c2)


# ============================================================================
# SARIF Formatter Tests
# ============================================================================

class TestSARIFFormatter(unittest.TestCase):
    """Test SARIF 2.1.0 output formatting."""

    def test_empty_findings(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        result = f.format_findings([])
        self.assertEqual(result["version"], "2.1.0")
        self.assertEqual(len(result["runs"]), 1)
        self.assertEqual(len(result["runs"][0]["results"]), 0)

    def test_single_finding(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        finding = {
            "title": "SQL Injection in login",
            "severity": "high",
            "description": "The login parameter is vulnerable to SQL injection",
            "url": "http://example.com/login",
            "vuln_type": "sqli",
            "confidence": 0.9,
            "remediation": "Use parameterized queries",
        }
        result = f.format_findings([finding])
        self.assertEqual(result["version"], "2.1.0")
        self.assertEqual(len(result["runs"][0]["results"]), 1)
        r = result["runs"][0]["results"][0]
        self.assertEqual(r["level"], "error")  # high -> error
        self.assertIn("SQL Injection", r["message"]["text"])

    def test_severity_mapping(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        self.assertEqual(f._severity_to_sarif_level("critical"), "error")
        self.assertEqual(f._severity_to_sarif_level("high"), "error")
        self.assertEqual(f._severity_to_sarif_level("medium"), "warning")
        self.assertEqual(f._severity_to_sarif_level("low"), "note")
        self.assertEqual(f._severity_to_sarif_level("info"), "note")

    def test_rules_generated(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        result = f.format_findings([
            {"title": "XSS", "severity": "medium", "vuln_type": "xss"},
            {"title": "SQLi", "severity": "high", "vuln_type": "sqli"},
        ])
        rules = result["runs"][0]["tool"]["driver"]["rules"]
        self.assertEqual(len(rules), 2)

    def test_valid_json(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        result = f.format_findings([{"title": "Test", "severity": "low"}])
        # Should be valid JSON
        json_str = json.dumps(result)
        parsed = json.loads(json_str)
        self.assertEqual(parsed["version"], "2.1.0")

    def test_schema_url(self):
        from lib.sarif_formatter import SARIFFormatter
        f = SARIFFormatter()
        result = f.format_findings([])
        self.assertIn("sarif-schema-2.1.0", result["$schema"])


# ============================================================================
# SQL Payloads Tests
# ============================================================================

class TestSQLPayloads(unittest.TestCase):
    """Test DB-specific SQL payloads."""

    def test_mysql_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("mysql")
        self.assertGreater(len(payloads), 10)
        for p in payloads:
            self.assertEqual(p.db_type, "mysql")
            self.assertIn(p.technique, ["union", "error_based", "blind_boolean", "blind_time", "stacked"])

    def test_postgresql_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("postgresql")
        self.assertGreater(len(payloads), 10)

    def test_mssql_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("mssql")
        self.assertGreater(len(payloads), 10)

    def test_oracle_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("oracle")
        self.assertGreater(len(payloads), 8)

    def test_sqlite_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("sqlite")
        self.assertGreater(len(payloads), 8)

    def test_generic_payloads(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("generic")
        self.assertGreater(len(payloads), 10)

    def test_technique_filter(self):
        from lib.sql_payloads import get_sql_payloads
        payloads = get_sql_payloads("mysql", technique="union")
        for p in payloads:
            self.assertEqual(p.technique, "union")

    def test_waf_bypass(self):
        from lib.sql_payloads import get_waf_bypass_payloads
        payloads = get_waf_bypass_payloads("mysql")
        self.assertGreater(len(payloads), 0)
        for p in payloads:
            self.assertTrue(p.waf_bypass)

    def test_all_db_types(self):
        from lib.sql_payloads import get_all_db_types
        types = get_all_db_types()
        self.assertIn("mysql", types)
        self.assertIn("postgresql", types)
        self.assertIn("mssql", types)
        self.assertIn("oracle", types)
        self.assertIn("sqlite", types)
        self.assertIn("generic", types)

    def test_all_techniques(self):
        from lib.sql_payloads import get_all_techniques
        techniques = get_all_techniques()
        self.assertIn("union", techniques)
        self.assertIn("blind_time", techniques)

    def test_all_payloads_flat(self):
        from lib.sql_payloads import get_all_payloads_flat
        all_payloads = get_all_payloads_flat()
        self.assertGreater(len(all_payloads), 50)


# ============================================================================
# PoC Generator Tests
# ============================================================================

class TestPoCGenerator(unittest.TestCase):
    """Test PoC script generation."""

    def test_sqli_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "sqli",
            "url": "http://target.com/login",
            "method": "POST",
            "parameter": "username",
            "payload": "' OR 1=1-- -",
            "title": "SQL Injection in login",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "sqli")
        self.assertIn("curl", poc["curl_command"])
        self.assertIn("import requests", poc["script"])
        self.assertEqual(poc["safety_level"], "caution")

    def test_xss_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "xss",
            "url": "http://target.com/search",
            "parameter": "q",
            "payload": "<script>alert(1)</script>",
            "title": "Reflected XSS",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "xss")
        self.assertIn("browser_url", poc)

    def test_idor_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "idor",
            "url": "http://target.com/api/users/1",
            "title": "IDOR on user endpoint",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "idor")

    def test_generic_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "title": "Some custom finding",
            "url": "http://target.com/api/test",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "generic")

    def test_auto_detect_sqli(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "title": "SQL Injection in search parameter",
            "url": "http://target.com/search",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "sqli")

    def test_auto_detect_xss(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "title": "Reflected Cross-Site Scripting",
            "url": "http://target.com/search",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "xss")

    def test_ssrf_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "ssrf",
            "url": "http://target.com/fetch",
            "parameter": "url",
            "title": "SSRF via URL parameter",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "ssrf")

    def test_lfi_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "lfi",
            "url": "http://target.com/view",
            "parameter": "file",
            "title": "LFI in file parameter",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "lfi")

    def test_cmdi_poc(self):
        from lib.poc_generator import PoCGenerator
        gen = PoCGenerator()
        finding = {
            "vuln_type": "cmdi",
            "url": "http://target.com/ping",
            "parameter": "host",
            "title": "Command injection in ping",
        }
        poc = gen.generate(finding)
        self.assertEqual(poc["poc_type"], "cmdi")


# ============================================================================
# World Model Plans Tests
# ============================================================================

class _PlansMockRecord(dict):
    """Dict subclass supporting both dict['key'] and dict.key access, like asyncpg.Record."""
    def __getattr__(self, name):
        try:
            return self[name]
        except KeyError:
            raise AttributeError(name)


class _PlansMockConnection:
    """Minimal asyncpg connection mock for WorldModelDatabase plan operations."""

    def __init__(self, tables):
        self._tables = tables

    async def execute(self, sql, *params):
        sql_lower = sql.strip().lower()
        if sql_lower.startswith("insert into"):
            self._handle_insert(sql, params)
        elif sql_lower.startswith("update"):
            self._handle_update(sql, params)
        return "OK"

    async def fetchrow(self, sql, *params):
        rows = await self.fetch(sql, *params)
        return rows[0] if rows else None

    async def fetch(self, sql, *params):
        return self._handle_select(sql, params)

    def transaction(self):
        return _PlansMockTransaction(self)

    def _handle_insert(self, sql, params):
        sql_lower = sql.lower()
        after_into = sql[sql_lower.index("insert into") + len("insert into"):].strip()
        table = after_into.split()[0].strip()
        self._tables.setdefault(table, [])

        cols_start = sql.index("(", sql_lower.index(table) + len(table))
        cols_end = sql.index(")", cols_start)
        columns = [c.strip() for c in sql[cols_start + 1:cols_end].split(",")]

        record = _PlansMockRecord()
        for i, col in enumerate(columns):
            if i < len(params):
                val = params[i]
                if isinstance(val, str) and col in ('steps',):
                    try:
                        val = json.loads(val)
                    except (json.JSONDecodeError, TypeError):
                        pass
                record[col] = val
        self._tables[table].append(record)

    def _handle_update(self, sql, params):
        sql_lower = sql.lower()
        table = sql[sql_lower.index("update") + 6:sql_lower.index("set")].strip()
        if table not in self._tables:
            return

        set_clause = sql[sql_lower.index("set") + 3:sql_lower.index("where")].strip()
        where_clause = sql[sql_lower.index("where") + 5:].strip()

        param_map = {f"${i + 1}": p for i, p in enumerate(params)}

        set_assignments = {}
        for part in set_clause.split(","):
            part = part.strip()
            if "=" in part:
                col, val_ph = part.split("=", 1)
                col, val_ph = col.strip(), val_ph.strip()
                if val_ph in param_map:
                    val = param_map[val_ph]
                    if isinstance(val, str) and col in ('steps',):
                        try:
                            val = json.loads(val)
                        except (json.JSONDecodeError, TypeError):
                            pass
                    set_assignments[col] = val

        where_conds = {}
        for part in where_clause.split(" AND "):
            part = part.strip()
            if "=" in part:
                col, val_ph = part.split("=", 1)
                col, val_ph = col.strip(), val_ph.strip()
                if val_ph in param_map:
                    where_conds[col] = param_map[val_ph]

        for row in self._tables.get(table, []):
            if all(row.get(k) == v for k, v in where_conds.items()):
                row.update(set_assignments)

    def _handle_select(self, sql, params):
        sql_lower = sql.lower()
        param_map = {f"${i + 1}": p for i, p in enumerate(params)}

        if "from" not in sql_lower:
            return []

        from_part = sql_lower.split("from")[1]
        table_part = from_part
        for kw in ("where", "group by", "order by", "limit"):
            if kw in table_part:
                table_part = table_part[:table_part.index(kw)]
        table = table_part.strip().split()[0].strip()

        rows = list(self._tables.get(table, []))

        # WHERE filtering
        if "where" in sql_lower:
            where_start = sql_lower.index("where") + 5
            where_end = len(sql_lower)
            for kw in ("order by", "limit", "offset"):
                if kw in sql_lower[where_start:]:
                    where_end = min(where_end, sql_lower.index(kw, where_start))
            where_clause = sql[where_start:where_end].strip()

            filtered = []
            for row in rows:
                match = True
                for part in where_clause.split(" AND "):
                    part = part.strip()
                    if "=" in part:
                        col, val_ph = part.split("=", 1)
                        col, val_ph = col.strip(), val_ph.strip()
                        val = param_map.get(val_ph, val_ph)
                        if row.get(col) != val:
                            match = False
                            break
                if match:
                    filtered.append(row)
            rows = filtered

        # ORDER BY
        if "order by" in sql_lower:
            order_part = sql_lower.split("order by")[1]
            for kw in ("limit", "offset"):
                if kw in order_part:
                    order_part = order_part[:order_part.index(kw)]
            order_part = order_part.strip()
            desc = "desc" in order_part
            order_col = order_part.split()[0].strip()
            rows.sort(key=lambda r: (r.get(order_col) is None, r.get(order_col, "")), reverse=desc)

        # LIMIT
        if "limit" in sql_lower:
            limit_part = sql_lower.split("limit")[-1].strip()
            limit_val = limit_part.split()[0].strip()
            limit_num = param_map.get(limit_val, 100) if limit_val.startswith("$") else int(limit_val)
            rows = rows[:limit_num]

        # OFFSET
        if "offset" in sql_lower:
            offset_part = sql_lower.split("offset")[-1].strip()
            offset_val = offset_part.split()[0].strip()
            offset_num = param_map.get(offset_val, 0) if offset_val.startswith("$") else int(offset_val)
            rows = rows[offset_num:]

        return [_PlansMockRecord(r) if not isinstance(r, _PlansMockRecord) else r for r in rows]


class _PlansMockTransaction:
    def __init__(self, conn):
        self.conn = conn

    async def __aenter__(self):
        return self

    async def __aexit__(self, *args):
        pass


class _PlansMockPool:
    def __init__(self):
        self._tables = {}
        self._conn = _PlansMockConnection(self._tables)

    def acquire(self):
        return _PlansMockPoolAcquire(self._conn)


class _PlansMockPoolAcquire:
    def __init__(self, conn):
        self.conn = conn

    async def __aenter__(self):
        return self.conn

    async def __aexit__(self, *args):
        pass


class TestWorldModelPlans(unittest.IsolatedAsyncioTestCase):
    """Test plans table in WorldModelDatabase."""

    async def asyncSetUp(self):
        from lib.world_model_db import WorldModelDatabase
        self.pool = _PlansMockPool()
        self.db = WorldModelDatabase(pool=self.pool, assessment_id=1)
        await self.db.init()

    async def test_add_plan(self):
        plan = await self.db.add_plan(
            title="Test Plan",
            goal="Test SQL injection",
            steps=[
                {"description": "Identify DB type"},
                {"description": "Test union injection"},
            ],
        )
        self.assertIn("id", plan)
        self.assertEqual(plan["title"], "Test Plan")
        self.assertEqual(len(plan["steps"]), 2)
        self.assertEqual(plan["steps"][0]["status"], "pending")
        self.assertEqual(plan["status"], "active")

    async def test_update_plan_step(self):
        plan = await self.db.add_plan(
            title="Test",
            goal="Test",
            steps=[{"description": "Step 1"}, {"description": "Step 2"}],
        )
        updated = await self.db.update_plan(
            plan_id=plan["id"],
            step_index=0,
            step_status="done",
            step_result="MySQL detected",
        )
        self.assertEqual(updated["steps"][0]["status"], "done")
        self.assertEqual(updated["steps"][0]["result"], "MySQL detected")
        self.assertEqual(updated["steps"][1]["status"], "pending")

    async def test_update_plan_reflection(self):
        plan = await self.db.add_plan(
            title="Test",
            goal="Test",
            steps=[{"description": "Step 1"}],
        )
        updated = await self.db.update_plan(
            plan_id=plan["id"],
            reflection="Union injection failed, blind confirmed",
            status="completed",
        )
        self.assertEqual(updated["reflection"], "Union injection failed, blind confirmed")
        self.assertEqual(updated["status"], "completed")

    async def test_query_plans(self):
        await self.db.add_plan(
            title="Plan A",
            goal="Goal A",
            steps=[{"description": "Step"}],
        )
        await self.db.add_plan(
            title="Plan B",
            goal="Goal B",
            steps=[{"description": "Step"}],
        )
        plans = await self.db.query(table="plans")
        self.assertEqual(len(plans), 2)

    async def test_plan_not_found(self):
        with self.assertRaises(ValueError):
            await self.db.update_plan(plan_id="nonexistent")

    async def test_step_index_out_of_range(self):
        plan = await self.db.add_plan(
            title="Test",
            goal="Test",
            steps=[{"description": "Step 1"}],
        )
        with self.assertRaises(ValueError):
            await self.db.update_plan(
                plan_id=plan["id"],
                step_index=5,
                step_status="done",
            )

    async def test_invalid_plan_status(self):
        plan = await self.db.add_plan(
            title="Test",
            goal="Test",
            steps=[{"description": "Step 1"}],
        )
        with self.assertRaises(ValueError):
            await self.db.update_plan(
                plan_id=plan["id"],
                status="invalid",
            )


# ============================================================================
# Integration: Payload Generator with sqli_db
# ============================================================================

class TestPayloadGeneratorSQLiDB(unittest.TestCase):
    """Test sqli_db integration in PayloadGenerator."""

    def test_sqli_db_type(self):
        from lib.payload_generator import PayloadGenerator
        gen = PayloadGenerator()
        types = gen.get_payload_types()
        self.assertIn("sqli_db", types)

    def test_sqli_db_payloads(self):
        from lib.payload_generator import PayloadGenerator
        gen = PayloadGenerator()
        payloads = gen.get_payloads_by_type("sqli_db")
        self.assertGreater(len(payloads), 50)
        self.assertEqual(payloads[0]["type"], "sqli_db")

    def test_get_db_payloads_mysql(self):
        from lib.payload_generator import PayloadGenerator
        gen = PayloadGenerator()
        payloads = gen.get_db_payloads(db_type="mysql")
        self.assertGreater(len(payloads), 10)
        for p in payloads:
            self.assertEqual(p["db_type"], "mysql")

    def test_get_db_payloads_with_technique(self):
        from lib.payload_generator import PayloadGenerator
        gen = PayloadGenerator()
        payloads = gen.get_db_payloads(db_type="mysql", technique="union")
        for p in payloads:
            self.assertEqual(p["technique"], "union")

    def test_description_includes_sqli_db(self):
        from lib.payload_generator import PayloadGenerator
        gen = PayloadGenerator()
        descs = gen.get_payload_type_descriptions()
        self.assertIn("sqli_db", descs)
        self.assertIn("DB-specific", descs["sqli_db"])


if __name__ == "__main__":
    unittest.main()
