"""
Tests for semantic duplicate finding detection in record_finding.

5 tests validating that near-duplicate findings are detected and skipped,
while unique findings proceed to card creation.
"""

import sys
import os
import json
import unittest
from unittest.mock import AsyncMock, MagicMock, patch

# Add modules to path (avoid pip mcp package shadowing)
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

from tools_pentest import (
    _handle_record_finding,
)


class TestDuplicateDetection(unittest.IsolatedAsyncioTestCase):
    """Test suite for semantic duplicate finding detection."""

    def setUp(self):
        self.mcp_service = MagicMock()
        self.mcp_service.current_assessment_id = 1
        self.mcp_service.scope_provider = MagicMock()
        self.mcp_service.activity_logger = None

    @patch("lib.embedder.get_embedder")
    @patch("tools_pentest._get_db")
    async def test_exact_duplicate_detected_without_embedder(self, mock_get_db, mock_get_embedder):
        """Test that exact title+URL match is detected when embedder unavailable."""
        mock_db = AsyncMock()
        mock_db.assessment_id = 1
        mock_db.query = AsyncMock(return_value=[
            {
                "id": "finding-existing",
                "title": "SQL Injection in /api/users",
                "url": "http://target/api/users",
                "metadata": json.dumps({"vuln_class": "sqli_error"}),
            }
        ])
        mock_db.coverage_mark = AsyncMock()
        mock_get_db.return_value = mock_db

        # Embedder not available (no sentence-transformers)
        mock_embedder = MagicMock()
        mock_embedder.available = False
        mock_embedder.embed.return_value = None
        mock_get_embedder.return_value = mock_embedder

        result = await _handle_record_finding(
            {
                "title": "SQL Injection in /api/users",
                "severity": "high",
                "url": "http://target/api/users",
                "description": "SQL injection via id param",
                "evidence": {"payload": "' OR 1=1--"},
                "remediation": "Use parameterized queries",
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
                "attack_scenario": "Attacker extracts DB",
            },
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        self.assertTrue(data["merged"])
        self.assertEqual(data["duplicate_of"], "finding-existing")
        self.assertEqual(data["similarity"], 1.0)
        self.assertIn("merged into existing", data["message"])

    @patch("lib.embedder.get_embedder")
    @patch("tools_pentest._get_db")
    async def test_unique_finding_not_flagged(self, mock_get_db, mock_get_embedder):
        """Test that a unique finding passes dedup and creates a card."""
        mock_db = AsyncMock()
        mock_db.assessment_id = 1
        # Existing finding is XSS, new is SQLi - different
        mock_db.query = AsyncMock(return_value=[
            {
                "id": "finding-xss",
                "title": "XSS in /search",
                "url": "http://target/search",
                "metadata": json.dumps({"vuln_class": "xss_reflected"}),
            }
        ])
        mock_db.coverage_mark = AsyncMock()
        mock_get_db.return_value = mock_db

        # Embedder not available
        mock_embedder = MagicMock()
        mock_embedder.available = False
        mock_embedder.embed.return_value = None
        mock_get_embedder.return_value = mock_embedder

        # Mock safe_add_card for the card creation path
        mock_result = MagicMock()
        mock_result.ok = True
        mock_result.data = {"id": "card-new"}
        self.mcp_service.safe_add_card = AsyncMock(return_value=mock_result)

        result = await _handle_record_finding(
            {
                "title": "SQL Injection in /api/users",
                "severity": "high",
                "url": "http://target/api/users",
                "description": "SQL injection via id param",
                "evidence": {"payload": "' OR 1=1--"},
                "remediation": "Use parameterized queries",
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
                "attack_scenario": "Attacker extracts DB",
            },
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        self.assertFalse(data.get("duplicate_detected", False))
        self.assertTrue(data.get("success") or data.get("card_id"))

    @patch("lib.embedder.get_embedder")
    @patch("lib.world_model_db.get_world_model_db")
    @patch("tools_pentest._get_db")
    async def test_semantic_duplicate_detected_with_embedder(self, mock_get_db, mock_get_wm_db, mock_get_embedder):
        """Test that semantic near-duplicate is detected via embedder (similarity > 0.85)."""
        import struct

        mock_db = AsyncMock()
        mock_db.assessment_id = 1
        mock_db.query = AsyncMock(return_value=[
            {
                "id": "finding-sqli",
                "title": "SQL Injection on /api/users endpoint",
                "url": "http://target/api/users",
                "metadata": json.dumps({"vuln_class": "sqli_error"}),
            }
        ])
        mock_get_db.return_value = mock_db

        # Mock world model DB for SAST merge check (returns no SAST match)
        mock_wm_db = AsyncMock()
        mock_wm_db.query = AsyncMock(return_value=[])
        mock_get_wm_db.return_value = mock_wm_db

        # Create fake embeddings that are very similar (cosine > 0.85)
        # Use simple 4-dimensional vectors for testing
        vec_a = struct.pack("4f", 0.9, 0.1, 0.2, 0.3)  # "new" finding
        vec_b = struct.pack("4f", 0.88, 0.12, 0.19, 0.31)  # "existing" finding (very similar)

        mock_embedder = MagicMock()
        mock_embedder.available = True
        embed_calls = [0]

        def mock_embed(text):
            embed_calls[0] += 1
            if embed_calls[0] == 1:
                return vec_a  # new finding
            return vec_b  # existing finding

        mock_embedder.embed = mock_embed
        mock_get_embedder.return_value = mock_embedder

        result = await _handle_record_finding(
            {
                "title": "SQLi in /api/users",
                "severity": "high",
                "url": "http://target/api/users",
                "vuln_class": "sqli_error",
                "description": "SQL injection found",
                "evidence": {},
                "remediation": "Use parameterized queries",
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
                "attack_scenario": "Attacker extracts DB",
            },
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        self.assertTrue(data["merged"])
        self.assertEqual(data["duplicate_of"], "finding-sqli")
        self.assertGreater(data["similarity"], 0.85)

    @patch("lib.embedder.get_embedder")
    @patch("tools_pentest._get_db")
    async def test_different_url_not_duplicate_without_embedder(self, mock_get_db, mock_get_embedder):
        """Test that same title but different URL is not flagged as duplicate (fallback)."""
        mock_db = AsyncMock()
        mock_db.assessment_id = 1
        mock_db.query = AsyncMock(return_value=[
            {
                "id": "finding-1",
                "title": "SQL Injection in /api/users",
                "url": "http://target/api/users",
                "metadata": json.dumps({"vuln_class": "sqli_error"}),
            }
        ])
        mock_db.coverage_mark = AsyncMock()
        mock_get_db.return_value = mock_db

        # Embedder not available
        mock_embedder = MagicMock()
        mock_embedder.available = False
        mock_embedder.embed.return_value = None
        mock_get_embedder.return_value = mock_embedder

        # Different URL
        mock_result = MagicMock()
        mock_result.ok = True
        mock_result.data = {"id": "card-new-2"}
        self.mcp_service.safe_add_card = AsyncMock(return_value=mock_result)

        result = await _handle_record_finding(
            {
                "title": "SQL Injection in /api/users",
                "severity": "high",
                "url": "http://target/api/orders",  # Different URL
                "description": "SQL injection",
                "evidence": {},
                "remediation": "Use parameterized queries",
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
                "attack_scenario": "Attacker extracts DB",
            },
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        self.assertFalse(data.get("duplicate_detected", False))
        self.assertTrue(data.get("success") or data.get("card_id"))

    @patch("lib.embedder.get_embedder")
    @patch("tools_pentest._get_db")
    async def test_dedup_failure_does_not_block_creation(self, mock_get_db, mock_get_embedder):
        """Test that if dedup check fails, finding creation proceeds anyway."""
        mock_db = AsyncMock()
        mock_db.assessment_id = 1
        # First call (dedup query) raises, second call (coverage update) works
        mock_db.query = AsyncMock(side_effect=Exception("DB connection lost"))
        mock_db.coverage_mark = AsyncMock()
        mock_get_db.return_value = mock_db

        mock_embedder = MagicMock()
        mock_embedder.available = False
        mock_get_embedder.return_value = mock_embedder

        # Card creation should still work
        mock_result = MagicMock()
        mock_result.ok = True
        mock_result.data = {"id": "card-resilient"}
        self.mcp_service.safe_add_card = AsyncMock(return_value=mock_result)

        result = await _handle_record_finding(
            {
                "title": "Missing HSTS Header",
                "severity": "low",
                "url": "http://target/",
                "description": "HSTS not set",
                "evidence": {"description": "Header missing"},
                "remediation": "Add Strict-Transport-Security header",
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
                "attack_scenario": "MITM downgrade",
            },
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        # Despite dedup failure, finding should be created
        self.assertFalse(data.get("duplicate_detected", False))
        self.assertTrue(data.get("success") or data.get("card_id"))


    @patch("lib.embedder.get_embedder")
    @patch("tools_pentest._get_db")
    async def test_duplicate_merges_evidence_via_update(self, mock_get_db, mock_get_embedder):
        """Test that when a duplicate is detected with evidence, an UPDATE merges evidence into existing finding."""
        mock_db = AsyncMock()
        mock_db._assessment_id = 1
        mock_db.query = AsyncMock(return_value=[
            {
                "id": "finding-existing-merge",
                "title": "SQL Injection in /api/users",
                "url": "http://target/api/users",
                "metadata": json.dumps({"vuln_class": "sqli_error"}),
            }
        ])
        mock_db._execute = AsyncMock()
        mock_get_db.return_value = mock_db

        # Embedder not available â€” fallback exact match
        mock_embedder = MagicMock()
        mock_embedder.available = False
        mock_embedder.embed.return_value = None
        mock_get_embedder.return_value = mock_embedder

        result = await _handle_record_finding(
            {
                "title": "SQL Injection in /api/users",
                "severity": "high",
                "url": "http://target/api/users",
                "description": "Duplicate with new evidence",
                "evidence": {"payload": "' UNION SELECT 1,2,3--", "description": "Union-based SQLi"},
                "remediation": "Use parameterized queries",
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
                "attack_scenario": "Attacker extracts DB",
            },
            self.mcp_service,
        )
        data = json.loads(result[0].text)

        # Should be detected as duplicate with merge
        self.assertTrue(data["merged"])
        self.assertEqual(data["duplicate_of"], "finding-existing-merge")

        # Verify _execute was called to merge evidence via UPDATE
        mock_db._execute.assert_called_once()
        call_args = mock_db._execute.call_args
        update_sql = call_args[0][0]
        self.assertIn("wm_findings", update_sql)
        self.assertIn("evidence_ids", update_sql)
        # Verify the finding ID was passed
        update_params = call_args[0][1]
        self.assertEqual(update_params[1], "finding-existing-merge")


if __name__ == "__main__":
    unittest.main()
