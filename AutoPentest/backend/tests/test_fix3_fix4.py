"""
Test Fix 3 (Phase Gates with Coverage Metrics) and Fix 4 (Simple Vulnerability Checklist)

Fix 3: Verify coverage_pct metric is calculated and Phase 4 gates require coverage.
Fix 4: Verify simple vulnerability checklist is present in pentest workflow resource.
"""
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../mcp/modules'))

import unittest
from unittest.mock import AsyncMock, MagicMock, patch


class TestFix3CoverageMetrics(unittest.IsolatedAsyncioTestCase):
    """Test Fix 3: Coverage percentage metric and Phase 4 gates."""

    async def test_coverage_pct_metric_calculated(self):
        """Verify get_metrics() returns coverage_pct."""
        from lib.phase_orchestrator import PhaseOrchestrator
        from lib.world_model_db import WorldModelDatabase

        # Mock database
        mock_db = AsyncMock(spec=WorldModelDatabase)
        mock_db._assessment_id = 123

        # Mock coverage matrix query: 10 total, 3 tested
        mock_db._fetchone = AsyncMock()
        mock_db._fetchone.side_effect = [
            {"cnt": 5},  # assets
            {"cnt": 10},  # endpoints
            {"cnt": 2},  # hypotheses
            {"cnt": 1},  # confirmed_hypotheses
            {"cnt": 3},  # findings
            {"cnt": 1},  # confirmed_findings
            {"total": 10, "tested": 3},  # coverage matrix
            {"total": 10, "verified": 10},  # SAST verification (Phase 3)
            {"cnt": 0},  # source_code indexed count (no source = auto-pass)
            {"total": 0, "reviewed": 0},  # code_audit_pct (vacuously true)
        ]

        orchestrator = PhaseOrchestrator(db=mock_db)
        metrics = await orchestrator.get_metrics()

        # Verify coverage_pct is calculated correctly
        self.assertIn("coverage_pct", metrics)
        self.assertEqual(metrics["coverage_pct"], 30.0, "10 total, 3 tested = 30%")

    async def test_coverage_pct_zero_when_no_coverage(self):
        """Verify coverage_pct is 0.0 when coverage matrix is empty."""
        from lib.phase_orchestrator import PhaseOrchestrator
        from lib.world_model_db import WorldModelDatabase

        mock_db = AsyncMock(spec=WorldModelDatabase)
        mock_db._assessment_id = 123
        mock_db._fetchone = AsyncMock()
        mock_db._fetchone.side_effect = [
            {"cnt": 5},  # assets
            {"cnt": 10},  # endpoints
            {"cnt": 2},  # hypotheses
            {"cnt": 1},  # confirmed_hypotheses
            {"cnt": 3},  # findings
            {"cnt": 1},  # confirmed_findings
            {"total": 0, "tested": 0},  # coverage matrix empty
            {"total": 0, "verified": 0},  # SAST verification (Phase 3)
            {"cnt": 0},  # source_code indexed count (no source = auto-pass)
            {"total": 0, "reviewed": 0},  # code_audit_pct (vacuously true)
        ]

        orchestrator = PhaseOrchestrator(db=mock_db)
        metrics = await orchestrator.get_metrics()

        self.assertEqual(metrics["coverage_pct"], 0.0)

    async def test_coverage_pct_handles_null_rows(self):
        """Verify coverage_pct handles None rows gracefully."""
        from lib.phase_orchestrator import PhaseOrchestrator
        from lib.world_model_db import WorldModelDatabase

        mock_db = AsyncMock(spec=WorldModelDatabase)
        mock_db._assessment_id = 123
        mock_db._fetchone = AsyncMock()
        mock_db._fetchone.side_effect = [
            {"cnt": 5},  # assets
            {"cnt": 10},  # endpoints
            {"cnt": 2},  # hypotheses
            {"cnt": 1},  # confirmed_hypotheses
            {"cnt": 3},  # findings
            {"cnt": 1},  # confirmed_findings
            None,  # coverage matrix query returns None
            {"total": 0, "verified": 0},  # SAST verification (Phase 3)
            {"cnt": 0},  # source_code indexed count (no source = auto-pass)
            {"total": 0, "reviewed": 0},  # code_audit_pct (vacuously true)
        ]

        orchestrator = PhaseOrchestrator(db=mock_db)
        metrics = await orchestrator.get_metrics()

        self.assertEqual(metrics["coverage_pct"], 0.0, "Should default to 0.0 when query returns None")

    def test_phase4_gates_require_coverage_pct(self):
        """Verify Phase 4 gates include min_coverage_pct requirement."""
        from lib.phase_orchestrator import PHASES

        phase4_def = PHASES[3]  # Phase 4 (0-indexed)
        self.assertEqual(phase4_def["phase"], 4)

        gates = phase4_def.get("gates", {})
        self.assertIn("min_coverage_pct", gates, "Phase 4 must require coverage percentage")
        self.assertEqual(gates["min_coverage_pct"], 25.0, "Phase 4 requires 25% coverage")

    def test_phase4_gates_require_min_findings(self):
        """Verify Phase 4 gates require at least 3 findings (increased from 1)."""
        from lib.phase_orchestrator import PHASES

        phase4_def = PHASES[3]
        gates = phase4_def.get("gates", {})
        self.assertEqual(gates["min_findings"], 3, "Phase 4 requires 3 findings (Fix 3)")

    def test_coverage_pct_in_metric_map(self):
        """Verify coverage_pct is in _METRIC_MAP for gate checking."""
        from lib.phase_orchestrator import PhaseOrchestrator
        from lib.world_model_db import WorldModelDatabase

        mock_db = AsyncMock(spec=WorldModelDatabase)
        orchestrator = PhaseOrchestrator(db=mock_db)

        # Call check_gates to verify it can handle coverage_pct
        # We'll use metrics that fail the coverage check
        metrics = {
            "assets": 5,
            "endpoints": 10,
            "findings": 3,
            "confirmed_hypotheses": 1,
            "coverage_pct": 10.0,  # Below 25% requirement
        }

        result = orchestrator.check_gates(target_phase=4, metrics=metrics)

        # Should fail because coverage_pct < 25
        self.assertFalse(result["met"], "Phase 4 gate should fail with 10% coverage")

        # Verify conditions include coverage_pct check
        conditions = result["conditions"]
        coverage_condition = next((c for c in conditions if "coverage" in c["name"].lower()), None)
        self.assertIsNotNone(coverage_condition, "Coverage condition should be present")
        self.assertFalse(coverage_condition["met"], "Coverage condition should not be met")

    def test_phase4_gate_passes_with_sufficient_coverage(self):
        """Verify Phase 4 gate passes when coverage >= 25%."""
        from lib.phase_orchestrator import PhaseOrchestrator
        from lib.world_model_db import WorldModelDatabase

        mock_db = AsyncMock(spec=WorldModelDatabase)
        orchestrator = PhaseOrchestrator(db=mock_db)

        metrics = {
            "assets": 5,
            "endpoints": 10,
            "findings": 5,
            "confirmed_hypotheses": 2,
            "coverage_pct": 30.0,  # Meets 25% requirement
        }

        result = orchestrator.check_gates(target_phase=4, metrics=metrics)

        # Should pass
        self.assertTrue(result["met"], "Phase 4 gate should pass with 30% coverage")


class TestSASTScannerGate(unittest.IsolatedAsyncioTestCase):
    """Test Phase 3 gate: require SAST scanners when source code is indexed."""

    def test_phase3_gate_includes_sast_scanners_run(self):
        """Verify Phase 3 gates include min_sast_scanners_run."""
        from lib.phase_orchestrator import PHASES

        phase3_def = PHASES[2]  # Phase 3 (0-indexed)
        self.assertEqual(phase3_def["phase"], 3)
        gates = phase3_def.get("gates", {})
        self.assertIn("min_sast_scanners_run", gates)
        self.assertEqual(gates["min_sast_scanners_run"], 1)

    async def test_gate_blocks_when_source_indexed_but_no_scanners(self):
        """Gate should BLOCK when source code is indexed but no SAST scanners ran."""
        from lib.phase_orchestrator import PhaseOrchestrator
        from lib.world_model_db import WorldModelDatabase

        mock_db = AsyncMock(spec=WorldModelDatabase)
        mock_db._assessment_id = 1
        mock_db._fetchone = AsyncMock()
        mock_db._fetchone.side_effect = [
            {"cnt": 5},   # assets
            {"cnt": 10},  # endpoints
            {"cnt": 2},   # hypotheses
            {"cnt": 1},   # confirmed_hypotheses
            {"cnt": 3},   # findings
            {"cnt": 1},   # confirmed_findings
            {"total": 10, "tested": 3},   # coverage matrix
            {"total": 0, "verified": 0},  # SAST scan results (0 = no scanners ran)
            {"cnt": 12},  # source_code indexed (12 files = git_repo_url was indexed)
            {"total": 0, "reviewed": 0},  # code_audit_pct
        ]

        orchestrator = PhaseOrchestrator(db=mock_db)
        metrics = await orchestrator.get_metrics()

        # sast_scanners_run should be 0 (source indexed but no scan results)
        self.assertEqual(metrics["sast_scanners_run"], 0)

        # Gate should BLOCK
        result = orchestrator.check_gates(target_phase=3, metrics=metrics)
        self.assertFalse(result["met"], "Gate should block: source indexed but 0 scanners ran")

        # Verify the specific unmet condition
        unmet = [c for c in result["conditions"] if not c["met"]]
        scanner_condition = next((c for c in unmet if "sast_scanners_run" in c["name"]), None)
        self.assertIsNotNone(scanner_condition, "sast_scanners_run condition should be unmet")

    async def test_gate_passes_when_source_indexed_and_scanners_ran(self):
        """Gate should PASS when source code is indexed AND SAST scanners ran."""
        from lib.phase_orchestrator import PhaseOrchestrator
        from lib.world_model_db import WorldModelDatabase

        mock_db = AsyncMock(spec=WorldModelDatabase)
        mock_db._assessment_id = 1
        mock_db._fetchone = AsyncMock()
        mock_db._fetchone.side_effect = [
            {"cnt": 5},   # assets
            {"cnt": 10},  # endpoints
            {"cnt": 2},   # hypotheses
            {"cnt": 1},   # confirmed_hypotheses
            {"cnt": 3},   # findings
            {"cnt": 1},   # confirmed_findings
            {"total": 10, "tested": 3},    # coverage matrix
            {"total": 8, "verified": 8},   # SAST scan results (8 = scanners ran)
            {"cnt": 12},  # source_code indexed (12 files)
            {"total": 0, "reviewed": 0},   # code_audit_pct
        ]

        orchestrator = PhaseOrchestrator(db=mock_db)
        metrics = await orchestrator.get_metrics()

        # sast_scanners_run should be 8 (from sast_total)
        self.assertEqual(metrics["sast_scanners_run"], 8)

        # Gate should PASS
        result = orchestrator.check_gates(target_phase=3, metrics=metrics)
        self.assertTrue(result["met"], "Gate should pass: source indexed and scanners ran")

    async def test_gate_autopasses_when_no_source_indexed(self):
        """Gate should auto-pass when no source code is indexed (no git_repo_url)."""
        from lib.phase_orchestrator import PhaseOrchestrator
        from lib.world_model_db import WorldModelDatabase

        mock_db = AsyncMock(spec=WorldModelDatabase)
        mock_db._assessment_id = 1
        mock_db._fetchone = AsyncMock()
        mock_db._fetchone.side_effect = [
            {"cnt": 5},   # assets
            {"cnt": 10},  # endpoints
            {"cnt": 2},   # hypotheses
            {"cnt": 1},   # confirmed_hypotheses
            {"cnt": 3},   # findings
            {"cnt": 1},   # confirmed_findings
            {"total": 10, "tested": 3},   # coverage matrix
            {"total": 0, "verified": 0},  # SAST scan results (0 = no scanners)
            {"cnt": 0},   # source_code indexed (0 = no git_repo_url)
            {"total": 0, "reviewed": 0},  # code_audit_pct
        ]

        orchestrator = PhaseOrchestrator(db=mock_db)
        metrics = await orchestrator.get_metrics()

        # sast_scanners_run should be 1 (auto-pass when no source indexed)
        self.assertEqual(metrics["sast_scanners_run"], 1)

        # Gate should PASS
        result = orchestrator.check_gates(target_phase=3, metrics=metrics)
        self.assertTrue(result["met"], "Gate should auto-pass: no source code indexed")


class TestFix4SimpleVulnerabilityChecklist(unittest.TestCase):
    """Test Fix 4: Simple vulnerability checklist in pentest workflow."""

    def test_simple_vulnerability_checklist_exists(self):
        """Verify simple_vulnerability_checklist is in pentest workflow resource."""
        from resources import _get_pentest_workflow

        workflow = _get_pentest_workflow()

        self.assertIn("simple_vulnerability_checklist", workflow,
            "Pentest workflow must include simple_vulnerability_checklist")

    def test_checklist_has_8_tests(self):
        """Verify checklist includes all 8 mandatory tests."""
        from resources import _get_pentest_workflow

        workflow = _get_pentest_workflow()
        checklist = workflow["simple_vulnerability_checklist"]
        tests = checklist.get("tests", [])

        self.assertEqual(len(tests), 8, "Checklist must have 8 tests")

        # Verify expected test names
        expected_tests = [
            "Security Headers",
            "Weak Password Policy",
            "Username Enumeration",
            "CSRF Protection",
            "Default Credentials",
            "Input Validation",
            "Rate Limiting",
            "Error Handling"
        ]

        actual_names = [test["name"] for test in tests]
        for expected in expected_tests:
            self.assertIn(expected, actual_names, f"Test '{expected}' must be in checklist")

    def test_each_test_has_required_fields(self):
        """Verify each test has all required fields."""
        from resources import _get_pentest_workflow

        workflow = _get_pentest_workflow()
        tests = workflow["simple_vulnerability_checklist"]["tests"]

        required_fields = ["name", "tool", "priority", "effort", "how", "what_to_check", "record_if"]

        for test in tests:
            for field in required_fields:
                self.assertIn(field, test,
                    f"Test '{test.get('name', 'UNKNOWN')}' must have '{field}' field")

    def test_checklist_specifies_completion_criteria(self):
        """Verify checklist includes completion criteria."""
        from resources import _get_pentest_workflow

        workflow = _get_pentest_workflow()
        checklist = workflow["simple_vulnerability_checklist"]

        self.assertIn("completion_criteria", checklist)
        criteria = checklist["completion_criteria"]

        self.assertIn("minimum_tests", criteria)
        self.assertEqual(criteria["minimum_tests"], 6,
            "Must complete at least 6 of 8 tests")

    def test_checklist_tools_are_valid(self):
        """Verify all tools referenced in checklist are real pentest tools."""
        from resources import _get_pentest_workflow

        workflow = _get_pentest_workflow()
        tests = workflow["simple_vulnerability_checklist"]["tests"]

        valid_tools = [
            "recon_endpoint",
            "inject_payload",
            "inject_batch",
            "analyze_headers",
            "get_test_payloads",
            "discover_attack_surface",
            "record_finding",
            "get_test_progress"
        ]

        for test in tests:
            tool = test.get("tool")
            self.assertIn(tool, valid_tools,
                f"Test '{test['name']}' uses invalid tool '{tool}'")

    def test_checklist_has_description(self):
        """Verify checklist has description explaining its purpose."""
        from resources import _get_pentest_workflow

        workflow = _get_pentest_workflow()
        checklist = workflow["simple_vulnerability_checklist"]

        self.assertIn("description", checklist)
        description = checklist["description"]

        # Verify description mentions mandatory nature
        self.assertIn("MANDATORY", description)
        self.assertIn("Phase 3", description)

    def test_checklist_references_assessment_gap(self):
        """Verify checklist references the Assessment 4 vs 10/11 gap."""
        from resources import _get_pentest_workflow

        workflow = _get_pentest_workflow()
        checklist = workflow["simple_vulnerability_checklist"]

        description = checklist["description"]

        # Should mention the finding gap
        self.assertTrue(
            "24" in description or "Assessment 4" in description,
            "Should reference Assessment 4 findings"
        )

    def test_security_headers_test_details(self):
        """Verify Security Headers test has correct details."""
        from resources import _get_pentest_workflow

        workflow = _get_pentest_workflow()
        tests = workflow["simple_vulnerability_checklist"]["tests"]

        headers_test = next(t for t in tests if t["name"] == "Security Headers")

        self.assertEqual(headers_test["tool"], "analyze_headers")
        self.assertEqual(headers_test["priority"], "CRITICAL")
        self.assertIn("CSP", str(headers_test["what_to_check"]))
        self.assertIn("HSTS", str(headers_test["what_to_check"]))

    def test_weak_password_test_details(self):
        """Verify Weak Password Policy test has correct details."""
        from resources import _get_pentest_workflow

        workflow = _get_pentest_workflow()
        tests = workflow["simple_vulnerability_checklist"]["tests"]

        password_test = next(t for t in tests if t["name"] == "Weak Password Policy")

        self.assertEqual(password_test["tool"], "inject_payload")
        self.assertEqual(password_test["priority"], "HIGH")
        self.assertIn("8 chars", password_test["what_to_check"][0])

    def test_username_enumeration_test_details(self):
        """Verify Username Enumeration test has correct details."""
        from resources import _get_pentest_workflow

        workflow = _get_pentest_workflow()
        tests = workflow["simple_vulnerability_checklist"]["tests"]

        enum_test = next(t for t in tests if t["name"] == "Username Enumeration")

        self.assertEqual(enum_test["tool"], "inject_batch")
        self.assertIn("response time", str(enum_test["what_to_check"]))


if __name__ == '__main__':
    unittest.main()
