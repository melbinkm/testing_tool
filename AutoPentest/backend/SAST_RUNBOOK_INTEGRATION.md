# SAST Integration into Autonomous Runbook - Implementation Summary

**Date:** 2026-02-17
**Status:** ✅ COMPLETE - All 463 tests pass (12 new tests added)

## Overview

Integrated SAST (Static Application Security Testing) tools into the autonomous runbook execution workflow. The LLM can now automatically clone source code, run multiple SAST scanners, verify findings dynamically, and record exploitable vulnerabilities — all within the existing 5-phase assessment workflow.

## Key Features

### 1. Local Repository Access
- **Change:** Replaced Docker volume with host bind mount for SAST repositories
- **Path:** `./sast_repos` → `/mnt/d/testing_tool/AutoPentest/sast_repos/{assessment_id}/{repo_name}/`
- **Impact:** Claude Code can use native Read/Grep/Glob tools directly on cloned repos for execution flow tracing

### 2. Function-Level Code Extraction
- **New Method:** `CodeIndexer.extract_function_at_line(content, language, line_number)`
- **Supports:** Python (indentation-based), JavaScript/TypeScript/Java/Go/C/C++/Rust (brace-based)
- **Fallback:** ±15 line context window if no function detected
- **Purpose:** Present LLM with vulnerable function only (not whole file) for focused analysis

### 3. SAST Verification Workflow
- **New Tool:** `sast_get_next_unverified` - Returns unverified SAST finding with:
  - Function-level code extract
  - Local file path for native Read/Grep access
  - Investigation guide (how to trace execution flow)
  - Remediation hint
- **New Tool:** `sast_mark_verified` - Records verification result:
  - `exploitable=true` → Creates finding with full severity + remediation
  - `exploitable=false` → Creates info-level finding (confirmed but not demonstrable)
  - `false_positive=true` → No finding, just marks verified

### 4. Scan Result Persistence
- **New Knowledge Category:** `"sast_scan_result"` in `KNOWLEDGE_CATEGORIES`
- **Storage:** All SAST findings (Semgrep, Bandit, Gitleaks) stored in `wm_knowledge` with `verified: false`
- **Tracking:** `sast_get_next_unverified` queries unverified findings for LLM verification

### 5. Autonomous Runbook Steps (7 new steps)

#### Phase 2: Mapping & Enumeration (5 new steps)
- **2.5:** `sast_clone_repo` - Clone git repository (skip if no repo)
- **2.6:** `sast_index_repo` - Index source code for RAG search (skip if clone failed)
- **2.7:** `sast_scan_semgrep` - Run Semgrep scanner (skip if clone failed)
- **2.8:** `sast_scan_bandit` - Run Bandit Python scanner (skip if clone failed)
- **2.9:** `sast_scan_gitleaks` - Run Gitleaks secret scanner (skip if clone failed)
- **Renumbered:** 2.5 → 2.10 (gate), 2.6 → 2.11 (advance)

#### Phase 3: Vulnerability Assessment (2 new steps)
- **3.7:** `sast_get_next_unverified` - Verify SAST findings dynamically (REPEATABLE)
  - Repeat until all SAST findings verified
  - Workflow: Read function → Trace execution with Read/Grep → Test with inject_payload → Mark verified
- **3.8:** `sast_correlate` - Cross-reference SAST↔DAST findings
- **Renumbered:** 3.7 → 3.9 (gate), 3.8 → 3.10 (advance)

### 6. Repeat Condition: `sast_all_verified`
- **Behavior:** Repeats step 3.7 until all `wm_knowledge` entries with `category="sast_scan_result"` have `verified=true`
- **Implementation:** Early check before PhaseOrchestrator to avoid unnecessary metrics calls

## Files Modified

| File | Changes | Lines |
|------|---------|-------|
| `docker-compose.yml` | Host bind mount for SAST repos | 3 |
| `lib/world_model_db.py` | Add "sast_scan_result" to KNOWLEDGE_CATEGORIES | 1 |
| `lib/code_indexer.py` | Add `extract_function_at_line()` method | +171 |
| `tools_sast.py` | Modify 3 scan handlers + add 2 new tools | +260 |
| `tools_auto_run.py` | Add 7 steps, renumber 4, add repeat condition | +80 |
| `lib/tool_metadata.py` | Add 2 tool entries, update phase sets | +35 |
| `tests/test_sast_runbook.py` | New test file with 12 tests | +270 |
| **Total** | | **~820 lines** |

## LLM Workflow (Step 3.7 Repeating Loop)

For each unverified SAST finding:

1. **Receive function code** - `sast_get_next_unverified()` returns vulnerable function only
2. **Trace execution flow** - Use `local_file_path` and `repo_local_root` with Read/Grep to:
   - Search for function callers
   - Find HTTP handler that calls this function
   - Check input sanitization/validation
   - Read related files for context
3. **Test dynamically** - Use `inject_payload`/`inject_batch` to attempt exploitation
4. **Develop bypasses** - Try encoding variations, WAF bypass payloads if needed
5. **Mark result** - `sast_mark_verified(finding_id, exploitable=bool, remediation="...")`
6. **Repeat** - Automatically gets next unverified finding until all verified

## Test Coverage

### New Tests (12 total)
1. `test_extract_function_python` - Python function extraction ✅
2. `test_extract_function_javascript` - JS function extraction ✅
3. `test_extract_function_fallback` - Context window fallback ✅
4. `test_sast_get_next_unverified_returns_function` - Tool returns function ✅
5. `test_sast_get_next_unverified_all_done` - Returns "all_verified" status ✅
6. `test_sast_mark_verified_exploitable` - Creates finding when exploitable ✅
7. `test_sast_mark_verified_informational` - Creates info finding ✅
8. `test_sast_mark_verified_false_positive` - No finding for FP ✅
9. `test_scan_stores_results_in_knowledge` - Scanners persist results ✅
10. `test_sast_all_verified_repeat_condition` - Repeat logic works ✅
11. `test_runbook_has_sast_steps` - All 7 SAST steps present ✅
12. `test_runbook_step_count` - Total steps = 38 ✅

### Test Results
- **Total:** 463 tests pass (was 451, added 12)
- **Failures:** 0
- **Skipped:** 7 (pre-existing)
- **Warnings:** 6 (pre-existing)

## Tool Metadata

### New Tools
- **sast_get_next_unverified**
  - Category: sast
  - Phase: assessment
  - Risk: safe, Budget: low
  - Dependencies: sast_scan_semgrep
  - Enables: sast_mark_verified

- **sast_mark_verified**
  - Category: sast
  - Phase: assessment
  - Risk: safe, Budget: low
  - Dependencies: sast_get_next_unverified
  - Enables: sast_record_finding

### Updated Counts
- **SAST tools:** 11 → 13
- **Phase 3 tools:** 52 → 54
- **Total runbook steps:** 31 → 38

## Usage Example

```python
# Autonomous runbook will automatically:

# Phase 2 (steps 2.5-2.9):
load_assessment(name="example.com")
orchestration_auto_run()  # → 2.5: sast_clone_repo
orchestration_auto_run(action="step_done")  # → 2.6: sast_index_repo
orchestration_auto_run(action="step_done")  # → 2.7: sast_scan_semgrep (finds 15 results)
orchestration_auto_run(action="step_done")  # → 2.8: sast_scan_bandit (finds 8 results)
orchestration_auto_run(action="step_done")  # → 2.9: sast_scan_gitleaks (finds 3 results)

# Phase 3 (step 3.7 repeats):
orchestration_auto_run()  # → 3.7: sast_get_next_unverified (returns first finding)
# LLM: Reads function, uses Read/Grep to trace callers, tests with inject_payload
sast_mark_verified(finding_id="...", exploitable=True, remediation="...")
orchestration_auto_run(action="step_done")  # → 3.7 repeats (25 more findings)
# ... repeats until all 26 findings verified
orchestration_auto_run(action="step_done")  # → 3.8: sast_correlate
```

## Key Design Decisions

1. **Host bind mount** - Enables Claude Code to use native Read/Grep for tracing execution flow (vs MCP-only access)
2. **Function-level extraction** - Reduces LLM token consumption and focuses analysis on vulnerable code
3. **Separate verification step** - Forces dynamic testing of static findings (prevents false positives)
4. **Repeatable step** - Automatically processes all SAST findings without manual intervention
5. **Informational findings** - Records real-but-not-exploitable findings to prevent duplicate scanning
6. **Early repeat check** - Avoids PhaseOrchestrator overhead for non-metrics conditions

## Production Readiness

✅ **All requirements met:**
- Local repo access for Claude Code ✅
- Function-level code splitting ✅
- Dynamic verification workflow ✅
- Informational findings for non-exploitable issues ✅
- Bypass development support (full HTTP tools available) ✅
- Remediation guidance included ✅
- Execution flow tracing via Read/Grep/Glob ✅
- Autonomous runbook integration ✅
- 100% test pass rate (463/463) ✅

## Next Steps

**Deployment:**
1. Restart Docker Compose to apply bind mount change: `docker compose down && docker compose up -d`
2. Verify `sast_repos` directory created on host: `ls -la /mnt/d/testing_tool/AutoPentest/sast_repos/`
3. Test SAST workflow with real repository (optional git_repo_url in assessment settings)
4. Monitor LLM performance in Phase 3 step 3.7 verification loop

**Optional Enhancements:**
- Add more SAST scanners (CodeQL, Snyk, etc.) as additional Phase 2 steps
- Add LLM prompts/examples to `resources.py` for SAST verification guidance
- Add SAST metrics to `orchestration_status` output (verified/total findings)
