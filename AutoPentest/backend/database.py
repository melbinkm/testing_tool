"""
Database connection and session management
"""
import logging
from sqlalchemy import create_engine, text
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from config import settings

logger = logging.getLogger("autopentest-mcp")

# Sync engine (legacy compatibility)
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    echo=False
)

# Async engine for improved performance
async_database_url = settings.DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://")
async_engine = create_async_engine(
    async_database_url,
    pool_pre_ping=True,
    echo=False
)

# Session factories
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
AsyncSessionLocal = async_sessionmaker(
    async_engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autocommit=False,
    autoflush=False
)

# Base class for models
Base = declarative_base()


def get_db():
    """
    Dependency for FastAPI routes to get database session (sync)
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


async def get_async_db():
    """
    Dependency for FastAPI routes to get async database session
    """
    async with AsyncSessionLocal() as session:
        yield session


def init_db():
    """
    Initialize database (create all tables)
    """
    Base.metadata.create_all(bind=engine)


# ---------------------------------------------------------------------------
# World Model tables (wm_*) â€” DDL for PostgreSQL + pgvector + FTS
# ---------------------------------------------------------------------------

_WM_SCHEMA_SQL = """
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

CREATE TABLE IF NOT EXISTS wm_assets (
    id            TEXT PRIMARY KEY,
    assessment_id INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
    kind          TEXT NOT NULL,
    name          TEXT NOT NULL,
    metadata      JSONB NOT NULL DEFAULT '{}',
    tags          JSONB NOT NULL DEFAULT '[]',
    discovered_at TIMESTAMPTZ NOT NULL,
    updated_at    TIMESTAMPTZ NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_wm_assets_assessment ON wm_assets(assessment_id);

CREATE TABLE IF NOT EXISTS wm_endpoints (
    id            TEXT PRIMARY KEY,
    assessment_id INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
    asset_id      TEXT NOT NULL,
    method        TEXT NOT NULL,
    path          TEXT NOT NULL,
    parameters    JSONB NOT NULL DEFAULT '{}',
    auth_required BOOLEAN NOT NULL DEFAULT FALSE,
    status        TEXT NOT NULL DEFAULT 'discovered',
    metadata      JSONB NOT NULL DEFAULT '{}',
    discovered_at TIMESTAMPTZ NOT NULL,
    updated_at    TIMESTAMPTZ NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_wm_endpoints_assessment ON wm_endpoints(assessment_id);
CREATE INDEX IF NOT EXISTS idx_wm_endpoints_asset ON wm_endpoints(asset_id);

CREATE TABLE IF NOT EXISTS wm_identities (
    id          TEXT PRIMARY KEY,
    assessment_id INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
    name        TEXT NOT NULL,
    auth_type   TEXT NOT NULL,
    scope       TEXT NOT NULL,
    permissions JSONB NOT NULL DEFAULT '[]',
    status      TEXT NOT NULL DEFAULT 'active',
    metadata    JSONB NOT NULL DEFAULT '{}',
    created_at  TIMESTAMPTZ NOT NULL,
    updated_at  TIMESTAMPTZ NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_wm_identities_assessment ON wm_identities(assessment_id);

CREATE TABLE IF NOT EXISTS wm_hypotheses (
    id          TEXT PRIMARY KEY,
    assessment_id INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
    title       TEXT NOT NULL,
    description TEXT NOT NULL,
    severity    TEXT NOT NULL DEFAULT 'info',
    status      TEXT NOT NULL DEFAULT 'proposed',
    evidence    JSONB NOT NULL DEFAULT '[]',
    target_id   TEXT,
    created_at  TIMESTAMPTZ NOT NULL,
    updated_at  TIMESTAMPTZ NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_wm_hypotheses_assessment ON wm_hypotheses(assessment_id);

CREATE TABLE IF NOT EXISTS wm_observations (
    id            TEXT PRIMARY KEY,
    assessment_id INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
    hypothesis_id TEXT NOT NULL,
    type          TEXT NOT NULL,
    content       TEXT NOT NULL,
    metadata      JSONB NOT NULL DEFAULT '{}',
    observed_at   TIMESTAMPTZ NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_wm_observations_assessment ON wm_observations(assessment_id);
CREATE INDEX IF NOT EXISTS idx_wm_observations_hypothesis ON wm_observations(hypothesis_id);

CREATE TABLE IF NOT EXISTS wm_findings (
    id            TEXT PRIMARY KEY,
    assessment_id INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
    hypothesis_id TEXT NOT NULL,
    title         TEXT NOT NULL,
    severity      TEXT NOT NULL,
    confidence    DOUBLE PRECISION NOT NULL DEFAULT 0.0,
    status        TEXT NOT NULL DEFAULT 'draft',
    evidence_ids  JSONB NOT NULL DEFAULT '[]',
    remediation   TEXT,
    metadata      JSONB NOT NULL DEFAULT '{}',
    created_at    TIMESTAMPTZ NOT NULL,
    updated_at    TIMESTAMPTZ NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_wm_findings_assessment ON wm_findings(assessment_id);
CREATE INDEX IF NOT EXISTS idx_wm_findings_hypothesis ON wm_findings(hypothesis_id);

CREATE TABLE IF NOT EXISTS wm_knowledge (
    id           TEXT PRIMARY KEY,
    assessment_id INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
    source_tool  TEXT NOT NULL,
    category     TEXT NOT NULL,
    target       TEXT NOT NULL DEFAULT '',
    title        TEXT NOT NULL,
    content      TEXT NOT NULL,
    chunk_index  INTEGER NOT NULL DEFAULT 0,
    chunk_total  INTEGER NOT NULL DEFAULT 1,
    parent_id    TEXT,
    content_size INTEGER NOT NULL DEFAULT 0,
    embedding    vector(384),
    metadata     JSONB NOT NULL DEFAULT '{}',
    tags         JSONB NOT NULL DEFAULT '[]',
    created_at   TIMESTAMPTZ NOT NULL,
    fts          tsvector GENERATED ALWAYS AS (
        setweight(to_tsvector('english', coalesce(title, '')), 'A') ||
        setweight(to_tsvector('english', coalesce(category, '')), 'B') ||
        setweight(to_tsvector('english', coalesce(target, '')), 'B') ||
        setweight(to_tsvector('english', coalesce(content, '')), 'D')
    ) STORED
);
CREATE INDEX IF NOT EXISTS idx_wm_knowledge_assessment ON wm_knowledge(assessment_id);
CREATE INDEX IF NOT EXISTS idx_wm_knowledge_category ON wm_knowledge(category);
CREATE INDEX IF NOT EXISTS idx_wm_knowledge_target ON wm_knowledge(target);
CREATE INDEX IF NOT EXISTS idx_wm_knowledge_parent ON wm_knowledge(parent_id);
CREATE INDEX IF NOT EXISTS idx_wm_knowledge_created ON wm_knowledge(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_wm_knowledge_fts ON wm_knowledge USING GIN(fts);

CREATE TABLE IF NOT EXISTS wm_plans (
    id          TEXT PRIMARY KEY,
    assessment_id INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
    title       TEXT NOT NULL,
    goal        TEXT NOT NULL,
    steps       JSONB NOT NULL DEFAULT '[]',
    status      TEXT NOT NULL DEFAULT 'active',
    reflection  TEXT NOT NULL DEFAULT '',
    created_at  TIMESTAMPTZ NOT NULL,
    updated_at  TIMESTAMPTZ NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_wm_plans_assessment ON wm_plans(assessment_id);

CREATE TABLE IF NOT EXISTS wm_relationships (
    id          TEXT PRIMARY KEY,
    assessment_id INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
    source_type TEXT NOT NULL,
    source_id   TEXT NOT NULL,
    target_type TEXT NOT NULL,
    target_id   TEXT NOT NULL,
    rel_type    TEXT NOT NULL,
    metadata    JSONB NOT NULL DEFAULT '{}',
    created_at  TIMESTAMPTZ NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_wm_rel_assessment ON wm_relationships(assessment_id);
CREATE INDEX IF NOT EXISTS idx_wm_rel_source ON wm_relationships(source_type, source_id);
CREATE INDEX IF NOT EXISTS idx_wm_rel_target ON wm_relationships(target_type, target_id);
CREATE INDEX IF NOT EXISTS idx_wm_rel_type ON wm_relationships(rel_type);

CREATE UNIQUE INDEX IF NOT EXISTS idx_wm_rel_unique
    ON wm_relationships(assessment_id, source_type, source_id, target_type, target_id, rel_type);

CREATE TABLE IF NOT EXISTS wm_coverage_matrix (
    id             TEXT PRIMARY KEY,
    assessment_id  INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
    endpoint_id    TEXT NOT NULL,
    vuln_class     TEXT NOT NULL,
    parameter      TEXT NOT NULL DEFAULT '',
    status         TEXT NOT NULL DEFAULT 'pending',
    tool_name      TEXT NOT NULL DEFAULT '',
    tool_args      JSONB NOT NULL DEFAULT '{}',
    finding_id     TEXT,
    result_summary TEXT NOT NULL DEFAULT '',
    priority       INTEGER NOT NULL DEFAULT 50,
    attempted_at   TIMESTAMPTZ,
    completed_at   TIMESTAMPTZ,
    created_at     TIMESTAMPTZ NOT NULL,
    updated_at     TIMESTAMPTZ NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_wm_cm_assessment ON wm_coverage_matrix(assessment_id);
CREATE INDEX IF NOT EXISTS idx_wm_cm_status ON wm_coverage_matrix(status);
CREATE INDEX IF NOT EXISTS idx_wm_cm_vuln_class ON wm_coverage_matrix(vuln_class);
CREATE INDEX IF NOT EXISTS idx_wm_cm_priority ON wm_coverage_matrix(priority DESC);
CREATE INDEX IF NOT EXISTS idx_wm_cm_parameter ON wm_coverage_matrix(parameter);

CREATE UNIQUE INDEX IF NOT EXISTS idx_wm_cm_unique
    ON wm_coverage_matrix(assessment_id, endpoint_id, vuln_class, parameter);

CREATE TABLE IF NOT EXISTS wm_scope_config (
    id               SERIAL PRIMARY KEY,
    assessment_id    INTEGER NOT NULL REFERENCES assessments(id) ON DELETE CASCADE,
    version          INTEGER NOT NULL DEFAULT 1,
    scope_data       JSONB NOT NULL,
    is_active        BOOLEAN NOT NULL DEFAULT TRUE,
    created_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by       TEXT,
    notes            TEXT
);
CREATE INDEX IF NOT EXISTS idx_wm_scope_config_assessment ON wm_scope_config(assessment_id);
CREATE INDEX IF NOT EXISTS idx_wm_scope_config_active ON wm_scope_config(assessment_id, is_active) WHERE is_active = TRUE;
CREATE UNIQUE INDEX IF NOT EXISTS idx_wm_scope_config_one_active
    ON wm_scope_config(assessment_id) WHERE is_active = TRUE;

CREATE TABLE IF NOT EXISTS wm_budget_state (
    assessment_id         INTEGER PRIMARY KEY REFERENCES assessments(id) ON DELETE CASCADE,
    total_requests        INTEGER NOT NULL DEFAULT 0,
    requests_by_target    JSONB NOT NULL DEFAULT '{}',
    recent_requests       JSONB NOT NULL DEFAULT '[]',
    start_time            TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_request_time     TIMESTAMPTZ,
    updated_at            TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS idx_wm_budget_state_updated ON wm_budget_state(updated_at DESC);
"""


async def create_wm_tables():
    """Create the world model tables (wm_*) in PostgreSQL.

    Should be called once at application startup, after the ORM tables exist.
    Runs each statement individually to handle 'IF NOT EXISTS' gracefully.
    """
    async with async_engine.begin() as conn:
        for statement in _WM_SCHEMA_SQL.split(";"):
            statement = statement.strip()
            if statement:
                try:
                    await conn.execute(text(statement))
                except Exception as exc:
                    # Ignore errors for already-existing objects
                    logger.debug("wm schema statement skipped: %s", exc)
    logger.info("World model (wm_*) tables ensured in PostgreSQL")
