"""
Activity Bridge - PostgreSQL LISTEN/NOTIFY to WebSocket Bridge

Listens for PostgreSQL NOTIFY events on the 'activity_events' channel
and broadcasts them to connected WebSocket clients via the ConnectionManager.
"""

import asyncio
import json
import logging
from typing import Optional

import asyncpg
from websocket.manager import ConnectionManager
from websocket.events import EventType, create_event

logger = logging.getLogger(__name__)


class ActivityBridge:
    """
    Bridges PostgreSQL NOTIFY events to WebSocket broadcasts.

    Maintains a dedicated PostgreSQL connection with LISTEN,
    translates activity_log events to WebSocket events,
    and broadcasts to subscribed clients.
    """

    def __init__(self, database_url: str, connection_manager: ConnectionManager):
        """
        Initialize the activity bridge.

        Args:
            database_url: PostgreSQL connection string
            connection_manager: WebSocket connection manager instance
        """
        self.database_url = database_url
        self.manager = connection_manager
        self.connection: Optional[asyncpg.Connection] = None
        self._task: Optional[asyncio.Task] = None
        self._running = False

    async def start(self) -> None:
        """Start the activity bridge listener."""
        if self._running:
            logger.warning("Activity bridge already running")
            return

        try:
            # Create dedicated connection for LISTEN
            self.connection = await asyncpg.connect(self.database_url)
            logger.info("Activity bridge connected to PostgreSQL")

            # Register listener callback
            await self.connection.add_listener('activity_events', self._handle_notification)
            logger.info("Activity bridge listening on 'activity_events' channel")

            self._running = True
            logger.info("Activity bridge started successfully")

        except Exception as e:
            logger.error(f"Failed to start activity bridge: {e}", exc_info=True)
            raise

    async def stop(self) -> None:
        """Stop the activity bridge listener."""
        if not self._running:
            return

        self._running = False

        try:
            if self.connection:
                await self.connection.remove_listener('activity_events', self._handle_notification)
                await self.connection.close()
                self.connection = None
                logger.info("Activity bridge stopped")
        except Exception as e:
            logger.error(f"Error stopping activity bridge: {e}", exc_info=True)

    async def _handle_notification(self, connection, pid, channel, payload_str):
        """
        Handle PostgreSQL NOTIFY event.

        Args:
            connection: PostgreSQL connection
            pid: Process ID of notifying backend
            channel: Channel name ('activity_events')
            payload_str: JSON payload string
        """
        try:
            # Parse JSON payload
            payload = json.loads(payload_str)

            assessment_id = payload.get('assessment_id')
            activity_type = payload.get('activity_type', '')
            data = payload.get('data', {})

            # Translate activity_type to WebSocket event type
            event_type = self._translate_activity_type(activity_type)

            if not event_type:
                logger.debug(f"Ignoring activity type: {activity_type}")
                return

            # Build WebSocket event
            event = create_event(
                event_type,
                data={
                    'activity_id': payload.get('id'),
                    'timestamp': payload.get('timestamp'),
                    **data  # Include all activity data
                },
                assessment_id=assessment_id
            )

            # Broadcast to assessment subscribers
            if assessment_id:
                await self.manager.broadcast(event, assessment_id=assessment_id)
                logger.debug(f"Broadcasted {event_type} to assessment {assessment_id}")

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse activity notification payload: {e}")
        except Exception as e:
            logger.error(f"Error handling activity notification: {e}", exc_info=True)

    def _translate_activity_type(self, activity_type: str) -> Optional[str]:
        """
        Translate activity_log activity_type to WebSocket event type.

        Args:
            activity_type: Activity type from activity_log table

        Returns:
            WebSocket event type string, or None to ignore
        """
        # Map activity types to WebSocket events
        mapping = {
            'tool_execution/started': EventType.TOOL_STARTED,
            'tool_execution/completed': EventType.TOOL_COMPLETED,
            'tool_execution/failed': EventType.TOOL_FAILED,
            'phase_transition': EventType.PHASE_CHANGED,
            'finding_created': EventType.FINDING_DISCOVERED,
            'scan_progress': EventType.SCAN_PROGRESS,
            'test_result': EventType.TEST_RESULT,
            'http_exchange': EventType.HTTP_EXCHANGE,
            'credential_tested': EventType.CREDENTIAL_TESTED,
            'coverage_updated': EventType.COVERAGE_UPDATED,
        }

        event_type = mapping.get(activity_type)
        return event_type if event_type else None


# Global bridge instance
_bridge_instance: Optional[ActivityBridge] = None


async def start_activity_bridge(database_url: str, connection_manager: ConnectionManager) -> ActivityBridge:
    """
    Start the global activity bridge instance.

    Args:
        database_url: PostgreSQL connection string
        connection_manager: WebSocket connection manager

    Returns:
        ActivityBridge instance
    """
    global _bridge_instance

    if _bridge_instance:
        logger.warning("Activity bridge already started")
        return _bridge_instance

    _bridge_instance = ActivityBridge(database_url, connection_manager)
    await _bridge_instance.start()

    return _bridge_instance


async def stop_activity_bridge() -> None:
    """Stop the global activity bridge instance."""
    global _bridge_instance

    if _bridge_instance:
        await _bridge_instance.stop()
        _bridge_instance = None
