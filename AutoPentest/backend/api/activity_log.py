"""
Activity Log API endpoints

Provides access to detailed activity logging for assessments,
including tool executions, phase transitions, findings, scans, and errors.
"""
from typing import Optional, List
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from sqlalchemy import text

from database import get_db
from models import Assessment
from utils.logger import get_logger

logger = get_logger(__name__)

router = APIRouter(prefix="/assessments/{assessment_id}/activity_log", tags=["activity_log"])

# Round 11 Fix 2B: Type translation mapping
_TYPE_MAP = {
    "tool_execution/started": "tool_started",
    "tool_execution/completed": "tool_completed",
    "tool_execution/failed": "tool_failed",
    "phase_transition": "phase_changed",
    "http_exchange": "http_exchange",
    "finding_created": "finding_created",
}

def _translate_type(raw_type: str) -> str:
    """Translate DB activity_type to frontend-expected type."""
    return _TYPE_MAP.get(raw_type, raw_type)


@router.get("")
async def get_activity_log(
    assessment_id: int,
    activity_type: Optional[str] = Query(None, description="Filter by activity type"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of entries to return"),
    offset: int = Query(0, ge=0, description="Number of entries to skip"),
    db: Session = Depends(get_db)
):
    """Get detailed activity log for assessment

    Activity types:
    - tool_execution: Tool invocations (started/completed/failed)
    - phase_transition: Phase orchestration transitions
    - finding_created: Findings created
    - scan_started: Scans initiated
    - scan_completed: Scans completed
    - recon_data: Reconnaissance data collected
    - world_model_update: World model database operations
    - error: Errors and exceptions
    """
    # Verify assessment exists
    assessment = db.query(Assessment).filter(Assessment.id == assessment_id).first()
    if not assessment:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Assessment with id {assessment_id} not found"
        )

    # Build query
    query = """
        SELECT
            id,
            activity_type,
            timestamp,
            data,
            created_at
        FROM activity_log
        WHERE assessment_id = :assessment_id
    """
    params = {"assessment_id": assessment_id}

    if activity_type:
        query += " AND activity_type = :activity_type"
        params["activity_type"] = activity_type

    query += " ORDER BY timestamp DESC LIMIT :limit OFFSET :offset"
    params["limit"] = limit
    params["offset"] = offset

    # Execute query
    result = db.execute(text(query), params)
    rows = result.fetchall()

    # Get total count
    count_query = """
        SELECT COUNT(*) as total
        FROM activity_log
        WHERE assessment_id = :assessment_id
    """
    count_params = {"assessment_id": assessment_id}

    if activity_type:
        count_query += " AND activity_type = :activity_type"
        count_params["activity_type"] = activity_type

    count_result = db.execute(text(count_query), count_params)
    total_count = count_result.fetchone()[0]

    return {
        "assessment_id": assessment_id,
        "total_entries": total_count,
        "returned_entries": len(rows),
        "limit": limit,
        "offset": offset,
        "activities": [
            {
                "id": row[0],
                "type": _translate_type(row[1]),  # Round 11 Fix 2B: Translate type
                "timestamp": row[2].isoformat() if row[2] else None,
                "data": row[3],
                "created_at": row[4].isoformat() if row[4] else None
            }
            for row in rows
        ]
    }


@router.get("/summary")
async def get_activity_summary(
    assessment_id: int,
    db: Session = Depends(get_db)
):
    """Get activity summary statistics for assessment"""
    # Verify assessment exists
    assessment = db.query(Assessment).filter(Assessment.id == assessment_id).first()
    if not assessment:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Assessment with id {assessment_id} not found"
        )

    # Get counts by activity type
    query = """
        SELECT
            activity_type,
            COUNT(*) as count
        FROM activity_log
        WHERE assessment_id = :assessment_id
        GROUP BY activity_type
        ORDER BY count DESC
    """
    result = db.execute(text(query), {"assessment_id": assessment_id})
    rows = result.fetchall()

    activity_counts = {row[0]: row[1] for row in rows}
    total_activities = sum(activity_counts.values())

    # Get time range
    time_query = """
        SELECT
            MIN(timestamp) as first_activity,
            MAX(timestamp) as last_activity
        FROM activity_log
        WHERE assessment_id = :assessment_id
    """
    time_result = db.execute(text(time_query), {"assessment_id": assessment_id})
    time_row = time_result.fetchone()

    first_activity = time_row[0].isoformat() if time_row[0] else None
    last_activity = time_row[1].isoformat() if time_row[1] else None

    # Get tool execution stats (Round 11 Fix 2C: LIKE query for tool_execution/*)
    tool_query = """
        SELECT
            data->>'tool_name' as tool_name,
            data->>'status' as status,
            COUNT(*) as count
        FROM activity_log
        WHERE assessment_id = :assessment_id
            AND activity_type LIKE 'tool_execution/%'
        GROUP BY data->>'tool_name', data->>'status'
        ORDER BY count DESC
    """
    tool_result = db.execute(text(tool_query), {"assessment_id": assessment_id})
    tool_rows = tool_result.fetchall()

    tool_stats = {}
    for row in tool_rows:
        tool_name = row[0]
        status = row[1]
        count = row[2]

        if tool_name not in tool_stats:
            tool_stats[tool_name] = {"started": 0, "completed": 0, "failed": 0}

        tool_stats[tool_name][status] = count

    return {
        "assessment_id": assessment_id,
        "total_activities": total_activities,
        "activity_counts": activity_counts,
        "time_range": {
            "first_activity": first_activity,
            "last_activity": last_activity
        },
        "tool_execution_stats": tool_stats
    }


@router.get("/timeline")
async def get_activity_timeline(
    assessment_id: int,
    interval: str = Query("hour", description="Time bucket interval (e.g., 'hour', 'minute', 'day')"),
    db: Session = Depends(get_db)
):
    """Get activity timeline with time-bucketed counts

    Groups activities into time intervals to show activity patterns over time.
    """
    # Validate interval parameter
    VALID_INTERVALS = {"second", "minute", "hour", "day", "week", "month", "quarter", "year"}
    if interval not in VALID_INTERVALS:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid interval. Must be one of: {', '.join(sorted(VALID_INTERVALS))}"
        )

    # Verify assessment exists
    assessment = db.query(Assessment).filter(Assessment.id == assessment_id).first()
    if not assessment:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Assessment with id {assessment_id} not found"
        )

    # Get timeline data
    query = """
        SELECT
            date_trunc(:interval, timestamp) as time_bucket,
            activity_type,
            COUNT(*) as count
        FROM activity_log
        WHERE assessment_id = :assessment_id
        GROUP BY time_bucket, activity_type
        ORDER BY time_bucket ASC, activity_type
    """
    result = db.execute(
        text(query),
        {"assessment_id": assessment_id, "interval": interval}
    )
    rows = result.fetchall()

    # Group by time bucket
    timeline = {}
    for row in rows:
        time_bucket = row[0].isoformat() if row[0] else None
        activity_type = row[1]
        count = row[2]

        if time_bucket not in timeline:
            timeline[time_bucket] = {}

        timeline[time_bucket][activity_type] = count

    return {
        "assessment_id": assessment_id,
        "interval": interval,
        "buckets": [
            {
                "time": time_bucket,
                "activities": activities
            }
            for time_bucket, activities in timeline.items()
        ]
    }
