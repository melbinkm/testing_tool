"""
Assessment sections (phases) API endpoints
"""
from typing import List
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy import text

from database import get_db
from models import AssessmentSection, Assessment
from schemas.section import SectionCreate, SectionUpdate, SectionResponse
from websocket.manager import manager
from websocket.events import event_section_updated
from utils.logger import get_logger

logger = get_logger(__name__)

router = APIRouter(prefix="/assessments/{assessment_id}/sections", tags=["sections"])


@router.get("", response_model=List[SectionResponse])
async def list_sections(
    assessment_id: int,
    db: Session = Depends(get_db)
):
    """Get all sections for an assessment"""
    # Verify assessment exists
    assessment = db.query(Assessment).filter(Assessment.id == assessment_id).first()
    if not assessment:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Assessment with id {assessment_id} not found"
        )

    sections = (
        db.query(AssessmentSection)
        .filter(AssessmentSection.assessment_id == assessment_id)
        .order_by(AssessmentSection.section_number)
        .all()
    )

    return sections


@router.post("", response_model=SectionResponse, status_code=status.HTTP_201_CREATED)
async def create_section(
    assessment_id: int,
    section: SectionCreate,
    db: Session = Depends(get_db)
):
    """Create or update a section"""
    # Verify assessment exists
    assessment = db.query(Assessment).filter(Assessment.id == assessment_id).first()
    if not assessment:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Assessment with id {assessment_id} not found"
        )

    # Check if section already exists
    existing = db.query(AssessmentSection).filter(
        AssessmentSection.assessment_id == assessment_id,
        AssessmentSection.section_type == section.section_type,
        AssessmentSection.section_number == section.section_number
    ).first()

    if existing:
        # Update existing
        for field, value in section.model_dump().items():
            setattr(existing, field, value)
        db.commit()
        db.refresh(existing)

        # Broadcast WebSocket event
        section_dict = SectionResponse.model_validate(existing).model_dump(mode='json')
        await manager.broadcast(
            event_section_updated(assessment_id, section_dict),
            assessment_id=assessment_id
        )
        logger.info("Section updated", section_id=existing.id, section_type=existing.section_type, assessment_id=assessment_id)

        return existing

    # Create new
    new_section = AssessmentSection(
        assessment_id=assessment_id,
        **section.model_dump()
    )

    db.add(new_section)
    db.commit()
    db.refresh(new_section)

    # Broadcast WebSocket event
    section_dict = SectionResponse.model_validate(new_section).model_dump(mode='json')
    await manager.broadcast(
        event_section_updated(assessment_id, section_dict),
        assessment_id=assessment_id
    )
    logger.info("Section created", section_id=new_section.id, section_type=new_section.section_type, assessment_id=assessment_id)

    return new_section


@router.put("/{section_id}", response_model=SectionResponse)
async def update_section(
    assessment_id: int,
    section_id: int,
    section_update: SectionUpdate,
    db: Session = Depends(get_db)
):
    """Update an existing section"""
    section = db.query(AssessmentSection).filter(
        AssessmentSection.id == section_id,
        AssessmentSection.assessment_id == assessment_id
    ).first()

    if not section:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Section with id {section_id} not found"
        )

    # Update fields
    update_data = section_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(section, field, value)

    db.commit()
    db.refresh(section)

    # Broadcast WebSocket event
    section_dict = SectionResponse.model_validate(section).model_dump(mode='json')
    await manager.broadcast(
        event_section_updated(assessment_id, section_dict),
        assessment_id=assessment_id
    )
    logger.info("Section updated", section_id=section_id, assessment_id=assessment_id)

    return section


@router.delete("/{section_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_section(
    assessment_id: int,
    section_id: int,
    db: Session = Depends(get_db)
):
    """Delete a section"""
    section = db.query(AssessmentSection).filter(
        AssessmentSection.id == section_id,
        AssessmentSection.assessment_id == assessment_id
    ).first()

    if not section:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Section with id {section_id} not found"
        )

    db.delete(section)
    db.commit()
    return None


@router.get("/phases", response_model=dict)
async def get_phase_progress(
    assessment_id: int,
    db: Session = Depends(get_db)
):
    """Get phase orchestration progress from world model.

    Returns phase status from wm_plans table, showing progression through
    the 6-phase pentest lifecycle with gate conditions and metrics.
    """
    # Verify assessment exists
    assessment = db.query(Assessment).filter(Assessment.id == assessment_id).first()
    if not assessment:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Assessment with id {assessment_id} not found"
        )

    # Query wm_plans table for phase data
    try:
        # Use raw SQL since wm_plans is in PostgreSQL, not SQLAlchemy ORM
        result = db.execute(
            text("SELECT steps FROM wm_plans WHERE assessment_id = :assessment_id AND title = :title LIMIT 1"),
            {"assessment_id": assessment_id, "title": "Assessment Phase Orchestration"}
        )
        row = result.fetchone()

        if not row:
            # No orchestration plan yet - return default phase structure
            return {
                "assessment_id": assessment_id,
                "phases": [
                    {"phase": 1, "name": "Reconnaissance", "status": "pending", "result": ""},
                    {"phase": 2, "name": "Mapping & Enumeration", "status": "pending", "result": ""},
                    {"phase": 3, "name": "SAST Code Review", "status": "pending", "result": ""},
                    {"phase": 4, "name": "Vulnerability Assessment", "status": "pending", "result": ""},
                    {"phase": 5, "name": "Exploitation", "status": "pending", "result": ""},
                    {"phase": 6, "name": "Post-Exploitation & Reporting", "status": "pending", "result": ""},
                ],
                "current_phase": 1,
                "progress_pct": 0,
                "is_complete": False,
                "message": "Phase orchestration not initialized"
            }

        steps = row[0]  # JSONB column

        # Determine current phase
        current_phase = 1
        is_complete = False

        for i in range(len(steps) - 1, -1, -1):
            if steps[i].get("status") == "in_progress":
                current_phase = i + 1
                break
        else:
            # No in_progress phase, find last done
            last_done_index = None
            for i in range(len(steps) - 1, -1, -1):
                if steps[i].get("status") == "done":
                    last_done_index = i
                    break

            if last_done_index is not None:
                # If all phases are done (last is phase 5), assessment is complete
                if last_done_index == len(steps) - 1:
                    current_phase = len(steps)  # Keep at 5
                    is_complete = True
                else:
                    current_phase = last_done_index + 2  # Next phase

        # Calculate progress
        completed_phases = sum(1 for step in steps if step.get("status") == "done")
        progress_pct = round((completed_phases / 6) * 100, 1)

        # Add phase numbers to steps
        phases_with_numbers = []
        for i, step in enumerate(steps):
            phases_with_numbers.append({
                "phase": i + 1,
                "name": step.get("description", f"Phase {i + 1}"),
                "status": step.get("status", "pending"),
                "result": step.get("result", ""),
            })

        # Generate appropriate message
        if is_complete:
            message = "Assessment Complete"
        else:
            message = f"Phase {current_phase}: {phases_with_numbers[current_phase - 1]['name']}"

        return {
            "assessment_id": assessment_id,
            "phases": phases_with_numbers,
            "current_phase": current_phase,
            "progress_pct": progress_pct,
            "is_complete": is_complete,
            "message": message
        }

    except Exception as e:
        logger.error(f"Error fetching phase progress: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error fetching phase progress: {str(e)}"
        )
